"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var bitgo_utxo_lib_1 = require("bitgo-utxo-lib");
/**
 * @param {String} xpub - a base-58 encoded extended public key (BIP32)
 * @return {String} the uncompressed public key in hexadecimal
 */
function xpubToUncompressedPub(xpub) {
    if (!isValidXpub(xpub)) {
        throw new Error('invalid xpub');
    }
    var hdNode = bitgo_utxo_lib_1.HDNode.fromBase58(xpub, bitgo_utxo_lib_1.networks.bitcoin);
    return hdNode.keyPair.__Q.getEncoded(false).toString('hex');
}
exports.xpubToUncompressedPub = xpubToUncompressedPub;
/**
 * @param {String} xprv - base58-encoded extended private key (BIP32)
 * @return {String} the hex-encoded raw private key
 */
function xprvToRawPrv(xprv) {
    if (!isValidXprv(xprv)) {
        throw new Error('invalid xprv');
    }
    var hdNode = bitgo_utxo_lib_1.HDNode.fromBase58(xprv, bitgo_utxo_lib_1.networks.bitcoin);
    return hdNode.keyPair.d.toBuffer(32).toString('hex');
}
exports.xprvToRawPrv = xprvToRawPrv;
/**
 * @param {String} prv - Private key in hex format to get the extended keys for
 * @return {ExtendedKeys} xprv and xpub in string format
 */
function rawPrvToExtendedKeys(prv) {
    var keyPair = bitgo_utxo_lib_1.ECPair.fromPrivateKeyBuffer(Buffer.from(prv, 'hex'));
    var hd = new bitgo_utxo_lib_1.HDNode(keyPair, Buffer.alloc(32));
    return {
        xprv: hd.toBase58(),
        xpub: hd.neutered().toBase58(),
    };
}
exports.rawPrvToExtendedKeys = rawPrvToExtendedKeys;
/**
 * Whether the input is a valid BIP32 xpub or not
 */
function isValidXpub(xpub) {
    if (xpub.substr(0, 4) !== 'xpub') {
        // check for xpub formats we don't support, such as tpub
        return false;
    }
    try {
        bitgo_utxo_lib_1.HDNode.fromBase58(xpub, bitgo_utxo_lib_1.networks.bitcoin);
    }
    catch (err) {
        return false;
    }
    // if HD generation didn't throw, it is a valid xpub
    return true;
}
exports.isValidXpub = isValidXpub;
/**
 * Whether the input is a valid BIP32 xprv or not
 */
function isValidXprv(xprv) {
    if (xprv.substr(0, 4) !== 'xprv') {
        // check for xprv formats we don't support
        return false;
    }
    try {
        bitgo_utxo_lib_1.HDNode.fromBase58(xprv, bitgo_utxo_lib_1.networks.bitcoin);
    }
    catch (err) {
        return false;
    }
    // if HD generation didn't throw, it is a valid xprv
    return true;
}
exports.isValidXprv = isValidXprv;
/**
 * Whether the input is a valid secp256k1 public key
 */
function isValidPub(pub) {
    try {
        bitgo_utxo_lib_1.ECPair.fromPublicKeyBuffer(new Buffer(pub, 'hex'));
    }
    catch (e) {
        return false;
    }
    return true;
}
exports.isValidPub = isValidPub;
/**
 * Whether the input is a valid secp256k1 private key
 */
function isValidPrv(prv) {
    try {
        bitgo_utxo_lib_1.ECPair.fromPrivateKeyBuffer(new Buffer(prv, 'hex'));
    }
    catch (e) {
        return false;
    }
    return true;
}
exports.isValidPrv = isValidPrv;
//# sourceMappingURL=crypto.js.map