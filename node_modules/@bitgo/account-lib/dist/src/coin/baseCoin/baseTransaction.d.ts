import { BaseCoin as CoinConfig } from '@bitgo/statics';
import { BaseKey, Entry } from './iface';
import { TransactionType } from './enum';
/**
 * Generic transaction to be extended with coin specific logic.
 */
export declare abstract class BaseTransaction {
    protected _coinConfig: Readonly<CoinConfig>;
    protected _id: string;
    protected _inputs: Entry[];
    protected _outputs: Entry[];
    protected _type: TransactionType;
    protected _signatures: string[];
    /**
     * Base constructor.
     *
     * @param _coinConfig BaseCoin from statics library
     */
    protected constructor(_coinConfig: Readonly<CoinConfig>);
    /**
     * Get the transaction id as seen in the blockchain. Transactions computed offline may not have an
     * id, however, this is left to the coin implementation.
     */
    readonly id: string;
    /**
     * One of {@link TransactionType}
     */
    readonly type: TransactionType;
    /**
     * Get the list of outputs. Amounts are expressed in absolute value.
     */
    readonly outputs: Entry[];
    /**
     * Get the list of inputs. Amounts are expressed in absolute value.
     */
    readonly inputs: Entry[];
    /**
     * Get the list of signatures (if any) produced for this transaction.
     */
    readonly signature: string[];
    /**
     * Whether the private key can sign this transaction in its current state or not. it is possible
     * some transactions can only enforce this check after some other fields have been filled already
     * or even during build time.
     *
     * @param {BaseKey} key Private key to verify permissions on
     * @returns {boolean} false if the key cannot sign the transaction without a doubt, true otherwise
     */
    abstract canSign(key: BaseKey): boolean;
    /**
     * Return the transaction in a coin specific JSON format.
     */
    abstract toJson(): any;
    /**
     * Return the transaction in a format it can be broadcasted to the blockchain.
     */
    abstract toBroadcastFormat(): any;
}
