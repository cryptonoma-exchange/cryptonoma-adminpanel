"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var crypto = __importStar(require("crypto"));
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var baseCoin_1 = require("../baseCoin");
var tron_1 = require("../../../resources/trx/protobuf/tron");
var errors_1 = require("../baseCoin/errors");
var baseCoin_2 = require("../baseCoin/");
var enum_1 = require("./enum");
var utils_1 = require("./utils");
/**
 * Tron transaction model.
 */
var Transaction = /** @class */ (function (_super) {
    __extends(Transaction, _super);
    /**
     * Public constructor.
     */
    function Transaction(coinConfig, rawTransaction) {
        var _this = _super.call(this, coinConfig) || this;
        if (rawTransaction) {
            if (!rawTransaction.txID) {
                throw new errors_1.ParseTransactionError('Transaction has no id');
            }
            _this._id = rawTransaction.txID;
            _this._transaction = rawTransaction;
            _this._decodedRawDataHex = utils_1.decodeTransaction(rawTransaction.raw_data_hex);
            // Destination depends on the contract type
            _this.recordRawDataFields(_this._decodedRawDataHex);
        }
        return _this;
    }
    /**
     * Parse the transaction raw data and record the most important fields.
     *
     * @param rawData Object from a tron transaction
     */
    Transaction.prototype.recordRawDataFields = function (rawData) {
        // Contract-agnostic fields
        this._validFrom = rawData.timestamp;
        this._validTo = rawData.expiration;
        var output, input;
        // Contract-specific fields
        switch (rawData.contractType) {
            case enum_1.ContractType.Transfer:
                this._type = baseCoin_2.TransactionType.Send;
                var value = new bignumber_js_1.default(rawData.contract[0].parameter.value.amount).toFixed(0);
                output = {
                    address: rawData.contract[0].parameter.value.to_address,
                    value: value,
                };
                input = {
                    address: rawData.contract[0].parameter.value.owner_address,
                    value: value,
                };
                break;
            case enum_1.ContractType.AccountPermissionUpdate:
                this._type = baseCoin_2.TransactionType.WalletInitialization;
                output = {
                    address: rawData.contract.owner_address,
                    value: '0',
                };
                input = {
                    address: rawData.contract.owner_address,
                    value: '0',
                };
                break;
            default:
                throw new errors_1.ParseTransactionError('Unsupported contract type');
        }
        this._inputs = [input];
        this._outputs = [output];
    };
    /**
     * Recalculate and update the transaction id. This should be done after changing any transaction
     * field since the the id is a hash of the transaction body.
     */
    Transaction.prototype.updateId = function () {
        if (!this._transaction) {
            throw new errors_1.ParseTransactionError('Empty transaction');
        }
        var hexBuffer = Buffer.from(this._transaction.raw_data_hex, 'hex');
        var newTxid = crypto
            .createHash('sha256')
            .update(hexBuffer)
            .digest('hex');
        this._transaction.txID = newTxid;
        this._id = newTxid;
    };
    /**
     * Extend the expiration date by the given number of milliseconds.
     *
     * @param extensionMs The number of milliseconds to extend the expiration by
     */
    Transaction.prototype.extendExpiration = function (extensionMs) {
        if (extensionMs < 0) {
            throw new errors_1.ExtendTransactionError('Invalid extension range. Must be positive a integer');
        }
        if (!this._transaction) {
            throw new errors_1.ExtendTransactionError('Empty transaction');
        }
        if (this._transaction.signature && this._transaction.signature.length > 0) {
            throw new errors_1.ExtendTransactionError('Cannot extend a signed transaction');
        }
        var rawDataHex = this._transaction.raw_data_hex;
        var bytes = Buffer.from(rawDataHex, 'hex');
        var raw;
        try {
            raw = tron_1.protocol.Transaction.raw.decode(bytes);
            var newExpiration = new bignumber_js_1.default(raw.expiration).plus(extensionMs).toNumber();
            raw.expiration = newExpiration;
            var newRawDataHex = Buffer.from(tron_1.protocol.Transaction.raw.encode(raw).finish()).toString('hex');
            // Set the internal variables to account for the new expiration date
            this._transaction.raw_data_hex = newRawDataHex;
            this._transaction.raw_data.expiration = newExpiration;
            this._decodedRawDataHex = utils_1.decodeTransaction(newRawDataHex);
            this.recordRawDataFields(this._decodedRawDataHex);
            this.updateId();
        }
        catch (e) {
            throw new errors_1.ExtendTransactionError('There was an error decoding the initial raw_data_hex from the serialized tx.');
        }
    };
    Object.defineProperty(Transaction.prototype, "signature", {
        /**
         * Get the signatures associated with this transaction.
         */
        get: function () {
            if (!this._transaction) {
                throw new errors_1.ParseTransactionError('Empty transaction');
            }
            if (this._transaction.signature) {
                return this._transaction.signature;
            }
            return [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transaction.prototype, "validFrom", {
        /**
         * Get the time in milliseconds this transaction becomes valid and can be broadcasted to the
         * network.
         */
        get: function () {
            return this._validFrom;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transaction.prototype, "validTo", {
        /**
         * Get the expiration time in milliseconds.
         */
        get: function () {
            return this._validTo;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    Transaction.prototype.canSign = function (key) {
        // Tron transaction do not contain the owners account address so it is not possible to check the
        // private key with any but the account main address. This is not enough to fail this check, so
        // it is a no-op.
        return true;
    };
    /** @inheritdoc */
    Transaction.prototype.toJson = function () {
        if (!this._transaction) {
            throw new errors_1.ParseTransactionError('Empty transaction');
        }
        return this._transaction;
    };
    /** @inheritdoc */
    Transaction.prototype.toBroadcastFormat = function () {
        return JSON.stringify(this.toJson());
    };
    return Transaction;
}(baseCoin_1.BaseTransaction));
exports.Transaction = Transaction;
//# sourceMappingURL=transaction.js.map