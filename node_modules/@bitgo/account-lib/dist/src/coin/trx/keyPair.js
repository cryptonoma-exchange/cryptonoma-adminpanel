"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var crypto = __importStar(require("crypto"));
var bitgo_utxo_lib_1 = require("bitgo-utxo-lib");
var enum_1 = require("../baseCoin/enum");
var Crypto = __importStar(require("../../utils/crypto"));
var Utils = __importStar(require("./utils"));
var iface_1 = require("./iface");
var DEFAULT_SEED_SIZE_BYTES = 16;
/**
 * Tron keys and address management.
 */
var KeyPair = /** @class */ (function () {
    /**
     * Public constructor. By default, creates a key pair with a random master seed.
     *
     * @param source Either a master seed, a private key (extended or raw), or a public key
     *     (extended, compressed, or uncompressed)
     */
    function KeyPair(source) {
        if (!source) {
            var seed = crypto.randomBytes(DEFAULT_SEED_SIZE_BYTES);
            this.hdNode = bitgo_utxo_lib_1.HDNode.fromSeedBuffer(seed);
        }
        else if (iface_1.isSeed(source)) {
            this.hdNode = bitgo_utxo_lib_1.HDNode.fromSeedBuffer(source.seed);
        }
        else if (iface_1.isPrivateKey(source)) {
            this.recordKeysFromPrivateKey(source.prv);
        }
        else if (iface_1.isPublicKey(source)) {
            this.recordKeysFromPublicKey(source.pub);
        }
        else {
            throw new Error('Invalid key pair options');
        }
        if (this.hdNode) {
            this.keyPair = this.hdNode.keyPair;
        }
    }
    /**
     * Build a Hierarchical Deterministic node or an ECPair from a private key.
     *
     * @param prv An extended or raw private key
     */
    KeyPair.prototype.recordKeysFromPrivateKey = function (prv) {
        if (Crypto.isValidXprv(prv)) {
            this.hdNode = bitgo_utxo_lib_1.HDNode.fromBase58(prv);
        }
        else if (Crypto.isValidPrv(prv)) {
            // Cannot create the HD node without the chain code, so create a regular Key Chain
            this.keyPair = bitgo_utxo_lib_1.ECPair.fromPrivateKeyBuffer(new Buffer(prv, 'hex'));
        }
        else {
            throw new Error('Unsupported private key');
        }
    };
    /**
     * Build a Hierarchical Deterministic node or an ECPair from a public key.
     *
     * @param {String} pub - An extended, compressed, or uncompressed public key
     */
    KeyPair.prototype.recordKeysFromPublicKey = function (pub) {
        if (Crypto.isValidXpub(pub)) {
            this.hdNode = bitgo_utxo_lib_1.HDNode.fromBase58(pub);
        }
        else if (Crypto.isValidPub(pub)) {
            // Cannot create an HD node without the chain code, so create a regular Key Chain
            this.keyPair = bitgo_utxo_lib_1.ECPair.fromPublicKeyBuffer(new Buffer(pub, 'hex'));
        }
        else {
            throw new Error('Unsupported public key: ' + pub);
        }
    };
    /**
     * Tron default keys format is raw private and uncompressed public key
     * @return The keys in the protocol default key format
     */
    KeyPair.prototype.getKeys = function () {
        var result = {
            pub: this.keyPair.Q.getEncoded(false)
                .toString('hex')
                .toUpperCase(),
        };
        if (this.keyPair.d) {
            result.prv = this.keyPair.d
                .toBuffer(32)
                .toString('hex')
                .toUpperCase();
        }
        return result;
    };
    /**
     * Get the extended public key, and the private key if one is available. This is only possible
     * when the key pair was created from a seed or extended keys.
     */
    KeyPair.prototype.getExtendedKeys = function () {
        if (!this.hdNode) {
            throw new Error('Cannot get extended keys');
        }
        var result = {
            xpub: this.hdNode.neutered().toBase58(),
        };
        // A neutered HD node means it only contains the public key information
        if (!this.hdNode.isNeutered()) {
            result.xprv = this.hdNode.toBase58();
        }
        return result;
    };
    /**
     * Get a public address in the specified format, or in base58 if none is provided.
     */
    KeyPair.prototype.getAddress = function (format) {
        var pub = this.getKeys().pub;
        // These are custom Tron methods. They can probably be replaced with other methods or libraries
        var addressBytes = Utils.getRawAddressFromPubKey(Buffer.from(pub, 'hex'));
        if (!format || format === enum_1.AddressFormat.base58) {
            // Default address are in hex
            return Utils.getBase58AddressFromByteArray(addressBytes);
        }
        else if (format === enum_1.AddressFormat.hex) {
            return Utils.getHexAddressFromByteArray(addressBytes);
        }
        throw new Error('Unsupported address format');
    };
    /**
     * Generates a signature for an arbitrary string with the current private key using keccak256
     * hashing algorithm. Throws if there is no private key.
     * @param {string} message to produce a signature for
     * @return The signature as a buffer
     */
    KeyPair.prototype.signMessage = function (message) {
        var messageToSign = Buffer.from(message).toString('hex');
        var prv = this.getKeys().prv;
        if (!prv) {
            throw new Error('Missing private key');
        }
        var signature = Utils.signString(messageToSign, prv, true).replace(/^0x/, '');
        return Buffer.from(signature, 'hex');
    };
    /**
     * Verifies a message signature using the current public key.
     * @param {string} message signed
     * @param {Buffer} signature to verify
     * @return True if the message was signed with the current key pair
     */
    KeyPair.prototype.verifySignature = function (message, signature) {
        var messageToVerify = Buffer.from(message).toString('hex');
        var address = this.getAddress(enum_1.AddressFormat.base58);
        return Utils.verifySignature(messageToVerify, address, signature.toString('hex'), true);
    };
    return KeyPair;
}());
exports.KeyPair = KeyPair;
//# sourceMappingURL=keyPair.js.map