"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var local_forging_1 = require("@taquito/local-forging");
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var baseCoin_1 = require("../baseCoin");
var errors_1 = require("../baseCoin/errors");
var baseCoin_2 = require("../baseCoin/");
var multisigUtils_1 = require("./multisigUtils");
var Utils = __importStar(require("./utils"));
/**
 * Tezos transaction model.
 */
var Transaction = /** @class */ (function (_super) {
    __extends(Transaction, _super);
    /**
     * Public constructor.
     *
     * @param {Readonly<CoinConfig>} coinConfig
     */
    function Transaction(coinConfig) {
        return _super.call(this, coinConfig) || this;
    }
    /**
     * Initialize the transaction fields based on another serialized transaction.
     *
     * @param serializedTransaction Transaction in broadcast format.
     */
    Transaction.prototype.initFromSerializedTransaction = function (serializedTransaction) {
        return __awaiter(this, void 0, void 0, function () {
            var parsedTransaction, e_1, unsignedSerializedTransaction, signature, parsedTransaction, transactionId;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._encodedTransaction = serializedTransaction;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 4, , 8]);
                        return [4 /*yield*/, local_forging_1.localForger.parse(serializedTransaction)];
                    case 2:
                        parsedTransaction = _a.sent();
                        return [4 /*yield*/, this.initFromParsedTransaction(parsedTransaction)];
                    case 3:
                        _a.sent();
                        return [3 /*break*/, 8];
                    case 4:
                        e_1 = _a.sent();
                        unsignedSerializedTransaction = serializedTransaction.slice(0, -128);
                        signature = serializedTransaction.slice(-128);
                        if (Utils.isValidSignature(signature)) {
                            throw new errors_1.ParseTransactionError('Invalid transaction');
                        }
                        return [4 /*yield*/, local_forging_1.localForger.parse(unsignedSerializedTransaction)];
                    case 5:
                        parsedTransaction = _a.sent();
                        return [4 /*yield*/, Utils.calculateTransactionId(serializedTransaction)];
                    case 6:
                        transactionId = _a.sent();
                        return [4 /*yield*/, this.initFromParsedTransaction(parsedTransaction, transactionId)];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 8];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Initialize the transaction fields based on another parsed transaction.
     *
     * @param {ParsedTransaction} parsedTransaction A Tezos transaction object
     * @param {string} transactionId The transaction id of the parsedTransaction if it is signed
     */
    Transaction.prototype.initFromParsedTransaction = function (parsedTransaction, transactionId) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, operationIndex, _i, _b, operation, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (!!this._encodedTransaction) return [3 /*break*/, 2];
                        _a = this;
                        return [4 /*yield*/, local_forging_1.localForger.forge(parsedTransaction)];
                    case 1:
                        _a._encodedTransaction = _d.sent();
                        _d.label = 2;
                    case 2:
                        if (transactionId) {
                            // If the transaction id is passed, save it and clean up the entries since they will be
                            // recalculated
                            this._id = transactionId;
                            this._inputs = [];
                            this._outputs = [];
                        }
                        else {
                            this._id = '';
                        }
                        this._parsedTransaction = parsedTransaction;
                        operationIndex = 0;
                        _i = 0, _b = parsedTransaction.contents;
                        _d.label = 3;
                    case 3:
                        if (!(_i < _b.length)) return [3 /*break*/, 10];
                        operation = _b[_i];
                        if (this._source && this._source != operation.source) {
                            throw new errors_1.InvalidTransactionError('Source must be the same for every operation but it changed from ' + this._source + ' to ' + operation.source);
                        }
                        else {
                            this._source = operation.source;
                        }
                        _c = operation.kind;
                        switch (_c) {
                            case local_forging_1.CODEC.OP_ORIGINATION: return [3 /*break*/, 4];
                            case local_forging_1.CODEC.OP_REVEAL: return [3 /*break*/, 6];
                            case local_forging_1.CODEC.OP_TRANSACTION: return [3 /*break*/, 7];
                        }
                        return [3 /*break*/, 8];
                    case 4: return [4 /*yield*/, this.recordOriginationOpFields(operation, operationIndex)];
                    case 5:
                        _d.sent();
                        operationIndex++;
                        return [3 /*break*/, 9];
                    case 6:
                        this.recordRevealOpFields(operation);
                        return [3 /*break*/, 9];
                    case 7:
                        this.recordTransactionOpFields(operation);
                        return [3 /*break*/, 9];
                    case 8: return [3 /*break*/, 9];
                    case 9:
                        _i++;
                        return [3 /*break*/, 3];
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Record the most important fields from an origination operation.
     *
     * @param {Operation} operation An operation object from a Tezos transaction
     * @param {number} index The origination operation index in the transaction. Used to calculate the
     *      originated address
     */
    Transaction.prototype.recordOriginationOpFields = function (operation, index) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b, _c, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        this._type = baseCoin_2.TransactionType.WalletInitialization;
                        this._delegate = operation.delegate;
                        _b = (_a = this._outputs).push;
                        _c = {};
                        if (!this._id) return [3 /*break*/, 2];
                        return [4 /*yield*/, Utils.calculateOriginatedAddress(this._id, index)];
                    case 1:
                        _d = _e.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        _d = '';
                        _e.label = 3;
                    case 3:
                        _b.apply(_a, [(
                            // Kt addresses can only be calculated for signed transactions with an id
                            _c.address = _d,
                                // Balance
                                _c.value = operation.balance,
                                _c)]);
                        this._inputs.push({
                            address: operation.source,
                            // Balance + fees + max gas + max storage are paid by the source account
                            value: new bignumber_js_1.default(operation.balance).plus(operation.fee).toString(),
                        });
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Record the most important fields from a reveal operation.
     *
     * @param {RevealOp} operation A reveal operation object from a Tezos transaction
     */
    Transaction.prototype.recordRevealOpFields = function (operation) {
        this._type = baseCoin_2.TransactionType.AddressInitialization;
        this._inputs.push({
            address: operation.source,
            // Balance + fees + max gas + max storage are paid by the source account
            value: operation.fee,
        });
    };
    /**
     * Record the most important fields for a Transaction operation.
     *
     * @param {TransactionOp} operation A transaction object from a Tezos operation
     */
    Transaction.prototype.recordTransactionOpFields = function (operation) {
        this._type = baseCoin_2.TransactionType.Send;
        var transferData = multisigUtils_1.getMultisigTransferDataFromOperation(operation);
        // Fees are paid by the source account, along with the amount in the transaction
        this._inputs.push({
            address: operation.source,
            value: new bignumber_js_1.default(transferData.fee.fee).toFixed(0),
        });
        if (transferData.coin === 'mutez') {
            this._outputs.push({
                // Kt addresses can only be calculated for signed transactions with an id
                address: transferData.to,
                // Balance
                value: transferData.amount,
            });
            // The funds being transferred from the wallet
            this._inputs.push({
                address: transferData.from,
                // Balance + fees + max gas + max storage are paid by the source account
                value: transferData.amount,
            });
        }
    };
    /**
     * Sign the transaction with the provided key. It does not check if the signer is allowed to sign
     * it or not.
     *
     * @param {KeyPair} keyPair The key to sign the transaction with
     */
    Transaction.prototype.sign = function (keyPair) {
        return __awaiter(this, void 0, void 0, function () {
            var encodedTransaction, signedTransaction, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        // TODO: fail if the transaction is already signed
                        // Check if there is a transaction to sign
                        if (!this._parsedTransaction) {
                            throw new errors_1.InvalidTransactionError('Empty transaction');
                        }
                        return [4 /*yield*/, local_forging_1.localForger.forge(this._parsedTransaction)];
                    case 1:
                        encodedTransaction = _b.sent();
                        return [4 /*yield*/, Utils.sign(keyPair, encodedTransaction)];
                    case 2:
                        signedTransaction = _b.sent();
                        this._encodedTransaction = signedTransaction.sbytes;
                        // The transaction id can only be calculated for signed transactions
                        _a = this;
                        return [4 /*yield*/, Utils.calculateTransactionId(this._encodedTransaction)];
                    case 3:
                        // The transaction id can only be calculated for signed transactions
                        _a._id = _b.sent();
                        return [4 /*yield*/, this.initFromParsedTransaction(this._parsedTransaction, this._id)];
                    case 4:
                        _b.sent();
                        this._signatures.push(signedTransaction.sig);
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Update the list of signatures for a multisig transaction operation.
     *
     * @param {IndexedSignature[]} signatures List of signatures and the index they should be put on
     *    in the multisig transfer
     * @param {number} index The transfer index to add the signatures to
     */
    Transaction.prototype.addTransferSignature = function (signatures, index) {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this._parsedTransaction) {
                            throw new errors_1.InvalidTransactionError('Empty transaction');
                        }
                        multisigUtils_1.updateMultisigTransferSignatures(this._parsedTransaction.contents[index], signatures);
                        _a = this;
                        return [4 /*yield*/, local_forging_1.localForger.forge(this._parsedTransaction)];
                    case 1:
                        _a._encodedTransaction = _b.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /** @inheritdoc */
    Transaction.prototype.canSign = function (key) {
        // TODO: check the key belongs to the _source account in _parsedTransaction
        return true;
    };
    /** @inheritdoc */
    Transaction.prototype.toJson = function () {
        if (!this._parsedTransaction) {
            throw new errors_1.InvalidTransactionError('Empty transaction');
        }
        return this._parsedTransaction;
    };
    /** @inheritdoc */
    Transaction.prototype.toBroadcastFormat = function () {
        if (!this._encodedTransaction) {
            throw new errors_1.InvalidTransactionError('Missing encoded transaction');
        }
        return this._encodedTransaction;
    };
    Object.defineProperty(Transaction.prototype, "source", {
        /**
         * Get the transaction source if it is available.
         */
        get: function () {
            if (!this._source) {
                throw new errors_1.InvalidTransactionError('Transaction not initialized');
            }
            return this._source;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transaction.prototype, "delegate", {
        /**
         * Get the transaction delegation address if it is available.
         */
        get: function () {
            return this._delegate;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get the signatures for the given multisig transfer,
     *
     * @param {number} transferIndex The transfer script index in the Tezos transaction
     * @returns {IndexedSignature[]} A list of signatures with their index inside the multisig transfer
     *      script
     */
    Transaction.prototype.getTransferSignatures = function (transferIndex) {
        if (transferIndex === void 0) { transferIndex = 0; }
        if (!this._parsedTransaction) {
            return [];
        }
        return multisigUtils_1.getMultisigTransferSignatures(this._parsedTransaction.contents[transferIndex]);
    };
    /**
     * Get the list of index per tezos transaction type. This is useful to locate specific operations
     * within the transaction and verify or sign them.
     *
     * @returns {{[p: string]: number[]}} List of indexes where the key is the transaction kind
     */
    Transaction.prototype.getIndexesByTransactionType = function () {
        if (!this._parsedTransaction) {
            return {};
        }
        var indexes = {};
        for (var i = 0; i < this._parsedTransaction.contents.length; i++) {
            var kind = this._parsedTransaction.contents[i].kind;
            indexes[kind] = indexes[kind] ? indexes[kind].concat([i]) : [i];
        }
        return indexes;
    };
    return Transaction;
}(baseCoin_1.BaseTransaction));
exports.Transaction = Transaction;
//# sourceMappingURL=transaction.js.map