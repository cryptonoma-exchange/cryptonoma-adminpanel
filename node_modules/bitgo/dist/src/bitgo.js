"use strict";
//
// BitGo JavaScript SDK
//
// Copyright 2014, BitGo, Inc.  All Rights Reserved.
//
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var superagent = require("superagent");
var bitcoin = require("bitgo-utxo-lib");
var bitcoin_1 = require("./bitcoin");
var bitcoinMessage = require("bitcoinjs-message");
var sanitizeHtml = require("sanitize-html");
var eol = require("eol");
var PendingApprovals = require('./pendingapprovals');
var shamir = require("secrets.js-grempe");
var sjcl = require("./vendor/sjcl.min.js");
var bs58 = require("bs58");
var common = require("./common");
var util_1 = require("./v2/internal/util");
var Bluebird = require("bluebird");
var co = Bluebird.coroutine;
var pjson = require("../package.json");
var moment = require("moment");
var _ = require("lodash");
var url = require("url");
var querystring = require("querystring");
var config = require("./config");
var crypto = require("crypto");
var debugLib = require("debug");
var internal_1 = require("./v2/internal/internal");
var TransactionBuilder = require('./transactionBuilder');
var Blockchain = require('./blockchain');
var Keychains = require('./keychains');
var TravelRule = require('./travelRule');
var Wallet = require("./wallet");
var Wallets = require('./wallets');
var Markets = require('./markets');
var coinFactory_1 = require("./v2/coinFactory");
var debug = debugLib('bitgo:index');
if (!process.browser) {
    require('superagent-proxy')(superagent);
}
// Patch superagent to return bluebird promises
var _end = superagent.Request.prototype.end;
superagent.Request.prototype.end = function (cb) {
    var self = this;
    if (typeof cb === 'function') {
        return _end.call(self, cb);
    }
    return new Bluebird.Promise(function (resolve, reject) {
        var error;
        try {
            return _end.call(self, function (error, response) {
                if (error) {
                    return reject(error);
                }
                return resolve(response);
            });
        }
        catch (_error) {
            error = _error;
            return reject(error);
        }
    });
};
// Handle HTTP errors appropriately, returning the result body, or a named
// field from the body, if the optionalField parameter is provided.
superagent.Request.prototype.result = function (optionalField) {
    return this.then(handleResponseResult(optionalField), handleResponseError);
};
function handleResponseResult(optionalField) {
    return function (res) {
        if (_.isNumber(res.status) && res.status >= 200 && res.status < 300) {
            return optionalField ? res.body[optionalField] : res.body;
        }
        throw errFromResponse(res);
    };
}
function errFromResponse(res) {
    var errString = createResponseErrorString(res);
    var err = new Error(errString);
    err.status = res.status;
    if (res.body) {
        err.result = res.body;
    }
    if (_.has(res.header, 'x-auth-required') && (res.header['x-auth-required'] === 'true')) {
        err.invalidToken = true;
    }
    if (res.body.needsOTP) {
        err.needsOTP = true;
    }
    return err;
}
function handleResponseError(e) {
    if (e.response) {
        throw errFromResponse(e.response);
    }
    throw e;
}
/**
 * There are many ways a request can fail, and may ways information on that failure can be
 * communicated to the client. This function tries to handle those cases and create a sane error string
 * @param res Response from an HTTP request
 */
function createResponseErrorString(res) {
    var errString = res.status.toString(); // at the very least we'll have the status code
    if (res.body.error) {
        // this is the case we hope for, where the server gives us a nice error from the JSON body
        errString = res.body.error;
    }
    else {
        if (res.text) {
            // if the response came back as text, we try to parse it as HTML and remove all tags, leaving us
            // just the bare text, which we then trim of excessive newlines and limit to a certain length
            try {
                var sanitizedText = sanitizeHtml(res.text, { allowedTags: [] });
                sanitizedText = sanitizedText.trim();
                sanitizedText = eol.lf(sanitizedText); // use '\n' for all newlines
                sanitizedText = _.replace(sanitizedText, /\n[ |\t]{1,}\n/g, '\n\n'); // remove the spaces/tabs between newlines
                sanitizedText = _.replace(sanitizedText, /[\n]{3,}/g, '\n\n'); // have at most 2 consecutive newlines
                sanitizedText = sanitizedText.substring(0, 5000); // prevent message from getting too large
                errString = errString + '\n' + sanitizedText; // add it to our existing errString (at this point the more info the better!)
            }
            catch (e) {
                // do nothing, the response's HTML was too wacky to be parsed cleanly
            }
        }
    }
    return errString;
}
var BitGo = /** @class */ (function () {
    /**
     * Constructor for BitGo Object
     */
    function BitGo(params) {
        if (params === void 0) { params = {}; }
        if (!common.validateParams(params, [], ['clientId', 'clientSecret', 'refreshToken', 'accessToken', 'userAgent', 'customRootURI', 'customBitcoinNetwork', 'serverXpub', 'stellarFederationServerUrl']) ||
            (params.useProduction && !_.isBoolean(params.useProduction))) {
            throw new Error('invalid argument');
        }
        if ((!params.clientId) !== (!params.clientSecret)) {
            throw new Error('invalid argument - must provide both client id and secret');
        }
        // By default, we operate on the test server.
        // Deprecate useProduction in the future
        var env;
        if (params.useProduction) {
            if (params.env && params.env !== 'prod') {
                throw new Error('cannot use useProduction when env=' + params.env);
            }
            env = 'prod';
        }
        else if (params.customRootURI ||
            params.customBitcoinNetwork ||
            params.customSigningAddress ||
            params.serverXpub ||
            process.env.BITGO_CUSTOM_ROOT_URI ||
            process.env.BITGO_CUSTOM_BITCOIN_NETWORK) {
            env = 'custom';
            if (params.customRootURI) {
                common.Environments['custom'].uri = params.customRootURI;
            }
            if (params.customBitcoinNetwork) {
                common.Environments['custom'].network = params.customBitcoinNetwork;
            }
            if (params.customSigningAddress) {
                common.Environments['custom'].customSigningAddress = params.customSigningAddress;
            }
            if (params.serverXpub) {
                common.Environments['custom'].serverXpub = params.serverXpub;
            }
            if (params.stellarFederationServerUrl) {
                common.Environments['custom'].stellarFederationServerUrl = params.stellarFederationServerUrl;
            }
        }
        else {
            env = params.env || process.env.BITGO_ENV;
        }
        if (env === 'production') {
            env = 'prod'; // make life easier
        }
        if (env === 'custom' && _.isUndefined(common.Environments[env].uri)) {
            throw new Error('must use --customrooturi or set the BITGO_CUSTOM_ROOT_URI environment variable when using the custom environment');
        }
        if (env) {
            if (common.Environments[env]) {
                this._baseUrl = common.Environments[env].uri;
            }
            else {
                throw new Error('invalid environment ' + env + '. Supported environments: test, prod');
            }
        }
        else {
            env = 'test';
            if (!BitGo._testnetWarningMessage) {
                BitGo._testnetWarningMessage = true;
                console.log('BitGo SDK env not set - defaulting to test at test.bitgo.com.');
            }
            this._baseUrl = common.Environments[env].uri;
        }
        this._env = this.env = env;
        common.setNetwork(common.Environments[env].network);
        common.setRmgNetwork(common.Environments[env].rmgNetwork);
        this._microservicesUrl = params.microservicesUri;
        this._baseApiUrl = this._baseUrl + '/api/v1';
        this._baseApiUrlV2 = this._baseUrl + '/api/v2';
        this._keychains = null;
        this._wallets = null;
        this._clientId = params.clientId;
        this._clientSecret = params.clientSecret;
        this._token = params.accessToken;
        this._refreshToken = params.refreshToken;
        this._userAgent = params.userAgent || 'BitGoJS/' + this.version();
        this._promise = Bluebird;
        this._reqId = undefined;
        // whether to perform extra client-side validation for some things, such as
        // address validation or signature validation. defaults to true, but can be
        // turned off by setting to false. can also be overridden individually in the
        // functions that use it.
        this._validate = params.validate === undefined ? true : params.validate;
        // Create superagent methods specific to this BitGo instance.
        var methods = ['get', 'post', 'put', 'del', 'patch'];
        if (!params.proxy && process.env.BITGO_USE_PROXY) {
            params.proxy = process.env.BITGO_USE_PROXY;
        }
        if (process.browser && params.proxy) {
            throw new Error('cannot use https proxy params while in browser');
        }
        this._proxy = params.proxy;
        for (var index in methods) {
            var method = methods[index];
            this[method] = this.createPatch(method);
        }
        // capture outer stack so we have useful debug information if fetch constants fails
        var e = new Error();
        // Kick off first load of constants
        this.fetchConstants({}, function (err) {
            if (err) {
                // make sure an error does not terminate the entire script
                console.error('failed to fetch initial client constants from BitGo');
                debug(e.stack);
            }
        });
    }
    /**
     * This is a patching function which can apply our authorization
     * headers to any outbound request.
     * @param method
     */
    BitGo.prototype.createPatch = function (method) {
        var self = this;
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var req = superagent[method].apply(null, args);
            if (self._proxy) {
                req = req.proxy(self._proxy);
            }
            // Patch superagent to return promises
            var prototypicalEnd = req.end;
            req.end = function () {
                var thisReq = this;
                // intercept a request before it's submitted to the server for v2 authentication (based on token)
                thisReq.set('BitGo-SDK-Version', self.version());
                if (!_.isUndefined(self._reqId)) {
                    thisReq.set('Request-ID', self._reqId.toString());
                    // increment after setting the header so the sequence numbers start at 0
                    self._reqId.inc();
                    // request ids must be set before each request instead of being kept
                    // inside the bitgo object. This is to prevent reentrancy issues where
                    // multiple simultaneous requests could cause incorrect reqIds to be used
                    delete self._reqId;
                }
                // if there is no token, and we're not logged in, the request cannot be v2 authenticated
                thisReq.isV2Authenticated = true;
                thisReq.authenticationToken = self._token;
                // some of the older tokens appear to be only 40 characters long
                if ((self._token && self._token.length !== 67 && self._token.indexOf('v2x') !== 0)
                    || req.forceV1Auth) {
                    // use the old method
                    thisReq.isV2Authenticated = false;
                    thisReq.set('Authorization', 'Bearer ' + self._token);
                    return prototypicalEnd.apply(thisReq, arguments);
                }
                thisReq.set('BitGo-Auth-Version', '2.0');
                // prevent IE from caching requests
                thisReq.set('If-Modified-Since', 'Mon, 26 Jul 1997 05:00:00 GMT');
                if (self._token) {
                    // do a localized data serialization process
                    var data = thisReq._data;
                    if (typeof data !== 'string') {
                        var contentType = thisReq.get('Content-Type');
                        // Parse out just the content type from the header (ignore the charset)
                        if (contentType) {
                            contentType = contentType.split(';')[0];
                        }
                        var serialize = superagent.serialize[contentType];
                        if (!serialize && /[\/+]json\b/.test(contentType)) {
                            serialize = superagent.serialize['application/json'];
                        }
                        if (serialize) {
                            data = serialize(data);
                        }
                    }
                    thisReq._data = data;
                    var urlDetails = url.parse(req.url);
                    var queryString = void 0;
                    var query = req._query;
                    var qs = req.qs;
                    if (query && query.length > 0) {
                        // browser version
                        queryString = query.join('&');
                        req._query = [];
                    }
                    else if (qs) {
                        // node version
                        queryString = querystring.stringify(qs);
                        req.qs = null;
                    }
                    if (queryString) {
                        if (urlDetails.search) {
                            urlDetails.search += '&' + queryString;
                        }
                        else {
                            urlDetails.search = '?' + queryString;
                        }
                        req.url = url.format(urlDetails);
                    }
                    var requestProperties = self.calculateRequestHeaders({ url: req.url, token: self._token, text: data });
                    thisReq.set('Auth-Timestamp', requestProperties.timestamp.toString());
                    // we're not sending the actual token, but only its hash
                    thisReq.set('Authorization', 'Bearer ' + requestProperties.tokenHash);
                    // set the HMAC
                    thisReq.set('HMAC', requestProperties.hmac);
                }
                return prototypicalEnd.apply(thisReq, arguments);
            };
            // verify that the response received from the server is signed correctly
            // right now, it is very permissive with the timestamp variance
            req.verifyResponse = function (response) {
                if (!req.isV2Authenticated || !req.authenticationToken) {
                    return response;
                }
                var verificationResponse = self.verifyResponse({
                    url: req.url,
                    hmac: response.header.hmac,
                    statusCode: response.status,
                    text: response.text,
                    timestamp: response.header.timestamp,
                    token: req.authenticationToken
                });
                if (!verificationResponse.isValid) {
                    // calculate the HMAC
                    var receivedHmac = response.header.hmac;
                    var expectedHmac = verificationResponse.expectedHmac;
                    var signatureSubject = verificationResponse.signatureSubject;
                    // Log only the first 10 characters of the token to ensure the full token isn't logged.
                    var partialBitgoToken = self._token ? self._token.substring(0, 10) : '';
                    var errorDetails = {
                        expectedHmac: expectedHmac,
                        receivedHmac: receivedHmac,
                        hmacInput: signatureSubject,
                        requestToken: req.authenticationToken,
                        bitgoToken: partialBitgoToken
                    };
                    debug('Invalid response HMAC: %O', errorDetails);
                    var error = new Error('invalid response HMAC, possible man-in-the-middle-attack');
                    error.result = errorDetails;
                    error.status = 511;
                    throw error;
                }
                return response;
            };
            var lastPromise = null;
            req.then = function () {
                if (!lastPromise) {
                    // cannot redefine end() to return a Bluebird<any>, even though
                    // that gets monkey patched in at runtime, so this cast is required
                    var reference = req.end()
                        .then(req.verifyResponse);
                    lastPromise = reference.then.apply(reference, arguments);
                }
                else {
                    lastPromise = lastPromise.then.apply(lastPromise, arguments);
                }
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                return lastPromise;
            };
            if (!process.browser) {
                // If not in the browser, set the User-Agent. Browsers don't allow
                // setting of User-Agent, so we must disable this when run in the
                // browser (browserify sets process.browser).
                req.set('User-Agent', self._userAgent);
            }
            // Set the request timeout to just above 5 minutes by default
            req.timeout(process.env.BITGO_TIMEOUT * 1000 || 305 * 1000);
            return req;
        };
    };
    /**
     * Calculate the HMAC for the given key and message
     * @param key {String} - the key to use for the HMAC
     * @param message {String} - the actual message to HMAC
     * @returns {*} - the result of the HMAC operation
     */
    BitGo.prototype.calculateHMAC = function (key, message) {
        return crypto.createHmac('sha256', key).update(message).digest('hex');
    };
    /**
     * Create a basecoin object
     * @param coinName
     */
    BitGo.prototype.coin = function (coinName) {
        return coinFactory_1.GlobalCoinFactory.getInstance(this, coinName);
    };
    /**
     * Create a basecoin object for a virtual token
     * @param tokenName
     * @param callback
     */
    BitGo.prototype.token = function (tokenName, callback) {
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, self.fetchConstants()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, self.coin(tokenName)];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     *
     */
    BitGo.prototype.getValidate = function () {
        return this._validate;
    };
    /**
     *
     */
    BitGo.prototype.setValidate = function (validate) {
        if (!_.isBoolean(validate)) {
            throw new Error('invalid argument');
        }
        this._validate = validate;
    };
    /**
     * Return the current BitGo environment
     */
    BitGo.prototype.getEnv = function () {
        return this._env;
    };
    /**
     * Clear out all state from this BitGo object, effectively logging out the current user.
     */
    BitGo.prototype.clear = function () {
        // TODO: are there any other fields which should be cleared?
        this._user = undefined;
        this._token = undefined;
        this._refreshToken = undefined;
        this._ecdhXprv = undefined;
    };
    /**
     * Helper function to return a rejected promise or call callback with error
     *
     * @deprecated
     */
    BitGo.prototype.reject = function (msg, callback) {
        return Bluebird.reject(new Error(msg)).nodeify(callback);
    };
    /**
     * Gets the version of the BitGoJS package
     */
    BitGo.prototype.version = function () {
        return pjson.version;
    };
    /**
     * Serialize this BitGo object to a JSON object.
     *
     * Caution: contains sensitive data
     */
    BitGo.prototype.toJSON = function () {
        return {
            user: this._user,
            token: this._token,
            extensionKey: this._extensionKey ? this._extensionKey.toWIF() : undefined,
        };
    };
    /**
     * Deserialize a JSON serialized BitGo object.
     *
     * Overwrites the properties on the current BitGo object with
     * those of the deserialzed object.
     *
     * @param json
     */
    BitGo.prototype.fromJSON = function (json) {
        this._user = json.user;
        this._token = json.token;
        if (json.extensionKey) {
            var network = common.Environments[this.getEnv()].network;
            this._extensionKey = bitcoin.ECPair.fromWIF(json.extensionKey, bitcoin.networks[network]);
        }
    };
    /**
     * Get the current user
     */
    BitGo.prototype.user = function () {
        return this._user;
    };
    /**
     * Verify a Bitcoin address is a valid base58 address
     * @deprecated
     */
    BitGo.prototype.verifyAddress = function (params) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['address'], []);
        if (!_.isString(params.address)) {
            throw new Error('missing required string address');
        }
        var address;
        try {
            address = bitcoin.address.fromBase58Check(params.address);
        }
        catch (e) {
            return false;
        }
        var networkName = common.Environments[this.getEnv()].network;
        var network = bitcoin.networks[networkName];
        return address.version === network.pubKeyHash || address.version === network.scriptHash;
    };
    /**
     */
    BitGo.prototype.verifyPassword = function (params, callback) {
        if (params === void 0) { params = {}; }
        if (!_.isString(params.password)) {
            throw new Error('missing required string password');
        }
        if (!this._user || !this._user.username) {
            throw new Error('no current user');
        }
        var hmacPassword = this.calculateHMAC(this._user.username, params.password);
        return this.post(this.url('/user/verifypassword'))
            .send({ password: hmacPassword })
            .result('valid')
            .nodeify(callback);
    };
    /**
     * Utility function to encrypt locally.
     */
    BitGo.prototype.encrypt = function (params) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['input', 'password'], []);
        var randomSalt = crypto.randomBytes(8);
        var randomIV = crypto.randomBytes(16);
        var encryptOptions = {
            iter: 10000,
            ks: 256,
            salt: [
                internal_1.bytesToWord(randomSalt.slice(0, 4)),
                internal_1.bytesToWord(randomSalt.slice(4))
            ],
            iv: [
                internal_1.bytesToWord(randomIV.slice(0, 4)),
                internal_1.bytesToWord(randomIV.slice(4, 8)),
                internal_1.bytesToWord(randomIV.slice(8, 12)),
                internal_1.bytesToWord(randomIV.slice(12, 16))
            ]
        };
        return sjcl.encrypt(params.password, params.input, encryptOptions);
    };
    /**
     * Decrypt an encrypted string locally.
     */
    BitGo.prototype.decrypt = function (params) {
        if (params === void 0) { params = {}; }
        params = params || {};
        common.validateParams(params, ['input', 'password'], []);
        try {
            return sjcl.decrypt(params.password, params.input);
        }
        catch (error) {
            if (error.message.includes('ccm: tag doesn\'t match')) {
                error.message = 'password error - ' + error.message;
            }
            throw error;
        }
    };
    /**
     * Generate a random password
     * @param   {Number} numWords     Number of 32-bit words
     * @returns {String}          base58 random password
     */
    BitGo.prototype.generateRandomPassword = function (numWords) {
        if (numWords === void 0) { numWords = 5; }
        var bytes = sjcl.codec.bytes.fromBits(sjcl.random.randomWords(numWords));
        return bs58.encode(bytes);
    };
    /**
     * Split a secret into shards using Shamir Secret Sharing.
     * @param seed A hexadecimal secret to split
     * @param passwords An array of the passwords used to encrypt each share
     * @param m The threshold number of shards necessary to reconstitute the secret
     */
    BitGo.prototype.splitSecret = function (_a) {
        var _this = this;
        var seed = _a.seed, passwords = _a.passwords, m = _a.m;
        if (!Array.isArray(passwords)) {
            throw new Error('passwords must be an array');
        }
        if (!_.isInteger(m) || m < 2) {
            throw new Error('m must be a positive integer greater than or equal to 2');
        }
        if (passwords.length < m) {
            throw new Error('passwords array length cannot be less than m');
        }
        var n = passwords.length;
        var secrets = shamir.share(seed, n, m);
        var shards = _.zipWith(secrets, passwords, function (shard, password) {
            return _this.encrypt({ input: shard, password: password });
        });
        var node = bitcoin.HDNode.fromSeedHex(seed);
        return {
            xpub: node.neutered().toBase58(),
            m: m,
            n: n,
            seedShares: shards,
        };
    };
    /**
     * Reconstitute a secret which was sharded with `splitSecret`.
     * @param shards
     * @param passwords
     */
    BitGo.prototype.reconstituteSecret = function (_a) {
        var _this = this;
        var shards = _a.shards, passwords = _a.passwords;
        if (!Array.isArray(shards)) {
            throw new Error('shards must be an array');
        }
        if (!Array.isArray(passwords)) {
            throw new Error('passwords must be an array');
        }
        if (shards.length !== passwords.length) {
            throw new Error('shards and passwords arrays must have same length');
        }
        var secrets = _.zipWith(shards, passwords, function (shard, password) {
            return _this.decrypt({ input: shard, password: password });
        });
        var seed = shamir.combine(secrets);
        var node = bitcoin.HDNode.fromSeedHex(seed);
        return {
            xpub: node.neutered().toBase58(),
            xprv: node.toBase58(),
            seed: seed,
        };
    };
    /**
     *
     * @param shards
     * @param passwords
     * @param m
     * @param xpub Optional xpub to verify the results against
     */
    BitGo.prototype.verifyShards = function (_a) {
        var _this = this;
        var shards = _a.shards, passwords = _a.passwords, m = _a.m, xpub = _a.xpub;
        /**
         * Generate all possible combinations of a given array's values given subset size m
         * @param array The array whose values are to be arranged in all combinations
         * @param m The size of each subset
         * @param entryIndices Recursively trailing set of currently chosen array indices for the combination subset under construction
         * @returns {Array}
         */
        var generateCombinations = function (array, m, entryIndices) {
            if (entryIndices === void 0) { entryIndices = []; }
            var combinations = [];
            if (entryIndices.length === m) {
                var currentCombination = _.at(array, entryIndices);
                return [currentCombination];
            }
            // The highest index
            var entryIndex = _.last(entryIndices);
            // If there are currently no indices, assume -1
            if (_.isUndefined(entryIndex)) {
                entryIndex = -1;
            }
            for (var i = entryIndex + 1; i < array.length; i++) {
                // append the current index to the trailing indices
                var currentEntryIndices = entryIndices.concat([i]);
                var newCombinations = generateCombinations(array, m, currentEntryIndices);
                combinations = combinations.concat(newCombinations);
            }
            return combinations;
        };
        if (!Array.isArray(shards)) {
            throw new Error('shards must be an array');
        }
        if (!Array.isArray(passwords)) {
            throw new Error('passwords must be an array');
        }
        if (shards.length !== passwords.length) {
            throw new Error('shards and passwords arrays must have same length');
        }
        var secrets = _.zipWith(shards, passwords, function (shard, password) {
            return _this.decrypt({ input: shard, password: password });
        });
        var secretCombinations = generateCombinations(secrets, m);
        var seeds = secretCombinations.map(function (currentCombination) {
            return shamir.combine(currentCombination);
        });
        var uniqueSeeds = _.uniq(seeds);
        if (uniqueSeeds.length !== 1) {
            return false;
        }
        var seed = _.first(uniqueSeeds);
        var node = bitcoin.HDNode.fromSeedHex(seed);
        var restoredXpub = node.neutered().toBase58();
        if (!_.isUndefined(xpub)) {
            if (!_.isString(xpub)) {
                throw new Error('xpub must be a string');
            }
            if (restoredXpub !== xpub) {
                return false;
            }
        }
        return true;
    };
    /**
     * Construct an ECDH secret from a private key and other user's public key
     */
    BitGo.prototype.getECDHSecret = function (_a) {
        var otherPubKeyHex = _a.otherPubKeyHex, eckey = _a.eckey;
        if (!_.isString(otherPubKeyHex)) {
            throw new Error('otherPubKeyHex string required');
        }
        if (!_.isObject(eckey)) {
            throw new Error('eckey object required');
        }
        var otherKeyPub = bitcoin.ECPair.fromPublicKeyBuffer(new Buffer(otherPubKeyHex, 'hex'));
        var secretPoint = otherKeyPub.Q.multiply(eckey.d);
        var secret = util_1.Util.bnToByteArrayUnsigned(secretPoint.affineX);
        return new Buffer(secret).toString('hex');
    };
    /**
     * Gets the user's private keychain, used for receiving shares
     */
    BitGo.prototype.getECDHSharingKeychain = function (params, callback) {
        var self = this;
        return this.get(this.url('/user/settings'))
            .result()
            .then(function (result) {
            if (!result.settings.ecdhKeychain) {
                return self.reject('ecdh keychain not found for user', callback);
            }
            return self.keychains().get({ xpub: result.settings.ecdhKeychain });
        })
            .nodeify(callback);
    };
    /**
     * Get bitcoin market data
     */
    BitGo.prototype.markets = function () {
        if (!this._markets) {
            this._markets = new Markets(this);
        }
        return this._markets;
    };
    /**
     * Get the latest bitcoin prices
     * (Deprecated: Will be removed in the future) use `bitgo.markets().latest()`
     * @deprecated
     */
    BitGo.prototype.market = function (params, callback) {
        return this.get(this.url('/market/latest'))
            .result()
            .nodeify(callback);
    };
    /**
     * Get market data from yesterday
     * (Deprecated: Will be removed in the future) use bitgo.markets().yesterday()
     */
    BitGo.prototype.yesterday = function (params, callback) {
        return this.get(this.url('/market/yesterday'))
            .result()
            .nodeify(callback);
    };
    /**
     * Synchronous method for activating an access token.
     */
    BitGo.prototype.authenticateWithAccessToken = function (_a) {
        var accessToken = _a.accessToken;
        this._token = accessToken;
    };
    /**
     *
     * @param responseBody Response body object
     * @param password Password for the symmetric decryption
     */
    BitGo.prototype.handleTokenIssuance = function (responseBody, password) {
        // make sure the response body contains the necessary properties
        common.validateParams(responseBody, ['derivationPath'], ['encryptedECDHXprv']);
        var environment = this._env;
        var environmentConfig = common.Environments[environment];
        var serverXpub = environmentConfig.serverXpub;
        var ecdhXprv = this._ecdhXprv;
        if (!ecdhXprv) {
            if (!password || !responseBody.encryptedECDHXprv) {
                throw new Error('ecdhXprv property must be set or password and encrypted encryptedECDHXprv must be provided');
            }
            try {
                ecdhXprv = this.decrypt({
                    input: responseBody.encryptedECDHXprv,
                    password: password
                });
            }
            catch (e) {
                e.errorCode = 'ecdh_xprv_decryption_failure';
                console.error('Failed to decrypt encryptedECDHXprv.');
                throw e;
            }
        }
        // construct HDNode objects for client's xprv and server's xpub
        var clientHDNode = bitcoin.HDNode.fromBase58(ecdhXprv);
        var serverHDNode = bitcoin.HDNode.fromBase58(serverXpub);
        // BIP32 derivation path is applied to both client and server master keys
        var derivationPath = responseBody.derivationPath;
        var clientDerivedNode = bitcoin_1.hdPath(clientHDNode).derive(derivationPath);
        var serverDerivedNode = bitcoin_1.hdPath(serverHDNode).derive(derivationPath);
        // calculating one-time ECDH key
        var secretPoint = serverDerivedNode.keyPair.__Q.multiply(clientDerivedNode.keyPair.d);
        var secret = secretPoint.getEncoded().toString('hex');
        // decrypt token with symmetric ECDH key
        var response;
        try {
            response = {
                token: this.decrypt({
                    input: responseBody.encryptedToken,
                    password: secret
                })
            };
        }
        catch (e) {
            e.errorCode = 'token_decryption_failure';
            console.error('Failed to decrypt token.');
            throw e;
        }
        if (!this._ecdhXprv) {
            response.ecdhXprv = ecdhXprv;
        }
        return response;
    };
    /**
     * Calculate the string that is to be HMACed for a certain HTTP request or response
     * @param urlPath
     * @param text
     * @param timestamp
     * @param statusCode Only set for HTTP responses, leave blank for requests
     * @returns {string}
     */
    BitGo.prototype.calculateHMACSubject = function (_a) {
        var urlPath = _a.urlPath, text = _a.text, timestamp = _a.timestamp, statusCode = _a.statusCode;
        var urlDetails = url.parse(urlPath);
        var queryPath = (urlDetails.query && urlDetails.query.length > 0) ? urlDetails.path : urlDetails.pathname;
        if (!_.isUndefined(statusCode) && _.isInteger(statusCode) && _.isFinite(statusCode)) {
            return [timestamp, queryPath, statusCode, text].join('|');
        }
        return [timestamp, queryPath, text].join('|');
    };
    /**
     * Calculate the HMAC for an HTTP request
     */
    BitGo.prototype.calculateRequestHMAC = function (_a) {
        var urlPath = _a.url, text = _a.text, timestamp = _a.timestamp, token = _a.token;
        var signatureSubject = this.calculateHMACSubject({ urlPath: urlPath, text: text, timestamp: timestamp });
        // calculate the HMAC
        return this.calculateHMAC(token, signatureSubject);
    };
    /**
     * Calculate request headers with HMAC
     */
    BitGo.prototype.calculateRequestHeaders = function (_a) {
        var url = _a.url, text = _a.text, token = _a.token;
        var timestamp = Date.now();
        var hmac = this.calculateRequestHMAC({ url: url, text: text, timestamp: timestamp, token: token });
        // calculate the SHA256 hash of the token
        var hashDigest = sjcl.hash.sha256.hash(token);
        var tokenHash = sjcl.codec.hex.fromBits(hashDigest);
        return {
            hmac: hmac,
            timestamp: timestamp,
            tokenHash: tokenHash,
        };
    };
    /**
     * Verify the HMAC for an HTTP response
     */
    BitGo.prototype.verifyResponse = function (_a) {
        var urlPath = _a.url, statusCode = _a.statusCode, text = _a.text, timestamp = _a.timestamp, token = _a.token, hmac = _a.hmac;
        var signatureSubject = this.calculateHMACSubject({
            urlPath: urlPath,
            text: text,
            timestamp: timestamp,
            statusCode: statusCode,
        });
        // calculate the HMAC
        var expectedHmac = this.calculateHMAC(token, signatureSubject);
        // verify the HMAC and timestamp
        return {
            isValid: expectedHmac === hmac,
            expectedHmac: expectedHmac,
            signatureSubject: signatureSubject,
        };
    };
    /**
     * Process the username, password and otp into an object containing the username and hashed password, ready to
     * send to bitgo for authentication.
     */
    BitGo.prototype.preprocessAuthenticationParams = function (_a) {
        var username = _a.username, password = _a.password, otp = _a.otp, forceSMS = _a.forceSMS, extensible = _a.extensible, trust = _a.trust;
        if (!_.isString(username)) {
            throw new Error('expected string username');
        }
        if (!_.isString(password)) {
            throw new Error('expected string password');
        }
        var lowerName = username.toLowerCase();
        // Calculate the password HMAC so we don't send clear-text passwords
        var hmacPassword = this.calculateHMAC(lowerName, password);
        var authParams = {
            email: lowerName,
            password: hmacPassword,
            forceSMS: !!forceSMS,
        };
        if (otp) {
            authParams.otp = otp;
            if (trust) {
                authParams.trust = 1;
            }
        }
        if (extensible) {
            this._extensionKey = bitcoin_1.makeRandomKey();
            authParams.extensible = true;
            authParams.extensionAddress = this._extensionKey.getAddress();
        }
        return authParams;
    };
    /**
     * Login to the bitgo platform.
     */
    BitGo.prototype.authenticate = function (params, callback) {
        var self = this;
        return co(function () {
            var forceV1Auth, authParams, password, authUrl, request, response, body, encryptedXprv, responseDetails;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!_.isObject(params)) {
                            throw new Error('required object params');
                        }
                        if (callback && !_.isFunction(callback)) {
                            throw new Error('callback parameter must be a function');
                        }
                        if (!_.isString(params.password)) {
                            throw new Error('expected string password');
                        }
                        forceV1Auth = !!params.forceV1Auth;
                        authParams = self.preprocessAuthenticationParams(params);
                        password = params.password;
                        if (self._token) {
                            return [2 /*return*/, self.reject('already logged in', callback)];
                        }
                        authUrl = self._microservicesUrl ?
                            self.microservicesUrl('/api/auth/v1/session') :
                            self.url('/user/login');
                        request = self.post(authUrl);
                        if (forceV1Auth) {
                            request.forceV1Auth = true;
                            // tell the server that the client was forced to downgrade the authentication protocol
                            authParams.forceV1Auth = true;
                        }
                        return [4 /*yield*/, request.send(authParams)];
                    case 1:
                        response = _a.sent();
                        body = response.body;
                        self._user = body.user;
                        if (body.access_token) {
                            self._token = body.access_token;
                            // if the downgrade was forced, adding a warning message might be prudent
                        }
                        else {
                            encryptedXprv = body.encryptedECDHXprv;
                            if (!encryptedXprv) {
                                throw new Error('Keychain needs encryptedXprv property');
                            }
                            responseDetails = self.handleTokenIssuance(response.body, password);
                            self._token = responseDetails.token;
                            self._ecdhXprv = responseDetails.ecdhXprv;
                            // verify the response's authenticity
                            request.verifyResponse(response);
                            // add the remaining component for easier access
                            response.body.access_token = self._token;
                        }
                        return [2 /*return*/, response];
                }
            });
        }).call(this)
            .then(handleResponseResult(), handleResponseError)
            .nodeify(callback);
    };
    /**
     * @param params
     * - operatingSystem: one of ios, android
     * - pushToken: hex-formatted token for the respective native push notification service
     * @param callback
     * @returns {*}
     * @deprecated
     */
    BitGo.prototype.registerPushToken = function (params, callback) {
        params = params || {};
        common.validateParams(params, ['pushToken', 'operatingSystem'], [], callback);
        if (!this._token) {
            // this device has to be registered to an extensible session
            return this.reject('not logged in', callback);
        }
        var postParams = _.pick(params, ['pushToken', 'operatingSystem']);
        return this.post(this.url('/devices'))
            .send(postParams)
            .result()
            .nodeify(callback);
    };
    /**
     *
     * @param params
     * - pushVerificationToken: the token received via push notification to confirm the device's mobility
     * @param callback
     * @deprecated
     */
    BitGo.prototype.verifyPushToken = function (params, callback) {
        var self = this;
        return co(function () {
            var postParams;
            return __generator(this, function (_a) {
                if (!_.isObject(params)) {
                    throw new Error('required object params');
                }
                if (!_.isString(params.pushVerificationToken)) {
                    throw new Error('required string pushVerificationToken');
                }
                if (!self._token) {
                    // this device has to be registered to an extensible session
                    throw new Error('not logged in');
                }
                postParams = _.pick(params, 'pushVerificationToken');
                return [2 /*return*/, self.post(self.url('/devices/verify'))
                        .send(postParams)
                        .result()];
            });
        }).call(this)
            .nodeify(callback);
    };
    /**
     * Login to the bitgo system using an authcode generated via Oauth
     */
    BitGo.prototype.authenticateWithAuthCode = function (params, callback) {
        var self = this;
        return co(function () {
            var authCode, request, body, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!_.isObject(params)) {
                            throw new Error('required object params');
                        }
                        if (!_.isString(params.authCode)) {
                            throw new Error('required string authCode');
                        }
                        if (!self._clientId || !self._clientSecret) {
                            throw new Error('Need client id and secret set first to use this');
                        }
                        authCode = params.authCode;
                        if (self._token) {
                            return [2 /*return*/, self.reject('already logged in', callback)];
                        }
                        request = self.post(self._baseUrl + '/oauth/token');
                        request.forceV1Auth = true; // OAuth currently only supports v1 authentication
                        return [4 /*yield*/, request
                                .send({
                                grant_type: 'authorization_code',
                                code: authCode,
                                client_id: self._clientId,
                                client_secret: self._clientSecret,
                            })
                                .result()];
                    case 1:
                        body = _b.sent();
                        self._token = body.access_token;
                        self._refreshToken = body.refresh_token;
                        _a = self;
                        return [4 /*yield*/, self.me()];
                    case 2:
                        _a._user = _b.sent();
                        return [2 /*return*/, body];
                }
            });
        })
            .call(this)
            .nodeify(callback);
    };
    /**
     * Use refresh token to get new access token.
     * If the refresh token is null/defined, then we use the stored token from auth
     */
    BitGo.prototype.refreshToken = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var refreshToken, body;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        common.validateParams(params, [], ['refreshToken'], callback);
                        refreshToken = params.refreshToken || self._refreshToken;
                        if (!refreshToken) {
                            throw new Error('Must provide refresh token or have authenticated with Oauth before');
                        }
                        if (!self._clientId || !self._clientSecret) {
                            throw new Error('Need client id and secret set first to use this');
                        }
                        return [4 /*yield*/, self.post(self._baseUrl + '/oauth/token')
                                .send({
                                grant_type: 'refresh_token',
                                refresh_token: refreshToken,
                                client_id: self._clientId,
                                client_secret: self._clientSecret
                            })
                                .result()];
                    case 1:
                        body = _a.sent();
                        self._token = body.access_token;
                        self._refreshToken = body.refresh_token;
                        return [2 /*return*/, body];
                }
            });
        })
            .call(this)
            .nodeify(callback);
    };
    /**
     *
     * listAccessTokens
     * Get information on all of the BitGo access tokens on the user
     * @return {
     *  id: <id of the token>
     *  label: <the user-provided label for this token>
     *  user: <id of the user on the token>
     *  enterprise <id of the enterprise this token is valid for>
     *  client: <the auth client that this token belongs to>
     *  scope: <list of allowed OAuth scope values>
     *  created: <date the token was created>
     *  expires: <date the token will expire>
     *  origin: <the origin for which this token is valid>
     *  isExtensible: <flag indicating if the token can be extended>
     *  extensionAddress: <address whose private key's signature is necessary for extensions>
     *  unlock: <info for actions that require an unlock before firing>
     * }
     */
    BitGo.prototype.listAccessTokens = function (params, callback) {
        return this.get(this.url('/user/accesstoken'))
            .send()
            .result('accessTokens')
            .nodeify(callback);
    };
    /**
     * addAccessToken
     * Add a BitGo API Access Token to the current user account
     * @param params {
     *    otp: (required) <valid otp code>
     *    label: (required) <label for the token>
     *    duration: <length of time in seconds the token will be valid for>
     *    ipRestrict: <array of IP address strings to whitelist>
     *    txValueLimit: <number of outgoing satoshis allowed on this token>
     *    scope: (required) <authorization scope of the requested token>
     * }
     * @param callback
     * @return {
     *    id: <id of the token>
     *    token: <access token hex string to be used for BitGo API request verification>
     *    label: <user-provided label for this token>
     *    user: <id of the user on the token>
     *    enterprise <id of the enterprise this token is valid for>
     *    client: <the auth client that this token belongs to>
     *    scope: <list of allowed OAuth scope values>
     *    created: <date the token was created>
     *    expires: <date the token will expire>
     *    origin: <the origin for which this token is valid>
     *    isExtensible: <flag indicating if the token can be extended>
     *    extensionAddress: <address whose private key's signature is necessary for extensions>
     *    unlock: <info for actions that require an unlock before firing>
     * }
     */
    BitGo.prototype.addAccessToken = function (params, callback) {
        var self = this;
        return co(function () {
            var authUrl, request, response, responseDetails;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!_.isString(params.label)) {
                            throw new Error('required string label');
                        }
                        // check non-string params
                        if (params.duration) {
                            if (!_.isNumber(params.duration) || params.duration < 0) {
                                throw new Error('duration must be a non-negative number');
                            }
                        }
                        if (params.ipRestrict) {
                            if (!_.isArray(params.ipRestrict)) {
                                throw new Error('ipRestrict must be an array');
                            }
                            _.forEach(params.ipRestrict, function (ipAddr) {
                                if (!_.isString(ipAddr)) {
                                    throw new Error('ipRestrict must be an array of IP address strings');
                                }
                            });
                        }
                        if (params.txValueLimit) {
                            if (!_.isNumber(params.txValueLimit)) {
                                throw new Error('txValueLimit must be a number');
                            }
                            if (params.txValueLimit < 0) {
                                throw new Error('txValueLimit must be a non-negative number');
                            }
                        }
                        if (params.scope && params.scope.length > 0) {
                            if (!_.isArray(params.scope)) {
                                throw new Error('scope must be an array');
                            }
                        }
                        else {
                            throw new Error('must specify scope for token');
                        }
                        authUrl = self._microservicesUrl ?
                            self.microservicesUrl('/api/auth/v1/accesstoken') :
                            self.url('/user/accesstoken');
                        request = self.post(authUrl);
                        if (!self._ecdhXprv) {
                            // without a private key, the user cannot decrypt the new access token the server will send
                            request.forceV1Auth = true;
                        }
                        return [4 /*yield*/, request.send(params)];
                    case 1:
                        response = _a.sent();
                        if (request.forceV1Auth) {
                            response.body.warning = 'A protocol downgrade has occurred because this is a legacy account.';
                            return [2 /*return*/, response];
                        }
                        // verify the authenticity of the server's response before proceeding any further
                        request.verifyResponse(response);
                        responseDetails = self.handleTokenIssuance(response.body);
                        response.body.token = responseDetails.token;
                        return [2 /*return*/, response];
                }
            });
        }).call(this)
            .then(handleResponseResult(), handleResponseError)
            .nodeify(callback);
    };
    /**
     * Sets the expire time of an access token matching either the id or label to the current date, effectively deleting it
     *
     * Params:
     * id: <id of the access token to be deleted>
     * label: <label of the access token to be deleted>
     *
     * Returns:
     * id: <id of the token>
     * label: <user-provided label for this token>
     * user: <id of the user on the token>
     * enterprise <id of the enterprise this token is valid for>
     * client: <the auth client that this token belongs to>
     * scope: <list of allowed OAuth scope values>
     * created: <date the token was created>
     * expires: <date the token will expire>
     * origin: <the origin for which this token is valid>
     * isExtensible: <flag indicating if the token can be extended>
     * extensionAddress: <address whose private key's signature is ne*cessary for extensions>
     * unlock: <info for actions that require an unlock before firing>
     * @param params
     * @param callback
     */
    BitGo.prototype.removeAccessToken = function (_a, callback) {
        var id = _a.id, label = _a.label;
        var self = this;
        return co(function () {
            var tokens, matchingTokens;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if ((!id && !label) || (id && label)) {
                            throw new Error('must provide exactly one of id or label');
                        }
                        if (id) {
                            return [2 /*return*/, self.del(self.url("/user/accesstoken/" + id))
                                    .send()
                                    .result()];
                        }
                        return [4 /*yield*/, self.listAccessTokens()];
                    case 1:
                        tokens = _a.sent();
                        if (!tokens) {
                            throw new Error('token with this label does not exist');
                        }
                        matchingTokens = _.filter(tokens, { label: label });
                        if (matchingTokens.length > 1) {
                            throw new Error('ambiguous call: multiple tokens matching this label');
                        }
                        if (matchingTokens.length === 0) {
                            throw new Error('token with this label does not exist');
                        }
                        return [2 /*return*/, self.del(self.url("/user/accesstoken/" + matchingTokens[0].id))
                                .send()
                                .result()];
                }
            });
        })
            .call(this)
            .nodeify(callback);
    };
    /**
     * Logout of BitGo
     * @param params
     * @param callback
     */
    BitGo.prototype.logout = function (params, callback) {
        var self = this;
        return co(function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, self.get(self.url('/user/logout')).result()];
                    case 1:
                        result = _a.sent();
                        self.clear();
                        return [2 /*return*/, result];
                }
            });
        })
            .call(this)
            .nodeify(callback);
    };
    /**
     * Get a user by ID (name/email only)
     * @param id
     * @param callback
     */
    BitGo.prototype.getUser = function (_a, callback) {
        var id = _a.id;
        return co(function () {
            return __generator(this, function (_a) {
                if (!_.isString(id)) {
                    throw new Error('expected string id');
                }
                return [2 /*return*/, this.get(this.url("/user/" + id)).result('user')];
            });
        })
            .call(this)
            .nodeify(callback);
    };
    /**
     * Change the password of the currently logged in user.
     * Also change all v1 and v2 keychain passwords if they match the
     * given oldPassword. Returns nothing on success.
     * @param oldPassword {String} - the current password
     * @param newPassword {String} - the new password
     * @param callback
     */
    BitGo.prototype.changePassword = function (_a, callback) {
        var oldPassword = _a.oldPassword, newPassword = _a.newPassword;
        var self = this;
        return co(function coChangePassword() {
            var user, validation, coin, updateKeychainPasswordParams, v1KeychainUpdatePWResult, v2Keychains, updatePasswordParams;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!_.isString(oldPassword)) {
                            throw new Error('expected string oldPassword');
                        }
                        if (!_.isString(newPassword)) {
                            throw new Error('expected string newPassword');
                        }
                        user = self.user();
                        if (typeof user !== 'object' || !user.username) {
                            throw new Error('missing required object user');
                        }
                        return [4 /*yield*/, self.verifyPassword({ password: oldPassword })];
                    case 1:
                        validation = _a.sent();
                        if (!validation) {
                            throw new Error('the provided oldPassword is incorrect');
                        }
                        coin = common.Environments[self.getEnv()].network === 'bitcoin' ? 'btc' : 'tbtc';
                        updateKeychainPasswordParams = { oldPassword: oldPassword, newPassword: newPassword };
                        return [4 /*yield*/, self.keychains().updatePassword(updateKeychainPasswordParams)];
                    case 2:
                        v1KeychainUpdatePWResult = _a.sent();
                        return [4 /*yield*/, self.coin(coin).keychains().updatePassword(updateKeychainPasswordParams)];
                    case 3:
                        v2Keychains = _a.sent();
                        updatePasswordParams = {
                            keychains: v1KeychainUpdatePWResult.keychains,
                            v2_keychains: v2Keychains,
                            version: v1KeychainUpdatePWResult.version,
                            oldPassword: self.calculateHMAC(user.username, oldPassword),
                            password: self.calculateHMAC(user.username, newPassword)
                        };
                        return [2 /*return*/, self.post(self.url('/user/changepassword'))
                                .send(updatePasswordParams)
                                .result()];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Get the current logged in user
     * @param params
     * @param callback
     */
    BitGo.prototype.me = function (params, callback) {
        return this.getUser({ id: 'me' }, callback);
    };
    /**
     * Unlock the session by providing OTP
     * @param {string} otp Required OTP code for the account.
     * @param {number} duration Desired duration of the unlock in seconds (default=600, max=3600).
     * @param callback
     */
    BitGo.prototype.unlock = function (_a, callback) {
        var otp = _a.otp, duration = _a.duration;
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                if (otp && !_.isString(otp)) {
                    throw new Error('expected string or undefined otp');
                }
                return [2 /*return*/, self.post(self.url('/user/unlock'))
                        .send({ otp: otp, duration: duration })
                        .result()];
            });
        })
            .call(this)
            .nodeify(callback);
    };
    /**
     * Lock the session
     * @param params
     * @param callback
     */
    BitGo.prototype.lock = function (params, callback) {
        return this.post(this.url('/user/lock'))
            .result()
            .nodeify(callback);
    };
    /**
     * Get the current session
     */
    BitGo.prototype.session = function (params, callback) {
        return this.get(this.url('/user/session'))
            .result('session')
            .nodeify(callback);
    };
    /**
     * Trigger a push/sms for the OTP code
     * @param {boolean} params.forceSMS If set to true, will use SMS to send the OTP to the user even if they have other 2FA method set up.
     * @deprecated
     */
    BitGo.prototype.sendOTP = function (params, callback) {
        if (params === void 0) { params = {}; }
        return this.post(this.url('/user/sendotp'))
            .send(params)
            .result()
            .nodeify(callback);
    };
    /**
     * Extend token, provided the current token is extendable
     * @param params
     * - duration: duration in seconds by which to extend the token, starting at the current time
     * @param callback
     */
    BitGo.prototype.extendToken = function (params, callback) {
        if (params === void 0) { params = {}; }
        if (!this._extensionKey) {
            throw new Error('missing required property _extensionKey');
        }
        var timestamp = Date.now();
        var duration = params.duration;
        var message = timestamp + '|' + this._token + '|' + duration;
        var privateKey = this._extensionKey.d.toBuffer(32);
        var isCompressed = this._extensionKey.compressed;
        var prefix = bitcoin.networks.bitcoin.messagePrefix;
        var signature = bitcoinMessage.sign(message, privateKey, isCompressed, prefix).toString('hex');
        return this.post(this.url('/user/extendtoken'))
            .send(params)
            .set('timestamp', timestamp.toString())
            .set('signature', signature)
            .result()
            .nodeify(callback);
    };
    /**
     * Get a key for sharing a wallet with a user
     * @param email email of user to share wallet with
     * @param callback
     */
    BitGo.prototype.getSharingKey = function (_a, callback) {
        var email = _a.email;
        if (!_.isString(email)) {
            throw new Error('required string email');
        }
        return this.post(this.url('/user/sharingkey'))
            .send({ email: email })
            .result()
            .nodeify(callback);
    };
    /**
     * Test connectivity to the server
     * @param params
     * @param callback
     */
    BitGo.prototype.ping = function (_a, callback) {
        var reqId = (_a === void 0 ? {} : _a).reqId;
        if (reqId) {
            this._reqId = reqId;
        }
        return this.get(this.url('/ping'))
            .result()
            .nodeify(callback);
    };
    /**
     * Get the blockchain object.
     * @deprecated
     */
    BitGo.prototype.blockchain = function () {
        if (!this._blockchain) {
            this._blockchain = new Blockchain(this);
        }
        return this._blockchain;
    };
    /**
     * Get the user's keychains object.
     * @deprecated
     */
    BitGo.prototype.keychains = function () {
        if (!this._keychains) {
            this._keychains = new Keychains(this);
        }
        return this._keychains;
    };
    /**
     * Get the user's wallets object.
     * @deprecated
     */
    BitGo.prototype.wallets = function () {
        if (!this._wallets) {
            this._wallets = new Wallets(this);
        }
        return this._wallets;
    };
    /**
     * Get the travel rule object
     * @deprecated
     */
    BitGo.prototype.travelRule = function () {
        if (!this._travelRule) {
            this._travelRule = new TravelRule(this);
        }
        return this._travelRule;
    };
    /**
     * Get pending approvals that can be approved/ or rejected
     * @deprecated
     */
    BitGo.prototype.pendingApprovals = function () {
        if (!this._pendingApprovals) {
            this._pendingApprovals = new PendingApprovals(this);
        }
        return this._pendingApprovals;
    };
    /**
     * A factory method to create a new Wallet object, initialized with the wallet params
     * Can be used to reconstitute a wallet from cached data
     * @param walletParams
     * @deprecated
     */
    BitGo.prototype.newWalletObject = function (walletParams) {
        return new Wallet(this, walletParams);
    };
    /**
     * Create a url for calling BitGo platform APIs
     * @param path
     * @param version
     */
    BitGo.prototype.url = function (path, version) {
        if (version === void 0) { version = 1; }
        var baseUrl = version === 2 ? this._baseApiUrlV2 : this._baseApiUrl;
        return baseUrl + path;
    };
    /**
     * Create a url for calling BitGo microservice APIs
     */
    BitGo.prototype.microservicesUrl = function (path) {
        return this._microservicesUrl + path;
    };
    /**
     * Get all the address labels on all of the user's wallets
     */
    BitGo.prototype.labels = function (params, callback) {
        return this.get(this.url('/labels'))
            .result('labels')
            .nodeify(callback);
    };
    /**
     * Estimates approximate fee per kb needed for a tx to get into a block
     * @param {number} params.numBlocks target blocks for the transaction to be confirmed
     * @param {number} params.maxFee maximum fee willing to be paid (for safety)
     * @param {array[string]} params.inputs list of unconfirmed txIds from which this transaction uses inputs
     * @param {number} params.txSize estimated transaction size in bytes, optional parameter used for CPFP estimation.
     * @param {boolean} params.cpfpAware flag indicating fee should take into account CPFP
     * @deprecated
     */
    BitGo.prototype.estimateFee = function (params, callback) {
        if (params === void 0) { params = {}; }
        var queryParams = { version: 12 };
        if (params.numBlocks) {
            if (!_.isNumber(params.numBlocks)) {
                throw new Error('invalid argument');
            }
            queryParams.numBlocks = params.numBlocks;
        }
        if (params.maxFee) {
            if (!_.isNumber(params.maxFee)) {
                throw new Error('invalid argument');
            }
            queryParams.maxFee = params.maxFee;
        }
        if (params.inputs) {
            if (!Array.isArray(params.inputs)) {
                throw new Error('invalid argument');
            }
            queryParams.inputs = params.inputs;
        }
        if (params.txSize) {
            if (!_.isNumber(params.txSize)) {
                throw new Error('invalid argument');
            }
            queryParams.txSize = params.txSize;
        }
        if (params.cpfpAware) {
            if (!_.isBoolean(params.cpfpAware)) {
                throw new Error('invalid argument');
            }
            queryParams.cpfpAware = params.cpfpAware;
        }
        return this.get(this.url('/tx/fee'))
            .query(queryParams)
            .result()
            .nodeify(callback);
    };
    /**
     * Get BitGo's guarantee using an instant id
     * @param params
     * @param callback
     * @deprecated
     */
    BitGo.prototype.instantGuarantee = function (params, callback) {
        var self = this;
        return co(function () {
            var body, signingAddress, signatureBuffer, prefix, isValidSignature;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!_.isString(params.id)) {
                            throw new Error('required string id');
                        }
                        return [4 /*yield*/, self.get(self.url('/instant/' + params.id)).result()];
                    case 1:
                        body = _a.sent();
                        if (!body.guarantee) {
                            throw new Error('no guarantee found in response body');
                        }
                        if (!body.signature) {
                            throw new Error('no signature found in guarantee response body');
                        }
                        signingAddress = common.Environments[self.getEnv()].signingAddress;
                        signatureBuffer = new Buffer(body.signature, 'hex');
                        prefix = bitcoin.networks[common.Environments[self.getEnv()].network].messagePrefix;
                        isValidSignature = bitcoinMessage.verify(body.guarantee, signingAddress, signatureBuffer, prefix);
                        if (!isValidSignature) {
                            throw new Error('incorrect signature');
                        }
                        return [2 /*return*/, body];
                }
            });
        })
            .call(this)
            .nodeify(callback);
    };
    /**
     * Get a target address for payment of a BitGo fee
     * @param params
     * @param callback
     * @deprecated
     */
    BitGo.prototype.getBitGoFeeAddress = function (params, callback) {
        return this.post(this.url('/billing/address'))
            .send({})
            .result()
            .nodeify(callback);
    };
    /**
     * Gets an address object (including the wallet id) for a given address.
     * @param {string} params.address The address to look up.
     * @deprecated
     */
    BitGo.prototype.getWalletAddress = function (_a, callback) {
        var address = _a.address;
        return this.get(this.url("/walletaddress/" + address))
            .result()
            .nodeify(callback);
    };
    /**
     * Fetch list of user webhooks
     *
     * @param callback
     * @returns {*}
     * @deprecated
     */
    BitGo.prototype.listWebhooks = function (callback) {
        return this.get(this.url('/webhooks'))
            .result()
            .nodeify(callback);
    };
    /**
     * Add new user webhook
     *
     * @param params
     * @param callback
     * @returns {*}
     * @deprecated
     */
    BitGo.prototype.addWebhook = function (params, callback) {
        if (!_.isString(params.url)) {
            throw new Error('required string url');
        }
        if (!_.isString(params.type)) {
            throw new Error('required string type');
        }
        return this.post(this.url('/webhooks'))
            .send(params)
            .result()
            .nodeify(callback);
    };
    /**
     * Remove user webhook
     *
     * @param params
     * @param callback
     * @returns {*}
     * @deprecated
     */
    BitGo.prototype.removeWebhook = function (params, callback) {
        if (!_.isString(params.url)) {
            throw new Error('required string url');
        }
        if (!_.isString(params.type)) {
            throw new Error('required string type');
        }
        return this.del(this.url('/webhooks'))
            .send(params)
            .result()
            .nodeify(callback);
    };
    /**
     * Fetch list of webhook notifications for the user
     *
     * @param params
     * @param callback
     * @returns {*}
     */
    BitGo.prototype.listWebhookNotifications = function (params, callback) {
        if (params === void 0) { params = {}; }
        var query = {};
        if (params.prevId) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            query.prevId = params.prevId;
        }
        if (params.limit) {
            if (!_.isNumber(params.limit)) {
                throw new Error('invalid limit argument, expecting number');
            }
            query.limit = params.limit;
        }
        return this.get(this.url('/webhooks/notifications'))
            .query(query)
            .result()
            .nodeify(callback);
    };
    /**
     * Simulate a user webhook
     *
     * @param params
     * @param callback
     * @returns {*}
     */
    BitGo.prototype.simulateWebhook = function (params, callback) {
        common.validateParams(params, ['webhookId', 'blockId'], [], callback);
        if (!_.isString(params.webhookId)) {
            throw new Error('required string webhookId');
        }
        if (!_.isString(params.blockId)) {
            throw new Error('required string blockId');
        }
        return this.post(this.url("/webhooks/" + params.webhookId + "/simulate"))
            .send(params)
            .result()
            .nodeify(callback);
    };
    /**
     * Receives a TTL and refetches as necessary
     * @param params
     * @param callback
     */
    BitGo.prototype.fetchConstants = function (params, callback) {
        var self = this;
        return co(function () {
            var env, resultPromise, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        env = self.getEnv();
                        if (!BitGo._constants) {
                            BitGo._constants = {};
                        }
                        if (!BitGo._constantsExpire) {
                            BitGo._constantsExpire = {};
                        }
                        if (BitGo._constants[env] && BitGo._constantsExpire[env] && new Date() < BitGo._constantsExpire[env]) {
                            return [2 /*return*/, BitGo._constants[env]];
                        }
                        resultPromise = superagent.get(self.url('/client/constants'));
                        return [4 /*yield*/, (self._proxy ? resultPromise.proxy(self._proxy) : resultPromise)];
                    case 1:
                        result = _a.sent();
                        BitGo._constants[env] = result.body.constants;
                        BitGo._constantsExpire[env] = moment.utc().add(result.body.ttl, 'second').toDate();
                        return [2 /*return*/, BitGo._constants[env]];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Synchronously get constants which are relevant to the client.
     *
     * Note: This function has a known race condition. It may return different values over time,
     * especially if called shortly after creation of the BitGo object.
     *
     * New code should call fetchConstants() directly instead.
     *
     * @deprecated
     * @param params
     * @return {Object} The client constants object
     */
    BitGo.prototype.getConstants = function (params) {
        // kick off a fresh request for the client constants
        this.fetchConstants(params, function (err) {
            if (err) {
                // make sure an error does not terminate the entire script
                console.error('failed to fetch client constants from BitGo');
                console.trace(err);
            }
        });
        // use defaultConstants as the backup for keys that are not set in this._constants
        return _.merge({}, config.defaultConstants(this.getEnv()), BitGo._constants[this.getEnv()]);
    };
    /**
     * V1 method for calculating miner fee amounts, given the number and
     * type of transaction inputs, along with a fee rate in satoshis per vkB.
     *
     * This method should not be used for new code.
     *
     * @deprecated
     * @param params
     * @param callback
     * @return {any}
     */
    BitGo.prototype.calculateMinerFeeInfo = function (params, callback) {
        return co(function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, TransactionBuilder.calculateMinerFeeInfo(params)];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Set a request tracer to provide request IDs during multi-request workflows
     */
    BitGo.prototype.setRequestTracer = function (reqTracer) {
        if (reqTracer) {
            this._reqId = reqTracer;
        }
    };
    BitGo._testnetWarningMessage = false;
    return BitGo;
}());
exports.BitGo = BitGo;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYml0Z28uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYml0Z28udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLEVBQUU7QUFDRix1QkFBdUI7QUFDdkIsRUFBRTtBQUNGLG9EQUFvRDtBQUNwRCxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVGLHVDQUF5QztBQUN6Qyx3Q0FBMEM7QUFDMUMscUNBQWtEO0FBQ2xELGtEQUFxRDtBQUNyRCw0Q0FBK0M7QUFDL0MseUJBQTRCO0FBRTVCLElBQU0sZ0JBQWdCLEdBQUcsT0FBTyxDQUFDLG9CQUFvQixDQUFDLENBQUM7QUFDdkQsMENBQTZDO0FBQzdDLDJDQUE4QztBQUM5QywyQkFBOEI7QUFDOUIsaUNBQW1DO0FBR25DLDJDQUF5RDtBQUV6RCxtQ0FBcUM7QUFDckMsSUFBTyxFQUFFLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQztBQUMvQix1Q0FBMEM7QUFDMUMsK0JBQWtDO0FBQ2xDLDBCQUE0QjtBQUM1Qix5QkFBMkI7QUFDM0IseUNBQTJDO0FBQzNDLGlDQUFtQztBQUNuQywrQkFBaUM7QUFDakMsZ0NBQWtDO0FBQ2xDLG1EQUFxRDtBQUVyRCxJQUFNLGtCQUFrQixHQUFHLE9BQU8sQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0FBQzNELElBQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUMzQyxJQUFNLFNBQVMsR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7QUFDekMsSUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLGNBQWMsQ0FBQyxDQUFDO0FBQzNDLGlDQUFvQztBQUNwQyxJQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDckMsSUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQ3JDLGdEQUFxRDtBQUVyRCxJQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLENB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SSxHQUFHLEVBQUU7Z0JBQ1AsMERBQTBEO2dCQUMxRCxPQUFPLENBQUMsS0FBSyxDQUFDLDZDQUE2QyxDQUFDLENBQUM7Z0JBQzdELE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7YUFDcEI7UUFDSCxDQUFDLENBQUMsQ0FBQztRQUVILGtGQUFrRjtRQUNsRixPQUFPLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDOUYsQ0FBQztJQUVEOzs7Ozs7Ozs7O09BVUc7SUFDSCxxQ0FBcUIsR0FBckIsVUFBc0IsTUFBVyxFQUFFLFFBQTRCO1FBQzdELE9BQU8sRUFBRSxDQUFDOztnQkFDUixzQkFBTyxrQkFBa0IsQ0FBQyxxQkFBcUIsQ0FBQyxNQUFNLENBQUMsRUFBQzs7U0FDekQsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVEOztPQUVHO0lBQ0gsZ0NBQWdCLEdBQWhCLFVBQWlCLFNBQXlCO1FBQ3hDLElBQUksU0FBUyxFQUFFO1lBQ2IsSUFBSSxDQUFDLE1BQU0sR0FBRyxTQUFTLENBQUM7U0FDekI7SUFDSCxDQUFDO0lBMTJEYyw0QkFBc0IsR0FBRyxLQUFLLENBQUM7SUEyMkRoRCxZQUFDO0NBQUEsQUE1MkRELElBNDJEQztBQTUyRFksc0JBQUsiLCJzb3VyY2VzQ29udGVudCI6WyIvL1xuLy8gQml0R28gSmF2YVNjcmlwdCBTREtcbi8vXG4vLyBDb3B5cmlnaHQgMjAxNCwgQml0R28sIEluYy4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuXG5pbXBvcnQgKiBhcyBzdXBlcmFnZW50IGZyb20gJ3N1cGVyYWdlbnQnO1xuaW1wb3J0ICogYXMgYml0Y29pbiBmcm9tICdiaXRnby11dHhvLWxpYic7XG5pbXBvcnQgeyBtYWtlUmFuZG9tS2V5LCBoZFBhdGggfSBmcm9tICcuL2JpdGNvaW4nO1xuaW1wb3J0IGJpdGNvaW5NZXNzYWdlID0gcmVxdWlyZSgnYml0Y29pbmpzLW1lc3NhZ2UnKTtcbmltcG9ydCBzYW5pdGl6ZUh0bWwgPSByZXF1aXJlKCdzYW5pdGl6ZS1odG1sJyk7XG5pbXBvcnQgZW9sID0gcmVxdWlyZSgnZW9sJyk7XG5pbXBvcnQgeyBCYXNlQ29pbiB9IGZyb20gJy4vdjIvYmFzZUNvaW4nO1xuY29uc3QgUGVuZGluZ0FwcHJvdmFscyA9IHJlcXVpcmUoJy4vcGVuZGluZ2FwcHJvdmFscycpO1xuaW1wb3J0IHNoYW1pciA9IHJlcXVpcmUoJ3NlY3JldHMuanMtZ3JlbXBlJyk7XG5pbXBvcnQgc2pjbCA9IHJlcXVpcmUoJy4vdmVuZG9yL3NqY2wubWluLmpzJyk7XG5pbXBvcnQgYnM1OCA9IHJlcXVpcmUoJ2JzNTgnKTtcbmltcG9ydCAqIGFzIGNvbW1vbiBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQgeyBFbnZpcm9ubWVudE5hbWUgfSBmcm9tICcuL3YyL2Vudmlyb25tZW50cyc7XG5pbXBvcnQgeyBOb2RlQ2FsbGJhY2ssIFYxTmV0d29yayB9IGZyb20gJy4vdjIvdHlwZXMnO1xuaW1wb3J0IHsgUmVxdWVzdFRyYWNlciwgVXRpbCB9IGZyb20gJy4vdjIvaW50ZXJuYWwvdXRpbCc7XG5pbXBvcnQgeyBSZXF1ZXN0VHJhY2VyIGFzIElSZXF1ZXN0VHJhY2VyIH0gZnJvbSAnLi92Mi90eXBlcyc7XG5pbXBvcnQgKiBhcyBCbHVlYmlyZCBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgY28gPSBCbHVlYmlyZC5jb3JvdXRpbmU7XG5pbXBvcnQgcGpzb24gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKTtcbmltcG9ydCBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCAqIGFzIHVybCBmcm9tICd1cmwnO1xuaW1wb3J0ICogYXMgcXVlcnlzdHJpbmcgZnJvbSAncXVlcnlzdHJpbmcnO1xuaW1wb3J0ICogYXMgY29uZmlnIGZyb20gJy4vY29uZmlnJztcbmltcG9ydCAqIGFzIGNyeXB0byBmcm9tICdjcnlwdG8nO1xuaW1wb3J0ICogYXMgZGVidWdMaWIgZnJvbSAnZGVidWcnO1xuaW1wb3J0IHsgYnl0ZXNUb1dvcmQgfSBmcm9tICcuL3YyL2ludGVybmFsL2ludGVybmFsJztcblxuY29uc3QgVHJhbnNhY3Rpb25CdWlsZGVyID0gcmVxdWlyZSgnLi90cmFuc2FjdGlvbkJ1aWxkZXInKTtcbmNvbnN0IEJsb2NrY2hhaW4gPSByZXF1aXJlKCcuL2Jsb2NrY2hhaW4nKTtcbmNvbnN0IEtleWNoYWlucyA9IHJlcXVpcmUoJy4va2V5Y2hhaW5zJyk7XG5jb25zdCBUcmF2ZWxSdWxlID0gcmVxdWlyZSgnLi90cmF2ZWxSdWxlJyk7XG5pbXBvcnQgV2FsbGV0ID0gcmVxdWlyZSgnLi93YWxsZXQnKTtcbmNvbnN0IFdhbGxldHMgPSByZXF1aXJlKCcuL3dhbGxldHMnKTtcbmNvbnN0IE1hcmtldHMgPSByZXF1aXJlKCcuL21hcmtldHMnKTtcbmltcG9ydCB7IEdsb2JhbENvaW5GYWN0b3J5IH0gZnJvbSAnLi92Mi9jb2luRmFjdG9yeSc7XG5cbmNvbnN0IGRlYnVnID0gZGVidWdMaWIoJ2JpdGdvOmluZGV4Jyk7XG5cbmlmICghKHByb2Nlc3MgYXMgYW55KS5icm93c2VyKSB7XG4gIHJlcXVpcmUoJ3N1cGVyYWdlbnQtcHJveHknKShzdXBlcmFnZW50KTtcbn1cblxuLy8gUGF0Y2ggc3VwZXJhZ2VudCB0byByZXR1cm4gYmx1ZWJpcmQgcHJvbWlzZXNcbmNvbnN0IF9lbmQgPSAoc3VwZXJhZ2VudCBhcyBhbnkpLlJlcXVlc3QucHJvdG90eXBlLmVuZDtcbihzdXBlcmFnZW50IGFzIGFueSkuUmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oY2IpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gX2VuZC5jYWxsKHNlbGYsIGNiKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgQmx1ZWJpcmQuUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBsZXQgZXJyb3I7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBfZW5kLmNhbGwoc2VsZiwgZnVuY3Rpb24oZXJyb3IsIHJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgZXJyb3IgPSBfZXJyb3I7XG4gICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLy8gSGFuZGxlIEhUVFAgZXJyb3JzIGFwcHJvcHJpYXRlbHksIHJldHVybmluZyB0aGUgcmVzdWx0IGJvZHksIG9yIGEgbmFtZWRcbi8vIGZpZWxkIGZyb20gdGhlIGJvZHksIGlmIHRoZSBvcHRpb25hbEZpZWxkIHBhcmFtZXRlciBpcyBwcm92aWRlZC5cbihzdXBlcmFnZW50IGFzIGFueSkuUmVxdWVzdC5wcm90b3R5cGUucmVzdWx0ID0gZnVuY3Rpb24ob3B0aW9uYWxGaWVsZD86IHN0cmluZykge1xuICByZXR1cm4gdGhpcy50aGVuKGhhbmRsZVJlc3BvbnNlUmVzdWx0KG9wdGlvbmFsRmllbGQpLCBoYW5kbGVSZXNwb25zZUVycm9yKTtcbn07XG5cbmZ1bmN0aW9uIGhhbmRsZVJlc3BvbnNlUmVzdWx0KG9wdGlvbmFsRmllbGQ/OiBzdHJpbmcpOiAocmVzOiBzdXBlcmFnZW50LlJlc3BvbnNlKSA9PiBhbnkge1xuICByZXR1cm4gZnVuY3Rpb24ocmVzOiBzdXBlcmFnZW50LlJlc3BvbnNlKSB7XG4gICAgaWYgKF8uaXNOdW1iZXIocmVzLnN0YXR1cykgJiYgcmVzLnN0YXR1cyA+PSAyMDAgJiYgcmVzLnN0YXR1cyA8IDMwMCkge1xuICAgICAgcmV0dXJuIG9wdGlvbmFsRmllbGQgPyByZXMuYm9keVtvcHRpb25hbEZpZWxkXSA6IHJlcy5ib2R5O1xuICAgIH1cbiAgICB0aHJvdyBlcnJGcm9tUmVzcG9uc2UocmVzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXJyRnJvbVJlc3BvbnNlKHJlczogc3VwZXJhZ2VudC5SZXNwb25zZSk6IEVycm9yIHtcbiAgY29uc3QgZXJyU3RyaW5nID0gY3JlYXRlUmVzcG9uc2VFcnJvclN0cmluZyhyZXMpO1xuICBjb25zdCBlcnI6IGFueSA9IG5ldyBFcnJvcihlcnJTdHJpbmcpO1xuXG4gIGVyci5zdGF0dXMgPSByZXMuc3RhdHVzO1xuICBpZiAocmVzLmJvZHkpIHtcbiAgICBlcnIucmVzdWx0ID0gcmVzLmJvZHk7XG4gIH1cbiAgaWYgKF8uaGFzKHJlcy5oZWFkZXIsICd4LWF1dGgtcmVxdWlyZWQnKSAmJiAocmVzLmhlYWRlclsneC1hdXRoLXJlcXVpcmVkJ10gPT09ICd0cnVlJykpIHtcbiAgICBlcnIuaW52YWxpZFRva2VuID0gdHJ1ZTtcbiAgfVxuICBpZiAocmVzLmJvZHkubmVlZHNPVFApIHtcbiAgICBlcnIubmVlZHNPVFAgPSB0cnVlO1xuICB9XG4gIHJldHVybiBlcnI7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVJlc3BvbnNlRXJyb3IoZSk6IG5ldmVyIHtcbiAgaWYgKGUucmVzcG9uc2UpIHtcbiAgICB0aHJvdyBlcnJGcm9tUmVzcG9uc2UoZS5yZXNwb25zZSk7XG4gIH1cbiAgdGhyb3cgZTtcbn1cblxuLyoqXG4gKiBUaGVyZSBhcmUgbWFueSB3YXlzIGEgcmVxdWVzdCBjYW4gZmFpbCwgYW5kIG1heSB3YXlzIGluZm9ybWF0aW9uIG9uIHRoYXQgZmFpbHVyZSBjYW4gYmVcbiAqIGNvbW11bmljYXRlZCB0byB0aGUgY2xpZW50LiBUaGlzIGZ1bmN0aW9uIHRyaWVzIHRvIGhhbmRsZSB0aG9zZSBjYXNlcyBhbmQgY3JlYXRlIGEgc2FuZSBlcnJvciBzdHJpbmdcbiAqIEBwYXJhbSByZXMgUmVzcG9uc2UgZnJvbSBhbiBIVFRQIHJlcXVlc3RcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUmVzcG9uc2VFcnJvclN0cmluZyhyZXM6IHN1cGVyYWdlbnQuUmVzcG9uc2UpOiBzdHJpbmcge1xuICBsZXQgZXJyU3RyaW5nID0gcmVzLnN0YXR1cy50b1N0cmluZygpOyAvLyBhdCB0aGUgdmVyeSBsZWFzdCB3ZSdsbCBoYXZlIHRoZSBzdGF0dXMgY29kZVxuICBpZiAocmVzLmJvZHkuZXJyb3IpIHtcbiAgICAvLyB0aGlzIGlzIHRoZSBjYXNlIHdlIGhvcGUgZm9yLCB3aGVyZSB0aGUgc2VydmVyIGdpdmVzIHVzIGEgbmljZSBlcnJvciBmcm9tIHRoZSBKU09OIGJvZHlcbiAgICBlcnJTdHJpbmcgPSByZXMuYm9keS5lcnJvcjtcbiAgfSBlbHNlIHtcbiAgICBpZiAocmVzLnRleHQpIHtcbiAgICAgIC8vIGlmIHRoZSByZXNwb25zZSBjYW1lIGJhY2sgYXMgdGV4dCwgd2UgdHJ5IHRvIHBhcnNlIGl0IGFzIEhUTUwgYW5kIHJlbW92ZSBhbGwgdGFncywgbGVhdmluZyB1c1xuICAgICAgLy8ganVzdCB0aGUgYmFyZSB0ZXh0LCB3aGljaCB3ZSB0aGVuIHRyaW0gb2YgZXhjZXNzaXZlIG5ld2xpbmVzIGFuZCBsaW1pdCB0byBhIGNlcnRhaW4gbGVuZ3RoXG4gICAgICB0cnkge1xuICAgICAgICBsZXQgc2FuaXRpemVkVGV4dCA9IHNhbml0aXplSHRtbChyZXMudGV4dCwgeyBhbGxvd2VkVGFnczogW10gfSk7XG4gICAgICAgIHNhbml0aXplZFRleHQgPSBzYW5pdGl6ZWRUZXh0LnRyaW0oKTtcbiAgICAgICAgc2FuaXRpemVkVGV4dCA9IGVvbC5sZihzYW5pdGl6ZWRUZXh0KTsgLy8gdXNlICdcXG4nIGZvciBhbGwgbmV3bGluZXNcbiAgICAgICAgc2FuaXRpemVkVGV4dCA9IF8ucmVwbGFjZShzYW5pdGl6ZWRUZXh0LCAvXFxuWyB8XFx0XXsxLH1cXG4vZywgJ1xcblxcbicpOyAvLyByZW1vdmUgdGhlIHNwYWNlcy90YWJzIGJldHdlZW4gbmV3bGluZXNcbiAgICAgICAgc2FuaXRpemVkVGV4dCA9IF8ucmVwbGFjZShzYW5pdGl6ZWRUZXh0LCAvW1xcbl17Myx9L2csICdcXG5cXG4nKTsgLy8gaGF2ZSBhdCBtb3N0IDIgY29uc2VjdXRpdmUgbmV3bGluZXNcbiAgICAgICAgc2FuaXRpemVkVGV4dCA9IHNhbml0aXplZFRleHQuc3Vic3RyaW5nKDAsIDUwMDApOyAvLyBwcmV2ZW50IG1lc3NhZ2UgZnJvbSBnZXR0aW5nIHRvbyBsYXJnZVxuICAgICAgICBlcnJTdHJpbmcgPSBlcnJTdHJpbmcgKyAnXFxuJyArIHNhbml0aXplZFRleHQ7IC8vIGFkZCBpdCB0byBvdXIgZXhpc3RpbmcgZXJyU3RyaW5nIChhdCB0aGlzIHBvaW50IHRoZSBtb3JlIGluZm8gdGhlIGJldHRlciEpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGRvIG5vdGhpbmcsIHRoZSByZXNwb25zZSdzIEhUTUwgd2FzIHRvbyB3YWNreSB0byBiZSBwYXJzZWQgY2xlYW5seVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlcnJTdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQml0R29PcHRpb25zIHtcbiAgZW52PzogRW52aXJvbm1lbnROYW1lO1xuICBjbGllbnRJZD86IHN0cmluZztcbiAgY2xpZW50U2VjcmV0Pzogc3RyaW5nO1xuICBhY2Nlc3NUb2tlbj86IHN0cmluZztcbiAgdXNlckFnZW50Pzogc3RyaW5nO1xuICBjdXN0b21Sb290VVJJPzogc3RyaW5nO1xuICBjdXN0b21CaXRjb2luTmV0d29yaz86IFYxTmV0d29yaztcbiAgY3VzdG9tU2lnbmluZ0FkZHJlc3M/OiBzdHJpbmc7XG4gIHNlcnZlclhwdWI/OiBzdHJpbmc7XG4gIHN0ZWxsYXJGZWRlcmF0aW9uU2VydmVyVXJsPzogc3RyaW5nO1xuICB1c2VQcm9kdWN0aW9uPzogYm9vbGVhbjtcbiAgbWljcm9zZXJ2aWNlc1VyaT86IHN0cmluZztcbiAgcmVmcmVzaFRva2VuPzogc3RyaW5nO1xuICB2YWxpZGF0ZT86IGJvb2xlYW47XG4gIHByb3h5Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZXIge1xuICB1c2VybmFtZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJpdEdvSnNvbiB7XG4gIHVzZXI/OiBVc2VyO1xuICB0b2tlbj86IHN0cmluZztcbiAgZXh0ZW5zaW9uS2V5Pzogc3RyaW5nO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGVwcmVjYXRlZFZlcmlmeUFkZHJlc3NPcHRpb25zIHtcbiAgYWRkcmVzcz86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWZXJpZnlQYXNzd29yZE9wdGlvbnMge1xuICBwYXNzd29yZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFbmNyeXB0T3B0aW9ucyB7XG4gIGlucHV0Pzogc3RyaW5nO1xuICBwYXNzd29yZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEZWNyeXB0T3B0aW9ucyB7XG4gIGlucHV0Pzogc3RyaW5nO1xuICBwYXNzd29yZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTcGxpdFNlY3JldE9wdGlvbnMge1xuICBzZWVkOiBzdHJpbmc7XG4gIHBhc3N3b3Jkczogc3RyaW5nW107XG4gIG06IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTcGxpdFNlY3JldCB7XG4gIHhwdWI6IHN0cmluZztcbiAgbTogbnVtYmVyO1xuICBuOiBudW1iZXI7XG4gIHNlZWRTaGFyZXM6IGFueTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWNvbnN0aXR1dGVTZWNyZXRPcHRpb25zIHtcbiAgc2hhcmRzOiBzdHJpbmdbXTtcbiAgcGFzc3dvcmRzOiBzdHJpbmdbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWNvbnN0aXR1dGVkU2VjcmV0IHtcbiAgeHB1Yjogc3RyaW5nO1xuICB4cHJ2OiBzdHJpbmc7XG4gIHNlZWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWZXJpZnlTaGFyZHNPcHRpb25zIHtcbiAgc2hhcmRzOiBzdHJpbmdbXTtcbiAgcGFzc3dvcmRzOiBzdHJpbmdbXTtcbiAgbTogbnVtYmVyO1xuICB4cHViOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2V0RWNkaFNlY3JldE9wdGlvbnMge1xuICBvdGhlclB1YktleUhleDogc3RyaW5nO1xuICBlY2tleTogYml0Y29pbi5FQ1BhaXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWNjZXNzVG9rZW5PcHRpb25zIHtcbiAgYWNjZXNzVG9rZW46IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUb2tlbklzc3VhbmNlUmVzcG9uc2Uge1xuICBkZXJpdmF0aW9uUGF0aDogc3RyaW5nO1xuICBlbmNyeXB0ZWRUb2tlbjogc3RyaW5nO1xuICBlbmNyeXB0ZWRFQ0RIWHBydj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUb2tlbklzc3VhbmNlIHtcbiAgdG9rZW46IHN0cmluZztcbiAgZWNkaFhwcnY/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsY3VsYXRlSG1hY1N1YmplY3RPcHRpb25zIHtcbiAgdXJsUGF0aDogc3RyaW5nO1xuICB0ZXh0OiBzdHJpbmc7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xuICBzdGF0dXNDb2RlPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENhbGN1bGF0ZVJlcXVlc3RIbWFjT3B0aW9ucyB7XG4gIHVybDogc3RyaW5nO1xuICB0ZXh0OiBzdHJpbmc7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xuICB0b2tlbjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENhbGN1bGF0ZVJlcXVlc3RIZWFkZXJzT3B0aW9ucyB7XG4gIHVybDogc3RyaW5nO1xuICB0ZXh0OiBzdHJpbmc7XG4gIHRva2VuOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVxdWVzdEhlYWRlcnMge1xuICBobWFjOiBzdHJpbmc7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xuICB0b2tlbkhhc2g6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWZXJpZnlSZXNwb25zZU9wdGlvbnMgZXh0ZW5kcyBDYWxjdWxhdGVSZXF1ZXN0SGVhZGVyc09wdGlvbnMge1xuICBobWFjOiBzdHJpbmc7XG4gIHVybDogc3RyaW5nO1xuICB0ZXh0OiBzdHJpbmc7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xuICBzdGF0dXNDb2RlPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEF1dGhlbnRpY2F0ZU9wdGlvbnMge1xuICB1c2VybmFtZTogc3RyaW5nO1xuICBwYXNzd29yZDogc3RyaW5nO1xuICBvdHA/OiBzdHJpbmc7XG4gIHRydXN0PzogbnVtYmVyO1xuICBmb3JjZVNNUz86IGJvb2xlYW47XG4gIGV4dGVuc2libGU/OiBib29sZWFuO1xuICBmb3JjZVYxQXV0aD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvY2Vzc2VkQXV0aGVudGljYXRpb25PcHRpb25zIHtcbiAgZW1haWw6IHN0cmluZztcbiAgcGFzc3dvcmQ6IHN0cmluZztcbiAgZm9yY2VTTVM6IGJvb2xlYW47XG4gIG90cD86IHN0cmluZztcbiAgdHJ1c3Q/OiBudW1iZXI7XG4gIGV4dGVuc2libGU/OiBib29sZWFuO1xuICBleHRlbnNpb25BZGRyZXNzPzogc3RyaW5nO1xuICBmb3JjZVYxQXV0aD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWRkQWNjZXNzVG9rZW5PcHRpb25zIHtcbiAgbGFiZWw6IHN0cmluZztcbiAgb3RwPzogc3RyaW5nO1xuICBkdXJhdGlvbj86IG51bWJlcjtcbiAgaXBSZXN0cmljdD86IHN0cmluZ1tdO1xuICB0eFZhbHVlTGltaXQ/OiBudW1iZXI7XG4gIHNjb3BlOiBzdHJpbmdbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZW1vdmVBY2Nlc3NUb2tlbk9wdGlvbnMge1xuICBpZD86IHN0cmluZztcbiAgbGFiZWw/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2V0VXNlck9wdGlvbnMge1xuICBpZDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENoYW5nZVBhc3N3b3JkT3B0aW9ucyB7XG4gIG9sZFBhc3N3b3JkOiBzdHJpbmc7XG4gIG5ld1Bhc3N3b3JkOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVW5sb2NrT3B0aW9ucyB7XG4gIG90cD86IHN0cmluZztcbiAgZHVyYXRpb24/OiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFeHRlbmRUb2tlbk9wdGlvbnMge1xuICBkdXJhdGlvbj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZXRTaGFyaW5nS2V5T3B0aW9ucyB7XG4gIGVtYWlsOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGluZ09wdGlvbnMge1xuICByZXFJZD86IElSZXF1ZXN0VHJhY2VyO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRXN0aW1hdGVGZWVPcHRpb25zIHtcbiAgbnVtQmxvY2tzPzogbnVtYmVyO1xuICBtYXhGZWU/OiBudW1iZXI7XG4gIGlucHV0cz86IHN0cmluZ1tdO1xuICB0eFNpemU/OiBudW1iZXI7XG4gIGNwZnBBd2FyZT86IGJvb2xlYW47XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBXZWJob29rT3B0aW9ucyB7XG4gIHVybDogc3RyaW5nO1xuICB0eXBlOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGlzdFdlYmhvb2tOb3RpZmljYXRpb25zT3B0aW9ucyB7XG4gIHByZXZJZD86IHN0cmluZztcbiAgbGltaXQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQml0R29TaW11bGF0ZVdlYmhvb2tPcHRpb25zIHtcbiAgd2ViaG9va0lkOiBzdHJpbmc7XG4gIGJsb2NrSWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdXRoZW50aWNhdGVXaXRoQXV0aENvZGVPcHRpb25zIHtcbiAgYXV0aENvZGU6IHN0cmluZztcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFZlcmlmeVB1c2hUb2tlbk9wdGlvbnMge1xuICBwdXNoVmVyaWZpY2F0aW9uVG9rZW46IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCaXRHb1JlcXVlc3QgZXh0ZW5kcyBzdXBlcmFnZW50LlJlcXVlc3Qge1xuICByZXN1bHQ6IChvcHRpb25hbEZpZWxkPzogc3RyaW5nKSA9PiBCbHVlYmlyZDxhbnk+O1xuICBlbmQ6IChjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxzdXBlcmFnZW50LlJlc3BvbnNlPikgPT4gQmx1ZWJpcmQ8c3VwZXJhZ2VudC5SZXNwb25zZT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQml0R28ge1xuICBnZXQodXJsOiBzdHJpbmcsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPHN1cGVyYWdlbnQuUmVzcG9uc2U+KTogQml0R29SZXF1ZXN0O1xuICBwb3N0KHVybDogc3RyaW5nLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxzdXBlcmFnZW50LlJlc3BvbnNlPik6IEJpdEdvUmVxdWVzdDtcbiAgcHV0KHVybDogc3RyaW5nLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxzdXBlcmFnZW50LlJlc3BvbnNlPik6IEJpdEdvUmVxdWVzdDtcbiAgZGVsKHVybDogc3RyaW5nLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxzdXBlcmFnZW50LlJlc3BvbnNlPik6IEJpdEdvUmVxdWVzdDtcbiAgcGF0Y2godXJsOiBzdHJpbmcsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPHN1cGVyYWdlbnQuUmVzcG9uc2U+KTogQml0R29SZXF1ZXN0O1xufVxuXG5leHBvcnQgY2xhc3MgQml0R28ge1xuICBwcml2YXRlIHN0YXRpYyBfdGVzdG5ldFdhcm5pbmdNZXNzYWdlID0gZmFsc2U7XG4gIHByaXZhdGUgc3RhdGljIF9jb25zdGFudHM6IGFueTtcbiAgcHJpdmF0ZSBzdGF0aWMgX2NvbnN0YW50c0V4cGlyZTogYW55O1xuICBwcml2YXRlIHJlYWRvbmx5IF9lbnY6IEVudmlyb25tZW50TmFtZTtcbiAgLyoqXG4gICAqIEV4cG9zZSBlbnYgcHJvcGVydHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgZW52OiBFbnZpcm9ubWVudE5hbWU7XG4gIHByaXZhdGUgcmVhZG9ubHkgX2Jhc2VVcmw6IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSBfbWljcm9zZXJ2aWNlc1VybD86IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSBfYmFzZUFwaVVybDogc3RyaW5nO1xuICBwcml2YXRlIHJlYWRvbmx5IF9iYXNlQXBpVXJsVjI6IHN0cmluZztcbiAgcHJpdmF0ZSBfdXNlcj86IFVzZXI7XG4gIHByaXZhdGUgX2tleWNoYWluczogYW55O1xuICBwcml2YXRlIF93YWxsZXRzOiBhbnk7XG4gIHByaXZhdGUgcmVhZG9ubHkgX2NsaWVudElkPzogc3RyaW5nO1xuICBwcml2YXRlIHJlYWRvbmx5IF9jbGllbnRTZWNyZXQ/OiBzdHJpbmc7XG4gIHByaXZhdGUgX3Rva2VuPzogc3RyaW5nO1xuICBwcml2YXRlIF9yZWZyZXNoVG9rZW4/OiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgX3VzZXJBZ2VudDogc3RyaW5nO1xuICBwcml2YXRlIHJlYWRvbmx5IF9wcm9taXNlOiB0eXBlb2YgQmx1ZWJpcmQ7XG4gIHByaXZhdGUgX3ZhbGlkYXRlOiBib29sZWFuO1xuICBwcml2YXRlIHJlYWRvbmx5IF9wcm94eT86IHN0cmluZztcbiAgcHJpdmF0ZSBfcmVxSWQ/OiBJUmVxdWVzdFRyYWNlcjtcbiAgcHJpdmF0ZSBfZWNkaFhwcnY/OiBzdHJpbmc7XG4gIHByaXZhdGUgX2V4dGVuc2lvbktleT86IGJpdGNvaW4uRUNQYWlyO1xuICBwcml2YXRlIF9tYXJrZXRzPzogYW55O1xuICBwcml2YXRlIF9ibG9ja2NoYWluPzogYW55O1xuICBwcml2YXRlIF90cmF2ZWxSdWxlPzogYW55O1xuICBwcml2YXRlIF9wZW5kaW5nQXBwcm92YWxzPzogYW55O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBmb3IgQml0R28gT2JqZWN0XG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXJhbXM6IEJpdEdvT3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgWydjbGllbnRJZCcsICdjbGllbnRTZWNyZXQnLCAncmVmcmVzaFRva2VuJywgJ2FjY2Vzc1Rva2VuJywgJ3VzZXJBZ2VudCcsICdjdXN0b21Sb290VVJJJywgJ2N1c3RvbUJpdGNvaW5OZXR3b3JrJywgJ3NlcnZlclhwdWInLCAnc3RlbGxhckZlZGVyYXRpb25TZXJ2ZXJVcmwnXSkgfHxcbiAgICAgIChwYXJhbXMudXNlUHJvZHVjdGlvbiAmJiAhXy5pc0Jvb2xlYW4ocGFyYW1zLnVzZVByb2R1Y3Rpb24pKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKCghcGFyYW1zLmNsaWVudElkKSAhPT0gKCFwYXJhbXMuY2xpZW50U2VjcmV0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IC0gbXVzdCBwcm92aWRlIGJvdGggY2xpZW50IGlkIGFuZCBzZWNyZXQnKTtcbiAgICB9XG5cbiAgICAvLyBCeSBkZWZhdWx0LCB3ZSBvcGVyYXRlIG9uIHRoZSB0ZXN0IHNlcnZlci5cbiAgICAvLyBEZXByZWNhdGUgdXNlUHJvZHVjdGlvbiBpbiB0aGUgZnV0dXJlXG4gICAgbGV0IGVudjogRW52aXJvbm1lbnROYW1lO1xuXG4gICAgaWYgKHBhcmFtcy51c2VQcm9kdWN0aW9uKSB7XG4gICAgICBpZiAocGFyYW1zLmVudiAmJiBwYXJhbXMuZW52ICE9PSAncHJvZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgdXNlIHVzZVByb2R1Y3Rpb24gd2hlbiBlbnY9JyArIHBhcmFtcy5lbnYpO1xuICAgICAgfVxuICAgICAgZW52ID0gJ3Byb2QnO1xuICAgIH0gZWxzZSBpZiAocGFyYW1zLmN1c3RvbVJvb3RVUkkgfHxcbiAgICAgIHBhcmFtcy5jdXN0b21CaXRjb2luTmV0d29yayB8fFxuICAgICAgcGFyYW1zLmN1c3RvbVNpZ25pbmdBZGRyZXNzIHx8XG4gICAgICBwYXJhbXMuc2VydmVyWHB1YiB8fFxuICAgICAgcHJvY2Vzcy5lbnYuQklUR09fQ1VTVE9NX1JPT1RfVVJJIHx8XG4gICAgICBwcm9jZXNzLmVudi5CSVRHT19DVVNUT01fQklUQ09JTl9ORVRXT1JLKSB7XG4gICAgICBlbnYgPSAnY3VzdG9tJztcbiAgICAgIGlmIChwYXJhbXMuY3VzdG9tUm9vdFVSSSkge1xuICAgICAgICBjb21tb24uRW52aXJvbm1lbnRzWydjdXN0b20nXS51cmkgPSBwYXJhbXMuY3VzdG9tUm9vdFVSSTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbXMuY3VzdG9tQml0Y29pbk5ldHdvcmspIHtcbiAgICAgICAgY29tbW9uLkVudmlyb25tZW50c1snY3VzdG9tJ10ubmV0d29yayA9IHBhcmFtcy5jdXN0b21CaXRjb2luTmV0d29yaztcbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbXMuY3VzdG9tU2lnbmluZ0FkZHJlc3MpIHtcbiAgICAgICAgKGNvbW1vbi5FbnZpcm9ubWVudHNbJ2N1c3RvbSddIGFzIGFueSkuY3VzdG9tU2lnbmluZ0FkZHJlc3MgPSBwYXJhbXMuY3VzdG9tU2lnbmluZ0FkZHJlc3M7XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLnNlcnZlclhwdWIpIHtcbiAgICAgICAgY29tbW9uLkVudmlyb25tZW50c1snY3VzdG9tJ10uc2VydmVyWHB1YiA9IHBhcmFtcy5zZXJ2ZXJYcHViO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy5zdGVsbGFyRmVkZXJhdGlvblNlcnZlclVybCkge1xuICAgICAgICBjb21tb24uRW52aXJvbm1lbnRzWydjdXN0b20nXS5zdGVsbGFyRmVkZXJhdGlvblNlcnZlclVybCA9IHBhcmFtcy5zdGVsbGFyRmVkZXJhdGlvblNlcnZlclVybDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZW52ID0gcGFyYW1zLmVudiB8fCBwcm9jZXNzLmVudi5CSVRHT19FTlYgYXMgRW52aXJvbm1lbnROYW1lO1xuICAgIH1cblxuICAgIGlmIChlbnYgYXMgc3RyaW5nID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGVudiA9ICdwcm9kJzsgLy8gbWFrZSBsaWZlIGVhc2llclxuICAgIH1cblxuICAgIGlmIChlbnYgPT09ICdjdXN0b20nICYmIF8uaXNVbmRlZmluZWQoY29tbW9uLkVudmlyb25tZW50c1tlbnZdLnVyaSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbXVzdCB1c2UgLS1jdXN0b21yb290dXJpIG9yIHNldCB0aGUgQklUR09fQ1VTVE9NX1JPT1RfVVJJIGVudmlyb25tZW50IHZhcmlhYmxlIHdoZW4gdXNpbmcgdGhlIGN1c3RvbSBlbnZpcm9ubWVudCcpO1xuICAgIH1cblxuICAgIGlmIChlbnYpIHtcbiAgICAgIGlmIChjb21tb24uRW52aXJvbm1lbnRzW2Vudl0pIHtcbiAgICAgICAgdGhpcy5fYmFzZVVybCA9IGNvbW1vbi5FbnZpcm9ubWVudHNbZW52XS51cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZW52aXJvbm1lbnQgJyArIGVudiArICcuIFN1cHBvcnRlZCBlbnZpcm9ubWVudHM6IHRlc3QsIHByb2QnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZW52ID0gJ3Rlc3QnO1xuICAgICAgaWYgKCFCaXRHby5fdGVzdG5ldFdhcm5pbmdNZXNzYWdlKSB7XG4gICAgICAgIEJpdEdvLl90ZXN0bmV0V2FybmluZ01lc3NhZ2UgPSB0cnVlO1xuICAgICAgICBjb25zb2xlLmxvZygnQml0R28gU0RLIGVudiBub3Qgc2V0IC0gZGVmYXVsdGluZyB0byB0ZXN0IGF0IHRlc3QuYml0Z28uY29tLicpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYmFzZVVybCA9IGNvbW1vbi5FbnZpcm9ubWVudHNbZW52XS51cmk7XG4gICAgfVxuICAgIHRoaXMuX2VudiA9IHRoaXMuZW52ID0gZW52O1xuXG4gICAgY29tbW9uLnNldE5ldHdvcmsoY29tbW9uLkVudmlyb25tZW50c1tlbnZdLm5ldHdvcmspO1xuICAgIGNvbW1vbi5zZXRSbWdOZXR3b3JrKGNvbW1vbi5FbnZpcm9ubWVudHNbZW52XS5ybWdOZXR3b3JrKTtcblxuICAgIHRoaXMuX21pY3Jvc2VydmljZXNVcmwgPSBwYXJhbXMubWljcm9zZXJ2aWNlc1VyaTtcbiAgICB0aGlzLl9iYXNlQXBpVXJsID0gdGhpcy5fYmFzZVVybCArICcvYXBpL3YxJztcbiAgICB0aGlzLl9iYXNlQXBpVXJsVjIgPSB0aGlzLl9iYXNlVXJsICsgJy9hcGkvdjInO1xuICAgIHRoaXMuX2tleWNoYWlucyA9IG51bGw7XG4gICAgdGhpcy5fd2FsbGV0cyA9IG51bGw7XG4gICAgdGhpcy5fY2xpZW50SWQgPSBwYXJhbXMuY2xpZW50SWQ7XG4gICAgdGhpcy5fY2xpZW50U2VjcmV0ID0gcGFyYW1zLmNsaWVudFNlY3JldDtcbiAgICB0aGlzLl90b2tlbiA9IHBhcmFtcy5hY2Nlc3NUb2tlbjtcbiAgICB0aGlzLl9yZWZyZXNoVG9rZW4gPSBwYXJhbXMucmVmcmVzaFRva2VuO1xuICAgIHRoaXMuX3VzZXJBZ2VudCA9IHBhcmFtcy51c2VyQWdlbnQgfHwgJ0JpdEdvSlMvJyArIHRoaXMudmVyc2lvbigpO1xuICAgIHRoaXMuX3Byb21pc2UgPSBCbHVlYmlyZDtcbiAgICB0aGlzLl9yZXFJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIHdoZXRoZXIgdG8gcGVyZm9ybSBleHRyYSBjbGllbnQtc2lkZSB2YWxpZGF0aW9uIGZvciBzb21lIHRoaW5ncywgc3VjaCBhc1xuICAgIC8vIGFkZHJlc3MgdmFsaWRhdGlvbiBvciBzaWduYXR1cmUgdmFsaWRhdGlvbi4gZGVmYXVsdHMgdG8gdHJ1ZSwgYnV0IGNhbiBiZVxuICAgIC8vIHR1cm5lZCBvZmYgYnkgc2V0dGluZyB0byBmYWxzZS4gY2FuIGFsc28gYmUgb3ZlcnJpZGRlbiBpbmRpdmlkdWFsbHkgaW4gdGhlXG4gICAgLy8gZnVuY3Rpb25zIHRoYXQgdXNlIGl0LlxuICAgIHRoaXMuX3ZhbGlkYXRlID0gcGFyYW1zLnZhbGlkYXRlID09PSB1bmRlZmluZWQgPyB0cnVlIDogcGFyYW1zLnZhbGlkYXRlO1xuXG4gICAgLy8gQ3JlYXRlIHN1cGVyYWdlbnQgbWV0aG9kcyBzcGVjaWZpYyB0byB0aGlzIEJpdEdvIGluc3RhbmNlLlxuICAgIGNvbnN0IG1ldGhvZHMgPSBbJ2dldCcsICdwb3N0JywgJ3B1dCcsICdkZWwnLCAncGF0Y2gnXTtcblxuICAgIGlmICghcGFyYW1zLnByb3h5ICYmIHByb2Nlc3MuZW52LkJJVEdPX1VTRV9QUk9YWSkge1xuICAgICAgcGFyYW1zLnByb3h5ID0gcHJvY2Vzcy5lbnYuQklUR09fVVNFX1BST1hZO1xuICAgIH1cblxuICAgIGlmICgocHJvY2VzcyBhcyBhbnkpLmJyb3dzZXIgJiYgcGFyYW1zLnByb3h5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCB1c2UgaHR0cHMgcHJveHkgcGFyYW1zIHdoaWxlIGluIGJyb3dzZXInKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wcm94eSA9IHBhcmFtcy5wcm94eTtcblxuICAgIGZvciAoY29uc3QgaW5kZXggaW4gbWV0aG9kcykge1xuICAgICAgY29uc3QgbWV0aG9kID0gbWV0aG9kc1tpbmRleF07XG4gICAgICB0aGlzW21ldGhvZF0gPSB0aGlzLmNyZWF0ZVBhdGNoKG1ldGhvZCk7XG4gICAgfVxuXG4gICAgLy8gY2FwdHVyZSBvdXRlciBzdGFjayBzbyB3ZSBoYXZlIHVzZWZ1bCBkZWJ1ZyBpbmZvcm1hdGlvbiBpZiBmZXRjaCBjb25zdGFudHMgZmFpbHNcbiAgICBjb25zdCBlID0gbmV3IEVycm9yKCk7XG5cbiAgICAvLyBLaWNrIG9mZiBmaXJzdCBsb2FkIG9mIGNvbnN0YW50c1xuICAgIHRoaXMuZmV0Y2hDb25zdGFudHMoe30sIGZ1bmN0aW9uKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICAvLyBtYWtlIHN1cmUgYW4gZXJyb3IgZG9lcyBub3QgdGVybWluYXRlIHRoZSBlbnRpcmUgc2NyaXB0XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2ZhaWxlZCB0byBmZXRjaCBpbml0aWFsIGNsaWVudCBjb25zdGFudHMgZnJvbSBCaXRHbycpO1xuICAgICAgICBkZWJ1ZyhlLnN0YWNrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgcGF0Y2hpbmcgZnVuY3Rpb24gd2hpY2ggY2FuIGFwcGx5IG91ciBhdXRob3JpemF0aW9uXG4gICAqIGhlYWRlcnMgdG8gYW55IG91dGJvdW5kIHJlcXVlc3QuXG4gICAqIEBwYXJhbSBtZXRob2RcbiAgICovXG4gIHByaXZhdGUgY3JlYXRlUGF0Y2gobWV0aG9kOiBzdHJpbmcpOiAodXJsOiBzdHJpbmcsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPHN1cGVyYWdlbnQuUmVzcG9uc2U+KSA9PiBzdXBlcmFnZW50LlJlcXVlc3Qge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICBsZXQgcmVxOiBzdXBlcmFnZW50LlN1cGVyQWdlbnRSZXF1ZXN0ID0gc3VwZXJhZ2VudFttZXRob2RdLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgaWYgKHNlbGYuX3Byb3h5KSB7XG4gICAgICAgIHJlcSA9IHJlcS5wcm94eShzZWxmLl9wcm94eSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFBhdGNoIHN1cGVyYWdlbnQgdG8gcmV0dXJuIHByb21pc2VzXG4gICAgICBjb25zdCBwcm90b3R5cGljYWxFbmQgPSByZXEuZW5kO1xuICAgICAgcmVxLmVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCB0aGlzUmVxOiBzdXBlcmFnZW50LlN1cGVyQWdlbnRSZXF1ZXN0ID0gdGhpcztcbiAgICAgICAgLy8gaW50ZXJjZXB0IGEgcmVxdWVzdCBiZWZvcmUgaXQncyBzdWJtaXR0ZWQgdG8gdGhlIHNlcnZlciBmb3IgdjIgYXV0aGVudGljYXRpb24gKGJhc2VkIG9uIHRva2VuKVxuICAgICAgICB0aGlzUmVxLnNldCgnQml0R28tU0RLLVZlcnNpb24nLCBzZWxmLnZlcnNpb24oKSk7XG5cbiAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHNlbGYuX3JlcUlkKSkge1xuICAgICAgICAgIHRoaXNSZXEuc2V0KCdSZXF1ZXN0LUlEJywgc2VsZi5fcmVxSWQudG9TdHJpbmcoKSk7XG5cbiAgICAgICAgICAvLyBpbmNyZW1lbnQgYWZ0ZXIgc2V0dGluZyB0aGUgaGVhZGVyIHNvIHRoZSBzZXF1ZW5jZSBudW1iZXJzIHN0YXJ0IGF0IDBcbiAgICAgICAgICBzZWxmLl9yZXFJZC5pbmMoKTtcblxuICAgICAgICAgIC8vIHJlcXVlc3QgaWRzIG11c3QgYmUgc2V0IGJlZm9yZSBlYWNoIHJlcXVlc3QgaW5zdGVhZCBvZiBiZWluZyBrZXB0XG4gICAgICAgICAgLy8gaW5zaWRlIHRoZSBiaXRnbyBvYmplY3QuIFRoaXMgaXMgdG8gcHJldmVudCByZWVudHJhbmN5IGlzc3VlcyB3aGVyZVxuICAgICAgICAgIC8vIG11bHRpcGxlIHNpbXVsdGFuZW91cyByZXF1ZXN0cyBjb3VsZCBjYXVzZSBpbmNvcnJlY3QgcmVxSWRzIHRvIGJlIHVzZWRcbiAgICAgICAgICBkZWxldGUgc2VsZi5fcmVxSWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyB0b2tlbiwgYW5kIHdlJ3JlIG5vdCBsb2dnZWQgaW4sIHRoZSByZXF1ZXN0IGNhbm5vdCBiZSB2MiBhdXRoZW50aWNhdGVkXG4gICAgICAgIHRoaXNSZXEuaXNWMkF1dGhlbnRpY2F0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzUmVxLmF1dGhlbnRpY2F0aW9uVG9rZW4gPSBzZWxmLl90b2tlbjtcbiAgICAgICAgLy8gc29tZSBvZiB0aGUgb2xkZXIgdG9rZW5zIGFwcGVhciB0byBiZSBvbmx5IDQwIGNoYXJhY3RlcnMgbG9uZ1xuICAgICAgICBpZiAoKHNlbGYuX3Rva2VuICYmIHNlbGYuX3Rva2VuLmxlbmd0aCAhPT0gNjcgJiYgc2VsZi5fdG9rZW4uaW5kZXhPZigndjJ4JykgIT09IDApXG4gICAgICAgICAgfHwgcmVxLmZvcmNlVjFBdXRoKSB7XG4gICAgICAgICAgLy8gdXNlIHRoZSBvbGQgbWV0aG9kXG4gICAgICAgICAgdGhpc1JlcS5pc1YyQXV0aGVudGljYXRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgdGhpc1JlcS5zZXQoJ0F1dGhvcml6YXRpb24nLCAnQmVhcmVyICcgKyBzZWxmLl90b2tlbik7XG4gICAgICAgICAgcmV0dXJuIHByb3RvdHlwaWNhbEVuZC5hcHBseSh0aGlzUmVxLCBhcmd1bWVudHMgYXMgYW55KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXNSZXEuc2V0KCdCaXRHby1BdXRoLVZlcnNpb24nLCAnMi4wJyk7XG4gICAgICAgIC8vIHByZXZlbnQgSUUgZnJvbSBjYWNoaW5nIHJlcXVlc3RzXG4gICAgICAgIHRoaXNSZXEuc2V0KCdJZi1Nb2RpZmllZC1TaW5jZScsICdNb24sIDI2IEp1bCAxOTk3IDA1OjAwOjAwIEdNVCcpO1xuICAgICAgICBpZiAoc2VsZi5fdG9rZW4pIHtcblxuICAgICAgICAgIC8vIGRvIGEgbG9jYWxpemVkIGRhdGEgc2VyaWFsaXphdGlvbiBwcm9jZXNzXG4gICAgICAgICAgbGV0IGRhdGEgPSAodGhpc1JlcSBhcyBhbnkpLl9kYXRhO1xuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcblxuICAgICAgICAgICAgbGV0IGNvbnRlbnRUeXBlID0gdGhpc1JlcS5nZXQoJ0NvbnRlbnQtVHlwZScpO1xuICAgICAgICAgICAgLy8gUGFyc2Ugb3V0IGp1c3QgdGhlIGNvbnRlbnQgdHlwZSBmcm9tIHRoZSBoZWFkZXIgKGlnbm9yZSB0aGUgY2hhcnNldClcbiAgICAgICAgICAgIGlmIChjb250ZW50VHlwZSkge1xuICAgICAgICAgICAgICBjb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlLnNwbGl0KCc7JylbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2VyaWFsaXplID0gc3VwZXJhZ2VudC5zZXJpYWxpemVbY29udGVudFR5cGVdO1xuICAgICAgICAgICAgaWYgKCFzZXJpYWxpemUgJiYgL1tcXC8rXWpzb25cXGIvLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgICAgICAgICAgIHNlcmlhbGl6ZSA9IHN1cGVyYWdlbnQuc2VyaWFsaXplWydhcHBsaWNhdGlvbi9qc29uJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VyaWFsaXplKSB7XG4gICAgICAgICAgICAgIGRhdGEgPSBzZXJpYWxpemUoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgICh0aGlzUmVxIGFzIGFueSkuX2RhdGEgPSBkYXRhO1xuXG4gICAgICAgICAgY29uc3QgdXJsRGV0YWlscyA9IHVybC5wYXJzZShyZXEudXJsKTtcblxuICAgICAgICAgIGxldCBxdWVyeVN0cmluZzogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgICAgICAgIGNvbnN0IHF1ZXJ5OiBzdHJpbmdbXSA9IChyZXEgYXMgYW55KS5fcXVlcnk7XG4gICAgICAgICAgY29uc3QgcXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSAocmVxIGFzIGFueSkucXM7XG4gICAgICAgICAgaWYgKHF1ZXJ5ICYmIHF1ZXJ5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIGJyb3dzZXIgdmVyc2lvblxuICAgICAgICAgICAgcXVlcnlTdHJpbmcgPSBxdWVyeS5qb2luKCcmJyk7XG4gICAgICAgICAgICAocmVxIGFzIGFueSkuX3F1ZXJ5ID0gW107XG4gICAgICAgICAgfSBlbHNlIGlmIChxcykge1xuICAgICAgICAgICAgLy8gbm9kZSB2ZXJzaW9uXG4gICAgICAgICAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeShxcyk7XG4gICAgICAgICAgICAocmVxIGFzIGFueSkucXMgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChxdWVyeVN0cmluZykge1xuICAgICAgICAgICAgaWYgKHVybERldGFpbHMuc2VhcmNoKSB7XG4gICAgICAgICAgICAgIHVybERldGFpbHMuc2VhcmNoICs9ICcmJyArIHF1ZXJ5U3RyaW5nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdXJsRGV0YWlscy5zZWFyY2ggPSAnPycgKyBxdWVyeVN0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcS51cmwgPSB1cmwuZm9ybWF0KHVybERldGFpbHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHJlcXVlc3RQcm9wZXJ0aWVzID0gc2VsZi5jYWxjdWxhdGVSZXF1ZXN0SGVhZGVycyh7IHVybDogcmVxLnVybCwgdG9rZW46IHNlbGYuX3Rva2VuLCB0ZXh0OiBkYXRhIH0pO1xuICAgICAgICAgIHRoaXNSZXEuc2V0KCdBdXRoLVRpbWVzdGFtcCcsIHJlcXVlc3RQcm9wZXJ0aWVzLnRpbWVzdGFtcC50b1N0cmluZygpKTtcblxuICAgICAgICAgIC8vIHdlJ3JlIG5vdCBzZW5kaW5nIHRoZSBhY3R1YWwgdG9rZW4sIGJ1dCBvbmx5IGl0cyBoYXNoXG4gICAgICAgICAgdGhpc1JlcS5zZXQoJ0F1dGhvcml6YXRpb24nLCAnQmVhcmVyICcgKyByZXF1ZXN0UHJvcGVydGllcy50b2tlbkhhc2gpO1xuXG4gICAgICAgICAgLy8gc2V0IHRoZSBITUFDXG4gICAgICAgICAgdGhpc1JlcS5zZXQoJ0hNQUMnLCByZXF1ZXN0UHJvcGVydGllcy5obWFjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm90b3R5cGljYWxFbmQuYXBwbHkodGhpc1JlcSwgYXJndW1lbnRzIGFzIGFueSk7XG4gICAgICB9O1xuXG4gICAgICAvLyB2ZXJpZnkgdGhhdCB0aGUgcmVzcG9uc2UgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyIGlzIHNpZ25lZCBjb3JyZWN0bHlcbiAgICAgIC8vIHJpZ2h0IG5vdywgaXQgaXMgdmVyeSBwZXJtaXNzaXZlIHdpdGggdGhlIHRpbWVzdGFtcCB2YXJpYW5jZVxuICAgICAgcmVxLnZlcmlmeVJlc3BvbnNlID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKCFyZXEuaXNWMkF1dGhlbnRpY2F0ZWQgfHwgIXJlcS5hdXRoZW50aWNhdGlvblRva2VuKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdmVyaWZpY2F0aW9uUmVzcG9uc2UgPSBzZWxmLnZlcmlmeVJlc3BvbnNlKHtcbiAgICAgICAgICB1cmw6IHJlcS51cmwsXG4gICAgICAgICAgaG1hYzogcmVzcG9uc2UuaGVhZGVyLmhtYWMsXG4gICAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgIHRleHQ6IHJlc3BvbnNlLnRleHQsXG4gICAgICAgICAgdGltZXN0YW1wOiByZXNwb25zZS5oZWFkZXIudGltZXN0YW1wLFxuICAgICAgICAgIHRva2VuOiByZXEuYXV0aGVudGljYXRpb25Ub2tlblxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXZlcmlmaWNhdGlvblJlc3BvbnNlLmlzVmFsaWQpIHtcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIEhNQUNcbiAgICAgICAgICBjb25zdCByZWNlaXZlZEhtYWMgPSByZXNwb25zZS5oZWFkZXIuaG1hYztcbiAgICAgICAgICBjb25zdCBleHBlY3RlZEhtYWMgPSB2ZXJpZmljYXRpb25SZXNwb25zZS5leHBlY3RlZEhtYWM7XG4gICAgICAgICAgY29uc3Qgc2lnbmF0dXJlU3ViamVjdCA9IHZlcmlmaWNhdGlvblJlc3BvbnNlLnNpZ25hdHVyZVN1YmplY3Q7XG4gICAgICAgICAgLy8gTG9nIG9ubHkgdGhlIGZpcnN0IDEwIGNoYXJhY3RlcnMgb2YgdGhlIHRva2VuIHRvIGVuc3VyZSB0aGUgZnVsbCB0b2tlbiBpc24ndCBsb2dnZWQuXG4gICAgICAgICAgY29uc3QgcGFydGlhbEJpdGdvVG9rZW4gPSBzZWxmLl90b2tlbiA/IHNlbGYuX3Rva2VuLnN1YnN0cmluZygwLCAxMCkgOiAnJztcbiAgICAgICAgICBjb25zdCBlcnJvckRldGFpbHMgPSB7XG4gICAgICAgICAgICBleHBlY3RlZEhtYWMsXG4gICAgICAgICAgICByZWNlaXZlZEhtYWMsXG4gICAgICAgICAgICBobWFjSW5wdXQ6IHNpZ25hdHVyZVN1YmplY3QsXG4gICAgICAgICAgICByZXF1ZXN0VG9rZW46IHJlcS5hdXRoZW50aWNhdGlvblRva2VuLFxuICAgICAgICAgICAgYml0Z29Ub2tlbjogcGFydGlhbEJpdGdvVG9rZW5cbiAgICAgICAgICB9O1xuICAgICAgICAgIGRlYnVnKCdJbnZhbGlkIHJlc3BvbnNlIEhNQUM6ICVPJywgZXJyb3JEZXRhaWxzKTtcbiAgICAgICAgICBjb25zdCBlcnJvcjogYW55ID0gbmV3IEVycm9yKCdpbnZhbGlkIHJlc3BvbnNlIEhNQUMsIHBvc3NpYmxlIG1hbi1pbi10aGUtbWlkZGxlLWF0dGFjaycpO1xuICAgICAgICAgIGVycm9yLnJlc3VsdCA9IGVycm9yRGV0YWlscztcbiAgICAgICAgICBlcnJvci5zdGF0dXMgPSA1MTE7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgfTtcblxuICAgICAgbGV0IGxhc3RQcm9taXNlOiBCbHVlYmlyZDxhbnk+IHwgbnVsbCA9IG51bGw7XG4gICAgICByZXEudGhlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIWxhc3RQcm9taXNlKSB7XG4gICAgICAgICAgLy8gY2Fubm90IHJlZGVmaW5lIGVuZCgpIHRvIHJldHVybiBhIEJsdWViaXJkPGFueT4sIGV2ZW4gdGhvdWdoXG4gICAgICAgICAgLy8gdGhhdCBnZXRzIG1vbmtleSBwYXRjaGVkIGluIGF0IHJ1bnRpbWUsIHNvIHRoaXMgY2FzdCBpcyByZXF1aXJlZFxuICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZTogQmx1ZWJpcmQ8YW55PiA9IChyZXEuZW5kKCkgYXMgdW5rbm93biBhcyBCbHVlYmlyZDxhbnk+KVxuICAgICAgICAgICAgLnRoZW4ocmVxLnZlcmlmeVJlc3BvbnNlKTtcbiAgICAgICAgICBsYXN0UHJvbWlzZSA9IHJlZmVyZW5jZS50aGVuLmFwcGx5KHJlZmVyZW5jZSwgYXJndW1lbnRzIGFzIGFueSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFzdFByb21pc2UgPSBsYXN0UHJvbWlzZS50aGVuLmFwcGx5KGxhc3RQcm9taXNlLCBhcmd1bWVudHMgYXMgYW55KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIHJldHVybiBsYXN0UHJvbWlzZSE7XG4gICAgICB9O1xuXG4gICAgICBpZiAoIShwcm9jZXNzIGFzIGFueSkuYnJvd3Nlcikge1xuICAgICAgICAvLyBJZiBub3QgaW4gdGhlIGJyb3dzZXIsIHNldCB0aGUgVXNlci1BZ2VudC4gQnJvd3NlcnMgZG9uJ3QgYWxsb3dcbiAgICAgICAgLy8gc2V0dGluZyBvZiBVc2VyLUFnZW50LCBzbyB3ZSBtdXN0IGRpc2FibGUgdGhpcyB3aGVuIHJ1biBpbiB0aGVcbiAgICAgICAgLy8gYnJvd3NlciAoYnJvd3NlcmlmeSBzZXRzIHByb2Nlc3MuYnJvd3NlcikuXG4gICAgICAgIHJlcS5zZXQoJ1VzZXItQWdlbnQnLCBzZWxmLl91c2VyQWdlbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdGhlIHJlcXVlc3QgdGltZW91dCB0byBqdXN0IGFib3ZlIDUgbWludXRlcyBieSBkZWZhdWx0XG4gICAgICByZXEudGltZW91dCgocHJvY2Vzcy5lbnYuQklUR09fVElNRU9VVCBhcyBhbnkpICogMTAwMCB8fCAzMDUgKiAxMDAwKTtcbiAgICAgIHJldHVybiByZXE7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIEhNQUMgZm9yIHRoZSBnaXZlbiBrZXkgYW5kIG1lc3NhZ2VcbiAgICogQHBhcmFtIGtleSB7U3RyaW5nfSAtIHRoZSBrZXkgdG8gdXNlIGZvciB0aGUgSE1BQ1xuICAgKiBAcGFyYW0gbWVzc2FnZSB7U3RyaW5nfSAtIHRoZSBhY3R1YWwgbWVzc2FnZSB0byBITUFDXG4gICAqIEByZXR1cm5zIHsqfSAtIHRoZSByZXN1bHQgb2YgdGhlIEhNQUMgb3BlcmF0aW9uXG4gICAqL1xuICBjYWxjdWxhdGVITUFDKGtleTogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBjcnlwdG8uY3JlYXRlSG1hYygnc2hhMjU2Jywga2V5KS51cGRhdGUobWVzc2FnZSkuZGlnZXN0KCdoZXgnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBiYXNlY29pbiBvYmplY3RcbiAgICogQHBhcmFtIGNvaW5OYW1lXG4gICAqL1xuICBjb2luKGNvaW5OYW1lOiBzdHJpbmcpOiBCYXNlQ29pbiB7XG4gICAgcmV0dXJuIEdsb2JhbENvaW5GYWN0b3J5LmdldEluc3RhbmNlKHRoaXMsIGNvaW5OYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBiYXNlY29pbiBvYmplY3QgZm9yIGEgdmlydHVhbCB0b2tlblxuICAgKiBAcGFyYW0gdG9rZW5OYW1lXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgdG9rZW4odG9rZW5OYW1lOiBzdHJpbmcsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPEJhc2VDb2luPik6IEJsdWViaXJkPEJhc2VDb2luPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPEJhc2VDb2luPihmdW5jdGlvbiAqKCkge1xuICAgICAgeWllbGQgc2VsZi5mZXRjaENvbnN0YW50cygpO1xuICAgICAgcmV0dXJuIHNlbGYuY29pbih0b2tlbk5hbWUpO1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICovXG4gIGdldFZhbGlkYXRlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKi9cbiAgc2V0VmFsaWRhdGUodmFsaWRhdGU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBpZiAoIV8uaXNCb29sZWFuKHZhbGlkYXRlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIHRoaXMuX3ZhbGlkYXRlID0gdmFsaWRhdGU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjdXJyZW50IEJpdEdvIGVudmlyb25tZW50XG4gICAqL1xuICBnZXRFbnYoKTogRW52aXJvbm1lbnROYW1lIHtcbiAgICByZXR1cm4gdGhpcy5fZW52O1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIG91dCBhbGwgc3RhdGUgZnJvbSB0aGlzIEJpdEdvIG9iamVjdCwgZWZmZWN0aXZlbHkgbG9nZ2luZyBvdXQgdGhlIGN1cnJlbnQgdXNlci5cbiAgICovXG4gIGNsZWFyKCk6IHZvaWQge1xuICAgIC8vIFRPRE86IGFyZSB0aGVyZSBhbnkgb3RoZXIgZmllbGRzIHdoaWNoIHNob3VsZCBiZSBjbGVhcmVkP1xuICAgIHRoaXMuX3VzZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmVmcmVzaFRva2VuID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2VjZGhYcHJ2ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0byByZXR1cm4gYSByZWplY3RlZCBwcm9taXNlIG9yIGNhbGwgY2FsbGJhY2sgd2l0aCBlcnJvclxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgcmVqZWN0KG1zZzogc3RyaW5nLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxuZXZlcj4pOiBCbHVlYmlyZDxuZXZlcj4ge1xuICAgIHJldHVybiBCbHVlYmlyZC5yZWplY3QobmV3IEVycm9yKG1zZykpLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZlcnNpb24gb2YgdGhlIEJpdEdvSlMgcGFja2FnZVxuICAgKi9cbiAgdmVyc2lvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiBwanNvbi52ZXJzaW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZSB0aGlzIEJpdEdvIG9iamVjdCB0byBhIEpTT04gb2JqZWN0LlxuICAgKlxuICAgKiBDYXV0aW9uOiBjb250YWlucyBzZW5zaXRpdmUgZGF0YVxuICAgKi9cbiAgdG9KU09OKCk6IEJpdEdvSnNvbiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZXI6IHRoaXMuX3VzZXIsXG4gICAgICB0b2tlbjogdGhpcy5fdG9rZW4sXG4gICAgICBleHRlbnNpb25LZXk6IHRoaXMuX2V4dGVuc2lvbktleSA/IHRoaXMuX2V4dGVuc2lvbktleS50b1dJRigpIDogdW5kZWZpbmVkLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemUgYSBKU09OIHNlcmlhbGl6ZWQgQml0R28gb2JqZWN0LlxuICAgKlxuICAgKiBPdmVyd3JpdGVzIHRoZSBwcm9wZXJ0aWVzIG9uIHRoZSBjdXJyZW50IEJpdEdvIG9iamVjdCB3aXRoXG4gICAqIHRob3NlIG9mIHRoZSBkZXNlcmlhbHplZCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSBqc29uXG4gICAqL1xuICBmcm9tSlNPTihqc29uOiBCaXRHb0pzb24pOiB2b2lkIHtcbiAgICB0aGlzLl91c2VyID0ganNvbi51c2VyO1xuICAgIHRoaXMuX3Rva2VuID0ganNvbi50b2tlbjtcbiAgICBpZiAoanNvbi5leHRlbnNpb25LZXkpIHtcbiAgICAgIGNvbnN0IG5ldHdvcmsgPSBjb21tb24uRW52aXJvbm1lbnRzW3RoaXMuZ2V0RW52KCldLm5ldHdvcms7XG4gICAgICB0aGlzLl9leHRlbnNpb25LZXkgPSBiaXRjb2luLkVDUGFpci5mcm9tV0lGKFxuICAgICAgICBqc29uLmV4dGVuc2lvbktleSxcbiAgICAgICAgYml0Y29pbi5uZXR3b3Jrc1tuZXR3b3JrXVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHVzZXJcbiAgICovXG4gIHVzZXIoKTogVXNlciB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXI7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IGEgQml0Y29pbiBhZGRyZXNzIGlzIGEgdmFsaWQgYmFzZTU4IGFkZHJlc3NcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHZlcmlmeUFkZHJlc3MocGFyYW1zOiBEZXByZWNhdGVkVmVyaWZ5QWRkcmVzc09wdGlvbnMgPSB7fSk6IGJvb2xlYW4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnYWRkcmVzcyddLCBbXSk7XG5cbiAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLmFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgc3RyaW5nIGFkZHJlc3MnKTtcbiAgICB9XG5cbiAgICBsZXQgYWRkcmVzcztcbiAgICB0cnkge1xuICAgICAgYWRkcmVzcyA9IGJpdGNvaW4uYWRkcmVzcy5mcm9tQmFzZTU4Q2hlY2socGFyYW1zLmFkZHJlc3MpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXR3b3JrTmFtZSA9IGNvbW1vbi5FbnZpcm9ubWVudHNbdGhpcy5nZXRFbnYoKV0ubmV0d29yaztcbiAgICBjb25zdCBuZXR3b3JrID0gYml0Y29pbi5uZXR3b3Jrc1tuZXR3b3JrTmFtZV07XG4gICAgcmV0dXJuIGFkZHJlc3MudmVyc2lvbiA9PT0gbmV0d29yay5wdWJLZXlIYXNoIHx8IGFkZHJlc3MudmVyc2lvbiA9PT0gbmV0d29yay5zY3JpcHRIYXNoO1xuICB9XG5cbiAgLyoqXG4gICAqL1xuICB2ZXJpZnlQYXNzd29yZChwYXJhbXM6IFZlcmlmeVBhc3N3b3JkT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KSB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5wYXNzd29yZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBzdHJpbmcgcGFzc3dvcmQnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3VzZXIgfHwgIXRoaXMuX3VzZXIudXNlcm5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gY3VycmVudCB1c2VyJyk7XG4gICAgfVxuICAgIGNvbnN0IGhtYWNQYXNzd29yZCA9IHRoaXMuY2FsY3VsYXRlSE1BQyh0aGlzLl91c2VyLnVzZXJuYW1lLCBwYXJhbXMucGFzc3dvcmQpO1xuXG4gICAgcmV0dXJuIHRoaXMucG9zdCh0aGlzLnVybCgnL3VzZXIvdmVyaWZ5cGFzc3dvcmQnKSlcbiAgICAgIC5zZW5kKHsgcGFzc3dvcmQ6IGhtYWNQYXNzd29yZCB9KVxuICAgICAgLnJlc3VsdCgndmFsaWQnKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gZW5jcnlwdCBsb2NhbGx5LlxuICAgKi9cbiAgZW5jcnlwdChwYXJhbXM6IEVuY3J5cHRPcHRpb25zID0ge30pOiBzdHJpbmcge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnaW5wdXQnLCAncGFzc3dvcmQnXSwgW10pO1xuXG4gICAgY29uc3QgcmFuZG9tU2FsdCA9IGNyeXB0by5yYW5kb21CeXRlcyg4KTtcbiAgICBjb25zdCByYW5kb21JViA9IGNyeXB0by5yYW5kb21CeXRlcygxNik7XG4gICAgY29uc3QgZW5jcnlwdE9wdGlvbnMgPSB7XG4gICAgICBpdGVyOiAxMDAwMCxcbiAgICAgIGtzOiAyNTYsXG4gICAgICBzYWx0OiBbXG4gICAgICAgIGJ5dGVzVG9Xb3JkKHJhbmRvbVNhbHQuc2xpY2UoMCwgNCkpLFxuICAgICAgICBieXRlc1RvV29yZChyYW5kb21TYWx0LnNsaWNlKDQpKVxuICAgICAgXSxcbiAgICAgIGl2OiBbXG4gICAgICAgIGJ5dGVzVG9Xb3JkKHJhbmRvbUlWLnNsaWNlKDAsIDQpKSxcbiAgICAgICAgYnl0ZXNUb1dvcmQocmFuZG9tSVYuc2xpY2UoNCwgOCkpLFxuICAgICAgICBieXRlc1RvV29yZChyYW5kb21JVi5zbGljZSg4LCAxMikpLFxuICAgICAgICBieXRlc1RvV29yZChyYW5kb21JVi5zbGljZSgxMiwgMTYpKVxuICAgICAgXVxuICAgIH07XG5cbiAgICByZXR1cm4gc2pjbC5lbmNyeXB0KHBhcmFtcy5wYXNzd29yZCwgcGFyYW1zLmlucHV0LCBlbmNyeXB0T3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogRGVjcnlwdCBhbiBlbmNyeXB0ZWQgc3RyaW5nIGxvY2FsbHkuXG4gICAqL1xuICBkZWNyeXB0KHBhcmFtczogRGVjcnlwdE9wdGlvbnMgPSB7fSk6IHN0cmluZyB7XG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnaW5wdXQnLCAncGFzc3dvcmQnXSwgW10pO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gc2pjbC5kZWNyeXB0KHBhcmFtcy5wYXNzd29yZCwgcGFyYW1zLmlucHV0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2NjbTogdGFnIGRvZXNuXFwndCBtYXRjaCcpKSB7XG4gICAgICAgIGVycm9yLm1lc3NhZ2UgPSAncGFzc3dvcmQgZXJyb3IgLSAnICsgZXJyb3IubWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHJhbmRvbSBwYXNzd29yZFxuICAgKiBAcGFyYW0gICB7TnVtYmVyfSBudW1Xb3JkcyAgICAgTnVtYmVyIG9mIDMyLWJpdCB3b3Jkc1xuICAgKiBAcmV0dXJucyB7U3RyaW5nfSAgICAgICAgICBiYXNlNTggcmFuZG9tIHBhc3N3b3JkXG4gICAqL1xuICBnZW5lcmF0ZVJhbmRvbVBhc3N3b3JkKG51bVdvcmRzOiBudW1iZXIgPSA1KTogc3RyaW5nIHtcbiAgICBjb25zdCBieXRlcyA9IHNqY2wuY29kZWMuYnl0ZXMuZnJvbUJpdHMoc2pjbC5yYW5kb20ucmFuZG9tV29yZHMobnVtV29yZHMpKTtcbiAgICByZXR1cm4gYnM1OC5lbmNvZGUoYnl0ZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0IGEgc2VjcmV0IGludG8gc2hhcmRzIHVzaW5nIFNoYW1pciBTZWNyZXQgU2hhcmluZy5cbiAgICogQHBhcmFtIHNlZWQgQSBoZXhhZGVjaW1hbCBzZWNyZXQgdG8gc3BsaXRcbiAgICogQHBhcmFtIHBhc3N3b3JkcyBBbiBhcnJheSBvZiB0aGUgcGFzc3dvcmRzIHVzZWQgdG8gZW5jcnlwdCBlYWNoIHNoYXJlXG4gICAqIEBwYXJhbSBtIFRoZSB0aHJlc2hvbGQgbnVtYmVyIG9mIHNoYXJkcyBuZWNlc3NhcnkgdG8gcmVjb25zdGl0dXRlIHRoZSBzZWNyZXRcbiAgICovXG4gIHNwbGl0U2VjcmV0KHsgc2VlZCwgcGFzc3dvcmRzLCBtIH06IFNwbGl0U2VjcmV0T3B0aW9ucyk6IFNwbGl0U2VjcmV0IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFzc3dvcmRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXNzd29yZHMgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgIH1cbiAgICBpZiAoIV8uaXNJbnRlZ2VyKG0pIHx8IG0gPCAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ20gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDInKTtcbiAgICB9XG5cbiAgICBpZiAocGFzc3dvcmRzLmxlbmd0aCA8IG0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncGFzc3dvcmRzIGFycmF5IGxlbmd0aCBjYW5ub3QgYmUgbGVzcyB0aGFuIG0nKTtcbiAgICB9XG5cbiAgICBjb25zdCBuID0gcGFzc3dvcmRzLmxlbmd0aDtcbiAgICBjb25zdCBzZWNyZXRzOiBzdHJpbmdbXSA9IHNoYW1pci5zaGFyZShzZWVkLCBuLCBtKTtcbiAgICBjb25zdCBzaGFyZHMgPSBfLnppcFdpdGgoc2VjcmV0cywgcGFzc3dvcmRzLCAoc2hhcmQsIHBhc3N3b3JkKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5lbmNyeXB0KHsgaW5wdXQ6IHNoYXJkLCBwYXNzd29yZCB9KTtcbiAgICB9KTtcbiAgICBjb25zdCBub2RlID0gYml0Y29pbi5IRE5vZGUuZnJvbVNlZWRIZXgoc2VlZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHhwdWI6IG5vZGUubmV1dGVyZWQoKS50b0Jhc2U1OCgpLFxuICAgICAgbSxcbiAgICAgIG4sXG4gICAgICBzZWVkU2hhcmVzOiBzaGFyZHMsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNvbnN0aXR1dGUgYSBzZWNyZXQgd2hpY2ggd2FzIHNoYXJkZWQgd2l0aCBgc3BsaXRTZWNyZXRgLlxuICAgKiBAcGFyYW0gc2hhcmRzXG4gICAqIEBwYXJhbSBwYXNzd29yZHNcbiAgICovXG4gIHJlY29uc3RpdHV0ZVNlY3JldCh7IHNoYXJkcywgcGFzc3dvcmRzIH06IFJlY29uc3RpdHV0ZVNlY3JldE9wdGlvbnMpOiBSZWNvbnN0aXR1dGVkU2VjcmV0IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2hhcmRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaGFyZHMgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFzc3dvcmRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXNzd29yZHMgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgIH1cblxuICAgIGlmIChzaGFyZHMubGVuZ3RoICE9PSBwYXNzd29yZHMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NoYXJkcyBhbmQgcGFzc3dvcmRzIGFycmF5cyBtdXN0IGhhdmUgc2FtZSBsZW5ndGgnKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZWNyZXRzID0gXy56aXBXaXRoKHNoYXJkcywgcGFzc3dvcmRzLCAoc2hhcmQsIHBhc3N3b3JkKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5kZWNyeXB0KHsgaW5wdXQ6IHNoYXJkLCBwYXNzd29yZCB9KTtcbiAgICB9KTtcbiAgICBjb25zdCBzZWVkOiBzdHJpbmcgPSBzaGFtaXIuY29tYmluZShzZWNyZXRzKTtcbiAgICBjb25zdCBub2RlID0gYml0Y29pbi5IRE5vZGUuZnJvbVNlZWRIZXgoc2VlZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHhwdWI6IG5vZGUubmV1dGVyZWQoKS50b0Jhc2U1OCgpIGFzIHN0cmluZyxcbiAgICAgIHhwcnY6IG5vZGUudG9CYXNlNTgoKSBhcyBzdHJpbmcsXG4gICAgICBzZWVkLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHNoYXJkc1xuICAgKiBAcGFyYW0gcGFzc3dvcmRzXG4gICAqIEBwYXJhbSBtXG4gICAqIEBwYXJhbSB4cHViIE9wdGlvbmFsIHhwdWIgdG8gdmVyaWZ5IHRoZSByZXN1bHRzIGFnYWluc3RcbiAgICovXG4gIHZlcmlmeVNoYXJkcyh7IHNoYXJkcywgcGFzc3dvcmRzLCBtLCB4cHViIH06IFZlcmlmeVNoYXJkc09wdGlvbnMpOiBib29sZWFuIHtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhbGwgcG9zc2libGUgY29tYmluYXRpb25zIG9mIGEgZ2l2ZW4gYXJyYXkncyB2YWx1ZXMgZ2l2ZW4gc3Vic2V0IHNpemUgbVxuICAgICAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkgd2hvc2UgdmFsdWVzIGFyZSB0byBiZSBhcnJhbmdlZCBpbiBhbGwgY29tYmluYXRpb25zXG4gICAgICogQHBhcmFtIG0gVGhlIHNpemUgb2YgZWFjaCBzdWJzZXRcbiAgICAgKiBAcGFyYW0gZW50cnlJbmRpY2VzIFJlY3Vyc2l2ZWx5IHRyYWlsaW5nIHNldCBvZiBjdXJyZW50bHkgY2hvc2VuIGFycmF5IGluZGljZXMgZm9yIHRoZSBjb21iaW5hdGlvbiBzdWJzZXQgdW5kZXIgY29uc3RydWN0aW9uXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGNvbnN0IGdlbmVyYXRlQ29tYmluYXRpb25zID0gKGFycmF5OiBzdHJpbmdbXSwgbTogbnVtYmVyLCBlbnRyeUluZGljZXM6IG51bWJlcltdID0gW10pOiBzdHJpbmdbXVtdID0+IHtcbiAgICAgIGxldCBjb21iaW5hdGlvbnM6IHN0cmluZ1tdW10gPSBbXTtcblxuICAgICAgaWYgKGVudHJ5SW5kaWNlcy5sZW5ndGggPT09IG0pIHtcbiAgICAgICAgY29uc3QgY3VycmVudENvbWJpbmF0aW9uID0gXy5hdChhcnJheSwgZW50cnlJbmRpY2VzKTtcbiAgICAgICAgcmV0dXJuIFtjdXJyZW50Q29tYmluYXRpb25dO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgaGlnaGVzdCBpbmRleFxuICAgICAgbGV0IGVudHJ5SW5kZXggPSBfLmxhc3QoZW50cnlJbmRpY2VzKTtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBjdXJyZW50bHkgbm8gaW5kaWNlcywgYXNzdW1lIC0xXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChlbnRyeUluZGV4KSkge1xuICAgICAgICBlbnRyeUluZGV4ID0gLTE7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gZW50cnlJbmRleCArIDE7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGN1cnJlbnQgaW5kZXggdG8gdGhlIHRyYWlsaW5nIGluZGljZXNcbiAgICAgICAgY29uc3QgY3VycmVudEVudHJ5SW5kaWNlcyA9IFsuLi5lbnRyeUluZGljZXMsIGldO1xuICAgICAgICBjb25zdCBuZXdDb21iaW5hdGlvbnMgPSBnZW5lcmF0ZUNvbWJpbmF0aW9ucyhhcnJheSwgbSwgY3VycmVudEVudHJ5SW5kaWNlcyk7XG4gICAgICAgIGNvbWJpbmF0aW9ucyA9IFsuLi5jb21iaW5hdGlvbnMsIC4uLm5ld0NvbWJpbmF0aW9uc107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb21iaW5hdGlvbnM7XG4gICAgfTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShzaGFyZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NoYXJkcyBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShwYXNzd29yZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bhc3N3b3JkcyBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgfVxuXG4gICAgaWYgKHNoYXJkcy5sZW5ndGggIT09IHBhc3N3b3Jkcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2hhcmRzIGFuZCBwYXNzd29yZHMgYXJyYXlzIG11c3QgaGF2ZSBzYW1lIGxlbmd0aCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHNlY3JldHMgPSBfLnppcFdpdGgoc2hhcmRzLCBwYXNzd29yZHMsIChzaGFyZCwgcGFzc3dvcmQpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmRlY3J5cHQoeyBpbnB1dDogc2hhcmQsIHBhc3N3b3JkIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IHNlY3JldENvbWJpbmF0aW9ucyA9IGdlbmVyYXRlQ29tYmluYXRpb25zKHNlY3JldHMsIG0pO1xuICAgIGNvbnN0IHNlZWRzID0gc2VjcmV0Q29tYmluYXRpb25zLm1hcChjdXJyZW50Q29tYmluYXRpb24gPT4ge1xuICAgICAgcmV0dXJuIHNoYW1pci5jb21iaW5lKGN1cnJlbnRDb21iaW5hdGlvbik7XG4gICAgfSk7XG4gICAgY29uc3QgdW5pcXVlU2VlZHMgPSBfLnVuaXEoc2VlZHMpO1xuICAgIGlmICh1bmlxdWVTZWVkcy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc2VlZCA9IF8uZmlyc3QodW5pcXVlU2VlZHMpO1xuICAgIGNvbnN0IG5vZGUgPSBiaXRjb2luLkhETm9kZS5mcm9tU2VlZEhleChzZWVkKTtcbiAgICBjb25zdCByZXN0b3JlZFhwdWIgPSBub2RlLm5ldXRlcmVkKCkudG9CYXNlNTgoKTtcblxuICAgIGlmICghXy5pc1VuZGVmaW5lZCh4cHViKSkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHhwdWIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigneHB1YiBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdG9yZWRYcHViICE9PSB4cHViKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYW4gRUNESCBzZWNyZXQgZnJvbSBhIHByaXZhdGUga2V5IGFuZCBvdGhlciB1c2VyJ3MgcHVibGljIGtleVxuICAgKi9cbiAgZ2V0RUNESFNlY3JldCh7IG90aGVyUHViS2V5SGV4LCBlY2tleSB9OiBHZXRFY2RoU2VjcmV0T3B0aW9ucykge1xuICAgIGlmICghXy5pc1N0cmluZyhvdGhlclB1YktleUhleCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb3RoZXJQdWJLZXlIZXggc3RyaW5nIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmICghXy5pc09iamVjdChlY2tleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZWNrZXkgb2JqZWN0IHJlcXVpcmVkJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3RoZXJLZXlQdWIgPSBiaXRjb2luLkVDUGFpci5mcm9tUHVibGljS2V5QnVmZmVyKG5ldyBCdWZmZXIob3RoZXJQdWJLZXlIZXgsICdoZXgnKSk7XG4gICAgY29uc3Qgc2VjcmV0UG9pbnQgPSBvdGhlcktleVB1Yi5RLm11bHRpcGx5KChlY2tleSBhcyBiaXRjb2luLkVDUGFpcikuZCk7XG4gICAgY29uc3Qgc2VjcmV0ID0gVXRpbC5iblRvQnl0ZUFycmF5VW5zaWduZWQoc2VjcmV0UG9pbnQuYWZmaW5lWCk7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc2VjcmV0KS50b1N0cmluZygnaGV4Jyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdXNlcidzIHByaXZhdGUga2V5Y2hhaW4sIHVzZWQgZm9yIHJlY2VpdmluZyBzaGFyZXNcbiAgICovXG4gIGdldEVDREhTaGFyaW5nS2V5Y2hhaW4ocGFyYW1zPzoge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gdGhpcy5nZXQodGhpcy51cmwoJy91c2VyL3NldHRpbmdzJykpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICBpZiAoIXJlc3VsdC5zZXR0aW5ncy5lY2RoS2V5Y2hhaW4pIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5yZWplY3QoJ2VjZGgga2V5Y2hhaW4gbm90IGZvdW5kIGZvciB1c2VyJywgY2FsbGJhY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGYua2V5Y2hhaW5zKCkuZ2V0KHsgeHB1YjogcmVzdWx0LnNldHRpbmdzLmVjZGhLZXljaGFpbiB9KTtcbiAgICAgIH0pXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGJpdGNvaW4gbWFya2V0IGRhdGFcbiAgICovXG4gIG1hcmtldHMoKSB7XG4gICAgaWYgKCF0aGlzLl9tYXJrZXRzKSB7XG4gICAgICB0aGlzLl9tYXJrZXRzID0gbmV3IE1hcmtldHModGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9tYXJrZXRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGF0ZXN0IGJpdGNvaW4gcHJpY2VzXG4gICAqIChEZXByZWNhdGVkOiBXaWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZSkgdXNlIGBiaXRnby5tYXJrZXRzKCkubGF0ZXN0KClgXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBtYXJrZXQocGFyYW1zPzoge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQodGhpcy51cmwoJy9tYXJrZXQvbGF0ZXN0JykpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgbWFya2V0IGRhdGEgZnJvbSB5ZXN0ZXJkYXlcbiAgICogKERlcHJlY2F0ZWQ6IFdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlKSB1c2UgYml0Z28ubWFya2V0cygpLnllc3RlcmRheSgpXG4gICAqL1xuICB5ZXN0ZXJkYXkocGFyYW1zPzoge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQodGhpcy51cmwoJy9tYXJrZXQveWVzdGVyZGF5JykpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTeW5jaHJvbm91cyBtZXRob2QgZm9yIGFjdGl2YXRpbmcgYW4gYWNjZXNzIHRva2VuLlxuICAgKi9cbiAgYXV0aGVudGljYXRlV2l0aEFjY2Vzc1Rva2VuKHsgYWNjZXNzVG9rZW4gfTogQWNjZXNzVG9rZW5PcHRpb25zKTogdm9pZCB7XG4gICAgdGhpcy5fdG9rZW4gPSBhY2Nlc3NUb2tlbjtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gcmVzcG9uc2VCb2R5IFJlc3BvbnNlIGJvZHkgb2JqZWN0XG4gICAqIEBwYXJhbSBwYXNzd29yZCBQYXNzd29yZCBmb3IgdGhlIHN5bW1ldHJpYyBkZWNyeXB0aW9uXG4gICAqL1xuICBoYW5kbGVUb2tlbklzc3VhbmNlKHJlc3BvbnNlQm9keTogVG9rZW5Jc3N1YW5jZVJlc3BvbnNlLCBwYXNzd29yZD86IHN0cmluZyk6IFRva2VuSXNzdWFuY2Uge1xuICAgIC8vIG1ha2Ugc3VyZSB0aGUgcmVzcG9uc2UgYm9keSBjb250YWlucyB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXNcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocmVzcG9uc2VCb2R5LCBbJ2Rlcml2YXRpb25QYXRoJ10sIFsnZW5jcnlwdGVkRUNESFhwcnYnXSk7XG5cbiAgICBjb25zdCBlbnZpcm9ubWVudCA9IHRoaXMuX2VudjtcbiAgICBjb25zdCBlbnZpcm9ubWVudENvbmZpZyA9IGNvbW1vbi5FbnZpcm9ubWVudHNbZW52aXJvbm1lbnRdO1xuICAgIGNvbnN0IHNlcnZlclhwdWIgPSBlbnZpcm9ubWVudENvbmZpZy5zZXJ2ZXJYcHViO1xuICAgIGxldCBlY2RoWHBydiA9IHRoaXMuX2VjZGhYcHJ2O1xuICAgIGlmICghZWNkaFhwcnYpIHtcbiAgICAgIGlmICghcGFzc3dvcmQgfHwgIXJlc3BvbnNlQm9keS5lbmNyeXB0ZWRFQ0RIWHBydikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VjZGhYcHJ2IHByb3BlcnR5IG11c3QgYmUgc2V0IG9yIHBhc3N3b3JkIGFuZCBlbmNyeXB0ZWQgZW5jcnlwdGVkRUNESFhwcnYgbXVzdCBiZSBwcm92aWRlZCcpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgZWNkaFhwcnYgPSB0aGlzLmRlY3J5cHQoe1xuICAgICAgICAgIGlucHV0OiByZXNwb25zZUJvZHkuZW5jcnlwdGVkRUNESFhwcnYsXG4gICAgICAgICAgcGFzc3dvcmQ6IHBhc3N3b3JkXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlLmVycm9yQ29kZSA9ICdlY2RoX3hwcnZfZGVjcnlwdGlvbl9mYWlsdXJlJztcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGRlY3J5cHQgZW5jcnlwdGVkRUNESFhwcnYuJyk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29uc3RydWN0IEhETm9kZSBvYmplY3RzIGZvciBjbGllbnQncyB4cHJ2IGFuZCBzZXJ2ZXIncyB4cHViXG4gICAgY29uc3QgY2xpZW50SEROb2RlID0gYml0Y29pbi5IRE5vZGUuZnJvbUJhc2U1OChlY2RoWHBydik7XG4gICAgY29uc3Qgc2VydmVySEROb2RlID0gYml0Y29pbi5IRE5vZGUuZnJvbUJhc2U1OChzZXJ2ZXJYcHViKTtcblxuICAgIC8vIEJJUDMyIGRlcml2YXRpb24gcGF0aCBpcyBhcHBsaWVkIHRvIGJvdGggY2xpZW50IGFuZCBzZXJ2ZXIgbWFzdGVyIGtleXNcbiAgICBjb25zdCBkZXJpdmF0aW9uUGF0aCA9IHJlc3BvbnNlQm9keS5kZXJpdmF0aW9uUGF0aDtcbiAgICBjb25zdCBjbGllbnREZXJpdmVkTm9kZSA9IGhkUGF0aChjbGllbnRIRE5vZGUpLmRlcml2ZShkZXJpdmF0aW9uUGF0aCk7XG4gICAgY29uc3Qgc2VydmVyRGVyaXZlZE5vZGUgPSBoZFBhdGgoc2VydmVySEROb2RlKS5kZXJpdmUoZGVyaXZhdGlvblBhdGgpO1xuXG4gICAgLy8gY2FsY3VsYXRpbmcgb25lLXRpbWUgRUNESCBrZXlcbiAgICBjb25zdCBzZWNyZXRQb2ludCA9IHNlcnZlckRlcml2ZWROb2RlLmtleVBhaXIuX19RLm11bHRpcGx5KGNsaWVudERlcml2ZWROb2RlLmtleVBhaXIuZCk7XG4gICAgY29uc3Qgc2VjcmV0ID0gc2VjcmV0UG9pbnQuZ2V0RW5jb2RlZCgpLnRvU3RyaW5nKCdoZXgnKTtcblxuICAgIC8vIGRlY3J5cHQgdG9rZW4gd2l0aCBzeW1tZXRyaWMgRUNESCBrZXlcbiAgICBsZXQgcmVzcG9uc2U6IFRva2VuSXNzdWFuY2U7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3BvbnNlID0ge1xuICAgICAgICB0b2tlbjogdGhpcy5kZWNyeXB0KHtcbiAgICAgICAgICBpbnB1dDogcmVzcG9uc2VCb2R5LmVuY3J5cHRlZFRva2VuLFxuICAgICAgICAgIHBhc3N3b3JkOiBzZWNyZXRcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZS5lcnJvckNvZGUgPSAndG9rZW5fZGVjcnlwdGlvbl9mYWlsdXJlJztcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBkZWNyeXB0IHRva2VuLicpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9lY2RoWHBydikge1xuICAgICAgcmVzcG9uc2UuZWNkaFhwcnYgPSBlY2RoWHBydjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgc3RyaW5nIHRoYXQgaXMgdG8gYmUgSE1BQ2VkIGZvciBhIGNlcnRhaW4gSFRUUCByZXF1ZXN0IG9yIHJlc3BvbnNlXG4gICAqIEBwYXJhbSB1cmxQYXRoXG4gICAqIEBwYXJhbSB0ZXh0XG4gICAqIEBwYXJhbSB0aW1lc3RhbXBcbiAgICogQHBhcmFtIHN0YXR1c0NvZGUgT25seSBzZXQgZm9yIEhUVFAgcmVzcG9uc2VzLCBsZWF2ZSBibGFuayBmb3IgcmVxdWVzdHNcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGNhbGN1bGF0ZUhNQUNTdWJqZWN0KHsgdXJsUGF0aCwgdGV4dCwgdGltZXN0YW1wLCBzdGF0dXNDb2RlIH06IENhbGN1bGF0ZUhtYWNTdWJqZWN0T3B0aW9ucyk6IHN0cmluZyB7XG4gICAgY29uc3QgdXJsRGV0YWlscyA9IHVybC5wYXJzZSh1cmxQYXRoKTtcbiAgICBjb25zdCBxdWVyeVBhdGggPSAodXJsRGV0YWlscy5xdWVyeSAmJiB1cmxEZXRhaWxzLnF1ZXJ5Lmxlbmd0aCA+IDApID8gdXJsRGV0YWlscy5wYXRoIDogdXJsRGV0YWlscy5wYXRobmFtZTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoc3RhdHVzQ29kZSkgJiYgXy5pc0ludGVnZXIoc3RhdHVzQ29kZSkgJiYgXy5pc0Zpbml0ZShzdGF0dXNDb2RlKSkge1xuICAgICAgcmV0dXJuIFt0aW1lc3RhbXAsIHF1ZXJ5UGF0aCwgc3RhdHVzQ29kZSwgdGV4dF0uam9pbignfCcpO1xuICAgIH1cbiAgICByZXR1cm4gW3RpbWVzdGFtcCwgcXVlcnlQYXRoLCB0ZXh0XS5qb2luKCd8Jyk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBITUFDIGZvciBhbiBIVFRQIHJlcXVlc3RcbiAgICovXG4gIGNhbGN1bGF0ZVJlcXVlc3RITUFDKHsgdXJsOiB1cmxQYXRoLCB0ZXh0LCB0aW1lc3RhbXAsIHRva2VuIH06IENhbGN1bGF0ZVJlcXVlc3RIbWFjT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgY29uc3Qgc2lnbmF0dXJlU3ViamVjdCA9IHRoaXMuY2FsY3VsYXRlSE1BQ1N1YmplY3QoeyB1cmxQYXRoLCB0ZXh0LCB0aW1lc3RhbXAgfSk7XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIEhNQUNcbiAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVITUFDKHRva2VuLCBzaWduYXR1cmVTdWJqZWN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgcmVxdWVzdCBoZWFkZXJzIHdpdGggSE1BQ1xuICAgKi9cbiAgY2FsY3VsYXRlUmVxdWVzdEhlYWRlcnMoeyB1cmwsIHRleHQsIHRva2VuIH06IENhbGN1bGF0ZVJlcXVlc3RIZWFkZXJzT3B0aW9ucyk6IFJlcXVlc3RIZWFkZXJzIHtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGhtYWMgPSB0aGlzLmNhbGN1bGF0ZVJlcXVlc3RITUFDKHsgdXJsLCB0ZXh0LCB0aW1lc3RhbXAsIHRva2VuIH0pO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBTSEEyNTYgaGFzaCBvZiB0aGUgdG9rZW5cbiAgICBjb25zdCBoYXNoRGlnZXN0ID0gc2pjbC5oYXNoLnNoYTI1Ni5oYXNoKHRva2VuKTtcbiAgICBjb25zdCB0b2tlbkhhc2ggPSBzamNsLmNvZGVjLmhleC5mcm9tQml0cyhoYXNoRGlnZXN0KTtcbiAgICByZXR1cm4ge1xuICAgICAgaG1hYyxcbiAgICAgIHRpbWVzdGFtcCxcbiAgICAgIHRva2VuSGFzaCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSB0aGUgSE1BQyBmb3IgYW4gSFRUUCByZXNwb25zZVxuICAgKi9cbiAgdmVyaWZ5UmVzcG9uc2UoeyB1cmw6IHVybFBhdGgsIHN0YXR1c0NvZGUsIHRleHQsIHRpbWVzdGFtcCwgdG9rZW4sIGhtYWMgfTogVmVyaWZ5UmVzcG9uc2VPcHRpb25zKSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlU3ViamVjdCA9IHRoaXMuY2FsY3VsYXRlSE1BQ1N1YmplY3Qoe1xuICAgICAgdXJsUGF0aCxcbiAgICAgIHRleHQsXG4gICAgICB0aW1lc3RhbXAsXG4gICAgICBzdGF0dXNDb2RlLFxuICAgIH0pO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBITUFDXG4gICAgY29uc3QgZXhwZWN0ZWRIbWFjID0gdGhpcy5jYWxjdWxhdGVITUFDKHRva2VuLCBzaWduYXR1cmVTdWJqZWN0KTtcblxuICAgIC8vIHZlcmlmeSB0aGUgSE1BQyBhbmQgdGltZXN0YW1wXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzVmFsaWQ6IGV4cGVjdGVkSG1hYyA9PT0gaG1hYyxcbiAgICAgIGV4cGVjdGVkSG1hYyxcbiAgICAgIHNpZ25hdHVyZVN1YmplY3QsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIHRoZSB1c2VybmFtZSwgcGFzc3dvcmQgYW5kIG90cCBpbnRvIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSB1c2VybmFtZSBhbmQgaGFzaGVkIHBhc3N3b3JkLCByZWFkeSB0b1xuICAgKiBzZW5kIHRvIGJpdGdvIGZvciBhdXRoZW50aWNhdGlvbi5cbiAgICovXG4gIHByZXByb2Nlc3NBdXRoZW50aWNhdGlvblBhcmFtcyh7IHVzZXJuYW1lLCBwYXNzd29yZCwgb3RwLCBmb3JjZVNNUywgZXh0ZW5zaWJsZSwgdHJ1c3QgfTogQXV0aGVudGljYXRlT3B0aW9ucyk6IFByb2Nlc3NlZEF1dGhlbnRpY2F0aW9uT3B0aW9ucyB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKHVzZXJuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBzdHJpbmcgdXNlcm5hbWUnKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNTdHJpbmcocGFzc3dvcmQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHN0cmluZyBwYXNzd29yZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGxvd2VyTmFtZSA9IHVzZXJuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBwYXNzd29yZCBITUFDIHNvIHdlIGRvbid0IHNlbmQgY2xlYXItdGV4dCBwYXNzd29yZHNcbiAgICBjb25zdCBobWFjUGFzc3dvcmQgPSB0aGlzLmNhbGN1bGF0ZUhNQUMobG93ZXJOYW1lLCBwYXNzd29yZCk7XG5cbiAgICBjb25zdCBhdXRoUGFyYW1zOiBQcm9jZXNzZWRBdXRoZW50aWNhdGlvbk9wdGlvbnMgPSB7XG4gICAgICBlbWFpbDogbG93ZXJOYW1lLFxuICAgICAgcGFzc3dvcmQ6IGhtYWNQYXNzd29yZCxcbiAgICAgIGZvcmNlU01TOiAhIWZvcmNlU01TLFxuICAgIH07XG5cbiAgICBpZiAob3RwKSB7XG4gICAgICBhdXRoUGFyYW1zLm90cCA9IG90cDtcbiAgICAgIGlmICh0cnVzdCkge1xuICAgICAgICBhdXRoUGFyYW1zLnRydXN0ID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXh0ZW5zaWJsZSkge1xuICAgICAgdGhpcy5fZXh0ZW5zaW9uS2V5ID0gbWFrZVJhbmRvbUtleSgpO1xuICAgICAgYXV0aFBhcmFtcy5leHRlbnNpYmxlID0gdHJ1ZTtcbiAgICAgIGF1dGhQYXJhbXMuZXh0ZW5zaW9uQWRkcmVzcyA9IHRoaXMuX2V4dGVuc2lvbktleS5nZXRBZGRyZXNzKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF1dGhQYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogTG9naW4gdG8gdGhlIGJpdGdvIHBsYXRmb3JtLlxuICAgKi9cbiAgYXV0aGVudGljYXRlKHBhcmFtczogQXV0aGVudGljYXRlT3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxzdXBlcmFnZW50LlJlc3BvbnNlPihmdW5jdGlvbiAqKCkge1xuICAgICAgaWYgKCFfLmlzT2JqZWN0KHBhcmFtcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBvYmplY3QgcGFyYW1zJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYWxsYmFjayAmJiAhXy5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxiYWNrIHBhcmFtZXRlciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5wYXNzd29yZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBzdHJpbmcgcGFzc3dvcmQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZm9yY2VWMUF1dGggPSAhIXBhcmFtcy5mb3JjZVYxQXV0aDtcbiAgICAgIGNvbnN0IGF1dGhQYXJhbXMgPSBzZWxmLnByZXByb2Nlc3NBdXRoZW50aWNhdGlvblBhcmFtcyhwYXJhbXMpO1xuICAgICAgY29uc3QgcGFzc3dvcmQgPSBwYXJhbXMucGFzc3dvcmQ7XG5cbiAgICAgIGlmIChzZWxmLl90b2tlbikge1xuICAgICAgICByZXR1cm4gc2VsZi5yZWplY3QoJ2FscmVhZHkgbG9nZ2VkIGluJywgY2FsbGJhY2spO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhdXRoVXJsID0gc2VsZi5fbWljcm9zZXJ2aWNlc1VybCA/XG4gICAgICAgIHNlbGYubWljcm9zZXJ2aWNlc1VybCgnL2FwaS9hdXRoL3YxL3Nlc3Npb24nKSA6XG4gICAgICAgIHNlbGYudXJsKCcvdXNlci9sb2dpbicpO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHNlbGYucG9zdChhdXRoVXJsKTtcblxuICAgICAgaWYgKGZvcmNlVjFBdXRoKSB7XG4gICAgICAgIChyZXF1ZXN0IGFzIGFueSkuZm9yY2VWMUF1dGggPSB0cnVlO1xuICAgICAgICAvLyB0ZWxsIHRoZSBzZXJ2ZXIgdGhhdCB0aGUgY2xpZW50IHdhcyBmb3JjZWQgdG8gZG93bmdyYWRlIHRoZSBhdXRoZW50aWNhdGlvbiBwcm90b2NvbFxuICAgICAgICBhdXRoUGFyYW1zLmZvcmNlVjFBdXRoID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3BvbnNlOiBzdXBlcmFnZW50LlJlc3BvbnNlID0geWllbGQgcmVxdWVzdC5zZW5kKGF1dGhQYXJhbXMpO1xuICAgICAgLy8gZXh0cmFjdCBib2R5IGFuZCB1c2VyIGluZm9ybWF0aW9uXG4gICAgICBjb25zdCBib2R5ID0gcmVzcG9uc2UuYm9keTtcbiAgICAgIHNlbGYuX3VzZXIgPSBib2R5LnVzZXI7XG5cbiAgICAgIGlmIChib2R5LmFjY2Vzc190b2tlbikge1xuICAgICAgICBzZWxmLl90b2tlbiA9IGJvZHkuYWNjZXNzX3Rva2VuO1xuICAgICAgICAvLyBpZiB0aGUgZG93bmdyYWRlIHdhcyBmb3JjZWQsIGFkZGluZyBhIHdhcm5pbmcgbWVzc2FnZSBtaWdodCBiZSBwcnVkZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjaGVjayB0aGUgcHJlc2VuY2Ugb2YgYW4gZW5jcnlwdGVkIEVDREggeHBydlxuICAgICAgICAvLyBpZiBub3QgcHJlc2VudCwgbGVnYWN5IGFjY291bnRcbiAgICAgICAgY29uc3QgZW5jcnlwdGVkWHBydiA9IGJvZHkuZW5jcnlwdGVkRUNESFhwcnY7XG4gICAgICAgIGlmICghZW5jcnlwdGVkWHBydikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignS2V5Y2hhaW4gbmVlZHMgZW5jcnlwdGVkWHBydiBwcm9wZXJ0eScpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2VEZXRhaWxzID0gc2VsZi5oYW5kbGVUb2tlbklzc3VhbmNlKHJlc3BvbnNlLmJvZHksIHBhc3N3b3JkKTtcbiAgICAgICAgc2VsZi5fdG9rZW4gPSByZXNwb25zZURldGFpbHMudG9rZW47XG4gICAgICAgIHNlbGYuX2VjZGhYcHJ2ID0gcmVzcG9uc2VEZXRhaWxzLmVjZGhYcHJ2O1xuXG4gICAgICAgIC8vIHZlcmlmeSB0aGUgcmVzcG9uc2UncyBhdXRoZW50aWNpdHlcbiAgICAgICAgcmVxdWVzdC52ZXJpZnlSZXNwb25zZShyZXNwb25zZSk7XG5cbiAgICAgICAgLy8gYWRkIHRoZSByZW1haW5pbmcgY29tcG9uZW50IGZvciBlYXNpZXIgYWNjZXNzXG4gICAgICAgIHJlc3BvbnNlLmJvZHkuYWNjZXNzX3Rva2VuID0gc2VsZi5fdG9rZW47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9KS5jYWxsKHRoaXMpXG4gICAgICAudGhlbihoYW5kbGVSZXNwb25zZVJlc3VsdCgpLCBoYW5kbGVSZXNwb25zZUVycm9yKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogLSBvcGVyYXRpbmdTeXN0ZW06IG9uZSBvZiBpb3MsIGFuZHJvaWRcbiAgICogLSBwdXNoVG9rZW46IGhleC1mb3JtYXR0ZWQgdG9rZW4gZm9yIHRoZSByZXNwZWN0aXZlIG5hdGl2ZSBwdXNoIG5vdGlmaWNhdGlvbiBzZXJ2aWNlXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHJlZ2lzdGVyUHVzaFRva2VuKHBhcmFtcywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3B1c2hUb2tlbicsICdvcGVyYXRpbmdTeXN0ZW0nXSwgW10sIGNhbGxiYWNrKTtcblxuICAgIGlmICghdGhpcy5fdG9rZW4pIHtcbiAgICAgIC8vIHRoaXMgZGV2aWNlIGhhcyB0byBiZSByZWdpc3RlcmVkIHRvIGFuIGV4dGVuc2libGUgc2Vzc2lvblxuICAgICAgcmV0dXJuIHRoaXMucmVqZWN0KCdub3QgbG9nZ2VkIGluJywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIGNvbnN0IHBvc3RQYXJhbXMgPSBfLnBpY2socGFyYW1zLCBbJ3B1c2hUb2tlbicsICdvcGVyYXRpbmdTeXN0ZW0nXSk7XG5cbiAgICByZXR1cm4gdGhpcy5wb3N0KHRoaXMudXJsKCcvZGV2aWNlcycpKVxuICAgICAgLnNlbmQocG9zdFBhcmFtcylcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiAtIHB1c2hWZXJpZmljYXRpb25Ub2tlbjogdGhlIHRva2VuIHJlY2VpdmVkIHZpYSBwdXNoIG5vdGlmaWNhdGlvbiB0byBjb25maXJtIHRoZSBkZXZpY2UncyBtb2JpbGl0eVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHZlcmlmeVB1c2hUb2tlbihwYXJhbXM6IFZlcmlmeVB1c2hUb2tlbk9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24gKigpIHtcbiAgICAgIGlmICghXy5pc09iamVjdChwYXJhbXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgb2JqZWN0IHBhcmFtcycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnB1c2hWZXJpZmljYXRpb25Ub2tlbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBzdHJpbmcgcHVzaFZlcmlmaWNhdGlvblRva2VuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghc2VsZi5fdG9rZW4pIHtcbiAgICAgICAgLy8gdGhpcyBkZXZpY2UgaGFzIHRvIGJlIHJlZ2lzdGVyZWQgdG8gYW4gZXh0ZW5zaWJsZSBzZXNzaW9uXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGxvZ2dlZCBpbicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwb3N0UGFyYW1zID0gXy5waWNrKHBhcmFtcywgJ3B1c2hWZXJpZmljYXRpb25Ub2tlbicpO1xuXG4gICAgICByZXR1cm4gc2VsZi5wb3N0KHNlbGYudXJsKCcvZGV2aWNlcy92ZXJpZnknKSlcbiAgICAgICAgLnNlbmQocG9zdFBhcmFtcylcbiAgICAgICAgLnJlc3VsdCgpO1xuICAgIH0pLmNhbGwodGhpcylcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dpbiB0byB0aGUgYml0Z28gc3lzdGVtIHVzaW5nIGFuIGF1dGhjb2RlIGdlbmVyYXRlZCB2aWEgT2F1dGhcbiAgICovXG4gIGF1dGhlbnRpY2F0ZVdpdGhBdXRoQ29kZShwYXJhbXM6IEF1dGhlbnRpY2F0ZVdpdGhBdXRoQ29kZU9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24gKigpIHtcbiAgICAgIGlmICghXy5pc09iamVjdChwYXJhbXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgb2JqZWN0IHBhcmFtcycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLmF1dGhDb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVkIHN0cmluZyBhdXRoQ29kZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNlbGYuX2NsaWVudElkIHx8ICFzZWxmLl9jbGllbnRTZWNyZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIGNsaWVudCBpZCBhbmQgc2VjcmV0IHNldCBmaXJzdCB0byB1c2UgdGhpcycpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhdXRoQ29kZSA9IHBhcmFtcy5hdXRoQ29kZTtcblxuICAgICAgaWYgKHNlbGYuX3Rva2VuKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnJlamVjdCgnYWxyZWFkeSBsb2dnZWQgaW4nLCBjYWxsYmFjayk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBzZWxmLnBvc3Qoc2VsZi5fYmFzZVVybCArICcvb2F1dGgvdG9rZW4nKTtcbiAgICAgIHJlcXVlc3QuZm9yY2VWMUF1dGggPSB0cnVlOyAvLyBPQXV0aCBjdXJyZW50bHkgb25seSBzdXBwb3J0cyB2MSBhdXRoZW50aWNhdGlvblxuICAgICAgY29uc3QgYm9keSA9IHlpZWxkIHJlcXVlc3RcbiAgICAgICAgLnNlbmQoe1xuICAgICAgICAgIGdyYW50X3R5cGU6ICdhdXRob3JpemF0aW9uX2NvZGUnLFxuICAgICAgICAgIGNvZGU6IGF1dGhDb2RlLFxuICAgICAgICAgIGNsaWVudF9pZDogc2VsZi5fY2xpZW50SWQsXG4gICAgICAgICAgY2xpZW50X3NlY3JldDogc2VsZi5fY2xpZW50U2VjcmV0LFxuICAgICAgICB9KVxuICAgICAgICAucmVzdWx0KCk7XG5cbiAgICAgIHNlbGYuX3Rva2VuID0gYm9keS5hY2Nlc3NfdG9rZW47XG4gICAgICBzZWxmLl9yZWZyZXNoVG9rZW4gPSBib2R5LnJlZnJlc2hfdG9rZW47XG4gICAgICBzZWxmLl91c2VyID0geWllbGQgc2VsZi5tZSgpO1xuICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHJlZnJlc2ggdG9rZW4gdG8gZ2V0IG5ldyBhY2Nlc3MgdG9rZW4uXG4gICAqIElmIHRoZSByZWZyZXNoIHRva2VuIGlzIG51bGwvZGVmaW5lZCwgdGhlbiB3ZSB1c2UgdGhlIHN0b3JlZCB0b2tlbiBmcm9tIGF1dGhcbiAgICovXG4gIHJlZnJlc2hUb2tlbihwYXJhbXM6IHsgcmVmcmVzaFRva2VuPzogc3RyaW5nIH0gPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqKCkge1xuICAgICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFsncmVmcmVzaFRva2VuJ10sIGNhbGxiYWNrKTtcblxuICAgICAgY29uc3QgcmVmcmVzaFRva2VuID0gcGFyYW1zLnJlZnJlc2hUb2tlbiB8fCBzZWxmLl9yZWZyZXNoVG9rZW47XG5cbiAgICAgIGlmICghcmVmcmVzaFRva2VuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIHJlZnJlc2ggdG9rZW4gb3IgaGF2ZSBhdXRoZW50aWNhdGVkIHdpdGggT2F1dGggYmVmb3JlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghc2VsZi5fY2xpZW50SWQgfHwgIXNlbGYuX2NsaWVudFNlY3JldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgY2xpZW50IGlkIGFuZCBzZWNyZXQgc2V0IGZpcnN0IHRvIHVzZSB0aGlzJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJvZHkgPSB5aWVsZCBzZWxmLnBvc3Qoc2VsZi5fYmFzZVVybCArICcvb2F1dGgvdG9rZW4nKVxuICAgICAgICAuc2VuZCh7XG4gICAgICAgICAgZ3JhbnRfdHlwZTogJ3JlZnJlc2hfdG9rZW4nLFxuICAgICAgICAgIHJlZnJlc2hfdG9rZW46IHJlZnJlc2hUb2tlbixcbiAgICAgICAgICBjbGllbnRfaWQ6IHNlbGYuX2NsaWVudElkLFxuICAgICAgICAgIGNsaWVudF9zZWNyZXQ6IHNlbGYuX2NsaWVudFNlY3JldFxuICAgICAgICB9KVxuICAgICAgICAucmVzdWx0KCk7XG4gICAgICBzZWxmLl90b2tlbiA9IGJvZHkuYWNjZXNzX3Rva2VuO1xuICAgICAgc2VsZi5fcmVmcmVzaFRva2VuID0gYm9keS5yZWZyZXNoX3Rva2VuO1xuICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfSlcbiAgICAuY2FsbCh0aGlzKVxuICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBsaXN0QWNjZXNzVG9rZW5zXG4gICAqIEdldCBpbmZvcm1hdGlvbiBvbiBhbGwgb2YgdGhlIEJpdEdvIGFjY2VzcyB0b2tlbnMgb24gdGhlIHVzZXJcbiAgICogQHJldHVybiB7XG4gICAqICBpZDogPGlkIG9mIHRoZSB0b2tlbj5cbiAgICogIGxhYmVsOiA8dGhlIHVzZXItcHJvdmlkZWQgbGFiZWwgZm9yIHRoaXMgdG9rZW4+XG4gICAqICB1c2VyOiA8aWQgb2YgdGhlIHVzZXIgb24gdGhlIHRva2VuPlxuICAgKiAgZW50ZXJwcmlzZSA8aWQgb2YgdGhlIGVudGVycHJpc2UgdGhpcyB0b2tlbiBpcyB2YWxpZCBmb3I+XG4gICAqICBjbGllbnQ6IDx0aGUgYXV0aCBjbGllbnQgdGhhdCB0aGlzIHRva2VuIGJlbG9uZ3MgdG8+XG4gICAqICBzY29wZTogPGxpc3Qgb2YgYWxsb3dlZCBPQXV0aCBzY29wZSB2YWx1ZXM+XG4gICAqICBjcmVhdGVkOiA8ZGF0ZSB0aGUgdG9rZW4gd2FzIGNyZWF0ZWQ+XG4gICAqICBleHBpcmVzOiA8ZGF0ZSB0aGUgdG9rZW4gd2lsbCBleHBpcmU+XG4gICAqICBvcmlnaW46IDx0aGUgb3JpZ2luIGZvciB3aGljaCB0aGlzIHRva2VuIGlzIHZhbGlkPlxuICAgKiAgaXNFeHRlbnNpYmxlOiA8ZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSB0b2tlbiBjYW4gYmUgZXh0ZW5kZWQ+XG4gICAqICBleHRlbnNpb25BZGRyZXNzOiA8YWRkcmVzcyB3aG9zZSBwcml2YXRlIGtleSdzIHNpZ25hdHVyZSBpcyBuZWNlc3NhcnkgZm9yIGV4dGVuc2lvbnM+XG4gICAqICB1bmxvY2s6IDxpbmZvIGZvciBhY3Rpb25zIHRoYXQgcmVxdWlyZSBhbiB1bmxvY2sgYmVmb3JlIGZpcmluZz5cbiAgICogfVxuICAgKi9cbiAgbGlzdEFjY2Vzc1Rva2VucyhwYXJhbXM/OiB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybCgnL3VzZXIvYWNjZXNzdG9rZW4nKSlcbiAgICAgIC5zZW5kKClcbiAgICAgIC5yZXN1bHQoJ2FjY2Vzc1Rva2VucycpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogYWRkQWNjZXNzVG9rZW5cbiAgICogQWRkIGEgQml0R28gQVBJIEFjY2VzcyBUb2tlbiB0byB0aGUgY3VycmVudCB1c2VyIGFjY291bnRcbiAgICogQHBhcmFtIHBhcmFtcyB7XG4gICAqICAgIG90cDogKHJlcXVpcmVkKSA8dmFsaWQgb3RwIGNvZGU+XG4gICAqICAgIGxhYmVsOiAocmVxdWlyZWQpIDxsYWJlbCBmb3IgdGhlIHRva2VuPlxuICAgKiAgICBkdXJhdGlvbjogPGxlbmd0aCBvZiB0aW1lIGluIHNlY29uZHMgdGhlIHRva2VuIHdpbGwgYmUgdmFsaWQgZm9yPlxuICAgKiAgICBpcFJlc3RyaWN0OiA8YXJyYXkgb2YgSVAgYWRkcmVzcyBzdHJpbmdzIHRvIHdoaXRlbGlzdD5cbiAgICogICAgdHhWYWx1ZUxpbWl0OiA8bnVtYmVyIG9mIG91dGdvaW5nIHNhdG9zaGlzIGFsbG93ZWQgb24gdGhpcyB0b2tlbj5cbiAgICogICAgc2NvcGU6IChyZXF1aXJlZCkgPGF1dGhvcml6YXRpb24gc2NvcGUgb2YgdGhlIHJlcXVlc3RlZCB0b2tlbj5cbiAgICogfVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybiB7XG4gICAqICAgIGlkOiA8aWQgb2YgdGhlIHRva2VuPlxuICAgKiAgICB0b2tlbjogPGFjY2VzcyB0b2tlbiBoZXggc3RyaW5nIHRvIGJlIHVzZWQgZm9yIEJpdEdvIEFQSSByZXF1ZXN0IHZlcmlmaWNhdGlvbj5cbiAgICogICAgbGFiZWw6IDx1c2VyLXByb3ZpZGVkIGxhYmVsIGZvciB0aGlzIHRva2VuPlxuICAgKiAgICB1c2VyOiA8aWQgb2YgdGhlIHVzZXIgb24gdGhlIHRva2VuPlxuICAgKiAgICBlbnRlcnByaXNlIDxpZCBvZiB0aGUgZW50ZXJwcmlzZSB0aGlzIHRva2VuIGlzIHZhbGlkIGZvcj5cbiAgICogICAgY2xpZW50OiA8dGhlIGF1dGggY2xpZW50IHRoYXQgdGhpcyB0b2tlbiBiZWxvbmdzIHRvPlxuICAgKiAgICBzY29wZTogPGxpc3Qgb2YgYWxsb3dlZCBPQXV0aCBzY29wZSB2YWx1ZXM+XG4gICAqICAgIGNyZWF0ZWQ6IDxkYXRlIHRoZSB0b2tlbiB3YXMgY3JlYXRlZD5cbiAgICogICAgZXhwaXJlczogPGRhdGUgdGhlIHRva2VuIHdpbGwgZXhwaXJlPlxuICAgKiAgICBvcmlnaW46IDx0aGUgb3JpZ2luIGZvciB3aGljaCB0aGlzIHRva2VuIGlzIHZhbGlkPlxuICAgKiAgICBpc0V4dGVuc2libGU6IDxmbGFnIGluZGljYXRpbmcgaWYgdGhlIHRva2VuIGNhbiBiZSBleHRlbmRlZD5cbiAgICogICAgZXh0ZW5zaW9uQWRkcmVzczogPGFkZHJlc3Mgd2hvc2UgcHJpdmF0ZSBrZXkncyBzaWduYXR1cmUgaXMgbmVjZXNzYXJ5IGZvciBleHRlbnNpb25zPlxuICAgKiAgICB1bmxvY2s6IDxpbmZvIGZvciBhY3Rpb25zIHRoYXQgcmVxdWlyZSBhbiB1bmxvY2sgYmVmb3JlIGZpcmluZz5cbiAgICogfVxuICAgKi9cbiAgYWRkQWNjZXNzVG9rZW4ocGFyYW1zOiBBZGRBY2Nlc3NUb2tlbk9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288c3VwZXJhZ2VudC5SZXNwb25zZT4oZnVuY3Rpb24gKigpIHtcbiAgICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMubGFiZWwpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgc3RyaW5nIGxhYmVsJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIG5vbi1zdHJpbmcgcGFyYW1zXG4gICAgICBpZiAocGFyYW1zLmR1cmF0aW9uKSB7XG4gICAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMuZHVyYXRpb24pIHx8IHBhcmFtcy5kdXJhdGlvbiA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2R1cmF0aW9uIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbXMuaXBSZXN0cmljdCkge1xuICAgICAgICBpZiAoIV8uaXNBcnJheShwYXJhbXMuaXBSZXN0cmljdCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lwUmVzdHJpY3QgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIF8uZm9yRWFjaChwYXJhbXMuaXBSZXN0cmljdCwgZnVuY3Rpb24oaXBBZGRyKSB7XG4gICAgICAgICAgaWYgKCFfLmlzU3RyaW5nKGlwQWRkcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXBSZXN0cmljdCBtdXN0IGJlIGFuIGFycmF5IG9mIElQIGFkZHJlc3Mgc3RyaW5ncycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLnR4VmFsdWVMaW1pdCkge1xuICAgICAgICBpZiAoIV8uaXNOdW1iZXIocGFyYW1zLnR4VmFsdWVMaW1pdCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R4VmFsdWVMaW1pdCBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy50eFZhbHVlTGltaXQgPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eFZhbHVlTGltaXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy5zY29wZSAmJiBwYXJhbXMuc2NvcGUubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoIV8uaXNBcnJheShwYXJhbXMuc2NvcGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzY29wZSBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBzcGVjaWZ5IHNjb3BlIGZvciB0b2tlbicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhdXRoVXJsID0gc2VsZi5fbWljcm9zZXJ2aWNlc1VybCA/XG4gICAgICAgIHNlbGYubWljcm9zZXJ2aWNlc1VybCgnL2FwaS9hdXRoL3YxL2FjY2Vzc3Rva2VuJykgOlxuICAgICAgICBzZWxmLnVybCgnL3VzZXIvYWNjZXNzdG9rZW4nKTtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBzZWxmLnBvc3QoYXV0aFVybCk7XG5cbiAgICAgIGlmICghc2VsZi5fZWNkaFhwcnYpIHtcbiAgICAgICAgLy8gd2l0aG91dCBhIHByaXZhdGUga2V5LCB0aGUgdXNlciBjYW5ub3QgZGVjcnlwdCB0aGUgbmV3IGFjY2VzcyB0b2tlbiB0aGUgc2VydmVyIHdpbGwgc2VuZFxuICAgICAgICByZXF1ZXN0LmZvcmNlVjFBdXRoID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCByZXF1ZXN0LnNlbmQocGFyYW1zKTtcbiAgICAgIGlmIChyZXF1ZXN0LmZvcmNlVjFBdXRoKSB7XG4gICAgICAgIHJlc3BvbnNlLmJvZHkud2FybmluZyA9ICdBIHByb3RvY29sIGRvd25ncmFkZSBoYXMgb2NjdXJyZWQgYmVjYXVzZSB0aGlzIGlzIGEgbGVnYWN5IGFjY291bnQuJztcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgfVxuXG4gICAgICAvLyB2ZXJpZnkgdGhlIGF1dGhlbnRpY2l0eSBvZiB0aGUgc2VydmVyJ3MgcmVzcG9uc2UgYmVmb3JlIHByb2NlZWRpbmcgYW55IGZ1cnRoZXJcbiAgICAgIHJlcXVlc3QudmVyaWZ5UmVzcG9uc2UocmVzcG9uc2UpO1xuXG4gICAgICBjb25zdCByZXNwb25zZURldGFpbHMgPSBzZWxmLmhhbmRsZVRva2VuSXNzdWFuY2UocmVzcG9uc2UuYm9keSk7XG4gICAgICByZXNwb25zZS5ib2R5LnRva2VuID0gcmVzcG9uc2VEZXRhaWxzLnRva2VuO1xuXG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSkuY2FsbCh0aGlzKVxuICAgICAgLnRoZW4oaGFuZGxlUmVzcG9uc2VSZXN1bHQoKSwgaGFuZGxlUmVzcG9uc2VFcnJvcilcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBleHBpcmUgdGltZSBvZiBhbiBhY2Nlc3MgdG9rZW4gbWF0Y2hpbmcgZWl0aGVyIHRoZSBpZCBvciBsYWJlbCB0byB0aGUgY3VycmVudCBkYXRlLCBlZmZlY3RpdmVseSBkZWxldGluZyBpdFxuICAgKlxuICAgKiBQYXJhbXM6XG4gICAqIGlkOiA8aWQgb2YgdGhlIGFjY2VzcyB0b2tlbiB0byBiZSBkZWxldGVkPlxuICAgKiBsYWJlbDogPGxhYmVsIG9mIHRoZSBhY2Nlc3MgdG9rZW4gdG8gYmUgZGVsZXRlZD5cbiAgICpcbiAgICogUmV0dXJuczpcbiAgICogaWQ6IDxpZCBvZiB0aGUgdG9rZW4+XG4gICAqIGxhYmVsOiA8dXNlci1wcm92aWRlZCBsYWJlbCBmb3IgdGhpcyB0b2tlbj5cbiAgICogdXNlcjogPGlkIG9mIHRoZSB1c2VyIG9uIHRoZSB0b2tlbj5cbiAgICogZW50ZXJwcmlzZSA8aWQgb2YgdGhlIGVudGVycHJpc2UgdGhpcyB0b2tlbiBpcyB2YWxpZCBmb3I+XG4gICAqIGNsaWVudDogPHRoZSBhdXRoIGNsaWVudCB0aGF0IHRoaXMgdG9rZW4gYmVsb25ncyB0bz5cbiAgICogc2NvcGU6IDxsaXN0IG9mIGFsbG93ZWQgT0F1dGggc2NvcGUgdmFsdWVzPlxuICAgKiBjcmVhdGVkOiA8ZGF0ZSB0aGUgdG9rZW4gd2FzIGNyZWF0ZWQ+XG4gICAqIGV4cGlyZXM6IDxkYXRlIHRoZSB0b2tlbiB3aWxsIGV4cGlyZT5cbiAgICogb3JpZ2luOiA8dGhlIG9yaWdpbiBmb3Igd2hpY2ggdGhpcyB0b2tlbiBpcyB2YWxpZD5cbiAgICogaXNFeHRlbnNpYmxlOiA8ZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSB0b2tlbiBjYW4gYmUgZXh0ZW5kZWQ+XG4gICAqIGV4dGVuc2lvbkFkZHJlc3M6IDxhZGRyZXNzIHdob3NlIHByaXZhdGUga2V5J3Mgc2lnbmF0dXJlIGlzIG5lKmNlc3NhcnkgZm9yIGV4dGVuc2lvbnM+XG4gICAqIHVubG9jazogPGluZm8gZm9yIGFjdGlvbnMgdGhhdCByZXF1aXJlIGFuIHVubG9jayBiZWZvcmUgZmlyaW5nPlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgcmVtb3ZlQWNjZXNzVG9rZW4oeyBpZCwgbGFiZWwgfTogUmVtb3ZlQWNjZXNzVG9rZW5PcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uKigpIHtcbiAgICAgIGlmICgoIWlkICYmICFsYWJlbCkgfHwgKGlkICYmIGxhYmVsKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3QgcHJvdmlkZSBleGFjdGx5IG9uZSBvZiBpZCBvciBsYWJlbCcpO1xuICAgICAgfVxuICAgICAgaWYgKGlkKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmRlbChzZWxmLnVybChgL3VzZXIvYWNjZXNzdG9rZW4vJHtpZH1gKSlcbiAgICAgICAgICAuc2VuZCgpXG4gICAgICAgICAgLnJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0b2tlbnMgPSB5aWVsZCBzZWxmLmxpc3RBY2Nlc3NUb2tlbnMoKTtcblxuICAgICAgaWYgKCF0b2tlbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b2tlbiB3aXRoIHRoaXMgbGFiZWwgZG9lcyBub3QgZXhpc3QnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWF0Y2hpbmdUb2tlbnM6IGFueSA9IF8uZmlsdGVyKHRva2VucywgeyBsYWJlbCB9KTtcbiAgICAgIGlmIChtYXRjaGluZ1Rva2Vucy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYW1iaWd1b3VzIGNhbGw6IG11bHRpcGxlIHRva2VucyBtYXRjaGluZyB0aGlzIGxhYmVsJyk7XG4gICAgICB9XG4gICAgICBpZiAobWF0Y2hpbmdUb2tlbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndG9rZW4gd2l0aCB0aGlzIGxhYmVsIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLmRlbChzZWxmLnVybChgL3VzZXIvYWNjZXNzdG9rZW4vJHttYXRjaGluZ1Rva2Vuc1swXS5pZH1gKSlcbiAgICAgICAgLnNlbmQoKVxuICAgICAgICAucmVzdWx0KCk7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogTG9nb3V0IG9mIEJpdEdvXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBsb2dvdXQocGFyYW1zPzoge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24gKigpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHNlbGYuZ2V0KHNlbGYudXJsKCcvdXNlci9sb2dvdXQnKSkucmVzdWx0KCk7XG4gICAgICBzZWxmLmNsZWFyKCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHVzZXIgYnkgSUQgKG5hbWUvZW1haWwgb25seSlcbiAgICogQHBhcmFtIGlkXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgZ2V0VXNlcih7IGlkIH06IEdldFVzZXJPcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uKigpIHtcbiAgICAgIGlmICghXy5pc1N0cmluZyhpZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBzdHJpbmcgaWQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybChgL3VzZXIvJHtpZH1gKSkucmVzdWx0KCd1c2VyJyk7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlIHRoZSBwYXNzd29yZCBvZiB0aGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyLlxuICAgKiBBbHNvIGNoYW5nZSBhbGwgdjEgYW5kIHYyIGtleWNoYWluIHBhc3N3b3JkcyBpZiB0aGV5IG1hdGNoIHRoZVxuICAgKiBnaXZlbiBvbGRQYXNzd29yZC4gUmV0dXJucyBub3RoaW5nIG9uIHN1Y2Nlc3MuXG4gICAqIEBwYXJhbSBvbGRQYXNzd29yZCB7U3RyaW5nfSAtIHRoZSBjdXJyZW50IHBhc3N3b3JkXG4gICAqIEBwYXJhbSBuZXdQYXNzd29yZCB7U3RyaW5nfSAtIHRoZSBuZXcgcGFzc3dvcmRcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBjaGFuZ2VQYXNzd29yZCh7IG9sZFBhc3N3b3JkLCBuZXdQYXNzd29yZCB9OiBDaGFuZ2VQYXNzd29yZE9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24gKmNvQ2hhbmdlUGFzc3dvcmQoKSB7XG4gICAgICBpZiAoIV8uaXNTdHJpbmcob2xkUGFzc3dvcmQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgc3RyaW5nIG9sZFBhc3N3b3JkJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghXy5pc1N0cmluZyhuZXdQYXNzd29yZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBzdHJpbmcgbmV3UGFzc3dvcmQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXNlciA9IHNlbGYudXNlcigpO1xuICAgICAgaWYgKHR5cGVvZiB1c2VyICE9PSAnb2JqZWN0JyB8fCAhdXNlci51c2VybmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgb2JqZWN0IHVzZXInKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IHlpZWxkIHNlbGYudmVyaWZ5UGFzc3dvcmQoeyBwYXNzd29yZDogb2xkUGFzc3dvcmQgfSk7XG4gICAgICBpZiAoIXZhbGlkYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgcHJvdmlkZWQgb2xkUGFzc3dvcmQgaXMgaW5jb3JyZWN0Jyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGl0IGRvZXNuJ3QgbWF0dGVyIHdoaWNoIGNvaW4gd2UgY2hvb3NlIGJlY2F1c2UgdGhlIHYyIHVwZGF0ZVBhc3N3b3JkIGZ1bmN0aW9ucyB1cGRhdGVzIGFsbCB2MiBrZXljaGFpbnNcbiAgICAgIC8vIHdlIGp1c3QgbmVlZCB0byBjaG9vc2UgYSBjb2luIHRoYXQgZXhpc3RzIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50XG4gICAgICBjb25zdCBjb2luID0gY29tbW9uLkVudmlyb25tZW50c1tzZWxmLmdldEVudigpXS5uZXR3b3JrID09PSAnYml0Y29pbicgPyAnYnRjJyA6ICd0YnRjJztcblxuICAgICAgY29uc3QgdXBkYXRlS2V5Y2hhaW5QYXNzd29yZFBhcmFtcyA9IHsgb2xkUGFzc3dvcmQsIG5ld1Bhc3N3b3JkIH07XG4gICAgICBjb25zdCB2MUtleWNoYWluVXBkYXRlUFdSZXN1bHQgPSB5aWVsZCBzZWxmLmtleWNoYWlucygpLnVwZGF0ZVBhc3N3b3JkKHVwZGF0ZUtleWNoYWluUGFzc3dvcmRQYXJhbXMpO1xuICAgICAgY29uc3QgdjJLZXljaGFpbnMgPSB5aWVsZCBzZWxmLmNvaW4oY29pbikua2V5Y2hhaW5zKCkudXBkYXRlUGFzc3dvcmQodXBkYXRlS2V5Y2hhaW5QYXNzd29yZFBhcmFtcyk7XG5cbiAgICAgIGNvbnN0IHVwZGF0ZVBhc3N3b3JkUGFyYW1zID0ge1xuICAgICAgICBrZXljaGFpbnM6IHYxS2V5Y2hhaW5VcGRhdGVQV1Jlc3VsdC5rZXljaGFpbnMsXG4gICAgICAgIHYyX2tleWNoYWluczogdjJLZXljaGFpbnMsXG4gICAgICAgIHZlcnNpb246IHYxS2V5Y2hhaW5VcGRhdGVQV1Jlc3VsdC52ZXJzaW9uLFxuICAgICAgICBvbGRQYXNzd29yZDogc2VsZi5jYWxjdWxhdGVITUFDKHVzZXIudXNlcm5hbWUsIG9sZFBhc3N3b3JkKSxcbiAgICAgICAgcGFzc3dvcmQ6IHNlbGYuY2FsY3VsYXRlSE1BQyh1c2VyLnVzZXJuYW1lLCBuZXdQYXNzd29yZClcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBzZWxmLnBvc3Qoc2VsZi51cmwoJy91c2VyL2NoYW5nZXBhc3N3b3JkJykpXG4gICAgICAgIC5zZW5kKHVwZGF0ZVBhc3N3b3JkUGFyYW1zKVxuICAgICAgICAucmVzdWx0KCk7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgbG9nZ2VkIGluIHVzZXJcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIG1lKHBhcmFtcz86IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VXNlcih7IGlkOiAnbWUnIH0sIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbmxvY2sgdGhlIHNlc3Npb24gYnkgcHJvdmlkaW5nIE9UUFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3RwIFJlcXVpcmVkIE9UUCBjb2RlIGZvciB0aGUgYWNjb3VudC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIERlc2lyZWQgZHVyYXRpb24gb2YgdGhlIHVubG9jayBpbiBzZWNvbmRzIChkZWZhdWx0PTYwMCwgbWF4PTM2MDApLlxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHVubG9jayh7IG90cCwgZHVyYXRpb24gfTogVW5sb2NrT3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqKCkge1xuICAgICAgaWYgKG90cCAmJiAhXy5pc1N0cmluZyhvdHApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgc3RyaW5nIG9yIHVuZGVmaW5lZCBvdHAnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLnBvc3Qoc2VsZi51cmwoJy91c2VyL3VubG9jaycpKVxuICAgICAgICAuc2VuZCh7IG90cCwgZHVyYXRpb24gfSlcbiAgICAgICAgLnJlc3VsdCgpO1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIExvY2sgdGhlIHNlc3Npb25cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGxvY2socGFyYW1zPzoge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5wb3N0KHRoaXMudXJsKCcvdXNlci9sb2NrJykpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgc2Vzc2lvblxuICAgKi9cbiAgc2Vzc2lvbihwYXJhbXM/OiB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybCgnL3VzZXIvc2Vzc2lvbicpKVxuICAgICAgLnJlc3VsdCgnc2Vzc2lvbicpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlciBhIHB1c2gvc21zIGZvciB0aGUgT1RQIGNvZGVcbiAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMuZm9yY2VTTVMgSWYgc2V0IHRvIHRydWUsIHdpbGwgdXNlIFNNUyB0byBzZW5kIHRoZSBPVFAgdG8gdGhlIHVzZXIgZXZlbiBpZiB0aGV5IGhhdmUgb3RoZXIgMkZBIG1ldGhvZCBzZXQgdXAuXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBzZW5kT1RQKHBhcmFtczogeyBmb3JjZVNNUz86IGJvb2xlYW4gfSA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMucG9zdCh0aGlzLnVybCgnL3VzZXIvc2VuZG90cCcpKVxuICAgICAgLnNlbmQocGFyYW1zKVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogRXh0ZW5kIHRva2VuLCBwcm92aWRlZCB0aGUgY3VycmVudCB0b2tlbiBpcyBleHRlbmRhYmxlXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogLSBkdXJhdGlvbjogZHVyYXRpb24gaW4gc2Vjb25kcyBieSB3aGljaCB0byBleHRlbmQgdGhlIHRva2VuLCBzdGFydGluZyBhdCB0aGUgY3VycmVudCB0aW1lXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgZXh0ZW5kVG9rZW4ocGFyYW1zOiBFeHRlbmRUb2tlbk9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGlmICghdGhpcy5fZXh0ZW5zaW9uS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgX2V4dGVuc2lvbktleScpO1xuICAgIH1cblxuICAgIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgY29uc3QgZHVyYXRpb24gPSBwYXJhbXMuZHVyYXRpb247XG4gICAgY29uc3QgbWVzc2FnZSA9IHRpbWVzdGFtcCArICd8JyArIHRoaXMuX3Rva2VuICsgJ3wnICsgZHVyYXRpb247XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IHRoaXMuX2V4dGVuc2lvbktleS5kLnRvQnVmZmVyKDMyKTtcbiAgICBjb25zdCBpc0NvbXByZXNzZWQgPSB0aGlzLl9leHRlbnNpb25LZXkuY29tcHJlc3NlZDtcbiAgICBjb25zdCBwcmVmaXggPSBiaXRjb2luLm5ldHdvcmtzLmJpdGNvaW4ubWVzc2FnZVByZWZpeDtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBiaXRjb2luTWVzc2FnZS5zaWduKG1lc3NhZ2UsIHByaXZhdGVLZXksIGlzQ29tcHJlc3NlZCwgcHJlZml4KS50b1N0cmluZygnaGV4Jyk7XG5cbiAgICByZXR1cm4gdGhpcy5wb3N0KHRoaXMudXJsKCcvdXNlci9leHRlbmR0b2tlbicpKVxuICAgICAgLnNlbmQocGFyYW1zKVxuICAgICAgLnNldCgndGltZXN0YW1wJywgdGltZXN0YW1wLnRvU3RyaW5nKCkpXG4gICAgICAuc2V0KCdzaWduYXR1cmUnLCBzaWduYXR1cmUpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBrZXkgZm9yIHNoYXJpbmcgYSB3YWxsZXQgd2l0aCBhIHVzZXJcbiAgICogQHBhcmFtIGVtYWlsIGVtYWlsIG9mIHVzZXIgdG8gc2hhcmUgd2FsbGV0IHdpdGhcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBnZXRTaGFyaW5nS2V5KHsgZW1haWwgfTogR2V0U2hhcmluZ0tleU9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBpZiAoIV8uaXNTdHJpbmcoZW1haWwpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVkIHN0cmluZyBlbWFpbCcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBvc3QodGhpcy51cmwoJy91c2VyL3NoYXJpbmdrZXknKSlcbiAgICAgIC5zZW5kKHsgZW1haWwgfSlcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3QgY29ubmVjdGl2aXR5IHRvIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHBpbmcoeyByZXFJZCB9OiBQaW5nT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgaWYgKHJlcUlkKSB7XG4gICAgICB0aGlzLl9yZXFJZCA9IHJlcUlkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybCgnL3BpbmcnKSlcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYmxvY2tjaGFpbiBvYmplY3QuXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBibG9ja2NoYWluKCk6IGFueSB7XG4gICAgaWYgKCF0aGlzLl9ibG9ja2NoYWluKSB7XG4gICAgICB0aGlzLl9ibG9ja2NoYWluID0gbmV3IEJsb2NrY2hhaW4odGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ibG9ja2NoYWluO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdXNlcidzIGtleWNoYWlucyBvYmplY3QuXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBrZXljaGFpbnMoKTogYW55IHtcbiAgICBpZiAoIXRoaXMuX2tleWNoYWlucykge1xuICAgICAgdGhpcy5fa2V5Y2hhaW5zID0gbmV3IEtleWNoYWlucyh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2tleWNoYWlucztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHVzZXIncyB3YWxsZXRzIG9iamVjdC5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHdhbGxldHMoKSB7XG4gICAgaWYgKCF0aGlzLl93YWxsZXRzKSB7XG4gICAgICB0aGlzLl93YWxsZXRzID0gbmV3IFdhbGxldHModGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93YWxsZXRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdHJhdmVsIHJ1bGUgb2JqZWN0XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICB0cmF2ZWxSdWxlKCk6IGFueSB7XG4gICAgaWYgKCF0aGlzLl90cmF2ZWxSdWxlKSB7XG4gICAgICB0aGlzLl90cmF2ZWxSdWxlID0gbmV3IFRyYXZlbFJ1bGUodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90cmF2ZWxSdWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBwZW5kaW5nIGFwcHJvdmFscyB0aGF0IGNhbiBiZSBhcHByb3ZlZC8gb3IgcmVqZWN0ZWRcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHBlbmRpbmdBcHByb3ZhbHMoKTogYW55IHtcbiAgICBpZiAoIXRoaXMuX3BlbmRpbmdBcHByb3ZhbHMpIHtcbiAgICAgIHRoaXMuX3BlbmRpbmdBcHByb3ZhbHMgPSBuZXcgUGVuZGluZ0FwcHJvdmFscyh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdBcHByb3ZhbHM7XG4gIH1cblxuICAvKipcbiAgICogQSBmYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgV2FsbGV0IG9iamVjdCwgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgd2FsbGV0IHBhcmFtc1xuICAgKiBDYW4gYmUgdXNlZCB0byByZWNvbnN0aXR1dGUgYSB3YWxsZXQgZnJvbSBjYWNoZWQgZGF0YVxuICAgKiBAcGFyYW0gd2FsbGV0UGFyYW1zXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBuZXdXYWxsZXRPYmplY3Qod2FsbGV0UGFyYW1zKTogYW55IHtcbiAgICByZXR1cm4gbmV3IFdhbGxldCh0aGlzLCB3YWxsZXRQYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHVybCBmb3IgY2FsbGluZyBCaXRHbyBwbGF0Zm9ybSBBUElzXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEBwYXJhbSB2ZXJzaW9uXG4gICAqL1xuICB1cmwocGF0aDogc3RyaW5nLCB2ZXJzaW9uID0gMSk6IHN0cmluZyB7XG4gICAgY29uc3QgYmFzZVVybCA9IHZlcnNpb24gPT09IDIgPyB0aGlzLl9iYXNlQXBpVXJsVjIgOiB0aGlzLl9iYXNlQXBpVXJsO1xuICAgIHJldHVybiBiYXNlVXJsICsgcGF0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB1cmwgZm9yIGNhbGxpbmcgQml0R28gbWljcm9zZXJ2aWNlIEFQSXNcbiAgICovXG4gIG1pY3Jvc2VydmljZXNVcmwocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fbWljcm9zZXJ2aWNlc1VybCArIHBhdGg7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCB0aGUgYWRkcmVzcyBsYWJlbHMgb24gYWxsIG9mIHRoZSB1c2VyJ3Mgd2FsbGV0c1xuICAgKi9cbiAgbGFiZWxzKHBhcmFtcz86IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMudXJsKCcvbGFiZWxzJykpXG4gICAgICAucmVzdWx0KCdsYWJlbHMnKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEVzdGltYXRlcyBhcHByb3hpbWF0ZSBmZWUgcGVyIGtiIG5lZWRlZCBmb3IgYSB0eCB0byBnZXQgaW50byBhIGJsb2NrXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubnVtQmxvY2tzIHRhcmdldCBibG9ja3MgZm9yIHRoZSB0cmFuc2FjdGlvbiB0byBiZSBjb25maXJtZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5tYXhGZWUgbWF4aW11bSBmZWUgd2lsbGluZyB0byBiZSBwYWlkIChmb3Igc2FmZXR5KVxuICAgKiBAcGFyYW0ge2FycmF5W3N0cmluZ119IHBhcmFtcy5pbnB1dHMgbGlzdCBvZiB1bmNvbmZpcm1lZCB0eElkcyBmcm9tIHdoaWNoIHRoaXMgdHJhbnNhY3Rpb24gdXNlcyBpbnB1dHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy50eFNpemUgZXN0aW1hdGVkIHRyYW5zYWN0aW9uIHNpemUgaW4gYnl0ZXMsIG9wdGlvbmFsIHBhcmFtZXRlciB1c2VkIGZvciBDUEZQIGVzdGltYXRpb24uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLmNwZnBBd2FyZSBmbGFnIGluZGljYXRpbmcgZmVlIHNob3VsZCB0YWtlIGludG8gYWNjb3VudCBDUEZQXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBlc3RpbWF0ZUZlZShwYXJhbXM6IEVzdGltYXRlRmVlT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3QgcXVlcnlQYXJhbXM6IGFueSA9IHsgdmVyc2lvbjogMTIgfTtcbiAgICBpZiAocGFyYW1zLm51bUJsb2Nrcykge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy5udW1CbG9ja3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICAgICAgfVxuICAgICAgcXVlcnlQYXJhbXMubnVtQmxvY2tzID0gcGFyYW1zLm51bUJsb2NrcztcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5tYXhGZWUpIHtcbiAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMubWF4RmVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5UGFyYW1zLm1heEZlZSA9IHBhcmFtcy5tYXhGZWU7XG4gICAgfVxuICAgIGlmIChwYXJhbXMuaW5wdXRzKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zLmlucHV0cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgICB9XG4gICAgICBxdWVyeVBhcmFtcy5pbnB1dHMgPSBwYXJhbXMuaW5wdXRzO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLnR4U2l6ZSkge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy50eFNpemUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICAgICAgfVxuICAgICAgcXVlcnlQYXJhbXMudHhTaXplID0gcGFyYW1zLnR4U2l6ZTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5jcGZwQXdhcmUpIHtcbiAgICAgIGlmICghXy5pc0Jvb2xlYW4ocGFyYW1zLmNwZnBBd2FyZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgICB9XG4gICAgICBxdWVyeVBhcmFtcy5jcGZwQXdhcmUgPSBwYXJhbXMuY3BmcEF3YXJlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybCgnL3R4L2ZlZScpKVxuICAgICAgLnF1ZXJ5KHF1ZXJ5UGFyYW1zKVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IEJpdEdvJ3MgZ3VhcmFudGVlIHVzaW5nIGFuIGluc3RhbnQgaWRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGluc3RhbnRHdWFyYW50ZWUocGFyYW1zOiB7IGlkOiBzdHJpbmcgfSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqKCkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5pZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBzdHJpbmcgaWQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYm9keSA9IHlpZWxkIHNlbGYuZ2V0KHNlbGYudXJsKCcvaW5zdGFudC8nICsgcGFyYW1zLmlkKSkucmVzdWx0KCk7XG4gICAgICBpZiAoIWJvZHkuZ3VhcmFudGVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gZ3VhcmFudGVlIGZvdW5kIGluIHJlc3BvbnNlIGJvZHknKTtcbiAgICAgIH1cbiAgICAgIGlmICghYm9keS5zaWduYXR1cmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBzaWduYXR1cmUgZm91bmQgaW4gZ3VhcmFudGVlIHJlc3BvbnNlIGJvZHknKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpZ25pbmdBZGRyZXNzID0gY29tbW9uLkVudmlyb25tZW50c1tzZWxmLmdldEVudigpXS5zaWduaW5nQWRkcmVzcztcbiAgICAgIGNvbnN0IHNpZ25hdHVyZUJ1ZmZlciA9IG5ldyBCdWZmZXIoYm9keS5zaWduYXR1cmUsICdoZXgnKTtcbiAgICAgIGNvbnN0IHByZWZpeCA9IGJpdGNvaW4ubmV0d29ya3NbY29tbW9uLkVudmlyb25tZW50c1tzZWxmLmdldEVudigpXS5uZXR3b3JrXS5tZXNzYWdlUHJlZml4O1xuICAgICAgY29uc3QgaXNWYWxpZFNpZ25hdHVyZSA9IGJpdGNvaW5NZXNzYWdlLnZlcmlmeShib2R5Lmd1YXJhbnRlZSwgc2lnbmluZ0FkZHJlc3MsIHNpZ25hdHVyZUJ1ZmZlciwgcHJlZml4KTtcbiAgICAgIGlmICghaXNWYWxpZFNpZ25hdHVyZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luY29ycmVjdCBzaWduYXR1cmUnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBib2R5O1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHRhcmdldCBhZGRyZXNzIGZvciBwYXltZW50IG9mIGEgQml0R28gZmVlXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBnZXRCaXRHb0ZlZUFkZHJlc3MocGFyYW1zPzoge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5wb3N0KHRoaXMudXJsKCcvYmlsbGluZy9hZGRyZXNzJykpXG4gICAgICAuc2VuZCh7fSlcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gYWRkcmVzcyBvYmplY3QgKGluY2x1ZGluZyB0aGUgd2FsbGV0IGlkKSBmb3IgYSBnaXZlbiBhZGRyZXNzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmFkZHJlc3MgVGhlIGFkZHJlc3MgdG8gbG9vayB1cC5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGdldFdhbGxldEFkZHJlc3MoeyBhZGRyZXNzIH06IHsgYWRkcmVzczogc3RyaW5nIH0sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQodGhpcy51cmwoYC93YWxsZXRhZGRyZXNzLyR7YWRkcmVzc31gKSlcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGxpc3Qgb2YgdXNlciB3ZWJob29rc1xuICAgKlxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMgeyp9XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBsaXN0V2ViaG9va3MoY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybCgnL3dlYmhvb2tzJykpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgbmV3IHVzZXIgd2ViaG9va1xuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGFkZFdlYmhvb2socGFyYW1zOiBXZWJob29rT3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMudXJsKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBzdHJpbmcgdXJsJyk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy50eXBlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBzdHJpbmcgdHlwZScpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBvc3QodGhpcy51cmwoJy93ZWJob29rcycpKVxuICAgICAgLnNlbmQocGFyYW1zKVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHVzZXIgd2ViaG9va1xuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHJlbW92ZVdlYmhvb2socGFyYW1zOiBXZWJob29rT3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnVybCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgc3RyaW5nIHVybCcpO1xuICAgIH1cblxuICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMudHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgc3RyaW5nIHR5cGUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kZWwodGhpcy51cmwoJy93ZWJob29rcycpKVxuICAgICAgLnNlbmQocGFyYW1zKVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggbGlzdCBvZiB3ZWJob29rIG5vdGlmaWNhdGlvbnMgZm9yIHRoZSB1c2VyXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgbGlzdFdlYmhvb2tOb3RpZmljYXRpb25zKHBhcmFtczogTGlzdFdlYmhvb2tOb3RpZmljYXRpb25zT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3QgcXVlcnk6IGFueSA9IHt9O1xuICAgIGlmIChwYXJhbXMucHJldklkKSB7XG4gICAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnByZXZJZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHByZXZJZCBhcmd1bWVudCwgZXhwZWN0aW5nIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgcXVlcnkucHJldklkID0gcGFyYW1zLnByZXZJZDtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5saW1pdCkge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy5saW1pdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGxpbWl0IGFyZ3VtZW50LCBleHBlY3RpbmcgbnVtYmVyJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5saW1pdCA9IHBhcmFtcy5saW1pdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nZXQodGhpcy51cmwoJy93ZWJob29rcy9ub3RpZmljYXRpb25zJykpXG4gICAgICAucXVlcnkocXVlcnkpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW11bGF0ZSBhIHVzZXIgd2ViaG9va1xuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHNpbXVsYXRlV2ViaG9vayhwYXJhbXM6IEJpdEdvU2ltdWxhdGVXZWJob29rT3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnd2ViaG9va0lkJywgJ2Jsb2NrSWQnXSwgW10sIGNhbGxiYWNrKTtcbiAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLndlYmhvb2tJZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgc3RyaW5nIHdlYmhvb2tJZCcpO1xuICAgIH1cblxuICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMuYmxvY2tJZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgc3RyaW5nIGJsb2NrSWQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wb3N0KHRoaXMudXJsKGAvd2ViaG9va3MvJHtwYXJhbXMud2ViaG9va0lkfS9zaW11bGF0ZWApKVxuICAgICAgLnNlbmQocGFyYW1zKVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogUmVjZWl2ZXMgYSBUVEwgYW5kIHJlZmV0Y2hlcyBhcyBuZWNlc3NhcnlcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGZldGNoQ29uc3RhbnRzKHBhcmFtcz86IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uICooKSB7XG4gICAgICBjb25zdCBlbnYgPSBzZWxmLmdldEVudigpO1xuXG4gICAgICBpZiAoIUJpdEdvLl9jb25zdGFudHMpIHtcbiAgICAgICAgQml0R28uX2NvbnN0YW50cyA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKCFCaXRHby5fY29uc3RhbnRzRXhwaXJlKSB7XG4gICAgICAgIEJpdEdvLl9jb25zdGFudHNFeHBpcmUgPSB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKEJpdEdvLl9jb25zdGFudHNbZW52XSAmJiBCaXRHby5fY29uc3RhbnRzRXhwaXJlW2Vudl0gJiYgbmV3IERhdGUoKSA8IEJpdEdvLl9jb25zdGFudHNFeHBpcmVbZW52XSkge1xuICAgICAgICByZXR1cm4gQml0R28uX2NvbnN0YW50c1tlbnZdO1xuICAgICAgfVxuXG4gICAgICAvLyBjbGllbnQgY29uc3RhbnRzIGNhbGwgY2Fubm90IGJlIGF1dGhlbnRpY2F0ZWQgdXNpbmcgdGhlIG5vcm1hbCBITUFDIHZhbGlkYXRpb25cbiAgICAgIC8vIHNjaGVtZSwgc28gd2UgbmVlZCB0byB1c2UgYSByYXcgc3VwZXJhZ2VudCBpbnN0YW5jZSB0byBkbyB0aGlzIHJlcXVlc3QuXG4gICAgICAvLyBQcm94eSBzZXR0aW5ncyBtdXN0IHN0aWxsIGJlIHJlc3BlY3RlZCBob3dldmVyXG4gICAgICBjb25zdCByZXN1bHRQcm9taXNlID0gc3VwZXJhZ2VudC5nZXQoc2VsZi51cmwoJy9jbGllbnQvY29uc3RhbnRzJykpO1xuICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgKHNlbGYuX3Byb3h5ID8gcmVzdWx0UHJvbWlzZS5wcm94eShzZWxmLl9wcm94eSkgOiByZXN1bHRQcm9taXNlKTtcbiAgICAgIEJpdEdvLl9jb25zdGFudHNbZW52XSA9IHJlc3VsdC5ib2R5LmNvbnN0YW50cztcblxuICAgICAgQml0R28uX2NvbnN0YW50c0V4cGlyZVtlbnZdID0gbW9tZW50LnV0YygpLmFkZChyZXN1bHQuYm9keS50dGwsICdzZWNvbmQnKS50b0RhdGUoKTtcbiAgICAgIHJldHVybiBCaXRHby5fY29uc3RhbnRzW2Vudl07XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTeW5jaHJvbm91c2x5IGdldCBjb25zdGFudHMgd2hpY2ggYXJlIHJlbGV2YW50IHRvIHRoZSBjbGllbnQuXG4gICAqXG4gICAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaGFzIGEga25vd24gcmFjZSBjb25kaXRpb24uIEl0IG1heSByZXR1cm4gZGlmZmVyZW50IHZhbHVlcyBvdmVyIHRpbWUsXG4gICAqIGVzcGVjaWFsbHkgaWYgY2FsbGVkIHNob3J0bHkgYWZ0ZXIgY3JlYXRpb24gb2YgdGhlIEJpdEdvIG9iamVjdC5cbiAgICpcbiAgICogTmV3IGNvZGUgc2hvdWxkIGNhbGwgZmV0Y2hDb25zdGFudHMoKSBkaXJlY3RseSBpbnN0ZWFkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNsaWVudCBjb25zdGFudHMgb2JqZWN0XG4gICAqL1xuICBnZXRDb25zdGFudHMocGFyYW1zPzoge30pIHtcbiAgICAvLyBraWNrIG9mZiBhIGZyZXNoIHJlcXVlc3QgZm9yIHRoZSBjbGllbnQgY29uc3RhbnRzXG4gICAgdGhpcy5mZXRjaENvbnN0YW50cyhwYXJhbXMsIGZ1bmN0aW9uKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICAvLyBtYWtlIHN1cmUgYW4gZXJyb3IgZG9lcyBub3QgdGVybWluYXRlIHRoZSBlbnRpcmUgc2NyaXB0XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2ZhaWxlZCB0byBmZXRjaCBjbGllbnQgY29uc3RhbnRzIGZyb20gQml0R28nKTtcbiAgICAgICAgY29uc29sZS50cmFjZShlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gdXNlIGRlZmF1bHRDb25zdGFudHMgYXMgdGhlIGJhY2t1cCBmb3Iga2V5cyB0aGF0IGFyZSBub3Qgc2V0IGluIHRoaXMuX2NvbnN0YW50c1xuICAgIHJldHVybiBfLm1lcmdlKHt9LCBjb25maWcuZGVmYXVsdENvbnN0YW50cyh0aGlzLmdldEVudigpKSwgQml0R28uX2NvbnN0YW50c1t0aGlzLmdldEVudigpXSk7XG4gIH1cblxuICAvKipcbiAgICogVjEgbWV0aG9kIGZvciBjYWxjdWxhdGluZyBtaW5lciBmZWUgYW1vdW50cywgZ2l2ZW4gdGhlIG51bWJlciBhbmRcbiAgICogdHlwZSBvZiB0cmFuc2FjdGlvbiBpbnB1dHMsIGFsb25nIHdpdGggYSBmZWUgcmF0ZSBpbiBzYXRvc2hpcyBwZXIgdmtCLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQgZm9yIG5ldyBjb2RlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICBjYWxjdWxhdGVNaW5lckZlZUluZm8ocGFyYW1zOiBhbnksIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICByZXR1cm4gY28oZnVuY3Rpb24gKigpIHtcbiAgICAgIHJldHVybiBUcmFuc2FjdGlvbkJ1aWxkZXIuY2FsY3VsYXRlTWluZXJGZWVJbmZvKHBhcmFtcyk7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYSByZXF1ZXN0IHRyYWNlciB0byBwcm92aWRlIHJlcXVlc3QgSURzIGR1cmluZyBtdWx0aS1yZXF1ZXN0IHdvcmtmbG93c1xuICAgKi9cbiAgc2V0UmVxdWVzdFRyYWNlcihyZXFUcmFjZXI6IElSZXF1ZXN0VHJhY2VyKSB7XG4gICAgaWYgKHJlcVRyYWNlcikge1xuICAgICAgdGhpcy5fcmVxSWQgPSByZXFUcmFjZXI7XG4gICAgfVxuICB9XG59XG4iXX0=