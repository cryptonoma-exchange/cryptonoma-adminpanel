"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @prettier
 */
var Bluebird = require("bluebird");
var crypto = require("crypto");
var co = Bluebird.coroutine;
var bitgoAccountLib = require("@bitgo/account-lib");
var bitgo_utxo_lib_1 = require("bitgo-utxo-lib");
var request = require("superagent");
var common = require("../../common");
var baseCoin_1 = require("../baseCoin");
exports.MINIMUM_TRON_MSIG_TRANSACTION_FEE = 1e6;
var NodeTypes;
(function (NodeTypes) {
    NodeTypes[NodeTypes["Full"] = 0] = "Full";
    NodeTypes[NodeTypes["Solidity"] = 1] = "Solidity";
})(NodeTypes = exports.NodeTypes || (exports.NodeTypes = {}));
var Trx = /** @class */ (function (_super) {
    __extends(Trx, _super);
    function Trx(bitgo, staticsCoin) {
        var _this = _super.call(this, bitgo) || this;
        if (!staticsCoin) {
            throw new Error('missing required constructor parameter staticsCoin');
        }
        _this._staticsCoin = staticsCoin;
        return _this;
    }
    Trx.prototype.getChain = function () {
        return this._staticsCoin.name;
    };
    Trx.prototype.getFamily = function () {
        return this._staticsCoin.family;
    };
    Trx.prototype.getFullName = function () {
        return this._staticsCoin.fullName;
    };
    Trx.prototype.getBaseFactor = function () {
        return Math.pow(10, this._staticsCoin.decimalPlaces);
    };
    Trx.createInstance = function (bitgo, staticsCoin) {
        return new Trx(bitgo, staticsCoin);
    };
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    Trx.prototype.valuelessTransferAllowed = function () {
        return true;
    };
    /**
     * Checks if this is a valid base58 or hex address
     * @param address
     */
    Trx.prototype.isValidAddress = function (address) {
        if (!address) {
            return false;
        }
        return this.isValidHexAddress(address) || bitgoAccountLib.Trx.Utils.isBase58Address(address);
    };
    /**
     * Checks if this is a valid hex address
     * @param address hex address
     */
    Trx.prototype.isValidHexAddress = function (address) {
        return address.length === 42 && /^(0x)?([0-9a-f]{2})+$/i.test(address);
    };
    /**
     * Generate ed25519 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub, prv
     */
    Trx.prototype.generateKeyPair = function (seed) {
        // TODO: move this and address creation logic to account-lib
        if (!seed) {
            // An extended private key has both a normal 256 bit private key and a 256 bit chain code, both of which must be
            // random. 512 bits is therefore the maximum entropy and gives us maximum security against cracking.
            seed = crypto.randomBytes(512 / 8);
        }
        var hd = bitgo_utxo_lib_1.HDNode.fromSeedBuffer(seed);
        return {
            pub: hd.neutered().toBase58(),
            prv: hd.toBase58(),
        };
    };
    Trx.prototype.isValidXpub = function (xpub) {
        try {
            return bitgo_utxo_lib_1.HDNode.fromBase58(xpub).isNeutered();
        }
        catch (e) {
            return false;
        }
    };
    Trx.prototype.isValidPub = function (pub) {
        if (this.isValidXpub(pub)) {
            // xpubs can be converted into regular pubs, so technically it is a valid pub
            return true;
        }
        return new RegExp('^04[a-zA-Z0-9]{128}$').test(pub);
    };
    Trx.prototype.parseTransaction = function (params, callback) {
        return Bluebird.resolve({}).asCallback(callback);
    };
    Trx.prototype.verifyAddress = function (params) {
        return true;
    };
    Trx.prototype.verifyTransaction = function (params, callback) {
        return Bluebird.resolve(true).asCallback(callback);
    };
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {Object} prebuild object returned by platform
     * @param params.prv {String} user prv
     * @param params.wallet.addressVersion {String} this is the version of the Algorand multisig address generation format
     * @param callback
     * @returns Bluebird<SignedTransaction>
     */
    Trx.prototype.signTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            var txBuilder, transaction, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        txBuilder = bitgoAccountLib.getBuilder(self.getChain());
                        txBuilder.from(params.txPrebuild.txHex);
                        txBuilder.sign({ key: params.prv });
                        return [4 /*yield*/, txBuilder.build()];
                    case 1:
                        transaction = _a.sent();
                        response = {
                            txHex: JSON.stringify(transaction.toJson()),
                        };
                        if (transaction.toJson().signature.length >= 2) {
                            return [2 /*return*/, response];
                        }
                        // Half signed transaction
                        return [2 /*return*/, {
                                halfSigned: response,
                            }];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Return boolean indicating whether input is valid seed for the coin
     *
     * @param prv - the prv to be checked
     */
    Trx.prototype.isValidXprv = function (prv) {
        try {
            bitgo_utxo_lib_1.HDNode.fromBase58(prv);
            return true;
        }
        catch (e) {
            return false;
        }
    };
    /**
     * Convert a message to string in hexadecimal format.
     *
     * @param message {Buffer|String} message to sign
     * @return the message as a hexadecimal string
     */
    Trx.prototype.toHexString = function (message) {
        if (typeof message === 'string') {
            return Buffer.from(message).toString('hex');
        }
        else if (Buffer.isBuffer(message)) {
            return message.toString('hex');
        }
        else {
            throw new Error('Invalid messaged passed to signMessage');
        }
    };
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     * @param callback
     */
    Trx.prototype.signMessage = function (key, message, callback) {
        var self = this;
        return co(function cosignMessage() {
            var toSign, prv, sig;
            return __generator(this, function (_a) {
                toSign = self.toHexString(message);
                prv = key.prv;
                if (self.isValidXprv(prv)) {
                    prv = bitgo_utxo_lib_1.HDNode.fromBase58(prv)
                        .getKey()
                        .getPrivateKeyBuffer();
                }
                sig = bitgoAccountLib.Trx.Utils.signString(toSign, prv, true);
                // remove the preceding 0x
                sig = sig.replace(/^0x/, '');
                return [2 /*return*/, Buffer.from(sig, 'hex')];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Converts an xpub to a compressed pub
     * @param xpub
     */
    Trx.prototype.xpubToCompressedPub = function (xpub) {
        if (!this.isValidXpub(xpub)) {
            throw new Error('invalid xpub');
        }
        var hdNode = bitgo_utxo_lib_1.HDNode.fromBase58(xpub, bitgo_utxo_lib_1.networks.bitcoin);
        return hdNode.keyPair.__Q.getEncoded(false).toString('hex');
    };
    Trx.prototype.compressedPubToHexAddress = function (pub) {
        var byteArrayAddr = bitgoAccountLib.Trx.Utils.getByteArrayFromHexAddress(pub);
        var rawAddress = bitgoAccountLib.Trx.Utils.getRawAddressFromPubKey(byteArrayAddr);
        return bitgoAccountLib.Trx.Utils.getHexAddressFromByteArray(rawAddress);
    };
    Trx.prototype.xprvToCompressedPrv = function (xprv) {
        if (!this.isValidXprv(xprv)) {
            throw new Error('invalid xprv');
        }
        var hdNode = bitgo_utxo_lib_1.HDNode.fromBase58(xprv, bitgo_utxo_lib_1.networks.bitcoin);
        return hdNode.keyPair.d.toBuffer(32).toString('hex');
    };
    /**
     * Make a query to Trongrid for information such as balance, token balance, solidity calls
     * @param query {Object} key-value pairs of parameters to append after /api
     * @param callback
     * @returns {Object} response from Trongrid
     */
    Trx.prototype.recoveryPost = function (query, callback) {
        var self = this;
        return co(function () {
            var nodeUri, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        nodeUri = '';
                        switch (query.node) {
                            case NodeTypes.Full:
                                nodeUri = common.Environments[self.bitgo.getEnv()].tronNodes.full;
                                break;
                            case NodeTypes.Solidity:
                                nodeUri = common.Environments[self.bitgo.getEnv()].tronNodes.solidity;
                                break;
                            default:
                                throw new Error('node type not found');
                        }
                        return [4 /*yield*/, request
                                .post(nodeUri + query.path)
                                .type('json')
                                .send(query.jsonObj)];
                    case 1:
                        response = _a.sent();
                        if (!response.ok) {
                            throw new Error('could not reach Tron node');
                        }
                        // unfortunately, it doesn't look like most TRON nodes return valid json as body
                        return [2 /*return*/, JSON.parse(response.text)];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Query our explorer for the balance of an address
     * @param address {String} the address encoded in hex
     * @param callback
     * @returns {BigNumber} address balance
     */
    Trx.prototype.getAccountFromNode = function (address, callback) {
        var self = this;
        return co(function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, self.recoveryPost({
                            path: '/walletsolidity/getaccount',
                            jsonObj: { address: address },
                            node: NodeTypes.Solidity,
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Retrieves our build transaction from a node.
     * @param toAddr hex-encoded address
     * @param fromAddr hex-encoded address
     * @param amount
     * @param callback
     */
    Trx.prototype.getBuildTransaction = function (toAddr, fromAddr, amount, callback) {
        var self = this;
        return co(function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, self.recoveryPost({
                            path: '/wallet/createtransaction',
                            jsonObj: {
                                to_address: toAddr,
                                owner_address: fromAddr,
                                amount: amount,
                            },
                            node: NodeTypes.Full,
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Throws an error if any keys in the ownerKeys collection don't match the keys array we pass
     * @param ownerKeys
     * @param keysToFind
     */
    Trx.prototype.checkPermissions = function (ownerKeys, keys) {
        keys = keys.map(function (k) { return k.toUpperCase(); });
        ownerKeys.map(function (key) {
            var hexKey = key.address.toUpperCase();
            if (!keys.includes(hexKey)) {
                throw new Error("pub address " + hexKey + " not found in account");
            }
            if (key.weight !== 1) {
                throw new Error('owner permission is invalid for this structure');
            }
        });
    };
    /**
     * Builds a funds recovery transaction without BitGo.
     * We need to do three queries during this:
     * 1) Node query - how much money is in the account
     * 2) Build transaction - build our transaction for the amount
     * 3) Send signed build - send our signed build to a public node
     * @param params
     * @param callback
     */
    Trx.prototype.recover = function (params, callback) {
        var self = this;
        return co(function () {
            var isKrsRecovery, isUnsignedSweep, keys, bitgoHexAddr, recoveryAddressHex, account, recoveryAmount, userXPub, userXPrv, backupXPub, recoveryAmountMinusFees, buildTx, keyHexAddresses, txBuilder, _a, userPrv, backupXPrv, backupPrv, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        isKrsRecovery = params.backupKey.startsWith('xpub') && !params.userKey.startsWith('xpub');
                        isUnsignedSweep = params.backupKey.startsWith('xpub') && params.userKey.startsWith('xpub');
                        return [4 /*yield*/, self.initiateRecovery(params)];
                    case 1:
                        keys = _c.sent();
                        bitgoHexAddr = self.compressedPubToHexAddress(self.xpubToCompressedPub(params.bitgoKey));
                        recoveryAddressHex = bitgoAccountLib.Trx.Utils.getHexAddressFromBase58Address(params.recoveryDestination);
                        return [4 /*yield*/, self.getAccountFromNode(bitgoHexAddr)];
                    case 2:
                        account = _c.sent();
                        recoveryAmount = account.balance;
                        userXPub = keys[0].neutered().toBase58();
                        userXPrv = keys[0].toBase58();
                        backupXPub = keys[1].neutered().toBase58();
                        // construct the tx -
                        // there's an assumption here being made about fees: for a wallet that hasn't been used in awhile, the implication is
                        // it has maximum bandwidth. thus, a recovery should cost the minimum amount (1e6 sun or 1 Tron)
                        if (exports.MINIMUM_TRON_MSIG_TRANSACTION_FEE > recoveryAmount) {
                            throw new Error('Amount of funds to recover wouldnt be able to fund a send');
                        }
                        recoveryAmountMinusFees = recoveryAmount - exports.MINIMUM_TRON_MSIG_TRANSACTION_FEE;
                        return [4 /*yield*/, self.getBuildTransaction(recoveryAddressHex, bitgoHexAddr, recoveryAmountMinusFees)];
                    case 3:
                        buildTx = _c.sent();
                        keyHexAddresses = [
                            self.compressedPubToHexAddress(self.xpubToCompressedPub(userXPub)),
                            self.compressedPubToHexAddress(self.xpubToCompressedPub(backupXPub)),
                            bitgoHexAddr,
                        ];
                        // run checks to ensure this is a valid tx - permissions match our signer keys
                        self.checkPermissions(account.owner_permission.keys, keyHexAddresses);
                        self.checkPermissions(account.active_permission[0].keys, keyHexAddresses);
                        txBuilder = bitgoAccountLib.getBuilder(self.getChain());
                        txBuilder.from(buildTx);
                        if (!isUnsignedSweep) return [3 /*break*/, 5];
                        _a = {};
                        return [4 /*yield*/, txBuilder.build()];
                    case 4: return [2 /*return*/, (_a.tx = (_c.sent()).toJson(),
                            _a.recoveryAmount = recoveryAmountMinusFees,
                            _a)];
                    case 5:
                        userPrv = self.xprvToCompressedPrv(userXPrv);
                        txBuilder.sign({ key: userPrv });
                        // krs recoveries don't get signed
                        if (!isKrsRecovery) {
                            backupXPrv = keys[1].toBase58();
                            backupPrv = self.xprvToCompressedPrv(backupXPrv);
                            txBuilder.sign({ key: backupPrv });
                        }
                        _b = {};
                        return [4 /*yield*/, txBuilder.build()];
                    case 6: return [2 /*return*/, (_b.tx = (_c.sent()).toJson(),
                            _b.recoveryAmount = recoveryAmountMinusFees,
                            _b)];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Explain a Tron transaction from txHex
     * @param params
     * @param callback
     */
    Trx.prototype.explainTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            var txHex, txBuilder, tx, outputs, displayOrder, explanationResult;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        txHex = params.txHex || (params.halfSigned && params.halfSigned.txHex);
                        if (!txHex || !params.feeInfo) {
                            throw new Error('missing explain tx parameters');
                        }
                        txBuilder = bitgoAccountLib.getBuilder(self.getChain());
                        txBuilder.from(txHex);
                        return [4 /*yield*/, txBuilder.build()];
                    case 1:
                        tx = _a.sent();
                        outputs = [
                            {
                                amount: tx.outputs[0].value.toString(),
                                address: tx.outputs[0].address,
                            },
                        ];
                        displayOrder = [
                            'id',
                            'outputAmount',
                            'changeAmount',
                            'outputs',
                            'changeOutputs',
                            'fee',
                            'timestamp',
                            'expiration',
                        ];
                        explanationResult = {
                            displayOrder: displayOrder,
                            id: tx.id,
                            outputs: outputs,
                            outputAmount: outputs[0].amount,
                            changeOutputs: [],
                            changeAmount: '0',
                            fee: params.feeInfo,
                            timestamp: tx.validFrom,
                            expiration: tx.validTo,
                        };
                        return [2 /*return*/, explanationResult];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    return Trx;
}(baseCoin_1.BaseCoin));
exports.Trx = Trx;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJ4LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3YyL2NvaW5zL3RyeC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7R0FFRztBQUNILG1DQUFxQztBQUNyQywrQkFBaUM7QUFFakMsSUFBTSxFQUFFLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQztBQUM5QixvREFBc0Q7QUFDdEQsaURBQWtEO0FBQ2xELG9DQUFzQztBQUN0QyxxQ0FBdUM7QUFFdkMsd0NBYXFCO0FBS1IsUUFBQSxpQ0FBaUMsR0FBRyxHQUFHLENBQUM7QUE4Q3JELElBQVksU0FHWDtBQUhELFdBQVksU0FBUztJQUNuQix5Q0FBSSxDQUFBO0lBQ0osaURBQVEsQ0FBQTtBQUNWLENBQUMsRUFIVyxTQUFTLEdBQVQsaUJBQVMsS0FBVCxpQkFBUyxRQUdwQjtBQWNEO0lBQXlCLHVCQUFRO0lBRy9CLGFBQVksS0FBWSxFQUFFLFdBQXVDO1FBQWpFLFlBQ0Usa0JBQU0sS0FBSyxDQUFDLFNBT2I7UUFMQyxJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ2hCLE1BQU0sSUFBSSxLQUFLLENBQUMsb0RBQW9ELENBQUMsQ0FBQztTQUN2RTtRQUVELEtBQUksQ0FBQyxZQUFZLEdBQUcsV0FBVyxDQUFDOztJQUNsQyxDQUFDO0lBRUQsc0JBQVEsR0FBUjtRQUNFLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUM7SUFDaEMsQ0FBQztJQUVELHVCQUFTLEdBQVQ7UUFDRSxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDO0lBQ2xDLENBQUM7SUFFRCx5QkFBVyxHQUFYO1FBQ0UsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQztJQUNwQyxDQUFDO0lBRUQsMkJBQWEsR0FBYjtRQUNFLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsSUFB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QztJQUNILFVBQUM7QUFBRCxDQUFDLEFBaGVELENBQXlCLG1CQUFRLEdBZ2VoQztBQWhlWSxrQkFBRyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByZXR0aWVyXG4gKi9cbmltcG9ydCAqIGFzIEJsdWViaXJkIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCAqIGFzIGNyeXB0byBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHsgQ29pbkZhbWlseSwgQmFzZUNvaW4gYXMgU3RhdGljc0Jhc2VDb2luIH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MnO1xuY29uc3QgY28gPSBCbHVlYmlyZC5jb3JvdXRpbmU7XG5pbXBvcnQgKiBhcyBiaXRnb0FjY291bnRMaWIgZnJvbSAnQGJpdGdvL2FjY291bnQtbGliJztcbmltcG9ydCB7IEhETm9kZSwgbmV0d29ya3MgfSBmcm9tICdiaXRnby11dHhvLWxpYic7XG5pbXBvcnQgKiBhcyByZXF1ZXN0IGZyb20gJ3N1cGVyYWdlbnQnO1xuaW1wb3J0ICogYXMgY29tbW9uIGZyb20gJy4uLy4uL2NvbW1vbic7XG5cbmltcG9ydCB7XG4gIEJhc2VDb2luLFxuICBLZXlQYWlyLFxuICBQYXJzZWRUcmFuc2FjdGlvbixcbiAgUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFNpZ25lZFRyYW5zYWN0aW9uLFxuICBTaWduVHJhbnNhY3Rpb25PcHRpb25zLFxuICBWZXJpZnlBZGRyZXNzT3B0aW9ucyxcbiAgVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLFxuICBUcmFuc2FjdGlvbkZlZSxcbiAgVHJhbnNhY3Rpb25SZWNpcGllbnQgYXMgUmVjaXBpZW50LFxuICBUcmFuc2FjdGlvblByZWJ1aWxkIGFzIEJhc2VUcmFuc2FjdGlvblByZWJ1aWxkLFxuICBUcmFuc2FjdGlvbkV4cGxhbmF0aW9uLFxufSBmcm9tICcuLi9iYXNlQ29pbic7XG5cbmltcG9ydCB7IEJpdEdvIH0gZnJvbSAnLi4vLi4vYml0Z28nO1xuaW1wb3J0IHsgTm9kZUNhbGxiYWNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgTUlOSU1VTV9UUk9OX01TSUdfVFJBTlNBQ1RJT05fRkVFID0gMWU2O1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyb25TaWduVHJhbnNhY3Rpb25PcHRpb25zIGV4dGVuZHMgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4UHJlYnVpbGQ6IFRyYW5zYWN0aW9uUHJlYnVpbGQ7XG4gIHBydjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFR4SW5mbyB7XG4gIHJlY2lwaWVudHM6IFJlY2lwaWVudFtdO1xuICBmcm9tOiBzdHJpbmc7XG4gIHR4aWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcm9uVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiBleHRlbmRzIFRyYW5zYWN0aW9uRXhwbGFuYXRpb24ge1xuICBleHBpcmF0aW9uOiBudW1iZXI7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zYWN0aW9uUHJlYnVpbGQgZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25QcmVidWlsZCB7XG4gIHR4SGV4OiBzdHJpbmc7XG4gIHR4SW5mbzogVHhJbmZvO1xuICBmZWVJbmZvOiBUcmFuc2FjdGlvbkZlZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhIZXg/OiBzdHJpbmc7IC8vIHR4SGV4IGlzIHBvb3JseSBuYW1lZCBoZXJlOyBpdCBpcyBqdXN0IGEgd3JhcHBlZCBKU09OIG9iamVjdFxuICBoYWxmU2lnbmVkPzoge1xuICAgIHR4SGV4OiBzdHJpbmc7IC8vIHR4SGV4IGlzIHBvb3JseSBuYW1lZCBoZXJlOyBpdCBpcyBqdXN0IGEgd3JhcHBlZCBKU09OIG9iamVjdFxuICB9O1xuICBmZWVJbmZvOiBUcmFuc2FjdGlvbkZlZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWNvdmVyeU9wdGlvbnMge1xuICB1c2VyS2V5OiBzdHJpbmc7IC8vIEJveCBBXG4gIGJhY2t1cEtleTogc3RyaW5nOyAvLyBCb3ggQlxuICBiaXRnb0tleTogc3RyaW5nOyAvLyBCb3ggQyAtIHRoaXMgaXMgYml0Z28ncyB4cHViIGFuZCB3aWxsIGJlIHVzZWQgdG8gZGVyaXZlIHRoZWlyIHJvb3QgYWRkcmVzc1xuICByZWNvdmVyeURlc3RpbmF0aW9uOiBzdHJpbmc7IC8vIGJhc2U1OCBhZGRyZXNzXG4gIGtyc1Byb3ZpZGVyPzogc3RyaW5nO1xuICB3YWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlY292ZXJ5VHJhbnNhY3Rpb24ge1xuICB0eDogVHJhbnNhY3Rpb25QcmVidWlsZDtcbiAgcmVjb3ZlcnlBbW91bnQ6IG51bWJlcjtcbn1cblxuZXhwb3J0IGVudW0gTm9kZVR5cGVzIHtcbiAgRnVsbCxcbiAgU29saWRpdHksXG59XG5cbi8qKlxuICogVGhpcyBzdHJ1Y3R1cmUgaXMgbm90IGEgY29tcGxldGUgbW9kZWwgb2YgdGhlIEFjY291bnRSZXNwb25zZSBmcm9tIGEgbm9kZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBY2NvdW50UmVzcG9uc2Uge1xuICBhZGRyZXNzOiBzdHJpbmc7XG4gIGJhbGFuY2U6IG51bWJlcjtcbiAgb3duZXJfcGVybWlzc2lvbjoge1xuICAgIGtleXM6IFtiaXRnb0FjY291bnRMaWIuVHJ4LkludGVyZmFjZS5QZXJtaXNzaW9uS2V5XTtcbiAgfTtcbiAgYWN0aXZlX3Blcm1pc3Npb246IFt7IGtleXM6IFtiaXRnb0FjY291bnRMaWIuVHJ4LkludGVyZmFjZS5QZXJtaXNzaW9uS2V5XSB9XTtcbn1cblxuZXhwb3J0IGNsYXNzIFRyeCBleHRlbmRzIEJhc2VDb2luIHtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9zdGF0aWNzQ29pbjogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPjtcblxuICBjb25zdHJ1Y3RvcihiaXRnbzogQml0R28sIHN0YXRpY3NDb2luPzogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPikge1xuICAgIHN1cGVyKGJpdGdvKTtcblxuICAgIGlmICghc3RhdGljc0NvaW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBjb25zdHJ1Y3RvciBwYXJhbWV0ZXIgc3RhdGljc0NvaW4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zdGF0aWNzQ29pbiA9IHN0YXRpY3NDb2luO1xuICB9XG5cbiAgZ2V0Q2hhaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRpY3NDb2luLm5hbWU7XG4gIH1cblxuICBnZXRGYW1pbHkoKTogQ29pbkZhbWlseSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRpY3NDb2luLmZhbWlseTtcbiAgfVxuXG4gIGdldEZ1bGxOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0aWNzQ29pbi5mdWxsTmFtZTtcbiAgfVxuXG4gIGdldEJhc2VGYWN0b3IoKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KDEwLCB0aGlzLl9zdGF0aWNzQ29pbi5kZWNpbWFsUGxhY2VzKTtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVJbnN0YW5jZShiaXRnbzogQml0R28sIHN0YXRpY3NDb2luPzogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPik6IEJhc2VDb2luIHtcbiAgICByZXR1cm4gbmV3IFRyeChiaXRnbywgc3RhdGljc0NvaW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZsYWcgZm9yIHNlbmRpbmcgdmFsdWUgb2YgMFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBva2F5IHRvIHNlbmQgMCB2YWx1ZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICB2YWx1ZWxlc3NUcmFuc2ZlckFsbG93ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgaXMgYSB2YWxpZCBiYXNlNTggb3IgaGV4IGFkZHJlc3NcbiAgICogQHBhcmFtIGFkZHJlc3NcbiAgICovXG4gIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmICghYWRkcmVzcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkSGV4QWRkcmVzcyhhZGRyZXNzKSB8fCBiaXRnb0FjY291bnRMaWIuVHJ4LlV0aWxzLmlzQmFzZTU4QWRkcmVzcyhhZGRyZXNzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBpcyBhIHZhbGlkIGhleCBhZGRyZXNzXG4gICAqIEBwYXJhbSBhZGRyZXNzIGhleCBhZGRyZXNzXG4gICAqL1xuICBpc1ZhbGlkSGV4QWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gYWRkcmVzcy5sZW5ndGggPT09IDQyICYmIC9eKDB4KT8oWzAtOWEtZl17Mn0pKyQvaS50ZXN0KGFkZHJlc3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGVkMjU1MTkga2V5IHBhaXJcbiAgICpcbiAgICogQHBhcmFtIHNlZWRcbiAgICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IHdpdGggZ2VuZXJhdGVkIHB1YiwgcHJ2XG4gICAqL1xuICBnZW5lcmF0ZUtleVBhaXIoc2VlZD86IEJ1ZmZlcik6IEtleVBhaXIge1xuICAgIC8vIFRPRE86IG1vdmUgdGhpcyBhbmQgYWRkcmVzcyBjcmVhdGlvbiBsb2dpYyB0byBhY2NvdW50LWxpYlxuICAgIGlmICghc2VlZCkge1xuICAgICAgLy8gQW4gZXh0ZW5kZWQgcHJpdmF0ZSBrZXkgaGFzIGJvdGggYSBub3JtYWwgMjU2IGJpdCBwcml2YXRlIGtleSBhbmQgYSAyNTYgYml0IGNoYWluIGNvZGUsIGJvdGggb2Ygd2hpY2ggbXVzdCBiZVxuICAgICAgLy8gcmFuZG9tLiA1MTIgYml0cyBpcyB0aGVyZWZvcmUgdGhlIG1heGltdW0gZW50cm9weSBhbmQgZ2l2ZXMgdXMgbWF4aW11bSBzZWN1cml0eSBhZ2FpbnN0IGNyYWNraW5nLlxuICAgICAgc2VlZCA9IGNyeXB0by5yYW5kb21CeXRlcyg1MTIgLyA4KTtcbiAgICB9XG4gICAgY29uc3QgaGQgPSBIRE5vZGUuZnJvbVNlZWRCdWZmZXIoc2VlZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHB1YjogaGQubmV1dGVyZWQoKS50b0Jhc2U1OCgpLFxuICAgICAgcHJ2OiBoZC50b0Jhc2U1OCgpLFxuICAgIH07XG4gIH1cblxuICBpc1ZhbGlkWHB1Yih4cHViOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEhETm9kZS5mcm9tQmFzZTU4KHhwdWIpLmlzTmV1dGVyZWQoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaXNWYWxpZFB1YihwdWI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLmlzVmFsaWRYcHViKHB1YikpIHtcbiAgICAgIC8vIHhwdWJzIGNhbiBiZSBjb252ZXJ0ZWQgaW50byByZWd1bGFyIHB1YnMsIHNvIHRlY2huaWNhbGx5IGl0IGlzIGEgdmFsaWQgcHViXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoJ14wNFthLXpBLVowLTldezEyOH0kJykudGVzdChwdWIpO1xuICB9XG5cbiAgcGFyc2VUcmFuc2FjdGlvbihcbiAgICBwYXJhbXM6IFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zLFxuICAgIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFBhcnNlZFRyYW5zYWN0aW9uPlxuICApOiBCbHVlYmlyZDxQYXJzZWRUcmFuc2FjdGlvbj4ge1xuICAgIHJldHVybiBCbHVlYmlyZC5yZXNvbHZlKHt9KS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZlcmlmeUFkZHJlc3MocGFyYW1zOiBWZXJpZnlBZGRyZXNzT3B0aW9ucyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmVyaWZ5VHJhbnNhY3Rpb24ocGFyYW1zOiBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGJvb2xlYW4+KTogQmx1ZWJpcmQ8Ym9vbGVhbj4ge1xuICAgIHJldHVybiBCbHVlYmlyZC5yZXNvbHZlKHRydWUpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc2VtYmxlIGtleWNoYWluIGFuZCBoYWxmLXNpZ24gcHJlYnVpbHQgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLnR4UHJlYnVpbGQge09iamVjdH0gcHJlYnVpbGQgb2JqZWN0IHJldHVybmVkIGJ5IHBsYXRmb3JtXG4gICAqIEBwYXJhbSBwYXJhbXMucHJ2IHtTdHJpbmd9IHVzZXIgcHJ2XG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0LmFkZHJlc3NWZXJzaW9uIHtTdHJpbmd9IHRoaXMgaXMgdGhlIHZlcnNpb24gb2YgdGhlIEFsZ29yYW5kIG11bHRpc2lnIGFkZHJlc3MgZ2VuZXJhdGlvbiBmb3JtYXRcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIEJsdWViaXJkPFNpZ25lZFRyYW5zYWN0aW9uPlxuICAgKi9cbiAgc2lnblRyYW5zYWN0aW9uKFxuICAgIHBhcmFtczogVHJvblNpZ25UcmFuc2FjdGlvbk9wdGlvbnMsXG4gICAgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8U2lnbmVkVHJhbnNhY3Rpb24+XG4gICk6IEJsdWViaXJkPFNpZ25lZFRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPFNpZ25lZFRyYW5zYWN0aW9uPihmdW5jdGlvbiooKSB7XG4gICAgICBjb25zdCB0eEJ1aWxkZXIgPSBiaXRnb0FjY291bnRMaWIuZ2V0QnVpbGRlcihzZWxmLmdldENoYWluKCkpO1xuICAgICAgdHhCdWlsZGVyLmZyb20ocGFyYW1zLnR4UHJlYnVpbGQudHhIZXgpO1xuICAgICAgdHhCdWlsZGVyLnNpZ24oeyBrZXk6IHBhcmFtcy5wcnYgfSk7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHlpZWxkIHR4QnVpbGRlci5idWlsZCgpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAgIHR4SGV4OiBKU09OLnN0cmluZ2lmeSh0cmFuc2FjdGlvbi50b0pzb24oKSksXG4gICAgICB9O1xuICAgICAgaWYgKHRyYW5zYWN0aW9uLnRvSnNvbigpLnNpZ25hdHVyZS5sZW5ndGggPj0gMikge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICB9XG4gICAgICAvLyBIYWxmIHNpZ25lZCB0cmFuc2FjdGlvblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGFsZlNpZ25lZDogcmVzcG9uc2UsXG4gICAgICB9O1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBzZWVkIGZvciB0aGUgY29pblxuICAgKlxuICAgKiBAcGFyYW0gcHJ2IC0gdGhlIHBydiB0byBiZSBjaGVja2VkXG4gICAqL1xuICBpc1ZhbGlkWHBydihwcnY6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICBIRE5vZGUuZnJvbUJhc2U1OChwcnYpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgbWVzc2FnZSB0byBzdHJpbmcgaW4gaGV4YWRlY2ltYWwgZm9ybWF0LlxuICAgKlxuICAgKiBAcGFyYW0gbWVzc2FnZSB7QnVmZmVyfFN0cmluZ30gbWVzc2FnZSB0byBzaWduXG4gICAqIEByZXR1cm4gdGhlIG1lc3NhZ2UgYXMgYSBoZXhhZGVjaW1hbCBzdHJpbmdcbiAgICovXG4gIHRvSGV4U3RyaW5nKG1lc3NhZ2U6IHN0cmluZyB8IEJ1ZmZlcik6IHN0cmluZyB7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKG1lc3NhZ2UpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihtZXNzYWdlKSkge1xuICAgICAgcmV0dXJuIG1lc3NhZ2UudG9TdHJpbmcoJ2hleCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWVzc2FnZWQgcGFzc2VkIHRvIHNpZ25NZXNzYWdlJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gbWVzc2FnZSB3aXRoIHByaXZhdGUga2V5XG4gICAqXG4gICAqIEBwYXJhbSBrZXlcbiAgICogQHBhcmFtIG1lc3NhZ2VcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBzaWduTWVzc2FnZShrZXk6IEtleVBhaXIsIG1lc3NhZ2U6IHN0cmluZyB8IEJ1ZmZlciwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8QnVmZmVyPik6IEJsdWViaXJkPEJ1ZmZlcj4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxCdWZmZXI+KGZ1bmN0aW9uKiBjb3NpZ25NZXNzYWdlKCkge1xuICAgICAgY29uc3QgdG9TaWduID0gc2VsZi50b0hleFN0cmluZyhtZXNzYWdlKTtcblxuICAgICAgbGV0IHBydiA9IGtleS5wcnY7XG4gICAgICBpZiAoc2VsZi5pc1ZhbGlkWHBydihwcnYpKSB7XG4gICAgICAgIHBydiA9IEhETm9kZS5mcm9tQmFzZTU4KHBydilcbiAgICAgICAgICAuZ2V0S2V5KClcbiAgICAgICAgICAuZ2V0UHJpdmF0ZUtleUJ1ZmZlcigpO1xuICAgICAgfVxuXG4gICAgICBsZXQgc2lnID0gYml0Z29BY2NvdW50TGliLlRyeC5VdGlscy5zaWduU3RyaW5nKHRvU2lnbiwgcHJ2LCB0cnVlKTtcblxuICAgICAgLy8gcmVtb3ZlIHRoZSBwcmVjZWRpbmcgMHhcbiAgICAgIHNpZyA9IHNpZy5yZXBsYWNlKC9eMHgvLCAnJyk7XG5cbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzaWcsICdoZXgnKTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiB4cHViIHRvIGEgY29tcHJlc3NlZCBwdWJcbiAgICogQHBhcmFtIHhwdWJcbiAgICovXG4gIHhwdWJUb0NvbXByZXNzZWRQdWIoeHB1Yjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZFhwdWIoeHB1YikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB4cHViJyk7XG4gICAgfVxuXG4gICAgY29uc3QgaGROb2RlID0gSEROb2RlLmZyb21CYXNlNTgoeHB1YiwgbmV0d29ya3MuYml0Y29pbik7XG4gICAgcmV0dXJuIGhkTm9kZS5rZXlQYWlyLl9fUS5nZXRFbmNvZGVkKGZhbHNlKS50b1N0cmluZygnaGV4Jyk7XG4gIH1cblxuICBjb21wcmVzc2VkUHViVG9IZXhBZGRyZXNzKHB1Yjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBieXRlQXJyYXlBZGRyID0gYml0Z29BY2NvdW50TGliLlRyeC5VdGlscy5nZXRCeXRlQXJyYXlGcm9tSGV4QWRkcmVzcyhwdWIpO1xuICAgIGNvbnN0IHJhd0FkZHJlc3MgPSBiaXRnb0FjY291bnRMaWIuVHJ4LlV0aWxzLmdldFJhd0FkZHJlc3NGcm9tUHViS2V5KGJ5dGVBcnJheUFkZHIpO1xuICAgIHJldHVybiBiaXRnb0FjY291bnRMaWIuVHJ4LlV0aWxzLmdldEhleEFkZHJlc3NGcm9tQnl0ZUFycmF5KHJhd0FkZHJlc3MpO1xuICB9XG5cbiAgeHBydlRvQ29tcHJlc3NlZFBydih4cHJ2OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkWHBydih4cHJ2KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHhwcnYnKTtcbiAgICB9XG5cbiAgICBjb25zdCBoZE5vZGUgPSBIRE5vZGUuZnJvbUJhc2U1OCh4cHJ2LCBuZXR3b3Jrcy5iaXRjb2luKTtcbiAgICByZXR1cm4gaGROb2RlLmtleVBhaXIuZC50b0J1ZmZlcigzMikudG9TdHJpbmcoJ2hleCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBxdWVyeSB0byBUcm9uZ3JpZCBmb3IgaW5mb3JtYXRpb24gc3VjaCBhcyBiYWxhbmNlLCB0b2tlbiBiYWxhbmNlLCBzb2xpZGl0eSBjYWxsc1xuICAgKiBAcGFyYW0gcXVlcnkge09iamVjdH0ga2V5LXZhbHVlIHBhaXJzIG9mIHBhcmFtZXRlcnMgdG8gYXBwZW5kIGFmdGVyIC9hcGlcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IHJlc3BvbnNlIGZyb20gVHJvbmdyaWRcbiAgICovXG4gIHByaXZhdGUgcmVjb3ZlcnlQb3N0KFxuICAgIHF1ZXJ5OiB7IHBhdGg6IHN0cmluZzsganNvbk9iajogYW55OyBub2RlOiBOb2RlVHlwZXMgfSxcbiAgICBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+XG4gICk6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiooKSB7XG4gICAgICBsZXQgbm9kZVVyaSA9ICcnO1xuICAgICAgc3dpdGNoIChxdWVyeS5ub2RlKSB7XG4gICAgICAgIGNhc2UgTm9kZVR5cGVzLkZ1bGw6XG4gICAgICAgICAgbm9kZVVyaSA9IGNvbW1vbi5FbnZpcm9ubWVudHNbc2VsZi5iaXRnby5nZXRFbnYoKV0udHJvbk5vZGVzLmZ1bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTm9kZVR5cGVzLlNvbGlkaXR5OlxuICAgICAgICAgIG5vZGVVcmkgPSBjb21tb24uRW52aXJvbm1lbnRzW3NlbGYuYml0Z28uZ2V0RW52KCldLnRyb25Ob2Rlcy5zb2xpZGl0eTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vZGUgdHlwZSBub3QgZm91bmQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCByZXF1ZXN0XG4gICAgICAgIC5wb3N0KG5vZGVVcmkgKyBxdWVyeS5wYXRoKVxuICAgICAgICAudHlwZSgnanNvbicpXG4gICAgICAgIC5zZW5kKHF1ZXJ5Lmpzb25PYmopO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWNoIFRyb24gbm9kZScpO1xuICAgICAgfVxuXG4gICAgICAvLyB1bmZvcnR1bmF0ZWx5LCBpdCBkb2Vzbid0IGxvb2sgbGlrZSBtb3N0IFRST04gbm9kZXMgcmV0dXJuIHZhbGlkIGpzb24gYXMgYm9keVxuICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVzcG9uc2UudGV4dCk7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogUXVlcnkgb3VyIGV4cGxvcmVyIGZvciB0aGUgYmFsYW5jZSBvZiBhbiBhZGRyZXNzXG4gICAqIEBwYXJhbSBhZGRyZXNzIHtTdHJpbmd9IHRoZSBhZGRyZXNzIGVuY29kZWQgaW4gaGV4XG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7QmlnTnVtYmVyfSBhZGRyZXNzIGJhbGFuY2VcbiAgICovXG4gIHByaXZhdGUgZ2V0QWNjb3VudEZyb21Ob2RlKGFkZHJlc3M6IHN0cmluZywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8QWNjb3VudFJlc3BvbnNlPik6IEJsdWViaXJkPEFjY291bnRSZXNwb25zZT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxBY2NvdW50UmVzcG9uc2U+KGZ1bmN0aW9uKigpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHNlbGYucmVjb3ZlcnlQb3N0KHtcbiAgICAgICAgcGF0aDogJy93YWxsZXRzb2xpZGl0eS9nZXRhY2NvdW50JyxcbiAgICAgICAganNvbk9iajogeyBhZGRyZXNzIH0sXG4gICAgICAgIG5vZGU6IE5vZGVUeXBlcy5Tb2xpZGl0eSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgb3VyIGJ1aWxkIHRyYW5zYWN0aW9uIGZyb20gYSBub2RlLlxuICAgKiBAcGFyYW0gdG9BZGRyIGhleC1lbmNvZGVkIGFkZHJlc3NcbiAgICogQHBhcmFtIGZyb21BZGRyIGhleC1lbmNvZGVkIGFkZHJlc3NcbiAgICogQHBhcmFtIGFtb3VudFxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHByaXZhdGUgZ2V0QnVpbGRUcmFuc2FjdGlvbihcbiAgICB0b0FkZHI6IHN0cmluZyxcbiAgICBmcm9tQWRkcjogc3RyaW5nLFxuICAgIGFtb3VudDogbnVtYmVyLFxuICAgIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGJpdGdvQWNjb3VudExpYi5UcnguSW50ZXJmYWNlLlRyYW5zYWN0aW9uUmVjZWlwdD5cbiAgKTogQmx1ZWJpcmQ8Yml0Z29BY2NvdW50TGliLlRyeC5JbnRlcmZhY2UuVHJhbnNhY3Rpb25SZWNlaXB0PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPGJpdGdvQWNjb3VudExpYi5UcnguSW50ZXJmYWNlLlRyYW5zYWN0aW9uUmVjZWlwdD4oZnVuY3Rpb24qKCkge1xuICAgICAgLy8gb3VyIGFkZHJlc3NlcyBzaG91bGQgYmUgYmFzZTU4LCB3ZSdsbCBoYXZlIHRvIGVuY29kZSB0byBoZXhcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHNlbGYucmVjb3ZlcnlQb3N0KHtcbiAgICAgICAgcGF0aDogJy93YWxsZXQvY3JlYXRldHJhbnNhY3Rpb24nLFxuICAgICAgICBqc29uT2JqOiB7XG4gICAgICAgICAgdG9fYWRkcmVzczogdG9BZGRyLFxuICAgICAgICAgIG93bmVyX2FkZHJlc3M6IGZyb21BZGRyLFxuICAgICAgICAgIGFtb3VudCxcbiAgICAgICAgfSxcbiAgICAgICAgbm9kZTogTm9kZVR5cGVzLkZ1bGwsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogVGhyb3dzIGFuIGVycm9yIGlmIGFueSBrZXlzIGluIHRoZSBvd25lcktleXMgY29sbGVjdGlvbiBkb24ndCBtYXRjaCB0aGUga2V5cyBhcnJheSB3ZSBwYXNzXG4gICAqIEBwYXJhbSBvd25lcktleXNcbiAgICogQHBhcmFtIGtleXNUb0ZpbmRcbiAgICovXG4gIGNoZWNrUGVybWlzc2lvbnMob3duZXJLZXlzOiB7IGFkZHJlc3M6IHN0cmluZzsgd2VpZ2h0OiBudW1iZXIgfVtdLCBrZXlzOiBzdHJpbmdbXSkge1xuICAgIGtleXMgPSBrZXlzLm1hcChrID0+IGsudG9VcHBlckNhc2UoKSk7XG5cbiAgICBvd25lcktleXMubWFwKGtleSA9PiB7XG4gICAgICBjb25zdCBoZXhLZXkgPSBrZXkuYWRkcmVzcy50b1VwcGVyQ2FzZSgpO1xuICAgICAgaWYgKCFrZXlzLmluY2x1ZGVzKGhleEtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwdWIgYWRkcmVzcyAke2hleEtleX0gbm90IGZvdW5kIGluIGFjY291bnRgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleS53ZWlnaHQgIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvd25lciBwZXJtaXNzaW9uIGlzIGludmFsaWQgZm9yIHRoaXMgc3RydWN0dXJlJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGEgZnVuZHMgcmVjb3ZlcnkgdHJhbnNhY3Rpb24gd2l0aG91dCBCaXRHby5cbiAgICogV2UgbmVlZCB0byBkbyB0aHJlZSBxdWVyaWVzIGR1cmluZyB0aGlzOlxuICAgKiAxKSBOb2RlIHF1ZXJ5IC0gaG93IG11Y2ggbW9uZXkgaXMgaW4gdGhlIGFjY291bnRcbiAgICogMikgQnVpbGQgdHJhbnNhY3Rpb24gLSBidWlsZCBvdXIgdHJhbnNhY3Rpb24gZm9yIHRoZSBhbW91bnRcbiAgICogMykgU2VuZCBzaWduZWQgYnVpbGQgLSBzZW5kIG91ciBzaWduZWQgYnVpbGQgdG8gYSBwdWJsaWMgbm9kZVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgcmVjb3ZlcihwYXJhbXM6IFJlY292ZXJ5T3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8UmVjb3ZlcnlUcmFuc2FjdGlvbj4pOiBCbHVlYmlyZDxSZWNvdmVyeVRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPFJlY292ZXJ5VHJhbnNhY3Rpb24+KGZ1bmN0aW9uKigpIHtcbiAgICAgIGNvbnN0IGlzS3JzUmVjb3ZlcnkgPSBwYXJhbXMuYmFja3VwS2V5LnN0YXJ0c1dpdGgoJ3hwdWInKSAmJiAhcGFyYW1zLnVzZXJLZXkuc3RhcnRzV2l0aCgneHB1YicpO1xuICAgICAgY29uc3QgaXNVbnNpZ25lZFN3ZWVwID0gcGFyYW1zLmJhY2t1cEtleS5zdGFydHNXaXRoKCd4cHViJykgJiYgcGFyYW1zLnVzZXJLZXkuc3RhcnRzV2l0aCgneHB1YicpO1xuXG4gICAgICAvLyBnZXQgb3VyIHVzZXIsIGJhY2t1cCBrZXlzXG4gICAgICBjb25zdCBrZXlzID0geWllbGQgc2VsZi5pbml0aWF0ZVJlY292ZXJ5KHBhcmFtcyk7XG5cbiAgICAgIC8vIHdlIG5lZWQgdG8gZGVjb2RlIG91ciBiaXRnb0tleSB0byBhIGJhc2U1OCBhZGRyZXNzXG4gICAgICBjb25zdCBiaXRnb0hleEFkZHIgPSBzZWxmLmNvbXByZXNzZWRQdWJUb0hleEFkZHJlc3Moc2VsZi54cHViVG9Db21wcmVzc2VkUHViKHBhcmFtcy5iaXRnb0tleSkpO1xuICAgICAgY29uc3QgcmVjb3ZlcnlBZGRyZXNzSGV4ID0gYml0Z29BY2NvdW50TGliLlRyeC5VdGlscy5nZXRIZXhBZGRyZXNzRnJvbUJhc2U1OEFkZHJlc3MocGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24pO1xuXG4gICAgICAvLyBjYWxsIHRoZSBub2RlIHRvIGdldCBvdXIgYWNjb3VudCBiYWxhbmNlXG4gICAgICBjb25zdCBhY2NvdW50ID0geWllbGQgc2VsZi5nZXRBY2NvdW50RnJvbU5vZGUoYml0Z29IZXhBZGRyKTtcbiAgICAgIGNvbnN0IHJlY292ZXJ5QW1vdW50ID0gYWNjb3VudC5iYWxhbmNlO1xuXG4gICAgICBjb25zdCB1c2VyWFB1YiA9IGtleXNbMF0ubmV1dGVyZWQoKS50b0Jhc2U1OCgpO1xuICAgICAgY29uc3QgdXNlclhQcnYgPSBrZXlzWzBdLnRvQmFzZTU4KCk7XG4gICAgICBjb25zdCBiYWNrdXBYUHViID0ga2V5c1sxXS5uZXV0ZXJlZCgpLnRvQmFzZTU4KCk7XG5cbiAgICAgIC8vIGNvbnN0cnVjdCB0aGUgdHggLVxuICAgICAgLy8gdGhlcmUncyBhbiBhc3N1bXB0aW9uIGhlcmUgYmVpbmcgbWFkZSBhYm91dCBmZWVzOiBmb3IgYSB3YWxsZXQgdGhhdCBoYXNuJ3QgYmVlbiB1c2VkIGluIGF3aGlsZSwgdGhlIGltcGxpY2F0aW9uIGlzXG4gICAgICAvLyBpdCBoYXMgbWF4aW11bSBiYW5kd2lkdGguIHRodXMsIGEgcmVjb3Zlcnkgc2hvdWxkIGNvc3QgdGhlIG1pbmltdW0gYW1vdW50ICgxZTYgc3VuIG9yIDEgVHJvbilcbiAgICAgIGlmIChNSU5JTVVNX1RST05fTVNJR19UUkFOU0FDVElPTl9GRUUgPiByZWNvdmVyeUFtb3VudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Ftb3VudCBvZiBmdW5kcyB0byByZWNvdmVyIHdvdWxkbnQgYmUgYWJsZSB0byBmdW5kIGEgc2VuZCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVjb3ZlcnlBbW91bnRNaW51c0ZlZXMgPSByZWNvdmVyeUFtb3VudCAtIE1JTklNVU1fVFJPTl9NU0lHX1RSQU5TQUNUSU9OX0ZFRTtcbiAgICAgIGNvbnN0IGJ1aWxkVHggPSB5aWVsZCBzZWxmLmdldEJ1aWxkVHJhbnNhY3Rpb24ocmVjb3ZlcnlBZGRyZXNzSGV4LCBiaXRnb0hleEFkZHIsIHJlY292ZXJ5QW1vdW50TWludXNGZWVzKTtcblxuICAgICAgY29uc3Qga2V5SGV4QWRkcmVzc2VzID0gW1xuICAgICAgICBzZWxmLmNvbXByZXNzZWRQdWJUb0hleEFkZHJlc3Moc2VsZi54cHViVG9Db21wcmVzc2VkUHViKHVzZXJYUHViKSksXG4gICAgICAgIHNlbGYuY29tcHJlc3NlZFB1YlRvSGV4QWRkcmVzcyhzZWxmLnhwdWJUb0NvbXByZXNzZWRQdWIoYmFja3VwWFB1YikpLFxuICAgICAgICBiaXRnb0hleEFkZHIsXG4gICAgICBdO1xuXG4gICAgICAvLyBydW4gY2hlY2tzIHRvIGVuc3VyZSB0aGlzIGlzIGEgdmFsaWQgdHggLSBwZXJtaXNzaW9ucyBtYXRjaCBvdXIgc2lnbmVyIGtleXNcbiAgICAgIHNlbGYuY2hlY2tQZXJtaXNzaW9ucyhhY2NvdW50Lm93bmVyX3Blcm1pc3Npb24ua2V5cywga2V5SGV4QWRkcmVzc2VzKTtcbiAgICAgIHNlbGYuY2hlY2tQZXJtaXNzaW9ucyhhY2NvdW50LmFjdGl2ZV9wZXJtaXNzaW9uWzBdLmtleXMsIGtleUhleEFkZHJlc3Nlcyk7XG5cbiAgICAgIC8vIGNvbnN0cnVjdCBvdXIgdHhcbiAgICAgIGNvbnN0IHR4QnVpbGRlciA9IGJpdGdvQWNjb3VudExpYi5nZXRCdWlsZGVyKHNlbGYuZ2V0Q2hhaW4oKSk7XG4gICAgICB0eEJ1aWxkZXIuZnJvbShidWlsZFR4KTtcblxuICAgICAgLy8gdGhpcyB0eCBzaG91bGQgYmUgZW5vdWdoIHRvIGRyb3AgaW50byBhIG5vZGVcbiAgICAgIGlmIChpc1Vuc2lnbmVkU3dlZXApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eDogKHlpZWxkIHR4QnVpbGRlci5idWlsZCgpKS50b0pzb24oKSxcbiAgICAgICAgICByZWNvdmVyeUFtb3VudDogcmVjb3ZlcnlBbW91bnRNaW51c0ZlZXMsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVzZXJQcnYgPSBzZWxmLnhwcnZUb0NvbXByZXNzZWRQcnYodXNlclhQcnYpO1xuXG4gICAgICB0eEJ1aWxkZXIuc2lnbih7IGtleTogdXNlclBydiB9KTtcblxuICAgICAgLy8ga3JzIHJlY292ZXJpZXMgZG9uJ3QgZ2V0IHNpZ25lZFxuICAgICAgaWYgKCFpc0tyc1JlY292ZXJ5KSB7XG4gICAgICAgIGNvbnN0IGJhY2t1cFhQcnYgPSBrZXlzWzFdLnRvQmFzZTU4KCk7XG4gICAgICAgIGNvbnN0IGJhY2t1cFBydiA9IHNlbGYueHBydlRvQ29tcHJlc3NlZFBydihiYWNrdXBYUHJ2KTtcblxuICAgICAgICB0eEJ1aWxkZXIuc2lnbih7IGtleTogYmFja3VwUHJ2IH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eDogKHlpZWxkIHR4QnVpbGRlci5idWlsZCgpKS50b0pzb24oKSxcbiAgICAgICAgcmVjb3ZlcnlBbW91bnQ6IHJlY292ZXJ5QW1vdW50TWludXNGZWVzLFxuICAgICAgfTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBsYWluIGEgVHJvbiB0cmFuc2FjdGlvbiBmcm9tIHR4SGV4XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBleHBsYWluVHJhbnNhY3Rpb24oXG4gICAgcGFyYW1zOiBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zLFxuICAgIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFRyb25UcmFuc2FjdGlvbkV4cGxhbmF0aW9uPlxuICApOiBCbHVlYmlyZDxUcm9uVHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxUcm9uVHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4oZnVuY3Rpb24qKCkge1xuICAgICAgY29uc3QgdHhIZXggPSBwYXJhbXMudHhIZXggfHwgKHBhcmFtcy5oYWxmU2lnbmVkICYmIHBhcmFtcy5oYWxmU2lnbmVkLnR4SGV4KTtcbiAgICAgIGlmICghdHhIZXggfHwgIXBhcmFtcy5mZWVJbmZvKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBleHBsYWluIHR4IHBhcmFtZXRlcnMnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHR4QnVpbGRlciA9IGJpdGdvQWNjb3VudExpYi5nZXRCdWlsZGVyKHNlbGYuZ2V0Q2hhaW4oKSk7XG4gICAgICB0eEJ1aWxkZXIuZnJvbSh0eEhleCk7XG4gICAgICBjb25zdCB0eCA9IHlpZWxkIHR4QnVpbGRlci5idWlsZCgpO1xuICAgICAgY29uc3Qgb3V0cHV0cyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGFtb3VudDogdHgub3V0cHV0c1swXS52YWx1ZS50b1N0cmluZygpLFxuICAgICAgICAgIGFkZHJlc3M6IHR4Lm91dHB1dHNbMF0uYWRkcmVzcywgLy8gU2hvdWxkIHR1cm4gaXQgaW50byBhIHJlYWRhYmxlIGZvcm1hdCwgYWthIGJhc2U1OFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgY29uc3QgZGlzcGxheU9yZGVyID0gW1xuICAgICAgICAnaWQnLFxuICAgICAgICAnb3V0cHV0QW1vdW50JyxcbiAgICAgICAgJ2NoYW5nZUFtb3VudCcsXG4gICAgICAgICdvdXRwdXRzJyxcbiAgICAgICAgJ2NoYW5nZU91dHB1dHMnLFxuICAgICAgICAnZmVlJyxcbiAgICAgICAgJ3RpbWVzdGFtcCcsXG4gICAgICAgICdleHBpcmF0aW9uJyxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IGV4cGxhbmF0aW9uUmVzdWx0OiBUcm9uVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiA9IHtcbiAgICAgICAgZGlzcGxheU9yZGVyLFxuICAgICAgICBpZDogdHguaWQsXG4gICAgICAgIG91dHB1dHMsXG4gICAgICAgIG91dHB1dEFtb3VudDogb3V0cHV0c1swXS5hbW91bnQsXG4gICAgICAgIGNoYW5nZU91dHB1dHM6IFtdLCAvLyBhY2NvdW50IGJhc2VkIGRvZXMgbm90IHVzZSBjaGFuZ2Ugb3V0cHV0c1xuICAgICAgICBjaGFuZ2VBbW91bnQ6ICcwJywgLy8gYWNjb3VudCBiYXNlIGRvZXMgbm90IG1ha2UgY2hhbmdlXG4gICAgICAgIGZlZTogcGFyYW1zLmZlZUluZm8sXG4gICAgICAgIHRpbWVzdGFtcDogdHgudmFsaWRGcm9tLFxuICAgICAgICBleHBpcmF0aW9uOiB0eC52YWxpZFRvLFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGV4cGxhbmF0aW9uUmVzdWx0O1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG59XG4iXX0=