"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var bitcoin = require("bitgo-utxo-lib");
var bitcoinMessage = require("bitcoinjs-message");
var Bluebird = require("bluebird");
var crypto = require("crypto");
var request = require("superagent");
var _ = require("lodash");
var debugLib = require("debug");
var unspents_1 = require("@bitgo/unspents");
var codes_1 = require("@bitgo/unspents/dist/codes");
var bitcoin_1 = require("../../bitcoin");
var baseCoin_1 = require("../baseCoin");
var keychains_1 = require("../keychains");
var config = require("../../config");
var recovery_1 = require("../recovery");
var errors = require("../../errors");
var debug = debugLib('bitgo:v2:utxo');
var co = Bluebird.coroutine;
var AbstractUtxoCoin = /** @class */ (function (_super) {
    __extends(AbstractUtxoCoin, _super);
    function AbstractUtxoCoin(bitgo, network) {
        var _this = _super.call(this, bitgo) || this;
        if (!_.isObject(network)) {
            throw new Error('network must be an object');
        }
        _this._network = network;
        return _this;
    }
    Object.defineProperty(AbstractUtxoCoin.prototype, "network", {
        get: function () {
            return this._network;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractUtxoCoin, "validAddressTypes", {
        get: function () {
            var validAddressTypes = [];
            // best way I could find to loop over enum values
            // https://github.com/Microsoft/TypeScript/issues/17198#issuecomment-423836658
            // this is a typescript rough corner for sure
            var unspentTypeKeys = Object.keys(codes_1.UnspentType);
            var unspentTypes = unspentTypeKeys
                .map(function (k) { return codes_1.UnspentType[k]; })
                .map(function (v) { return v; });
            for (var _i = 0, unspentTypes_1 = unspentTypes; _i < unspentTypes_1.length; _i++) {
                var addressType = unspentTypes_1[_i];
                try {
                    unspents_1.Codes.forType(addressType);
                    validAddressTypes.push(addressType);
                }
                catch (e) {
                    // Do nothing. Codes.forType will throw if the address type has no chain codes, meaning it is invalid on the
                    // BitGo platform and should not be added to the validAddressTypes array.
                }
            }
            return validAddressTypes;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the factor between the base unit and its smallest subdivison
     * @return {number}
     */
    AbstractUtxoCoin.prototype.getBaseFactor = function () {
        return 1e8;
    };
    /**
     * Get an instance of the library which can be used to perform low-level operations for this coin
     */
    AbstractUtxoCoin.prototype.getCoinLibrary = function () {
        return bitcoin;
    };
    /**
     * Helper to get the version number for an address
     */
    AbstractUtxoCoin.prototype.getAddressVersion = function (address) {
        // try decoding as base58 first
        try {
            var version = this.getCoinLibrary().address.fromBase58Check(address).version;
            return version;
        }
        catch (e) {
            // if that fails, and we aren't supporting p2wsh, then we are done and did not find a version
            if (!this.supportsP2wsh()) {
                return;
            }
        }
        // otherwise, try decoding as bech32
        try {
            var _a = this.getCoinLibrary().address.fromBech32(address), version = _a.version, prefix = _a.prefix;
            if (_.isString(this.network.bech32) && prefix === this.network.bech32) {
                return version;
            }
        }
        catch (e) {
            // ignore errors, just fall through and return undefined
        }
    };
    /**
     * Helper to get the bech32 prefix for an address
     */
    AbstractUtxoCoin.prototype.getAddressPrefix = function (address) {
        // otherwise, try decoding as bech32
        try {
            var prefix = this.getCoinLibrary().address.fromBech32(address).prefix;
            return prefix;
        }
        catch (e) {
            // ignore errors, just fall through and return undefined
        }
    };
    /**
     * Check if an address is valid
     * @param address
     * @param forceAltScriptSupport
     */
    AbstractUtxoCoin.prototype.isValidAddress = function (address, forceAltScriptSupport) {
        if (forceAltScriptSupport === void 0) { forceAltScriptSupport = false; }
        var validVersions = [
            this.network.pubKeyHash,
            this.network.scriptHash,
        ];
        if (this.altScriptHash && (forceAltScriptSupport || this.supportAltScriptDestination)) {
            validVersions.push(this.altScriptHash);
        }
        var addressVersion = this.getAddressVersion(address);
        // the address version needs to be among the valid ones
        var addressVersionValid = _.isNumber(addressVersion) && validVersions.includes(addressVersion);
        var addressPrefix = this.getAddressPrefix(address);
        if (!this.supportsP2wsh() || _.isUndefined(addressPrefix)) {
            return addressVersionValid;
        }
        // address has a potential bech32 prefix, validate that
        return _.isString(this.network.bech32) && this.network.bech32 === addressPrefix;
    };
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    AbstractUtxoCoin.prototype.isValidPub = function (pub) {
        try {
            bitcoin.HDNode.fromBase58(pub);
            return true;
        }
        catch (e) {
            return false;
        }
    };
    /**
     * Get the latest block height
     * @param reqId
     * @param callback
     */
    AbstractUtxoCoin.prototype.getLatestBlockHeight = function (reqId, callback) {
        var self = this;
        return co(function () {
            var chainhead;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (reqId) {
                            this.bitgo._reqId = reqId;
                        }
                        return [4 /*yield*/, self.bitgo.get(self.url('/public/block/latest')).result()];
                    case 1:
                        chainhead = _a.sent();
                        return [2 /*return*/, chainhead.height];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Run custom coin logic after a transaction prebuild has been received from BitGo
     * @param prebuild
     * @param callback
     */
    AbstractUtxoCoin.prototype.postProcessPrebuild = function (prebuild, callback) {
        var self = this;
        return co(function () {
            var transaction, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (_.isUndefined(prebuild.txHex)) {
                            throw new Error('missing required txPrebuild property txHex');
                        }
                        transaction = bitcoin.Transaction.fromHex(prebuild.txHex, self.network);
                        if (!_.isUndefined(prebuild.blockHeight)) return [3 /*break*/, 2];
                        _a = prebuild;
                        return [4 /*yield*/, self.getLatestBlockHeight()];
                    case 1:
                        _a.blockHeight = (_b.sent());
                        _b.label = 2;
                    case 2:
                        // Lock transaction to the next block to discourage fee sniping
                        // See: https://github.com/bitcoin/bitcoin/blob/fb0ac482eee761ec17ed2c11df11e054347a026d/src/wallet/wallet.cpp#L2133
                        transaction.locktime = prebuild.blockHeight;
                        return [2 /*return*/, _.extend({}, prebuild, { txHex: transaction.toHex() })];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Find outputs that are within expected outputs but not within actual outputs, including duplicates
     * @param expectedOutputs
     * @param actualOutputs
     * @returns {Array}
     */
    AbstractUtxoCoin.findMissingOutputs = function (expectedOutputs, actualOutputs) {
        var keyFunc = function (_a) {
            var address = _a.address, amount = _a.amount;
            return address + ":" + Number(amount);
        };
        var groupedOutputs = _.groupBy(expectedOutputs, keyFunc);
        actualOutputs.forEach(function (output) {
            var group = groupedOutputs[keyFunc(output)];
            if (group) {
                group.pop();
            }
        });
        return _.flatten(_.values(groupedOutputs));
    };
    /**
     * Determine an address' type based on its witness and redeem script presence
     * @param addressDetails
     */
    AbstractUtxoCoin.inferAddressType = function (addressDetails) {
        if (_.isObject(addressDetails.coinSpecific)) {
            if (_.isString(addressDetails.coinSpecific.redeemScript) && _.isString(addressDetails.coinSpecific.witnessScript)) {
                return unspents_1.Codes.UnspentTypeTcomb('p2shP2wsh');
            }
            else if (_.isString(addressDetails.coinSpecific.redeemScript)) {
                return unspents_1.Codes.UnspentTypeTcomb('p2sh');
            }
            else if (_.isString(addressDetails.coinSpecific.witnessScript)) {
                return unspents_1.Codes.UnspentTypeTcomb('p2wsh');
            }
        }
        return null;
    };
    /**
     * Extract and fill transaction details such as internal/change spend, external spend (explicit vs. implicit), etc.
     * @param params
     * @param callback
     * @returns {*}
     */
    AbstractUtxoCoin.prototype.parseTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            var txParams, txPrebuild, wallet, _a, verification, reqId, disableNetworking, keychains, keychainArray, keySignatures, explanation, allOutputs, expectedOutputs, missingOutputs, allOutputDetails, changeOutputs, implicitOutputs, explicitOutputs, explicitExternalOutputs, explicitExternalSpendAmount, implicitExternalOutputs, implicitExternalSpendAmount, result;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        txParams = params.txParams, txPrebuild = params.txPrebuild, wallet = params.wallet, _a = params.verification, verification = _a === void 0 ? {} : _a, reqId = params.reqId;
                        if (!_.isUndefined(verification.disableNetworking) && !_.isBoolean(verification.disableNetworking)) {
                            throw new Error('verification.disableNetworking must be a boolean');
                        }
                        disableNetworking = verification.disableNetworking;
                        keychains = verification.keychains;
                        if (!(!keychains && disableNetworking)) return [3 /*break*/, 1];
                        throw new Error('cannot fetch keychains without networking');
                    case 1:
                        if (!!keychains) return [3 /*break*/, 3];
                        return [4 /*yield*/, Bluebird.props({
                                user: self.keychains().get({ id: wallet.keyIds()[keychains_1.KeyIndices.USER], reqId: reqId }),
                                backup: self.keychains().get({ id: wallet.keyIds()[keychains_1.KeyIndices.BACKUP], reqId: reqId }),
                                bitgo: self.keychains().get({ id: wallet.keyIds()[keychains_1.KeyIndices.BITGO], reqId: reqId }),
                            })];
                    case 2:
                        keychains = _b.sent();
                        _b.label = 3;
                    case 3:
                        if (!keychains) {
                            throw new Error('keychains are required, but could not be fetched');
                        }
                        keychainArray = [keychains.user, keychains.backup, keychains.bitgo];
                        keySignatures = _.get(wallet, '_wallet.keySignatures');
                        if (_.isUndefined(txPrebuild.txHex)) {
                            throw new Error('missing required txPrebuild property txHex');
                        }
                        return [4 /*yield*/, self.explainTransaction({
                                txHex: txPrebuild.txHex,
                                txInfo: txPrebuild.txInfo,
                            })];
                    case 4:
                        explanation = _b.sent();
                        allOutputs = explanation.outputs.concat(explanation.changeOutputs);
                        expectedOutputs = _.get(txParams, 'recipients', []);
                        missingOutputs = AbstractUtxoCoin.findMissingOutputs(expectedOutputs, allOutputs);
                        return [4 /*yield*/, Bluebird.map(allOutputs, co(function (currentOutput) {
                                var currentAddress, addressDetailsPrebuild, addressDetailsVerification, addressDetails, addressType, e_1, walletAddressNotFound, unexpectedAddress;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            currentAddress = currentOutput.address;
                                            addressDetailsPrebuild = _.get(txPrebuild, "txInfo.walletAddressDetails." + currentAddress, {});
                                            addressDetailsVerification = _.get(verification, "addresses." + currentAddress, {});
                                            debug('Parsing address details for %s', currentAddress);
                                            _a.label = 1;
                                        case 1:
                                            _a.trys.push([1, 4, , 5]);
                                            addressDetails = _.extend({}, addressDetailsPrebuild, addressDetailsVerification);
                                            debug('Locally available address %s details: %O', currentAddress, addressDetails);
                                            if (!(_.isEmpty(addressDetails) && !disableNetworking)) return [3 /*break*/, 3];
                                            return [4 /*yield*/, wallet.getAddress({ address: currentAddress, reqId: reqId })];
                                        case 2:
                                            addressDetails = _a.sent();
                                            debug('Downloaded address %s details: %O', currentAddress, addressDetails);
                                            _a.label = 3;
                                        case 3:
                                            addressType = AbstractUtxoCoin.inferAddressType(addressDetails);
                                            self.verifyAddress(_.extend({ addressType: addressType }, addressDetails, {
                                                keychains: keychainArray,
                                                address: currentAddress,
                                            }));
                                            debug('Address %s verification passed', currentAddress);
                                            // verify address succeeded without throwing, so the address was
                                            // correctly rederived from the wallet keychains, making it not external
                                            return [2 /*return*/, _.extend({}, currentOutput, addressDetails, { external: false })];
                                        case 4:
                                            e_1 = _a.sent();
                                            // verify address threw an exception
                                            debug('Address %s verification threw an error:', currentAddress, e_1);
                                            walletAddressNotFound = e_1.message.includes('wallet address not found');
                                            unexpectedAddress = (e_1 instanceof errors.UnexpectedAddressError);
                                            if (walletAddressNotFound || unexpectedAddress) {
                                                if (unexpectedAddress && !walletAddressNotFound) {
                                                    /**
                                                     * this could be a migrated SafeHD BCH wallet, and the transaction we are currently
                                                     * parsing is trying to spend change back to the v1 wallet base address.
                                                     * It does this since we don't allow new address creation for these wallets,
                                                     * and instead return the base address from the v1 wallet when a new address is requested.
                                                     * If this new address is requested for the purposes of spending change back to the wallet,
                                                     * the change will go to the v1 wallet base address. This address *is* on the wallet,
                                                     * but it will still cause an error to be thrown by verifyAddress, since the derivation path
                                                     * used for this address is non-standard. (I have seen these addresses derived using paths m/0/0 and m/101,
                                                     * whereas the v2 addresses are derived using path  m/0/0/${chain}/${index}).
                                                     *
                                                     * This means we need to check for this case explicitly in this catch block, and classify
                                                     * these types of outputs as internal instead of external. Failing to do so would cause the
                                                     * transaction's implicit external outputs (ie, outputs which go to addresses not specified in
                                                     * the recipients array) to add up to more than the 150 basis point limit which we enforce on
                                                     * pay-as-you-go outputs (which should be the only implicit external outputs on our transactions).
                                                     *
                                                     * The 150 basis point limit for implicit external sends is enforced in verifyTransaction,
                                                     * which calls this function to get information on the total external/internal spend amounts
                                                     * for a transaction. The idea here is to protect from the transaction being maliciously modified
                                                     * to add more implicit external spends (eg, to an attacker-controlled wallet).
                                                     *
                                                     * See verifyTransaction for more information on how transaction prebuilds are verified before signing.
                                                     */
                                                    if (_.isString(wallet.migratedFrom()) && wallet.migratedFrom() === currentAddress) {
                                                        debug('found address %s which was migrated from v1 wallet, address is not external', currentAddress);
                                                        return [2 /*return*/, _.extend({}, currentOutput, { external: false })];
                                                    }
                                                    debug('Address %s was found on wallet but could not be reconstructed', currentAddress);
                                                }
                                                // the address was found, but not on the wallet, which simply means it's external
                                                debug('Address %s presumed external', currentAddress);
                                                return [2 /*return*/, _.extend({}, currentOutput, { external: true })];
                                            }
                                            else if (e_1 instanceof errors.InvalidAddressDerivationPropertyError && currentAddress === txParams.changeAddress) {
                                                // expect to see this error when passing in a custom changeAddress with no chain or index
                                                return [2 /*return*/, _.extend({}, currentOutput, { external: false })];
                                            }
                                            debug('Address %s verification failed', currentAddress);
                                            /**
                                             * It might be a completely invalid address or a bad validation attempt or something else completely, in
                                             * which case we do not proceed and rather rethrow the error, which is safer than assuming that the address
                                             * validation failed simply because it's external to the wallet.
                                             */
                                            throw e_1;
                                        case 5: return [2 /*return*/];
                                    }
                                });
                            }).bind(this))];
                    case 5:
                        allOutputDetails = _b.sent();
                        changeOutputs = _.filter(allOutputDetails, { external: false });
                        implicitOutputs = AbstractUtxoCoin.findMissingOutputs(allOutputDetails, expectedOutputs);
                        explicitOutputs = AbstractUtxoCoin.findMissingOutputs(allOutputDetails, implicitOutputs);
                        explicitExternalOutputs = _.filter(explicitOutputs, { external: true });
                        explicitExternalSpendAmount = _.sumBy(explicitExternalOutputs, 'amount');
                        implicitExternalOutputs = _.filter(implicitOutputs, { external: true });
                        implicitExternalSpendAmount = _.sumBy(implicitExternalOutputs, 'amount');
                        result = {
                            keychains: keychains,
                            keySignatures: keySignatures,
                            outputs: allOutputDetails,
                            missingOutputs: missingOutputs,
                            explicitExternalOutputs: explicitExternalOutputs,
                            implicitExternalOutputs: implicitExternalOutputs,
                            changeOutputs: changeOutputs,
                            explicitExternalSpendAmount: explicitExternalSpendAmount,
                            implicitExternalSpendAmount: implicitExternalSpendAmount,
                        };
                        return [2 /*return*/, result];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Verify that a transaction prebuild complies with the original intention
     *
     * @param params
     * @param params.txParams params object passed to send
     * @param params.txPrebuild prebuild object returned by server
     * @param params.txPrebuild.txHex prebuilt transaction's txHex form
     * @param params.wallet Wallet object to obtain keys to verify against
     * @param params.verification Object specifying some verification parameters
     * @param params.verification.disableNetworking Disallow fetching any data from the internet for verification purposes
     * @param params.verification.keychains Pass keychains manually rather than fetching them by id
     * @param params.verification.addresses Address details to pass in for out-of-band verification
     * @param callback
     * @returns {boolean}
     */
    AbstractUtxoCoin.prototype.verifyTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            var txParams, txPrebuild, wallet, _a, verification, reqId, disableNetworking, parsedTransaction, keychains, keySignatures, userPub, userKey, userPrv, encryptedPrv, errorMessage, userPrivateKey, backupPubSignature, bitgoPubSignature, signingAddress, isValidBackupSignature, isValidBitgoSignature, missingOutputs, intendedExternalSpend, payAsYouGoLimit, nonChangeAmount, allOutputs, transaction, transactionCache, inputs, inputAmount, outputAmount, fee;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        txParams = params.txParams, txPrebuild = params.txPrebuild, wallet = params.wallet, _a = params.verification, verification = _a === void 0 ? {} : _a, reqId = params.reqId;
                        disableNetworking = !!verification.disableNetworking;
                        return [4 /*yield*/, self.parseTransaction({ txParams: txParams, txPrebuild: txPrebuild, wallet: wallet, verification: verification, reqId: reqId })];
                    case 1:
                        parsedTransaction = _b.sent();
                        keychains = parsedTransaction.keychains;
                        keySignatures = parsedTransaction.keySignatures;
                        if (!_.isEmpty(keySignatures)) {
                            userPub = keychains.user.pub;
                            userKey = bitcoin.HDNode.fromBase58(userPub);
                            userPrv = keychains.user.prv;
                            if (_.isEmpty(userPrv)) {
                                encryptedPrv = keychains.user.encryptedPrv;
                                if (!_.isEmpty(encryptedPrv)) {
                                    // if the decryption fails, it will throw an error
                                    userPrv = self.bitgo.decrypt({
                                        input: encryptedPrv,
                                        password: txParams.walletPassphrase,
                                    });
                                }
                            }
                            if (_.isEmpty(userPrv)) {
                                errorMessage = 'user private key unavailable for verification';
                                if (disableNetworking) {
                                    console.log(errorMessage);
                                }
                                else {
                                    throw new Error(errorMessage);
                                }
                            }
                            else {
                                userPrivateKey = bitcoin.HDNode.fromBase58(userPrv);
                                if (userPrivateKey.toBase58() === userPrivateKey.neutered().toBase58()) {
                                    throw new Error('user private key is only public');
                                }
                                if (userPrivateKey.neutered().toBase58() !== userPub) {
                                    throw new Error('user private key does not match public key');
                                }
                            }
                            backupPubSignature = keySignatures.backupPub;
                            bitgoPubSignature = keySignatures.bitgoPub;
                            signingAddress = userKey.keyPair.getAddress();
                            isValidBackupSignature = bitcoinMessage.verify(keychains.backup.pub, signingAddress, Buffer.from(backupPubSignature, 'hex'));
                            isValidBitgoSignature = bitcoinMessage.verify(keychains.bitgo.pub, signingAddress, Buffer.from(bitgoPubSignature, 'hex'));
                            if (!isValidBackupSignature || !isValidBitgoSignature) {
                                throw new Error('secondary public key signatures invalid');
                            }
                        }
                        else if (!disableNetworking) {
                            // these keys were obtained online and their signatures were not verified
                            // this could be dangerous
                            console.log('unsigned keys obtained online are being used for address verification');
                        }
                        missingOutputs = parsedTransaction.missingOutputs;
                        if (missingOutputs.length !== 0) {
                            // there are some outputs in the recipients list that have not made it into the actual transaction
                            throw new Error('expected outputs missing in transaction prebuild');
                        }
                        intendedExternalSpend = parsedTransaction.explicitExternalSpendAmount;
                        payAsYouGoLimit = intendedExternalSpend * 0.015;
                        nonChangeAmount = parsedTransaction.implicitExternalSpendAmount;
                        // the additional external outputs can only be BitGo's pay-as-you-go fee, but we cannot verify the wallet address
                        if (nonChangeAmount > payAsYouGoLimit) {
                            // there are some addresses that are outside the scope of intended recipients that are not change addresses
                            throw new Error('prebuild attempts to spend to unintended external recipients');
                        }
                        allOutputs = parsedTransaction.outputs;
                        transaction = bitcoin.Transaction.fromHex(txPrebuild.txHex, self.network);
                        transactionCache = {};
                        return [4 /*yield*/, Bluebird.map(transaction.ins, co(function (currentInput) {
                                var transactionId, txHex, localTx, currentOutput, address, _a, _b, transactionDetails;
                                return __generator(this, function (_c) {
                                    switch (_c.label) {
                                        case 0:
                                            transactionId = Buffer.from(currentInput.hash).reverse().toString('hex');
                                            txHex = _.get(txPrebuild, "txInfo.txHexes." + transactionId);
                                            if (!txHex) return [3 /*break*/, 1];
                                            localTx = bitcoin.Transaction.fromHex(txHex, self.network);
                                            if (localTx.getId() !== transactionId) {
                                                throw new Error('input transaction hex does not match id');
                                            }
                                            currentOutput = localTx.outs[currentInput.index];
                                            address = bitcoin.address.fromOutputScript(currentOutput.script, self.network);
                                            return [2 /*return*/, {
                                                    address: address,
                                                    value: currentOutput.value,
                                                }];
                                        case 1:
                                            if (!!transactionCache[transactionId]) return [3 /*break*/, 3];
                                            if (disableNetworking) {
                                                throw new Error('attempting to retrieve transaction details externally with networking disabled');
                                            }
                                            if (reqId) {
                                                self.bitgo.setRequestTracer(reqId);
                                            }
                                            _a = transactionCache;
                                            _b = transactionId;
                                            return [4 /*yield*/, self.bitgo.get(self.url("/public/tx/" + transactionId)).result()];
                                        case 2:
                                            _a[_b] = _c.sent();
                                            _c.label = 3;
                                        case 3:
                                            transactionDetails = transactionCache[transactionId];
                                            return [2 /*return*/, transactionDetails.outputs[currentInput.index]];
                                    }
                                });
                            }).bind(this))];
                    case 2:
                        inputs = _b.sent();
                        inputAmount = _.sumBy(inputs, 'value');
                        outputAmount = _.sumBy(allOutputs, 'amount');
                        fee = inputAmount - outputAmount;
                        if (fee < 0) {
                            throw new Error("attempting to spend " + outputAmount + " satoshis, which exceeds the input amount (" + inputAmount + " satoshis) by " + -fee);
                        }
                        return [2 /*return*/, true];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Make sure an address is valid and throw an error if it's not.
     * @param params.address The address string on the network
     * @param params.addressType
     * @param params.keychains Keychain objects with xpubs
     * @param params.coinSpecific Coin-specific details for the address such as a witness script
     * @param params.chain Derivation chain
     * @param params.index Derivation index
     * @throws {InvalidAddressError}
     * @throws {InvalidAddressDerivationPropertyError}
     * @throws {UnexpectedAddressError}
     */
    AbstractUtxoCoin.prototype.verifyAddress = function (params) {
        var address = params.address, addressType = params.addressType, keychains = params.keychains, coinSpecific = params.coinSpecific, chain = params.chain, index = params.index;
        if (!this.isValidAddress(address)) {
            throw new errors.InvalidAddressError("invalid address: " + address);
        }
        if ((_.isUndefined(chain) && _.isUndefined(index)) || (!(_.isFinite(chain) && _.isFinite(index)))) {
            throw new errors.InvalidAddressDerivationPropertyError("address validation failure: invalid chain (" + chain + ") or index (" + index + ")");
        }
        if (!_.isObject(coinSpecific)) {
            throw new errors.InvalidAddressVerificationObjectPropertyError('address validation failure: coinSpecific field must be an object');
        }
        if (!keychains) {
            throw new Error('missing required param keychains');
        }
        var expectedAddress = this.generateAddress({
            addressType: addressType,
            keychains: keychains,
            threshold: 2,
            chain: chain,
            index: index,
        });
        if (expectedAddress.address !== address) {
            throw new errors.UnexpectedAddressError("address validation failure: expected " + expectedAddress.address + " but got " + address);
        }
        return true;
    };
    /**
     * Indicates whether coin supports a block target
     * @returns {boolean}
     */
    AbstractUtxoCoin.prototype.supportsBlockTarget = function () {
        return true;
    };
    /**
     * Indicates whether a coin supports wrapped segwit outputs
     * @returns {boolean}
     */
    AbstractUtxoCoin.prototype.supportsP2shP2wsh = function () {
        return false;
    };
    /**
     * Indicates whether a coin supports native segwit outputs
     * @returns {boolean}
     */
    AbstractUtxoCoin.prototype.supportsP2wsh = function () {
        return false;
    };
    /**
     * TODO(BG-11487): Remove addressType, segwit, and bech32 params in SDKv6
     * Generate an address for a wallet based on a set of configurations
     * @param params.addressType {string}   Deprecated
     * @param params.keychains   {[object]} Array of objects with xpubs
     * @param params.threshold   {number}   Minimum number of signatures
     * @param params.chain       {number}   Derivation chain (see https://github.com/BitGo/unspents/blob/master/src/codes.ts for
     *                                                 the corresponding address type of a given chain code)
     * @param params.index       {number}   Derivation index
     * @param params.segwit      {boolean}  Deprecated
     * @param params.bech32      {boolean}  Deprecated
     * @returns {{chain: number, index: number, coin: number, coinSpecific: {outputScript, redeemScript}}}
     */
    AbstractUtxoCoin.prototype.generateAddress = function (params) {
        var keychains = params.keychains, threshold = params.threshold, chain = params.chain, index = params.index, _a = params.segwit, segwit = _a === void 0 ? false : _a, _b = params.bech32, bech32 = _b === void 0 ? false : _b;
        var derivationChain = 0;
        if (_.isNumber(chain) && _.isInteger(chain) && chain > 0) {
            derivationChain = chain;
        }
        function convertFlagsToAddressType() {
            if (_.isBoolean(segwit) && segwit) {
                return unspents_1.Codes.UnspentTypeTcomb('p2shP2wsh');
            }
            else if (_.isBoolean(bech32) && bech32) {
                return unspents_1.Codes.UnspentTypeTcomb('p2wsh');
            }
            else {
                return unspents_1.Codes.UnspentTypeTcomb('p2sh');
            }
        }
        var addressType = params.addressType || convertFlagsToAddressType();
        switch (addressType) {
            case unspents_1.Codes.UnspentTypeTcomb('p2sh'):
                if (!unspents_1.Codes.isP2sh(derivationChain)) {
                    throw new errors.AddressTypeChainMismatchError(addressType, derivationChain);
                }
                break;
            case unspents_1.Codes.UnspentTypeTcomb('p2shP2wsh'):
                if (!this.supportsP2shP2wsh()) {
                    throw new errors.P2shP2wshUnsupportedError();
                }
                if (!unspents_1.Codes.isP2shP2wsh(derivationChain)) {
                    throw new errors.AddressTypeChainMismatchError(addressType, derivationChain);
                }
                break;
            case unspents_1.Codes.UnspentTypeTcomb('p2wsh'):
                if (!this.supportsP2wsh()) {
                    throw new errors.P2wshUnsupportedError();
                }
                if (!unspents_1.Codes.isP2wsh(derivationChain)) {
                    throw new errors.AddressTypeChainMismatchError(addressType, derivationChain);
                }
                break;
            default:
                throw new errors.UnsupportedAddressTypeError();
        }
        var signatureThreshold = 2;
        if (_.isInteger(threshold)) {
            signatureThreshold = threshold;
            if (signatureThreshold <= 0) {
                throw new Error('threshold has to be positive');
            }
            if (signatureThreshold > keychains.length) {
                throw new Error('threshold cannot exceed number of keys');
            }
        }
        var derivationIndex = 0;
        if (_.isInteger(index) && index > 0) {
            derivationIndex = index;
        }
        var path = 'm/0/0/' + derivationChain + '/' + derivationIndex;
        var hdNodes = keychains.map(function (_a) {
            var pub = _a.pub;
            return bitcoin.HDNode.fromBase58(pub);
        });
        var derivedKeys = hdNodes.map(function (hdNode) { return bitcoin_1.hdPath(hdNode).deriveKey(path).getPublicKeyBuffer(); });
        var _c = this.createMultiSigAddress(addressType, signatureThreshold, derivedKeys), outputScript = _c.outputScript, redeemScript = _c.redeemScript, witnessScript = _c.witnessScript, address = _c.address;
        return {
            address: address,
            chain: derivationChain,
            index: derivationIndex,
            coin: this.getChain(),
            coinSpecific: {
                outputScript: outputScript.toString('hex'),
                redeemScript: redeemScript && redeemScript.toString('hex'),
                witnessScript: witnessScript && witnessScript.toString('hex'),
            },
            addressType: addressType,
        };
    };
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * @param params.txPrebuild transaction prebuild from bitgo server
     * @param params.prv private key to be used for signing
     * @param params.isLastSignature True if `TransactionBuilder.build()` should be called and not `TransactionBuilder.buildIncomplete()`
     * @param callback
     * @returns {Bluebird<SignedTransaction>}
     */
    AbstractUtxoCoin.prototype.signTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            var txPrebuild, userPrv, transaction, isLastSignature, keychain, keychainHdPath, txb, getSignatureContext, signatureIssues, index, signatureContext, privKey, sigHashType, witnessScript, witnessScriptHash, prevOutScript, subscript, isP2shP2wsh, witnessScript, index, signatureContext, isValidSignature, failedIndices, error;
            return __generator(this, function (_a) {
                txPrebuild = params.txPrebuild;
                userPrv = params.prv;
                if (_.isUndefined(txPrebuild) || !_.isObject(txPrebuild)) {
                    if (!_.isUndefined(txPrebuild) && !_.isObject(txPrebuild)) {
                        throw new Error("txPrebuild must be an object, got type " + typeof txPrebuild);
                    }
                    throw new Error('missing txPrebuild parameter');
                }
                transaction = bitcoin.Transaction.fromHex(txPrebuild.txHex, self.network);
                if (transaction.ins.length !== txPrebuild.txInfo.unspents.length) {
                    throw new Error('length of unspents array should equal to the number of transaction inputs');
                }
                isLastSignature = false;
                if (_.isBoolean(params.isLastSignature)) {
                    // if build is called instead of buildIncomplete, no signature placeholders are left in the sig script
                    isLastSignature = params.isLastSignature;
                }
                if (_.isUndefined(userPrv) || !_.isString(userPrv)) {
                    if (!_.isUndefined(userPrv)) {
                        throw new Error("prv must be a string, got type " + typeof userPrv);
                    }
                    throw new Error('missing prv parameter to sign transaction');
                }
                keychain = bitcoin.HDNode.fromBase58(userPrv);
                keychainHdPath = bitcoin_1.hdPath(keychain);
                txb = bitcoin.TransactionBuilder.fromTransaction(transaction, self.network);
                self.prepareTransactionBuilder(txb);
                getSignatureContext = function (txPrebuild, index) {
                    var currentUnspent = txPrebuild.txInfo.unspents[index];
                    return {
                        inputIndex: index,
                        unspent: currentUnspent,
                        path: 'm/0/0/' + currentUnspent.chain + '/' + currentUnspent.index,
                        isP2wsh: !currentUnspent.redeemScript,
                        isBitGoTaintedUnspent: self.isBitGoTaintedUnspent(currentUnspent),
                        error: undefined,
                    };
                };
                signatureIssues = [];
                // Sign inputs
                for (index = 0; index < transaction.ins.length; ++index) {
                    debug('Signing input %d of %d', index + 1, transaction.ins.length);
                    signatureContext = getSignatureContext(txPrebuild, index);
                    if (signatureContext.isBitGoTaintedUnspent) {
                        debug('Skipping input %d of %d (unspent from replay protection address which is platform signed only)', index + 1, transaction.ins.length);
                        continue;
                    }
                    privKey = keychainHdPath.deriveKey(signatureContext.path);
                    privKey.network = self.network;
                    debug('Input details: %O', signatureContext);
                    sigHashType = self.defaultSigHashType;
                    try {
                        if (signatureContext.isP2wsh) {
                            debug('Signing p2wsh input');
                            witnessScript = Buffer.from(signatureContext.unspent.witnessScript, 'hex');
                            witnessScriptHash = bitcoin.crypto.sha256(witnessScript);
                            prevOutScript = bitcoin.script.witnessScriptHash.output.encode(witnessScriptHash);
                            txb.sign(index, privKey, prevOutScript, sigHashType, signatureContext.unspent.value, witnessScript);
                        }
                        else {
                            subscript = new Buffer(signatureContext.unspent.redeemScript, 'hex');
                            isP2shP2wsh = !!signatureContext.unspent.witnessScript;
                            if (isP2shP2wsh) {
                                debug('Signing p2shP2wsh input');
                                witnessScript = Buffer.from(signatureContext.unspent.witnessScript, 'hex');
                                txb.sign(index, privKey, subscript, sigHashType, signatureContext.unspent.value, witnessScript);
                            }
                            else {
                                debug('Signing p2sh input');
                                txb.sign(index, privKey, subscript, sigHashType, signatureContext.unspent.value);
                            }
                        }
                    }
                    catch (e) {
                        debug('Failed to sign input:', e);
                        signatureContext.error = e;
                        signatureIssues.push(signatureContext);
                        continue;
                    }
                    debug('Successfully signed input %d of %d', index + 1, transaction.ins.length);
                }
                if (isLastSignature) {
                    transaction = txb.build();
                }
                else {
                    transaction = txb.buildIncomplete();
                }
                // Verify input signatures
                for (index = 0; index < transaction.ins.length; ++index) {
                    debug('Verifying input signature %d of %d', index + 1, transaction.ins.length);
                    signatureContext = getSignatureContext(txPrebuild, index);
                    if (signatureContext.isBitGoTaintedUnspent) {
                        debug('Skipping input signature %d of %d (unspent from replay protection address which is platform signed only)', index + 1, transaction.ins.length);
                        continue;
                    }
                    if (signatureContext.isP2wsh) {
                        transaction.setInputScript(index, Buffer.alloc(0));
                    }
                    isValidSignature = self.verifySignature(transaction, index, signatureContext.unspent.value);
                    if (!isValidSignature) {
                        debug('Invalid signature');
                        signatureContext.error = new Error('invalid signature');
                        signatureIssues.push(signatureContext);
                    }
                }
                if (signatureIssues.length > 0) {
                    failedIndices = signatureIssues.map(function (currentIssue) { return currentIssue.inputIndex; });
                    error = new Error("Failed to sign inputs at indices " + failedIndices.join(', '));
                    error.code = 'input_signature_failure';
                    error.signingErrors = signatureIssues;
                    throw error;
                }
                return [2 /*return*/, {
                        txHex: transaction.toBuffer().toString('hex'),
                    }];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Always false for coins other than BCH and TBCH.
     * @param unspent
     * @returns {boolean}
     */
    AbstractUtxoCoin.prototype.isBitGoTaintedUnspent = function (unspent) {
        return false;
    };
    /**
     * Modify the transaction builder to comply with the specific coin's requirements such as version and branch id
     * @param txBuilder
     * @returns {*}
     */
    AbstractUtxoCoin.prototype.prepareTransactionBuilder = function (txBuilder) {
        return txBuilder;
    };
    Object.defineProperty(AbstractUtxoCoin.prototype, "defaultSigHashType", {
        /**
         * Get the default sighash type to be used when signing transactions
         * @returns {number}
         */
        get: function () {
            return bitcoin.Transaction.SIGHASH_ALL;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Parse a transaction's signature script to obtain public keys, signatures, the sig script, and other properties
     * @param transaction
     * @param inputIndex
     * @returns { isSegwitInput: boolean, inputClassification: string, signatures: [Buffer], publicKeys: [Buffer], pubScript: Buffer }
     */
    AbstractUtxoCoin.prototype.parseSignatureScript = function (transaction, inputIndex) {
        var currentInput = transaction.ins[inputIndex];
        var isSegwitInput = currentInput.witness.length > 0;
        var isNativeSegwitInput = currentInput.script.length === 0;
        var decompiledSigScript, inputClassification;
        if (isSegwitInput) {
            // The decompiledSigScript is the script containing the signatures, public keys, and the script that was committed
            // to (pubScript). If this is a segwit input the decompiledSigScript is in the witness, regardless of whether it
            // is native or not. The inputClassification is determined based on whether or not the input is native to give an
            // accurate classification. Note that p2shP2wsh inputs will be classified as p2sh and not p2wsh.
            decompiledSigScript = currentInput.witness;
            if (isNativeSegwitInput) {
                inputClassification = bitcoin.script.classifyWitness(bitcoin.script.compile(decompiledSigScript), true);
            }
            else {
                inputClassification = bitcoin.script.classifyInput(currentInput.script, true);
            }
        }
        else {
            inputClassification = bitcoin.script.classifyInput(currentInput.script, true);
            decompiledSigScript = bitcoin.script.decompile(currentInput.script);
        }
        if (inputClassification === bitcoin.script.types.P2PKH) {
            var signature = decompiledSigScript[0], publicKey = decompiledSigScript[1];
            var publicKeys = [publicKey];
            var signatures = [signature];
            var pubScript = bitcoin.script.pubKeyHash.output.encode(bitcoin.crypto.hash160(publicKey));
            return { isSegwitInput: isSegwitInput, inputClassification: inputClassification, signatures: signatures, publicKeys: publicKeys, pubScript: pubScript };
        }
        else if (inputClassification === bitcoin.script.types.P2SH
            || inputClassification === bitcoin.script.types.P2WSH) {
            // Note the assumption here that if we have a p2sh or p2wsh input it will be multisig (appropriate because the
            // BitGo platform only supports multisig within these types of inputs). Signatures are all but the last entry in
            // the decompiledSigScript. The redeemScript/witnessScript (depending on which type of input this is) is the last
            // entry in the decompiledSigScript (denoted here as the pubScript). The public keys are the second through
            // antepenultimate entries in the decompiledPubScript. See below for a visual representation of the typical 2-of-3
            // multisig setup:
            //
            // decompiledSigScript = 0 <sig1> <sig2> <pubScript>
            // decompiledPubScript = 2 <pub1> <pub2> <pub3> 3 OP_CHECKMULTISIG
            var signatures = decompiledSigScript.slice(0, -1);
            var pubScript = _.last(decompiledSigScript);
            var decompiledPubScript = bitcoin.script.decompile(pubScript);
            var publicKeys = decompiledPubScript.slice(1, -2);
            // Op codes 81 through 96 represent numbers 1 through 16 (see https://en.bitcoin.it/wiki/Script#Opcodes), which is
            // why we subtract by 80 to get the number of signatures (n) and the number of public keys (m) in an n-of-m setup.
            var len = decompiledPubScript.length;
            var nSignatures = decompiledPubScript[0] - 80;
            var nPubKeys = decompiledPubScript[len - 2] - 80;
            // Due to a bug in the implementation of multisignature in the bitcoin protocol, a 0 is added to the signature
            // script, so we add 1 when asserting the number of signatures matches the number of signatures expected by the
            // pub script. Also, note that we consider a signature script with the the same number of signatures as public
            // keys (+1 as noted above) valid because we use placeholder signatures when parsing a half-signed signature
            // script.
            if (signatures.length !== nSignatures + 1 && signatures.length !== nPubKeys + 1) {
                throw new Error("expected " + nSignatures + " or " + nPubKeys + " signatures, got " + (signatures.length - 1));
            }
            if (publicKeys.length !== nPubKeys) {
                throw new Error("expected " + nPubKeys + " public keys, got " + publicKeys.length);
            }
            var lastOpCode = decompiledPubScript[len - 1];
            if (lastOpCode !== bitcoin.opcodes.OP_CHECKMULTISIG) {
                throw new Error("expected opcode #" + bitcoin.opcodes.OP_CHECKMULTISIG + ", got opcode #" + lastOpCode);
            }
            return { isSegwitInput: isSegwitInput, inputClassification: inputClassification, signatures: signatures, publicKeys: publicKeys, pubScript: pubScript };
        }
        else {
            return { isSegwitInput: isSegwitInput, inputClassification: inputClassification };
        }
    };
    /**
     * Calculate the hash to verify the signature against
     * @param transaction Transaction object
     * @param inputIndex
     * @param pubScript
     * @param amount The previous output's amount
     * @param hashType
     * @param isSegwitInput
     * @returns {*}
     */
    AbstractUtxoCoin.prototype.calculateSignatureHash = function (transaction, inputIndex, pubScript, amount, hashType, isSegwitInput) {
        if (isSegwitInput) {
            return transaction.hashForWitnessV0(inputIndex, pubScript, amount, hashType);
        }
        else {
            return transaction.hashForSignature(inputIndex, pubScript, hashType);
        }
    };
    /**
     * Verify the signature on a (half-signed) transaction
     * @param transaction bitcoinjs-lib tx object
     * @param inputIndex The input whererfore to check the signature
     * @param amount For segwit and BCH, the input amount needs to be known for signature verification
     * @param verificationSettings
     * @param verificationSettings.signatureIndex The index of the signature to verify (only iterates over non-empty signatures)
     * @param verificationSettings.publicKey The hex of the public key to verify (will verify all signatures)
     * @returns {boolean}
     */
    AbstractUtxoCoin.prototype.verifySignature = function (transaction, inputIndex, amount, verificationSettings) {
        if (verificationSettings === void 0) { verificationSettings = {}; }
        var _a = this.parseSignatureScript(transaction, inputIndex), signatures = _a.signatures, publicKeys = _a.publicKeys, isSegwitInput = _a.isSegwitInput, inputClassification = _a.inputClassification, pubScript = _a.pubScript;
        if (![bitcoin.script.types.P2WSH, bitcoin.script.types.P2SH, bitcoin.script.types.P2PKH].includes(inputClassification)) {
            return false;
        }
        if (!publicKeys || publicKeys.length === 0) {
            return false;
        }
        if (isSegwitInput && !amount) {
            return false;
        }
        // get the first non-empty signature and verify it against all public keys
        var nonEmptySignatures = _.filter(signatures, function (s) { return !_.isEmpty(s); });
        /*
        We either want to verify all signature/pubkey combinations, or do an explicit combination
    
        If a signature index is specified, only that signature is checked. It's verified against all public keys.
        If a single public key is found to be valid, the function returns true.
    
        If a public key is specified, we iterate over all signatures. If a single one matches the public key, the function
        returns true.
    
        If neither is specified, all signatures are checked against all public keys. Each signature must have its own distinct
        public key that it matches for the function to return true.
         */
        var signaturesToCheck = nonEmptySignatures;
        if (!_.isUndefined(verificationSettings.signatureIndex)) {
            signaturesToCheck = [nonEmptySignatures[verificationSettings.signatureIndex]];
        }
        var publicKeyHex = verificationSettings.publicKey;
        var matchedPublicKeyIndices = {};
        var areAllSignaturesValid = true;
        // go over all signatures
        for (var _i = 0, signaturesToCheck_1 = signaturesToCheck; _i < signaturesToCheck_1.length; _i++) {
            var signatureBuffer = signaturesToCheck_1[_i];
            var isSignatureValid = false;
            var hasSignatureBuffer = Buffer.isBuffer(signatureBuffer) && signatureBuffer.length > 0;
            if (hasSignatureBuffer && Buffer.isBuffer(pubScript) && pubScript.length > 0) {
                // slice the last byte from the signature hash input because it's the hash type
                var signature = bitcoin.ECSignature.fromDER(signatureBuffer.slice(0, -1));
                var hashType = _.last(signatureBuffer);
                if (!hashType) {
                    // missing hashType byte - signature cannot be validated
                    return false;
                }
                var signatureHash = this.calculateSignatureHash(transaction, inputIndex, pubScript, amount, hashType, isSegwitInput);
                for (var publicKeyIndex = 0; publicKeyIndex < publicKeys.length; publicKeyIndex++) {
                    var publicKeyBuffer = publicKeys[publicKeyIndex];
                    if (!_.isUndefined(publicKeyHex) && publicKeyBuffer.toString('hex') !== publicKeyHex) {
                        // we are only looking to verify one specific public key's signature (publicKeyHex)
                        // this particular public key is not the one whose signature we're trying to verify
                        continue;
                    }
                    if (matchedPublicKeyIndices[publicKeyIndex]) {
                        continue;
                    }
                    var publicKey = bitcoin.ECPair.fromPublicKeyBuffer(publicKeyBuffer);
                    if (publicKey.verify(signatureHash, signature)) {
                        isSignatureValid = true;
                        matchedPublicKeyIndices[publicKeyIndex] = true;
                        break;
                    }
                }
            }
            if (!_.isUndefined(publicKeyHex) && isSignatureValid) {
                // We were trying to see if any of the signatures was valid for the given public key. Evidently yes.
                return true;
            }
            if (!isSignatureValid && _.isUndefined(publicKeyHex)) {
                return false;
            }
            areAllSignaturesValid = isSignatureValid && areAllSignaturesValid;
        }
        return areAllSignaturesValid;
    };
    /**
     * Decompose a raw transaction into useful information, such as the total amounts,
     * change amounts, and transaction outputs.
     * @param params
     * @param callback
     */
    AbstractUtxoCoin.prototype.explainTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            var txHex, transaction, id, changeAddresses, spendAmount, changeAmount, txInfo, explanation, unspentValues, inputSignatures;
            return __generator(this, function (_a) {
                txHex = _.get(params, 'txHex');
                if (!txHex || !_.isString(txHex) || !txHex.match(/^([a-f0-9]{2})+$/i)) {
                    throw new Error('invalid transaction hex, must be a valid hex string');
                }
                try {
                    transaction = bitcoin.Transaction.fromHex(txHex, self.network);
                }
                catch (e) {
                    throw new Error('failed to parse transaction hex');
                }
                id = transaction.getId();
                changeAddresses = [];
                spendAmount = 0;
                changeAmount = 0;
                txInfo = _.get(params, 'txInfo');
                if (txInfo && txInfo.changeAddresses) {
                    changeAddresses = txInfo.changeAddresses;
                }
                explanation = {
                    displayOrder: ['id', 'outputAmount', 'changeAmount', 'outputs', 'changeOutputs'],
                    id: id,
                    outputs: [],
                    changeOutputs: [],
                };
                transaction.outs.forEach(function (currentOutput) {
                    var currentAddress = self.getCoinLibrary().address.fromOutputScript(currentOutput.script, self.network);
                    var currentAmount = currentOutput.value;
                    if (changeAddresses.indexOf(currentAddress) !== -1) {
                        // this is change
                        changeAmount += currentAmount;
                        explanation.changeOutputs.push({
                            address: currentAddress,
                            amount: currentAmount,
                        });
                        return;
                    }
                    spendAmount += currentAmount;
                    explanation.outputs.push({
                        address: currentAddress,
                        amount: currentAmount,
                    });
                });
                explanation.outputAmount = spendAmount;
                explanation.changeAmount = changeAmount;
                // add fee info if available
                if (params.feeInfo) {
                    explanation.displayOrder.push('fee');
                    explanation.fee = params.feeInfo;
                }
                if (_.isInteger(transaction.locktime) && transaction.locktime > 0) {
                    explanation.locktime = transaction.locktime;
                    explanation.displayOrder.push('locktime');
                }
                unspentValues = {};
                inputSignatures = transaction.ins.map(function (input, idx) {
                    var hasSigScript = !_.isEmpty(input.script);
                    var hasWitnessScript = !_.isEmpty(input.witness);
                    if (!hasSigScript && !hasWitnessScript) {
                        // no sig script or witness data for this input
                        debug('no signature script or witness script data for input %s', idx);
                        return 0;
                    }
                    var parsedSigScript;
                    try {
                        parsedSigScript = self.parseSignatureScript(transaction, idx);
                    }
                    catch (e) {
                        return false;
                    }
                    if (hasWitnessScript) {
                        if (!txInfo || !txInfo.unspents) {
                            // segwit txs require input values, cannot validate signatures
                            debug('unable to retrieve input amounts from unspents - cannot validate segwit input signatures');
                            return 0;
                        }
                        // lazily populate unspent values
                        if (_.isEmpty(unspentValues)) {
                            txInfo.unspents.forEach(function (unspent) {
                                unspentValues[unspent.id] = unspent.value;
                            });
                        }
                    }
                    var nonEmptySignatures = parsedSigScript.signatures.filter(function (sig) { return !_.isEmpty(sig); });
                    var validSignatures = nonEmptySignatures.map(function (sig, sigIndex) {
                        if (_.isEmpty(sig)) {
                            return false;
                        }
                        var parentTxId = Buffer.from(input.hash).reverse().toString('hex');
                        var inputId = parentTxId + ":" + input.index;
                        var amount = unspentValues[inputId];
                        try {
                            return self.verifySignature(transaction, idx, amount, { signatureIndex: sigIndex });
                        }
                        catch (e) {
                            return false;
                        }
                    });
                    return validSignatures.reduce(function (validCount, isValid) { return isValid ? validCount + 1 : validCount; }, 0);
                });
                explanation.inputSignatures = inputSignatures;
                explanation.signatures = _.max(inputSignatures);
                return [2 /*return*/, explanation];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Create a multisig address of a given type from a list of keychains and a signing threshold
     * @param addressType
     * @param signatureThreshold
     * @param keys
     */
    AbstractUtxoCoin.prototype.createMultiSigAddress = function (addressType, signatureThreshold, keys) {
        function createWitnessProgram(inputScript) {
            var witnessScriptHash = bitcoin.crypto.sha256(inputScript);
            return bitcoin.script.witnessScriptHash.output.encode(witnessScriptHash);
        }
        var multiSigScript = bitcoin.script.multisig.output.encode(signatureThreshold, keys);
        var outputScript, redeemScript, witnessScript;
        switch (addressType) {
            case unspents_1.Codes.UnspentTypeTcomb('p2sh'):
                var multisigScriptHash = bitcoin.crypto.hash160(multiSigScript);
                outputScript = bitcoin.script.scriptHash.output.encode(multisigScriptHash);
                redeemScript = multiSigScript;
                break;
            case unspents_1.Codes.UnspentTypeTcomb('p2shP2wsh'):
                var witnessProgram = createWitnessProgram(multiSigScript);
                var witnessProgramHash = bitcoin.crypto.hash160(witnessProgram);
                outputScript = bitcoin.script.scriptHash.output.encode(witnessProgramHash);
                redeemScript = witnessProgram;
                witnessScript = multiSigScript;
                break;
            case unspents_1.Codes.UnspentTypeTcomb('p2wsh'):
                outputScript = createWitnessProgram(multiSigScript);
                witnessScript = multiSigScript;
                break;
            default:
                throw new Error("unexpected addressType " + addressType);
        }
        return {
            outputScript: outputScript,
            redeemScript: redeemScript,
            witnessScript: witnessScript,
            address: bitcoin.address.fromOutputScript(outputScript, this.network),
        };
    };
    /**
     * @param scriptHashScript
     * @deprecated
     */
    // TODO(BG-11638): remove in next SDK major version release
    AbstractUtxoCoin.prototype.calculateRecoveryAddress = function (scriptHashScript) {
        return this.getCoinLibrary().address.fromOutputScript(scriptHashScript, this.network);
    };
    /**
     * Get a static fee rate which is used in recovery situations
     * @deprecated
     */
    AbstractUtxoCoin.prototype.getRecoveryFeePerBytes = function () {
        return Bluebird.resolve(100);
    };
    /**
     * Get a url which can be used for determining recovery fee rates
     */
    AbstractUtxoCoin.prototype.getRecoveryFeeRecommendationApiBaseUrl = function () {
        return Bluebird.reject(new Error('AbtractUtxoCoin method not implemented'));
    };
    /**
     * Get the current market price from a third party to be used for recovery
     */
    AbstractUtxoCoin.prototype.getRecoveryMarketPrice = function () {
        var self = this;
        return co(function getRecoveryMarketPrice() {
            var familyNamesToCoinGeckoIds, coinGeckoId, coinGeckoUrl, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        familyNamesToCoinGeckoIds = new Map()
                            .set('BTC', 'bitcoin')
                            .set('LTC', 'litecoin')
                            .set('BCH', 'bitcoin-cash')
                            .set('ZEC', 'zcash')
                            .set('DASH', 'dash');
                        coinGeckoId = familyNamesToCoinGeckoIds.get(self.getFamily().toUpperCase());
                        if (!coinGeckoId) {
                            throw new Error("There is no CoinGecko id for family name " + self.getFamily().toUpperCase() + ".");
                        }
                        coinGeckoUrl = config.coinGeckoBaseUrl + ("simple/price?ids=" + coinGeckoId + "&vs_currencies=USD");
                        return [4 /*yield*/, request.get(coinGeckoUrl).retry(2).result()];
                    case 1:
                        response = _a.sent();
                        // An example of response
                        // {
                        //   "ethereum": {
                        //     "usd": 220.64
                        //   }
                        // }
                        if (!response) {
                            throw new Error('Unable to reach Coin Gecko API for price data');
                        }
                        if (!response[coinGeckoId]['usd'] || typeof response[coinGeckoId]['usd'] !== 'number') {
                            throw new Error('Unexpected response from Coin Gecko API for price data');
                        }
                        return [2 /*return*/, response[coinGeckoId]['usd']];
                }
            });
        }).call(this);
    };
    /**
     * Helper function for recover()
     * This transforms the txInfo from recover into the format that offline-signing-tool expects
     * @param txInfo
     * @param txHex
     * @returns {{txHex: *, txInfo: {unspents: *}, feeInfo: {}, coin: void}}
     */
    AbstractUtxoCoin.prototype.formatForOfflineVault = function (txInfo, txHex) {
        var response = {
            txHex: txHex,
            txInfo: {
                unspents: txInfo.inputs,
            },
            feeInfo: {},
            coin: this.getChain(),
        };
        _.map(response.txInfo.unspents, function (unspent) {
            var pathArray = unspent.chainPath.split('/');
            // Note this code works because we assume our chainPath is m/0/0/chain/index - this will be incorrect for custom derivation schemes
            unspent.index = pathArray[4];
            unspent.chain = pathArray[3];
        });
        return response;
    };
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * - userKey: [encrypted] xprv, or xpub
     * - backupKey: [encrypted] xprv, or xpub if the xprv is held by a KRS provider
     * - walletPassphrase: necessary if one of the xprvs is encrypted
     * - bitgoKey: xpub
     * - krsProvider: necessary if backup key is held by KRS
     * - recoveryDestination: target address to send recovered funds to
     * - scan: the amount of consecutive addresses without unspents to scan through before stopping
     * - ignoreAddressTypes: (optional) array of AddressTypes to ignore, these are strings defined in Codes.UnspentTypeTcomb
     *        for example: ['p2shP2wsh', 'p2wsh'] will prevent code from checking for wrapped-segwit and native-segwit chains on the public block explorers
     * @param callback
     */
    AbstractUtxoCoin.prototype.recover = function (params, callback) {
        var self = this;
        return co(function recover() {
            // ============================HELPER FUNCTIONS============================
            function deriveKeys(keyArray, index) {
                return keyArray.map(function (k) { return k.derive(index); });
            }
            function queryBlockchainUnspentsPath(keyArray, basePath, addressesById) {
                return co(function () {
                    var MAX_SEQUENTIAL_ADDRESSES_WITHOUT_TXS, numSequentialAddressesWithoutTxs, gatherUnspents, walletUnspents;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                MAX_SEQUENTIAL_ADDRESSES_WITHOUT_TXS = params.scan || 20;
                                numSequentialAddressesWithoutTxs = 0;
                                gatherUnspents = co(function coGatherUnspents(addrIndex) {
                                    var derivedKeys, chain, keys, address, addrInfo, addressUnspents;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                derivedKeys = deriveKeys(keyArray, addrIndex);
                                                chain = Number(basePath.split('/').pop());
                                                keys = derivedKeys.map(function (k) { return k.getPublicKeyBuffer(); });
                                                address = self.createMultiSigAddress(unspents_1.Codes.typeForCode(chain), 2, keys);
                                                return [4 /*yield*/, self.getAddressInfoFromExplorer(address.address)];
                                            case 1:
                                                addrInfo = _a.sent();
                                                if (!(addrInfo.txCount === 0)) return [3 /*break*/, 2];
                                                numSequentialAddressesWithoutTxs++;
                                                return [3 /*break*/, 4];
                                            case 2:
                                                numSequentialAddressesWithoutTxs = 0;
                                                if (!(addrInfo.totalBalance > 0)) return [3 /*break*/, 4];
                                                // This address has a balance.
                                                address.chainPath = basePath + '/' + addrIndex;
                                                address.userKey = derivedKeys[0];
                                                address.backupKey = derivedKeys[1];
                                                addressesById[address.address] = address;
                                                return [4 /*yield*/, self.getUnspentInfoFromExplorer(address.address)];
                                            case 3:
                                                addressUnspents = _a.sent();
                                                addressUnspents.forEach(function addAddressToUnspent(unspent) {
                                                    unspent.address = address.address;
                                                    walletUnspents.push(unspent);
                                                });
                                                _a.label = 4;
                                            case 4:
                                                if (numSequentialAddressesWithoutTxs >= MAX_SEQUENTIAL_ADDRESSES_WITHOUT_TXS) {
                                                    // stop searching for addresses with unspents in them, we've found 5 in a row with none
                                                    // we are done
                                                    return [2 /*return*/];
                                                }
                                                return [2 /*return*/, gatherUnspents(addrIndex + 1)];
                                        }
                                    });
                                });
                                walletUnspents = [];
                                // This will populate walletAddresses
                                return [4 /*yield*/, gatherUnspents(0)];
                            case 1:
                                // This will populate walletAddresses
                                _a.sent();
                                if (walletUnspents.length === 0) {
                                    // Couldn't find any addresses with funds
                                    return [2 /*return*/, []];
                                }
                                return [2 /*return*/, walletUnspents];
                        }
                    });
                }).call(this);
            }
            var isKrsRecovery, isUnsignedSweep, krsProvider, keys, baseKeyPath, queries, addressesById, queryResponses, unspents, totalInputAmount, transactionBuilder, txInfo, feePerByte, outputSize, approximateSize, approximateFee, recoveryAmount, krsFee, err_1, krsFeeAddress, txHex, signedTx, _a, e_2;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        // ============================LOGIC============================
                        if (_.isUndefined(params.userKey)) {
                            throw new Error('missing userKey');
                        }
                        if (_.isUndefined(params.backupKey)) {
                            throw new Error('missing backupKey');
                        }
                        if (_.isUndefined(params.recoveryDestination) || !self.isValidAddress(params.recoveryDestination)) {
                            throw new Error('invalid recoveryDestination');
                        }
                        if (!_.isUndefined(params.scan) && (!_.isInteger(params.scan) || params.scan < 0)) {
                            throw new Error('scan must be a positive integer');
                        }
                        isKrsRecovery = params.backupKey.startsWith('xpub') && !params.userKey.startsWith('xpub');
                        isUnsignedSweep = params.backupKey.startsWith('xpub') && params.userKey.startsWith('xpub');
                        krsProvider = config.krsProviders[params.krsProvider];
                        if (isKrsRecovery && _.isUndefined(krsProvider)) {
                            throw new Error('unknown key recovery service provider');
                        }
                        if (isKrsRecovery && !(krsProvider.supportedCoins.includes(self.getFamily()))) {
                            throw new Error('specified key recovery service does not support recoveries for this coin');
                        }
                        return [4 /*yield*/, self.initiateRecovery(params)];
                    case 1:
                        keys = _b.sent();
                        baseKeyPath = deriveKeys(deriveKeys(keys, 0), 0);
                        queries = [];
                        addressesById = {};
                        _.forEach(Object.keys(unspents_1.Codes.UnspentTypeTcomb.meta.map), function (addressType) {
                            // If we aren't ignoring the address type, we derive the public key and construct the query for the external and
                            // internal indices
                            if (!_.includes(params.ignoreAddressTypes, addressType)) {
                                if (addressType === unspents_1.Codes.UnspentTypeTcomb('p2shP2wsh') && !self.supportsP2shP2wsh()) {
                                    // P2shP2wsh is not supported. Skip.
                                    return;
                                }
                                if (addressType === unspents_1.Codes.UnspentTypeTcomb('p2wsh') && !self.supportsP2wsh()) {
                                    // P2wsh is not supported. Skip.
                                    return;
                                }
                                var codes = void 0;
                                try {
                                    codes = unspents_1.Codes.forType(unspents_1.Codes.UnspentTypeTcomb(addressType));
                                }
                                catch (e) {
                                    // The unspent type is not supported by bitgo so attempting to get its chain codes throws. Catch that error
                                    // and continue.
                                    return;
                                }
                                var externalChainCode = codes.external;
                                var internalChainCode = codes.internal;
                                var externalKey = deriveKeys(baseKeyPath, externalChainCode);
                                var internalKey = deriveKeys(baseKeyPath, internalChainCode);
                                queries.push(queryBlockchainUnspentsPath(externalKey, '/0/0/' + externalChainCode, addressesById));
                                queries.push(queryBlockchainUnspentsPath(internalKey, '/0/0/' + internalChainCode, addressesById));
                            }
                        });
                        return [4 /*yield*/, Promise.all(queries)];
                    case 2:
                        queryResponses = _b.sent();
                        unspents = _.flatten(queryResponses);
                        totalInputAmount = _.sumBy(unspents, 'amount');
                        if (totalInputAmount <= 0) {
                            throw new Error('No input to recover - aborting!');
                        }
                        transactionBuilder = new bitcoin.TransactionBuilder(self.network);
                        self.prepareTransactionBuilder(transactionBuilder);
                        txInfo = {};
                        return [4 /*yield*/, self.getRecoveryFeePerBytes()];
                    case 3:
                        feePerByte = _b.sent();
                        outputSize = (isKrsRecovery ? 2 : 1) * unspents_1.VirtualSizes.txP2wshOutputSize;
                        approximateSize = unspents_1.VirtualSizes.txSegOverheadVSize + outputSize + (unspents_1.VirtualSizes.txP2shInputSize * unspents.length);
                        approximateFee = approximateSize * feePerByte;
                        // Construct a transaction
                        txInfo.inputs = unspents.map(function addInputForUnspent(unspent) {
                            var address = addressesById[unspent.address];
                            transactionBuilder.addInput(unspent.txid, unspent.n, 0xffffffff, address.outputScript);
                            return {
                                chainPath: address.chainPath,
                                redeemScript: address.redeemScript && address.redeemScript.toString('hex'),
                                witnessScript: address.witnessScript && address.witnessScript.toString('hex'),
                                value: unspent.amount,
                            };
                        });
                        recoveryAmount = totalInputAmount - approximateFee;
                        if (!isKrsRecovery) return [3 /*break*/, 7];
                        _b.label = 4;
                    case 4:
                        _b.trys.push([4, 6, , 7]);
                        return [4 /*yield*/, self.calculateFeeAmount({ provider: params.krsProvider, amount: recoveryAmount })];
                    case 5:
                        krsFee = _b.sent();
                        recoveryAmount -= krsFee;
                        return [3 /*break*/, 7];
                    case 6:
                        err_1 = _b.sent();
                        // Don't let this error block the recovery -
                        console.dir(err_1);
                        return [3 /*break*/, 7];
                    case 7:
                        if (recoveryAmount < 0) {
                            throw new Error('this wallet\'s balance is too low to pay the fees specified by the KRS provider');
                        }
                        transactionBuilder.addOutput(params.recoveryDestination, recoveryAmount);
                        if (isKrsRecovery && krsFee > 0) {
                            krsFeeAddress = krsProvider.feeAddresses[self.getChain()];
                            if (!krsFeeAddress) {
                                throw new Error('this KRS provider has not configured their fee structure yet - recovery cannot be completed');
                            }
                            transactionBuilder.addOutput(krsFeeAddress, krsFee);
                        }
                        if (!isUnsignedSweep) return [3 /*break*/, 8];
                        txHex = transactionBuilder.buildIncomplete().toBuffer().toString('hex');
                        return [2 /*return*/, self.formatForOfflineVault(txInfo, txHex)];
                    case 8:
                        signedTx = self.signRecoveryTransaction(transactionBuilder, unspents, addressesById, !isKrsRecovery);
                        txInfo.transactionHex = signedTx.build().toBuffer().toString('hex');
                        _b.label = 9;
                    case 9:
                        _b.trys.push([9, 11, , 12]);
                        _a = txInfo;
                        return [4 /*yield*/, self.verifyRecoveryTransaction(txInfo)];
                    case 10:
                        _a.tx = _b.sent();
                        return [3 /*break*/, 12];
                    case 11:
                        e_2 = _b.sent();
                        if (!(e_2 instanceof errors.MethodNotImplementedError)) {
                            // some coins don't have a reliable third party verification endpoint, so we continue without verification for those coins
                            throw new Error('could not verify recovery transaction');
                        }
                        return [3 /*break*/, 12];
                    case 12:
                        if (isKrsRecovery) {
                            txInfo.coin = self.getChain();
                            txInfo.backupKey = params.backupKey;
                            txInfo.recoveryAmount = recoveryAmount;
                        }
                        return [2 /*return*/, txInfo];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Apply signatures to a funds recovery transaction using user + backup key
     * @param txb {Object} a transaction builder object (with inputs and outputs)
     * @param unspents {Array} the unspents to use in the transaction
     * @param addresses {Array} the address and redeem script info for the unspents
     * @param cosign {Boolean} whether to cosign this transaction with the user's backup key (false if KRS recovery)
     * @returns the transaction builder originally passed in as the first argument
     */
    AbstractUtxoCoin.prototype.signRecoveryTransaction = function (txb, unspents, addresses, cosign) {
        var _this = this;
        var signatureIssues = [];
        unspents.forEach(function (unspent, i) {
            var address = addresses[unspent.address];
            var backupPrivateKey = address.backupKey.keyPair;
            var userPrivateKey = address.userKey.keyPair;
            // force-override networks
            backupPrivateKey.network = _this.network;
            userPrivateKey.network = _this.network;
            var currentSignatureIssue = {
                inputIndex: i,
                unspent: unspent,
                error: null,
            };
            if (cosign) {
                try {
                    txb.sign(i, backupPrivateKey, address.redeemScript, _this.defaultSigHashType, unspent.amount, address.witnessScript);
                }
                catch (e) {
                    currentSignatureIssue.error = e;
                    signatureIssues.push(currentSignatureIssue);
                }
            }
            try {
                txb.sign(i, userPrivateKey, address.redeemScript, _this.defaultSigHashType, unspent.amount, address.witnessScript);
            }
            catch (e) {
                currentSignatureIssue.error = e;
                signatureIssues.push(currentSignatureIssue);
            }
        });
        if (signatureIssues.length > 0) {
            var failedIndices = signatureIssues.map(function (currentIssue) { return currentIssue.inputIndex; });
            var error = new Error("Failed to sign inputs at indices " + failedIndices.join(', '));
            error.code = 'input_signature_failure';
            error.signingErrors = signatureIssues;
            throw error;
        }
        return txb;
    };
    /**
     * Calculates the amount (in base units) to pay a KRS provider when building a recovery transaction
     * @param params
     * @param params.provider {String} the KRS provider that holds the backup key
     * @param params.amount {Number} amount (in base units) to be recovered
     * @param callback
     * @returns {*}
     */
    AbstractUtxoCoin.prototype.calculateFeeAmount = function (params, callback) {
        var self = this;
        return co(function calculateFeeAmount() {
            var krsProvider, feeAmountUsd, currentPrice;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        krsProvider = config.krsProviders[params.provider];
                        if (krsProvider === undefined) {
                            throw new Error("no fee structure specified for provider " + params.provider);
                        }
                        if (!(krsProvider.feeType === 'flatUsd')) return [3 /*break*/, 2];
                        feeAmountUsd = krsProvider.feeAmount;
                        return [4 /*yield*/, self.getRecoveryMarketPrice()];
                    case 1:
                        currentPrice = _a.sent();
                        return [2 /*return*/, Math.round(feeAmountUsd / currentPrice * self.getBaseFactor())];
                    case 2: 
                    // we can add more fee structures here as needed for different providers, such as percentage of recovery amount
                    throw new Error('Fee structure not implemented');
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Recover BTC that was sent to the wrong chain
     * @param params
     * @param params.txid The txid of the faulty transaction
     * @param params.recoveryAddress address to send recovered funds to
     * @param params.wallet the wallet that received the funds
     * @param params.recoveryCoin the coin type of the wallet that received the funds
     * @param params.signed return a half-signed transaction (default=true)
     * @param params.walletPassphrase the wallet passphrase
     * @param params.xprv the unencrypted xprv (used instead of wallet passphrase)
     * @param callback
     * @returns {*}
     */
    AbstractUtxoCoin.prototype.recoverFromWrongChain = function (params, callback) {
        var self = this;
        return co(function recoverFromWrongChain() {
            var txid, recoveryAddress, wallet, walletPassphrase, xprv, recoveryCoin, signed, sourceCoinFamily, recoveryCoinFamily, supportedRecoveryCoins, recoveryTool;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        txid = params.txid, recoveryAddress = params.recoveryAddress, wallet = params.wallet, walletPassphrase = params.walletPassphrase, xprv = params.xprv;
                        recoveryCoin = params.coin || params.recoveryCoin;
                        if (!recoveryCoin) {
                            throw new Error('missing required object recoveryCoin');
                        }
                        signed = params.signed !== false;
                        sourceCoinFamily = self.getFamily();
                        recoveryCoinFamily = recoveryCoin.getFamily();
                        supportedRecoveryCoins = config.supportedCrossChainRecoveries[sourceCoinFamily];
                        if (_.isUndefined(supportedRecoveryCoins) || !supportedRecoveryCoins.includes(recoveryCoinFamily)) {
                            throw new Error("Recovery of " + sourceCoinFamily + " balances from " + recoveryCoinFamily + " wallets is not supported.");
                        }
                        recoveryTool = new recovery_1.CrossChainRecoveryTool({
                            bitgo: self.bitgo,
                            sourceCoin: self,
                            recoveryCoin: recoveryCoin,
                            logging: false,
                        });
                        return [4 /*yield*/, recoveryTool.buildTransaction({
                                wallet: wallet,
                                faultyTxId: txid,
                                recoveryAddress: recoveryAddress,
                            })];
                    case 1:
                        _a.sent();
                        if (!signed) return [3 /*break*/, 3];
                        return [4 /*yield*/, recoveryTool.signTransaction({ passphrase: walletPassphrase, prv: xprv })];
                    case 2:
                        _a.sent();
                        return [2 /*return*/, recoveryTool.export()];
                    case 3: return [4 /*yield*/, recoveryTool.buildUnsigned()];
                    case 4: return [2 /*return*/, _a.sent()];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Generate secp256k1 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub and prv
     */
    AbstractUtxoCoin.prototype.generateKeyPair = function (seed) {
        if (!seed) {
            // An extended private key has both a normal 256 bit private key and a 256
            // bit chain code, both of which must be random. 512 bits is therefore the
            // maximum entropy and gives us maximum security against cracking.
            seed = crypto.randomBytes(512 / 8);
        }
        var extendedKey = bitcoin.HDNode.fromSeedBuffer(seed);
        var xpub = extendedKey.neutered().toBase58();
        return {
            pub: xpub,
            prv: extendedKey.toBase58(),
        };
    };
    AbstractUtxoCoin.prototype.getExtraPrebuildParams = function (buildParams, callback) {
        return Bluebird.resolve({}).asCallback(callback);
    };
    AbstractUtxoCoin.prototype.preCreateBitGo = function (params) { };
    AbstractUtxoCoin.prototype.presignTransaction = function (params, callback) {
        return Bluebird.resolve(params).asCallback(callback);
    };
    AbstractUtxoCoin.prototype.supplementGenerateWallet = function (walletParams, keychains) {
        return Bluebird.resolve(walletParams);
    };
    AbstractUtxoCoin.prototype.transactionDataAllowed = function () {
        return false;
    };
    AbstractUtxoCoin.prototype.valuelessTransferAllowed = function () {
        return false;
    };
    AbstractUtxoCoin.prototype.verifyRecoveryTransaction = function (txInfo) {
        return Bluebird.reject(new errors.MethodNotImplementedError());
    };
    AbstractUtxoCoin.prototype.signMessage = function (key, message, callback) {
        return co(function cosignMessage() {
            var privateKey, privateKeyBuffer, isCompressed, prefix;
            return __generator(this, function (_a) {
                privateKey = bitcoin.HDNode.fromBase58(key.prv).getKey();
                privateKeyBuffer = privateKey.d.toBuffer(32);
                isCompressed = privateKey.compressed;
                prefix = bitcoin.networks.bitcoin.messagePrefix;
                return [2 /*return*/, bitcoinMessage.sign(message, privateKeyBuffer, isCompressed, prefix)];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    return AbstractUtxoCoin;
}(baseCoin_1.BaseCoin));
exports.AbstractUtxoCoin = AbstractUtxoCoin;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWJzdHJhY3RVdHhvQ29pbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy92Mi9jb2lucy9hYnN0cmFjdFV0eG9Db2luLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHdDQUEwQztBQUMxQyxrREFBb0Q7QUFDcEQsbUNBQXFDO0FBQ3JDLCtCQUFpQztBQUNqQyxvQ0FBc0M7QUFDdEMsMEJBQTRCO0FBQzVCLGdDQUFrQztBQUNsQyw0Q0FBc0Q7QUFDdEQsb0RBQXlEO0FBRXpELHlDQUF1QztBQUV2Qyx3Q0FTcUI7QUFDckIsMENBQW9EO0FBRXBELHFDQUF1QztBQUN2Qyx3Q0FBcUQ7QUFDckQscUNBQXVDO0FBSXZDLElBQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxlQUFlLENBQUMsQ0FBQztBQUN4QyxJQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDO0FBMkw5QjtJQUErQyxvQ0FBUTtJQUtyRCwwQkFBc0IsS0FBWSxFQUFFLE9BQW9CO1FBQXhELFlBQ0Usa0JBQU0sS0FBSyxDQUFDLFNBS2I7UUFKQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUN4QixNQUFNLElBQUksS0FBSyxDQUFDLDJCQUEyQixDQUFDLENBQUM7U0FDOUM7UUFDRCxLQUFJLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQzs7SUFDMUIsQ0FBQztJQUVELHNCQUFJLHFDQUFPO2FBQVg7WUFDRSxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDdkIsQ0FBQzs7O09BQUE7SUFFRCxzQkFBVyxxQ0FBaUI7YUFBNUI7WUFDRSxJQUFNLGlCQUFpQixHQUFrQixFQUFFLENBQUM7WUFDNUMsaURBQWlEO1lBQ2pELDhFQUE4RTtZQUM5RSw2Q0FBNkM7WUFDN0MsSUFBTSxlQUFlLEdBQWEsTUFBTSxDQUFDLElBQUksQ0FBQyxtQkFB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LEVBQUM7O1NBQzdFLENBQUM7YUFDQyxJQUFJLENBQUMsSUFBSSxDQUFDO2FBQ1YsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFDSCx1QkFBQztBQUFELENBQUMsQUF0eERELENBQStDLG1CQUFRLEdBc3hEdEQ7QUF0eERxQiw0Q0FBZ0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBiaXRjb2luIGZyb20gJ2JpdGdvLXV0eG8tbGliJztcbmltcG9ydCAqIGFzIGJpdGNvaW5NZXNzYWdlIGZyb20gJ2JpdGNvaW5qcy1tZXNzYWdlJztcbmltcG9ydCAqIGFzIEJsdWViaXJkIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCAqIGFzIGNyeXB0byBmcm9tICdjcnlwdG8nO1xuaW1wb3J0ICogYXMgcmVxdWVzdCBmcm9tICdzdXBlcmFnZW50JztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCAqIGFzIGRlYnVnTGliIGZyb20gJ2RlYnVnJztcbmltcG9ydCB7IENvZGVzLCBWaXJ0dWFsU2l6ZXMgfSBmcm9tICdAYml0Z28vdW5zcGVudHMnO1xuaW1wb3J0IHsgVW5zcGVudFR5cGUgfSBmcm9tICdAYml0Z28vdW5zcGVudHMvZGlzdC9jb2Rlcyc7XG5cbmltcG9ydCB7IGhkUGF0aCB9IGZyb20gJy4uLy4uL2JpdGNvaW4nO1xuaW1wb3J0IHsgQml0R28gfSBmcm9tICcuLi8uLi9iaXRnbyc7XG5pbXBvcnQge1xuICBCYXNlQ29pbiwgQWRkcmVzc0NvaW5TcGVjaWZpYyxcbiAgRXh0cmFQcmVidWlsZFBhcmFtc09wdGlvbnMsIEtleWNoYWluc1RyaXBsZXQsXG4gIFByZWNyZWF0ZUJpdEdvT3B0aW9ucywgUHJlc2lnblRyYW5zYWN0aW9uT3B0aW9ucywgU3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0T3B0aW9ucyxcbiAgVmVyaWZ5QWRkcmVzc09wdGlvbnMgYXMgQmFzZVZlcmlmeUFkZHJlc3NPcHRpb25zLFxuICBWZXJpZnlSZWNvdmVyeVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLFxuICBUcmFuc2FjdGlvblBhcmFtcyBhcyBCYXNlVHJhbnNhY3Rpb25QYXJhbXMsXG4gIFRyYW5zYWN0aW9uUHJlYnVpbGQgYXMgQmFzZVRyYW5zYWN0aW9uUHJlYnVpbGQsIFZlcmlmaWNhdGlvbk9wdGlvbnMsIFRyYW5zYWN0aW9uUmVjaXBpZW50LCBTaWduZWRUcmFuc2FjdGlvbixcbn0gZnJvbSAnLi4vYmFzZUNvaW4nO1xuaW1wb3J0IHsgS2V5Y2hhaW4sIEtleUluZGljZXMgfSBmcm9tICcuLi9rZXljaGFpbnMnO1xuaW1wb3J0IHsgTm9kZUNhbGxiYWNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0ICogYXMgY29uZmlnIGZyb20gJy4uLy4uL2NvbmZpZyc7XG5pbXBvcnQgeyBDcm9zc0NoYWluUmVjb3ZlcnlUb29sIH0gZnJvbSAnLi4vcmVjb3ZlcnknO1xuaW1wb3J0ICogYXMgZXJyb3JzIGZyb20gJy4uLy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBSZXF1ZXN0VHJhY2VyIH0gZnJvbSAnLi4vaW50ZXJuYWwvdXRpbCc7XG5pbXBvcnQgeyBXYWxsZXQgfSBmcm9tICcuLi93YWxsZXQnO1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnTGliKCdiaXRnbzp2Mjp1dHhvJyk7XG5jb25zdCBjbyA9IEJsdWViaXJkLmNvcm91dGluZTtcblxuZXhwb3J0IGludGVyZmFjZSBWZXJpZnlBZGRyZXNzT3B0aW9ucyBleHRlbmRzIEJhc2VWZXJpZnlBZGRyZXNzT3B0aW9ucyB7XG4gIGNoYWluOiBudW1iZXI7XG4gIGluZGV4OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3V0cHV0IHtcbiAgYWRkcmVzczogc3RyaW5nO1xuICBhbW91bnQ6IHN0cmluZyB8IG51bWJlcjtcbiAgZXh0ZXJuYWw/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zYWN0aW9uRmVlIHtcbiAgZmVlOiBudW1iZXI7XG4gIGZlZVJhdGU/OiBudW1iZXI7XG4gIHNpemU6IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zYWN0aW9uRXhwbGFuYXRpb24ge1xuICBkaXNwbGF5T3JkZXI6IHN0cmluZ1tdO1xuICBpZDogc3RyaW5nO1xuICBvdXRwdXRzOiBPdXRwdXRbXSxcbiAgY2hhbmdlT3V0cHV0czogT3V0cHV0W10sXG4gIG91dHB1dEFtb3VudDogc3RyaW5nO1xuICBjaGFuZ2VBbW91bnQ6IG51bWJlcjtcbiAgZmVlOiBUcmFuc2FjdGlvbkZlZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVbnNwZW50IHtcbiAgaWQ6IHN0cmluZyxcbiAgdmFsdWU6IHN0cmluZyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhIZXg6IHN0cmluZztcbiAgdHhJbmZvPzogeyBjaGFuZ2VBZGRyZXNzZXM6IHN0cmluZ1tdLCB1bnNwZW50czogVW5zcGVudFtdIH07XG4gIGZlZUluZm8/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXR4b05ldHdvcmsge1xuICBwdWJLZXlIYXNoOiBudW1iZXI7XG4gIHNjcmlwdEhhc2g6IG51bWJlcjtcbiAgYWx0U2NyaXB0SGFzaD86IG51bWJlcjtcbiAgYmVjaDMyOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFyc2VkU2lnbmF0dXJlU2NyaXB0IHtcbiAgaXNTZWd3aXRJbnB1dDogYm9vbGVhbjtcbiAgaW5wdXRDbGFzc2lmaWNhdGlvbjogc3RyaW5nO1xuICBzaWduYXR1cmVzPzogQnVmZmVyW107XG4gIHB1YmxpY0tleXM/OiBCdWZmZXJbXTtcbiAgcHViU2NyaXB0PzogQnVmZmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zYWN0aW9uUHJlYnVpbGQgZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25QcmVidWlsZCB7XG4gIHR4SW5mbz86IGFueTtcbiAgYmxvY2tIZWlnaHQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25QYXJhbXMgZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25QYXJhbXMge1xuICB3YWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xuICBjaGFuZ2VBZGRyZXNzPzogc3RyaW5nO1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eFBhcmFtczogVHJhbnNhY3Rpb25QYXJhbXM7XG4gIHR4UHJlYnVpbGQ6IFRyYW5zYWN0aW9uUHJlYnVpbGQ7XG4gIHdhbGxldDogV2FsbGV0O1xuICB2ZXJpZmljYXRpb24/OiBWZXJpZmljYXRpb25PcHRpb25zO1xuICByZXFJZD86IFJlcXVlc3RUcmFjZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFyc2VkVHJhbnNhY3Rpb24ge1xuICBrZXljaGFpbnM6IHtcbiAgICB1c2VyPzogS2V5Y2hhaW4sXG4gICAgYmFja3VwPzogS2V5Y2hhaW4sXG4gICAgYml0Z28/OiBLZXljaGFpbixcbiAgfTtcbiAga2V5U2lnbmF0dXJlczogYW55W107XG4gIG91dHB1dHM6IE91dHB1dFtdO1xuICBtaXNzaW5nT3V0cHV0czogT3V0cHV0W107XG4gIGV4cGxpY2l0RXh0ZXJuYWxPdXRwdXRzOiBPdXRwdXRbXTtcbiAgaW1wbGljaXRFeHRlcm5hbE91dHB1dHM6IE91dHB1dFtdO1xuICBjaGFuZ2VPdXRwdXRzOiBPdXRwdXRbXTtcbiAgZXhwbGljaXRFeHRlcm5hbFNwZW5kQW1vdW50OiBudW1iZXI7XG4gIGltcGxpY2l0RXh0ZXJuYWxTcGVuZEFtb3VudDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdlbmVyYXRlQWRkcmVzc09wdGlvbnMge1xuICBhZGRyZXNzVHlwZT86IHN0cmluZztcbiAga2V5Y2hhaW5zOiB7XG4gICAgcHViOiBzdHJpbmc7XG4gICAgYXNwS2V5SWQ/OiBzdHJpbmc7XG4gIH1bXTtcbiAgdGhyZXNob2xkOiBudW1iZXI7XG4gIGNoYWluPzogbnVtYmVyO1xuICBpbmRleDogbnVtYmVyO1xuICBzZWd3aXQ/OiBib29sZWFuO1xuICBiZWNoMzI/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFkZHJlc3NEZXRhaWxzIHtcbiAgYWRkcmVzczogc3RyaW5nO1xuICBjaGFpbjogbnVtYmVyO1xuICBpbmRleDogbnVtYmVyO1xuICBjb2luOiBzdHJpbmc7XG4gIGNvaW5TcGVjaWZpYzogQWRkcmVzc0NvaW5TcGVjaWZpYztcbiAgYWRkcmVzc1R5cGU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4UHJlYnVpbGQ6IHtcbiAgICB0eEhleDogc3RyaW5nO1xuICAgIHR4SW5mbzoge1xuICAgICAgdW5zcGVudHM6IHtcbiAgICAgICAgY2hhaW4/OiBudW1iZXI7XG4gICAgICAgIGluZGV4PzogbnVtYmVyO1xuICAgICAgICB2YWx1ZT86IG51bWJlcjtcbiAgICAgICAgYWRkcmVzcz86IHN0cmluZztcbiAgICAgICAgcmVkZWVtU2NyaXB0Pzogc3RyaW5nO1xuICAgICAgICB3aXRuZXNzU2NyaXB0Pzogc3RyaW5nO1xuICAgICAgfVtdO1xuICAgIH1cbiAgfTtcbiAgcHJ2OiBzdHJpbmc7XG4gIGlzTGFzdFNpZ25hdHVyZT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTXVsdGlTaWdBZGRyZXNzIHtcbiAgb3V0cHV0U2NyaXB0OiBCdWZmZXI7XG4gIHJlZGVlbVNjcmlwdDogQnVmZmVyO1xuICB3aXRuZXNzU2NyaXB0OiBCdWZmZXI7XG4gIGFkZHJlc3M6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPZmZsaW5lVmF1bHRUeEluZm8ge1xuICBpbnB1dHM6IHtcbiAgICBjaGFpblBhdGg6IHN0cmluZztcbiAgfVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlY292ZXJGcm9tV3JvbmdDaGFpbk9wdGlvbnMge1xuICB0eGlkOiBzdHJpbmc7XG4gIHJlY292ZXJ5QWRkcmVzczogc3RyaW5nO1xuICB3YWxsZXQ6IHN0cmluZztcbiAgd2FsbGV0UGFzc3BocmFzZTogc3RyaW5nO1xuICB4cHJ2OiBzdHJpbmc7XG4gIGNvaW4/OiBBYnN0cmFjdFV0eG9Db2luO1xuICByZWNvdmVyeUNvaW4/OiBBYnN0cmFjdFV0eG9Db2luO1xuICBzaWduZWQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZvcm1hdHRlZE9mZmxpbmVWYXVsdFR4SW5mbyB7XG4gIHR4SW5mbzoge1xuICAgIHVuc3BlbnRzOiB7XG4gICAgICBjaGFpblBhdGg6IHN0cmluZztcbiAgICAgIGluZGV4Pzogc3RyaW5nO1xuICAgICAgY2hhaW4/OiBzdHJpbmc7XG4gICAgfVtdO1xuICB9O1xuICB0eEhleDogc3RyaW5nO1xuICBmZWVJbmZvOiB7fTtcbiAgY29pbjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFkZHJlc3NJbmZvIHtcbiAgdHhDb3VudDogbnVtYmVyO1xuICB0b3RhbEJhbGFuY2U6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVbnNwZW50SW5mbyB7XG4gIGFkZHJlc3M6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWNvdmVyUGFyYW1zIHtcbiAgc2Nhbj86IG51bWJlcjtcbiAgdXNlcktleTogc3RyaW5nO1xuICBiYWNrdXBLZXk6IHN0cmluZztcbiAgcmVjb3ZlcnlEZXN0aW5hdGlvbjogc3RyaW5nO1xuICBrcnNQcm92aWRlcjogc3RyaW5nO1xuICBpZ25vcmVBZGRyZXNzVHlwZXM6IHN0cmluZ1tdO1xuICBiaXRnb0tleTogc3RyaW5nO1xuICB3YWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQWJzdHJhY3RVdHhvQ29pbiBleHRlbmRzIEJhc2VDb2luIHtcbiAgcHVibGljIGFsdFNjcmlwdEhhc2g/OiBudW1iZXI7XG4gIHB1YmxpYyBzdXBwb3J0QWx0U2NyaXB0RGVzdGluYXRpb24/OiBib29sZWFuO1xuICBwcml2YXRlIHJlYWRvbmx5IF9uZXR3b3JrOiBVdHhvTmV0d29yaztcblxuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoYml0Z286IEJpdEdvLCBuZXR3b3JrOiBVdHhvTmV0d29yaykge1xuICAgIHN1cGVyKGJpdGdvKTtcbiAgICBpZiAoIV8uaXNPYmplY3QobmV0d29yaykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbmV0d29yayBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIH1cbiAgICB0aGlzLl9uZXR3b3JrID0gbmV0d29yaztcbiAgfVxuXG4gIGdldCBuZXR3b3JrKCkge1xuICAgIHJldHVybiB0aGlzLl9uZXR3b3JrO1xuICB9XG5cbiAgc3RhdGljIGdldCB2YWxpZEFkZHJlc3NUeXBlcygpOiBVbnNwZW50VHlwZVtdIHtcbiAgICBjb25zdCB2YWxpZEFkZHJlc3NUeXBlczogVW5zcGVudFR5cGVbXSA9IFtdO1xuICAgIC8vIGJlc3Qgd2F5IEkgY291bGQgZmluZCB0byBsb29wIG92ZXIgZW51bSB2YWx1ZXNcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzE3MTk4I2lzc3VlY29tbWVudC00MjM4MzY2NThcbiAgICAvLyB0aGlzIGlzIGEgdHlwZXNjcmlwdCByb3VnaCBjb3JuZXIgZm9yIHN1cmVcbiAgICBjb25zdCB1bnNwZW50VHlwZUtleXM6IHN0cmluZ1tdID0gT2JqZWN0LmtleXMoVW5zcGVudFR5cGUpO1xuICAgIGNvbnN0IHVuc3BlbnRUeXBlczogVW5zcGVudFR5cGVbXSA9IHVuc3BlbnRUeXBlS2V5c1xuICAgICAgLm1hcChrID0+IFVuc3BlbnRUeXBlW2sgYXMgYW55XSlcbiAgICAgIC5tYXAodiA9PiB2IGFzIFVuc3BlbnRUeXBlKTtcbiAgICBmb3IgKGNvbnN0IGFkZHJlc3NUeXBlIG9mIHVuc3BlbnRUeXBlcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgQ29kZXMuZm9yVHlwZShhZGRyZXNzVHlwZSk7XG4gICAgICAgIHZhbGlkQWRkcmVzc1R5cGVzLnB1c2goYWRkcmVzc1R5cGUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBEbyBub3RoaW5nLiBDb2Rlcy5mb3JUeXBlIHdpbGwgdGhyb3cgaWYgdGhlIGFkZHJlc3MgdHlwZSBoYXMgbm8gY2hhaW4gY29kZXMsIG1lYW5pbmcgaXQgaXMgaW52YWxpZCBvbiB0aGVcbiAgICAgICAgLy8gQml0R28gcGxhdGZvcm0gYW5kIHNob3VsZCBub3QgYmUgYWRkZWQgdG8gdGhlIHZhbGlkQWRkcmVzc1R5cGVzIGFycmF5LlxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsaWRBZGRyZXNzVHlwZXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmFjdG9yIGJldHdlZW4gdGhlIGJhc2UgdW5pdCBhbmQgaXRzIHNtYWxsZXN0IHN1YmRpdmlzb25cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0QmFzZUZhY3RvcigpIHtcbiAgICByZXR1cm4gMWU4O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBpbnN0YW5jZSBvZiB0aGUgbGlicmFyeSB3aGljaCBjYW4gYmUgdXNlZCB0byBwZXJmb3JtIGxvdy1sZXZlbCBvcGVyYXRpb25zIGZvciB0aGlzIGNvaW5cbiAgICovXG4gIGdldENvaW5MaWJyYXJ5KCkge1xuICAgIHJldHVybiBiaXRjb2luO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciB0byBnZXQgdGhlIHZlcnNpb24gbnVtYmVyIGZvciBhbiBhZGRyZXNzXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0QWRkcmVzc1ZlcnNpb24oYWRkcmVzczogc3RyaW5nKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgICAvLyB0cnkgZGVjb2RpbmcgYXMgYmFzZTU4IGZpcnN0XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgdmVyc2lvbiB9ID0gdGhpcy5nZXRDb2luTGlicmFyeSgpLmFkZHJlc3MuZnJvbUJhc2U1OENoZWNrKGFkZHJlc3MpO1xuICAgICAgcmV0dXJuIHZlcnNpb247XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gaWYgdGhhdCBmYWlscywgYW5kIHdlIGFyZW4ndCBzdXBwb3J0aW5nIHAyd3NoLCB0aGVuIHdlIGFyZSBkb25lIGFuZCBkaWQgbm90IGZpbmQgYSB2ZXJzaW9uXG4gICAgICBpZiAoIXRoaXMuc3VwcG9ydHNQMndzaCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UsIHRyeSBkZWNvZGluZyBhcyBiZWNoMzJcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyB2ZXJzaW9uLCBwcmVmaXggfSA9IHRoaXMuZ2V0Q29pbkxpYnJhcnkoKS5hZGRyZXNzLmZyb21CZWNoMzIoYWRkcmVzcyk7XG4gICAgICBpZiAoXy5pc1N0cmluZyh0aGlzLm5ldHdvcmsuYmVjaDMyKSAmJiBwcmVmaXggPT09IHRoaXMubmV0d29yay5iZWNoMzIpIHtcbiAgICAgICAgcmV0dXJuIHZlcnNpb247XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gaWdub3JlIGVycm9ycywganVzdCBmYWxsIHRocm91Z2ggYW5kIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIHRvIGdldCB0aGUgYmVjaDMyIHByZWZpeCBmb3IgYW4gYWRkcmVzc1xuICAgKi9cbiAgcHJvdGVjdGVkIGdldEFkZHJlc3NQcmVmaXgoYWRkcmVzczogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICAvLyBvdGhlcndpc2UsIHRyeSBkZWNvZGluZyBhcyBiZWNoMzJcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBwcmVmaXggfSA9IHRoaXMuZ2V0Q29pbkxpYnJhcnkoKS5hZGRyZXNzLmZyb21CZWNoMzIoYWRkcmVzcyk7XG4gICAgICByZXR1cm4gcHJlZml4O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGlnbm9yZSBlcnJvcnMsIGp1c3QgZmFsbCB0aHJvdWdoIGFuZCByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGFkZHJlc3MgaXMgdmFsaWRcbiAgICogQHBhcmFtIGFkZHJlc3NcbiAgICogQHBhcmFtIGZvcmNlQWx0U2NyaXB0U3VwcG9ydFxuICAgKi9cbiAgaXNWYWxpZEFkZHJlc3MoYWRkcmVzczogc3RyaW5nLCBmb3JjZUFsdFNjcmlwdFN1cHBvcnQgPSBmYWxzZSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHZhbGlkVmVyc2lvbnMgPSBbXG4gICAgICB0aGlzLm5ldHdvcmsucHViS2V5SGFzaCxcbiAgICAgIHRoaXMubmV0d29yay5zY3JpcHRIYXNoLFxuICAgIF07XG4gICAgaWYgKHRoaXMuYWx0U2NyaXB0SGFzaCAmJiAoZm9yY2VBbHRTY3JpcHRTdXBwb3J0IHx8IHRoaXMuc3VwcG9ydEFsdFNjcmlwdERlc3RpbmF0aW9uKSkge1xuICAgICAgdmFsaWRWZXJzaW9ucy5wdXNoKHRoaXMuYWx0U2NyaXB0SGFzaCk7XG4gICAgfVxuXG4gICAgY29uc3QgYWRkcmVzc1ZlcnNpb24gPSB0aGlzLmdldEFkZHJlc3NWZXJzaW9uKGFkZHJlc3MpO1xuXG4gICAgLy8gdGhlIGFkZHJlc3MgdmVyc2lvbiBuZWVkcyB0byBiZSBhbW9uZyB0aGUgdmFsaWQgb25lc1xuICAgIGNvbnN0IGFkZHJlc3NWZXJzaW9uVmFsaWQgPSBfLmlzTnVtYmVyKGFkZHJlc3NWZXJzaW9uKSAmJiB2YWxpZFZlcnNpb25zLmluY2x1ZGVzKGFkZHJlc3NWZXJzaW9uKTtcbiAgICBjb25zdCBhZGRyZXNzUHJlZml4ID0gdGhpcy5nZXRBZGRyZXNzUHJlZml4KGFkZHJlc3MpO1xuXG4gICAgaWYgKCF0aGlzLnN1cHBvcnRzUDJ3c2goKSB8fCBfLmlzVW5kZWZpbmVkKGFkZHJlc3NQcmVmaXgpKSB7XG4gICAgICByZXR1cm4gYWRkcmVzc1ZlcnNpb25WYWxpZDtcbiAgICB9XG5cbiAgICAvLyBhZGRyZXNzIGhhcyBhIHBvdGVudGlhbCBiZWNoMzIgcHJlZml4LCB2YWxpZGF0ZSB0aGF0XG4gICAgcmV0dXJuIF8uaXNTdHJpbmcodGhpcy5uZXR3b3JrLmJlY2gzMikgJiYgdGhpcy5uZXR3b3JrLmJlY2gzMiA9PT0gYWRkcmVzc1ByZWZpeDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaW5wdXQgaXMgdmFsaWQgcHVibGljIGtleSBmb3IgdGhlIGNvaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwdWIgdGhlIHB1YiB0byBiZSBjaGVja2VkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBpcyBpdCB2YWxpZD9cbiAgICovXG4gIGlzVmFsaWRQdWIocHViOiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgYml0Y29pbi5IRE5vZGUuZnJvbUJhc2U1OChwdWIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxhdGVzdCBibG9jayBoZWlnaHRcbiAgICogQHBhcmFtIHJlcUlkXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgZ2V0TGF0ZXN0QmxvY2tIZWlnaHQocmVxSWQ/OiBSZXF1ZXN0VHJhY2VyLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxudW1iZXI+KTogQmx1ZWJpcmQ8bnVtYmVyPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPG51bWJlcj4oZnVuY3Rpb24gKigpIHtcbiAgICAgIGlmIChyZXFJZCkge1xuICAgICAgICB0aGlzLmJpdGdvLl9yZXFJZCA9IHJlcUlkO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hhaW5oZWFkID0geWllbGQgc2VsZi5iaXRnby5nZXQoc2VsZi51cmwoJy9wdWJsaWMvYmxvY2svbGF0ZXN0JykpLnJlc3VsdCgpO1xuICAgICAgcmV0dXJuIGNoYWluaGVhZC5oZWlnaHQ7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gY3VzdG9tIGNvaW4gbG9naWMgYWZ0ZXIgYSB0cmFuc2FjdGlvbiBwcmVidWlsZCBoYXMgYmVlbiByZWNlaXZlZCBmcm9tIEJpdEdvXG4gICAqIEBwYXJhbSBwcmVidWlsZFxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHBvc3RQcm9jZXNzUHJlYnVpbGQocHJlYnVpbGQ6IFRyYW5zYWN0aW9uUHJlYnVpbGQsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFRyYW5zYWN0aW9uUHJlYnVpbGQ+KTogQmx1ZWJpcmQ8VHJhbnNhY3Rpb25QcmVidWlsZD4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxUcmFuc2FjdGlvblByZWJ1aWxkPihmdW5jdGlvbiAqKCkge1xuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocHJlYnVpbGQudHhIZXgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCB0eFByZWJ1aWxkIHByb3BlcnR5IHR4SGV4Jyk7XG4gICAgICB9XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGJpdGNvaW4uVHJhbnNhY3Rpb24uZnJvbUhleChwcmVidWlsZC50eEhleCwgc2VsZi5uZXR3b3JrKTtcbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHByZWJ1aWxkLmJsb2NrSGVpZ2h0KSkge1xuICAgICAgICBwcmVidWlsZC5ibG9ja0hlaWdodCA9ICh5aWVsZCBzZWxmLmdldExhdGVzdEJsb2NrSGVpZ2h0KCkpIGFzIG51bWJlcjtcbiAgICAgIH1cbiAgICAgIC8vIExvY2sgdHJhbnNhY3Rpb24gdG8gdGhlIG5leHQgYmxvY2sgdG8gZGlzY291cmFnZSBmZWUgc25pcGluZ1xuICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXRjb2luL2Jsb2IvZmIwYWM0ODJlZWU3NjFlYzE3ZWQyYzExZGYxMWUwNTQzNDdhMDI2ZC9zcmMvd2FsbGV0L3dhbGxldC5jcHAjTDIxMzNcbiAgICAgIHRyYW5zYWN0aW9uLmxvY2t0aW1lID0gcHJlYnVpbGQuYmxvY2tIZWlnaHQ7XG4gICAgICByZXR1cm4gXy5leHRlbmQoe30sIHByZWJ1aWxkLCB7IHR4SGV4OiB0cmFuc2FjdGlvbi50b0hleCgpIH0pO1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogRmluZCBvdXRwdXRzIHRoYXQgYXJlIHdpdGhpbiBleHBlY3RlZCBvdXRwdXRzIGJ1dCBub3Qgd2l0aGluIGFjdHVhbCBvdXRwdXRzLCBpbmNsdWRpbmcgZHVwbGljYXRlc1xuICAgKiBAcGFyYW0gZXhwZWN0ZWRPdXRwdXRzXG4gICAqIEBwYXJhbSBhY3R1YWxPdXRwdXRzXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICovXG4gIHByb3RlY3RlZCBzdGF0aWMgZmluZE1pc3NpbmdPdXRwdXRzKGV4cGVjdGVkT3V0cHV0czogT3V0cHV0W10sIGFjdHVhbE91dHB1dHM6IE91dHB1dFtdKTogT3V0cHV0W10ge1xuICAgIGNvbnN0IGtleUZ1bmMgPSAoeyBhZGRyZXNzLCBhbW91bnQgfTogT3V0cHV0KTogc3RyaW5nID0+IGAke2FkZHJlc3N9OiR7TnVtYmVyKGFtb3VudCl9YDtcbiAgICBjb25zdCBncm91cGVkT3V0cHV0cyA9IF8uZ3JvdXBCeShleHBlY3RlZE91dHB1dHMsIGtleUZ1bmMpO1xuXG4gICAgYWN0dWFsT3V0cHV0cy5mb3JFYWNoKChvdXRwdXQpID0+IHtcbiAgICAgIGNvbnN0IGdyb3VwID0gZ3JvdXBlZE91dHB1dHNba2V5RnVuYyhvdXRwdXQpXTtcbiAgICAgIGlmIChncm91cCkge1xuICAgICAgICBncm91cC5wb3AoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBfLmZsYXR0ZW4oXy52YWx1ZXMoZ3JvdXBlZE91dHB1dHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgYW4gYWRkcmVzcycgdHlwZSBiYXNlZCBvbiBpdHMgd2l0bmVzcyBhbmQgcmVkZWVtIHNjcmlwdCBwcmVzZW5jZVxuICAgKiBAcGFyYW0gYWRkcmVzc0RldGFpbHNcbiAgICovXG4gIHN0YXRpYyBpbmZlckFkZHJlc3NUeXBlKGFkZHJlc3NEZXRhaWxzOiB7IGNvaW5TcGVjaWZpYzogQWRkcmVzc0NvaW5TcGVjaWZpYyB9KTogc3RyaW5nIHwgbnVsbCB7XG4gICAgaWYgKF8uaXNPYmplY3QoYWRkcmVzc0RldGFpbHMuY29pblNwZWNpZmljKSkge1xuICAgICAgaWYgKF8uaXNTdHJpbmcoYWRkcmVzc0RldGFpbHMuY29pblNwZWNpZmljLnJlZGVlbVNjcmlwdCkgJiYgXy5pc1N0cmluZyhhZGRyZXNzRGV0YWlscy5jb2luU3BlY2lmaWMud2l0bmVzc1NjcmlwdCkpIHtcbiAgICAgICAgcmV0dXJuIENvZGVzLlVuc3BlbnRUeXBlVGNvbWIoJ3Ayc2hQMndzaCcpO1xuICAgICAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKGFkZHJlc3NEZXRhaWxzLmNvaW5TcGVjaWZpYy5yZWRlZW1TY3JpcHQpKSB7XG4gICAgICAgIHJldHVybiBDb2Rlcy5VbnNwZW50VHlwZVRjb21iKCdwMnNoJyk7XG4gICAgICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcoYWRkcmVzc0RldGFpbHMuY29pblNwZWNpZmljLndpdG5lc3NTY3JpcHQpKSB7XG4gICAgICAgIHJldHVybiBDb2Rlcy5VbnNwZW50VHlwZVRjb21iKCdwMndzaCcpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IGFuZCBmaWxsIHRyYW5zYWN0aW9uIGRldGFpbHMgc3VjaCBhcyBpbnRlcm5hbC9jaGFuZ2Ugc3BlbmQsIGV4dGVybmFsIHNwZW5kIChleHBsaWNpdCB2cy4gaW1wbGljaXQpLCBldGMuXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgcGFyc2VUcmFuc2FjdGlvbihwYXJhbXM6IFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxQYXJzZWRUcmFuc2FjdGlvbj4pOiBCbHVlYmlyZDxQYXJzZWRUcmFuc2FjdGlvbj4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxQYXJzZWRUcmFuc2FjdGlvbj4oZnVuY3Rpb24gKigpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHhQYXJhbXMsXG4gICAgICAgIHR4UHJlYnVpbGQsXG4gICAgICAgIHdhbGxldCxcbiAgICAgICAgdmVyaWZpY2F0aW9uID0ge30sXG4gICAgICAgIHJlcUlkLFxuICAgICAgfSA9IHBhcmFtcztcblxuICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHZlcmlmaWNhdGlvbi5kaXNhYmxlTmV0d29ya2luZykgJiYgIV8uaXNCb29sZWFuKHZlcmlmaWNhdGlvbi5kaXNhYmxlTmV0d29ya2luZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2ZXJpZmljYXRpb24uZGlzYWJsZU5ldHdvcmtpbmcgbXVzdCBiZSBhIGJvb2xlYW4nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRpc2FibGVOZXR3b3JraW5nID0gdmVyaWZpY2F0aW9uLmRpc2FibGVOZXR3b3JraW5nO1xuXG4gICAgICAvLyBvYnRhaW4gdGhlIGtleWNoYWlucyBhbmQga2V5IHNpZ25hdHVyZXNcbiAgICAgIGxldCBrZXljaGFpbnM6IHtcbiAgICAgICAgdXNlcj86IEtleWNoYWluLFxuICAgICAgICBiYWNrdXA/OiBLZXljaGFpbixcbiAgICAgICAgYml0Z28/OiBLZXljaGFpbixcbiAgICAgIH0gfCB1bmRlZmluZWQgPSB2ZXJpZmljYXRpb24ua2V5Y2hhaW5zO1xuICAgICAgaWYgKCFrZXljaGFpbnMgJiYgZGlzYWJsZU5ldHdvcmtpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgZmV0Y2gga2V5Y2hhaW5zIHdpdGhvdXQgbmV0d29ya2luZycpO1xuICAgICAgfSBlbHNlIGlmICgha2V5Y2hhaW5zKSB7XG4gICAgICAgIGtleWNoYWlucyA9IHlpZWxkIEJsdWViaXJkLnByb3BzKHtcbiAgICAgICAgICB1c2VyOiBzZWxmLmtleWNoYWlucygpLmdldCh7IGlkOiB3YWxsZXQua2V5SWRzKClbS2V5SW5kaWNlcy5VU0VSXSwgcmVxSWQgfSksXG4gICAgICAgICAgYmFja3VwOiBzZWxmLmtleWNoYWlucygpLmdldCh7IGlkOiB3YWxsZXQua2V5SWRzKClbS2V5SW5kaWNlcy5CQUNLVVBdLCByZXFJZCB9KSxcbiAgICAgICAgICBiaXRnbzogc2VsZi5rZXljaGFpbnMoKS5nZXQoeyBpZDogd2FsbGV0LmtleUlkcygpW0tleUluZGljZXMuQklUR09dLCByZXFJZCB9KSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICgha2V5Y2hhaW5zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigna2V5Y2hhaW5zIGFyZSByZXF1aXJlZCwgYnV0IGNvdWxkIG5vdCBiZSBmZXRjaGVkJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGtleWNoYWluQXJyYXkgPSBba2V5Y2hhaW5zLnVzZXIsIGtleWNoYWlucy5iYWNrdXAsIGtleWNoYWlucy5iaXRnb107XG5cbiAgICAgIGNvbnN0IGtleVNpZ25hdHVyZXMgPSBfLmdldCh3YWxsZXQsICdfd2FsbGV0LmtleVNpZ25hdHVyZXMnKTtcblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQodHhQcmVidWlsZC50eEhleCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHR4UHJlYnVpbGQgcHJvcGVydHkgdHhIZXgnKTtcbiAgICAgIH1cbiAgICAgIC8vIG9idGFpbiBhbGwgb3V0cHV0c1xuICAgICAgY29uc3QgZXhwbGFuYXRpb246IFRyYW5zYWN0aW9uRXhwbGFuYXRpb24gPSB5aWVsZCBzZWxmLmV4cGxhaW5UcmFuc2FjdGlvbih7XG4gICAgICAgIHR4SGV4OiB0eFByZWJ1aWxkLnR4SGV4LFxuICAgICAgICB0eEluZm86IHR4UHJlYnVpbGQudHhJbmZvLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGFsbE91dHB1dHMgPSBbLi4uZXhwbGFuYXRpb24ub3V0cHV0cywgLi4uZXhwbGFuYXRpb24uY2hhbmdlT3V0cHV0c107XG5cbiAgICAgIC8vIHZlcmlmeSB0aGF0IGVhY2ggcmVjaXBpZW50IGZyb20gdHhQYXJhbXMgaGFzIHRoZWlyIG93biBvdXRwdXRcbiAgICAgIGNvbnN0IGV4cGVjdGVkT3V0cHV0cyA9IF8uZ2V0KHR4UGFyYW1zLCAncmVjaXBpZW50cycsIFtdIGFzIFRyYW5zYWN0aW9uUmVjaXBpZW50W10pO1xuICAgICAgY29uc3QgbWlzc2luZ091dHB1dHMgPSBBYnN0cmFjdFV0eG9Db2luLmZpbmRNaXNzaW5nT3V0cHV0cyhleHBlY3RlZE91dHB1dHMsIGFsbE91dHB1dHMpO1xuXG4gICAgICAvKipcbiAgICAgICAqIExvb3AgdGhyb3VnaCBhbGwgdGhlIG91dHB1dHMgYW5kIGNsYXNzaWZ5IGVhY2ggb2YgdGhlbSBhcyBlaXRoZXIgaW50ZXJuYWwgc3BlbmRzXG4gICAgICAgKiBvciBleHRlcm5hbCBzcGVuZHMgYnkgc2V0dGluZyB0aGUgXCJleHRlcm5hbFwiIHByb3BlcnR5IHRvIHRydWUgb3IgZmFsc2Ugb24gdGhlIG91dHB1dCBvYmplY3QuXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGFsbE91dHB1dERldGFpbHM6IE91dHB1dFtdID0geWllbGQgQmx1ZWJpcmQubWFwKGFsbE91dHB1dHMsIGNvKGZ1bmN0aW9uICooY3VycmVudE91dHB1dCkge1xuICAgICAgICBjb25zdCBjdXJyZW50QWRkcmVzcyA9IGN1cnJlbnRPdXRwdXQuYWRkcmVzcztcblxuICAgICAgICAvLyBhdHRlbXB0IHRvIGdyYWIgdGhlIGFkZHJlc3MgZGV0YWlscyBmcm9tIGVpdGhlciB0aGUgcHJlYnVpbHQgdHgsIG9yIHRoZSB2ZXJpZmljYXRpb24gcGFyYW1zLlxuICAgICAgICAvLyBJZiBib3RoIG9mIHRoZXNlIGFyZSBlbXB0eSwgdGhlbiB3ZSB3aWxsIHRyeSB0byBnZXQgdGhlIGFkZHJlc3MgZGV0YWlscyBmcm9tIGJpdGdvIGluc3RlYWRcbiAgICAgICAgY29uc3QgYWRkcmVzc0RldGFpbHNQcmVidWlsZCA9IF8uZ2V0KHR4UHJlYnVpbGQsIGB0eEluZm8ud2FsbGV0QWRkcmVzc0RldGFpbHMuJHtjdXJyZW50QWRkcmVzc31gLCB7fSk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3NEZXRhaWxzVmVyaWZpY2F0aW9uID0gXy5nZXQodmVyaWZpY2F0aW9uLCBgYWRkcmVzc2VzLiR7Y3VycmVudEFkZHJlc3N9YCwge30pO1xuICAgICAgICBkZWJ1ZygnUGFyc2luZyBhZGRyZXNzIGRldGFpbHMgZm9yICVzJywgY3VycmVudEFkZHJlc3MpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBvbmx5IHdheSB0byBkZXRlcm1pbmUgd2hldGhlciBhbiBhZGRyZXNzIGlzIGtub3duIG9uIHRoZSB3YWxsZXQgaXMgdG8gaW5pdGlhdGUgYSBuZXR3b3JrIHJlcXVlc3QgYW5kXG4gICAgICAgICAgICogZmV0Y2ggaXQuIFNob3VsZCB0aGUgcmVxdWVzdCBmYWlsIGFuZCByZXR1cm4gYSA0MDQsIGl0IHdpbGwgdGhyb3cgYW5kIHRoZXJlZm9yZSBoYXMgdG8gYmUgY2F1Z2h0LiBGb3IgdGhhdFxuICAgICAgICAgICAqIHJlYXNvbiwgYWRkcmVzcyB3YWxsZXQgb3duZXJzaGlwIGRldGVjdGlvbiBpcyB3cmFwcGVkIGluIGEgdHJ5L2NhdGNoLiBBZGRpdGlvbmFsbHksIG9uY2UgdGhlIGFkZHJlc3NcbiAgICAgICAgICAgKiBkZXRhaWxzIGFyZSBmZXRjaGVkIG9uIHRoZSB3YWxsZXQsIGEgbG9jYWwgYWRkcmVzcyB2YWxpZGF0aW9uIGlzIHJ1biwgd2hvc2UgZXJyb3JzIGhvd2V2ZXIgYXJlIGdlbmVyYXRlZFxuICAgICAgICAgICAqIGNsaWVudC1zaWRlIGFuZCBjYW4gdGhlcmVmb3JlIGJlIGFuYWx5emVkIHdpdGggbW9yZSBncmFudWxhcml0eSBhbmQgdHlwZSBjaGVja2luZy5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBsZXQgYWRkcmVzc0RldGFpbHMgPSBfLmV4dGVuZCh7fSwgYWRkcmVzc0RldGFpbHNQcmVidWlsZCwgYWRkcmVzc0RldGFpbHNWZXJpZmljYXRpb24pO1xuICAgICAgICAgIGRlYnVnKCdMb2NhbGx5IGF2YWlsYWJsZSBhZGRyZXNzICVzIGRldGFpbHM6ICVPJywgY3VycmVudEFkZHJlc3MsIGFkZHJlc3NEZXRhaWxzKTtcbiAgICAgICAgICBpZiAoXy5pc0VtcHR5KGFkZHJlc3NEZXRhaWxzKSAmJiAhZGlzYWJsZU5ldHdvcmtpbmcpIHtcbiAgICAgICAgICAgIGFkZHJlc3NEZXRhaWxzID0geWllbGQgd2FsbGV0LmdldEFkZHJlc3MoeyBhZGRyZXNzOiBjdXJyZW50QWRkcmVzcywgcmVxSWQgfSk7XG4gICAgICAgICAgICBkZWJ1ZygnRG93bmxvYWRlZCBhZGRyZXNzICVzIGRldGFpbHM6ICVPJywgY3VycmVudEFkZHJlc3MsIGFkZHJlc3NEZXRhaWxzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gdmVyaWZ5IHRoYXQgdGhlIGFkZHJlc3MgaXMgb24gdGhlIHdhbGxldC4gdmVyaWZ5QWRkcmVzcyB0aHJvd3MgaWZcbiAgICAgICAgICAvLyBpdCBmYWlscyB0byBjb3JyZWN0bHkgcmVkZXJpdmUgdGhlIGFkZHJlc3MsIG1lYW5pbmcgaXQncyBleHRlcm5hbFxuICAgICAgICAgIGNvbnN0IGFkZHJlc3NUeXBlID0gQWJzdHJhY3RVdHhvQ29pbi5pbmZlckFkZHJlc3NUeXBlKGFkZHJlc3NEZXRhaWxzKTtcbiAgICAgICAgICBzZWxmLnZlcmlmeUFkZHJlc3MoXy5leHRlbmQoeyBhZGRyZXNzVHlwZSB9LCBhZGRyZXNzRGV0YWlscywge1xuICAgICAgICAgICAga2V5Y2hhaW5zOiBrZXljaGFpbkFycmF5LFxuICAgICAgICAgICAgYWRkcmVzczogY3VycmVudEFkZHJlc3MsXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIGRlYnVnKCdBZGRyZXNzICVzIHZlcmlmaWNhdGlvbiBwYXNzZWQnLCBjdXJyZW50QWRkcmVzcyk7XG5cbiAgICAgICAgICAvLyB2ZXJpZnkgYWRkcmVzcyBzdWNjZWVkZWQgd2l0aG91dCB0aHJvd2luZywgc28gdGhlIGFkZHJlc3Mgd2FzXG4gICAgICAgICAgLy8gY29ycmVjdGx5IHJlZGVyaXZlZCBmcm9tIHRoZSB3YWxsZXQga2V5Y2hhaW5zLCBtYWtpbmcgaXQgbm90IGV4dGVybmFsXG4gICAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKHt9LCBjdXJyZW50T3V0cHV0LCBhZGRyZXNzRGV0YWlscywgeyBleHRlcm5hbDogZmFsc2UgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyB2ZXJpZnkgYWRkcmVzcyB0aHJldyBhbiBleGNlcHRpb25cbiAgICAgICAgICBkZWJ1ZygnQWRkcmVzcyAlcyB2ZXJpZmljYXRpb24gdGhyZXcgYW4gZXJyb3I6JywgY3VycmVudEFkZHJlc3MsIGUpO1xuICAgICAgICAgIC8vIFRvZG86IG5hbWUgc2VydmVyLXNpZGUgZXJyb3JzIHRvIGF2b2lkIG1lc3NhZ2UtYmFzZWQgY2hlY2tpbmcgW0JHLTUxMjRdXG4gICAgICAgICAgY29uc3Qgd2FsbGV0QWRkcmVzc05vdEZvdW5kID0gZS5tZXNzYWdlLmluY2x1ZGVzKCd3YWxsZXQgYWRkcmVzcyBub3QgZm91bmQnKTtcbiAgICAgICAgICBjb25zdCB1bmV4cGVjdGVkQWRkcmVzcyA9IChlIGluc3RhbmNlb2YgZXJyb3JzLlVuZXhwZWN0ZWRBZGRyZXNzRXJyb3IpO1xuICAgICAgICAgIGlmICh3YWxsZXRBZGRyZXNzTm90Rm91bmQgfHwgdW5leHBlY3RlZEFkZHJlc3MpIHtcbiAgICAgICAgICAgIGlmICh1bmV4cGVjdGVkQWRkcmVzcyAmJiAhd2FsbGV0QWRkcmVzc05vdEZvdW5kKSB7XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiB0aGlzIGNvdWxkIGJlIGEgbWlncmF0ZWQgU2FmZUhEIEJDSCB3YWxsZXQsIGFuZCB0aGUgdHJhbnNhY3Rpb24gd2UgYXJlIGN1cnJlbnRseVxuICAgICAgICAgICAgICAgKiBwYXJzaW5nIGlzIHRyeWluZyB0byBzcGVuZCBjaGFuZ2UgYmFjayB0byB0aGUgdjEgd2FsbGV0IGJhc2UgYWRkcmVzcy5cbiAgICAgICAgICAgICAgICogSXQgZG9lcyB0aGlzIHNpbmNlIHdlIGRvbid0IGFsbG93IG5ldyBhZGRyZXNzIGNyZWF0aW9uIGZvciB0aGVzZSB3YWxsZXRzLFxuICAgICAgICAgICAgICAgKiBhbmQgaW5zdGVhZCByZXR1cm4gdGhlIGJhc2UgYWRkcmVzcyBmcm9tIHRoZSB2MSB3YWxsZXQgd2hlbiBhIG5ldyBhZGRyZXNzIGlzIHJlcXVlc3RlZC5cbiAgICAgICAgICAgICAgICogSWYgdGhpcyBuZXcgYWRkcmVzcyBpcyByZXF1ZXN0ZWQgZm9yIHRoZSBwdXJwb3NlcyBvZiBzcGVuZGluZyBjaGFuZ2UgYmFjayB0byB0aGUgd2FsbGV0LFxuICAgICAgICAgICAgICAgKiB0aGUgY2hhbmdlIHdpbGwgZ28gdG8gdGhlIHYxIHdhbGxldCBiYXNlIGFkZHJlc3MuIFRoaXMgYWRkcmVzcyAqaXMqIG9uIHRoZSB3YWxsZXQsXG4gICAgICAgICAgICAgICAqIGJ1dCBpdCB3aWxsIHN0aWxsIGNhdXNlIGFuIGVycm9yIHRvIGJlIHRocm93biBieSB2ZXJpZnlBZGRyZXNzLCBzaW5jZSB0aGUgZGVyaXZhdGlvbiBwYXRoXG4gICAgICAgICAgICAgICAqIHVzZWQgZm9yIHRoaXMgYWRkcmVzcyBpcyBub24tc3RhbmRhcmQuIChJIGhhdmUgc2VlbiB0aGVzZSBhZGRyZXNzZXMgZGVyaXZlZCB1c2luZyBwYXRocyBtLzAvMCBhbmQgbS8xMDEsXG4gICAgICAgICAgICAgICAqIHdoZXJlYXMgdGhlIHYyIGFkZHJlc3NlcyBhcmUgZGVyaXZlZCB1c2luZyBwYXRoICBtLzAvMC8ke2NoYWlufS8ke2luZGV4fSkuXG4gICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAqIFRoaXMgbWVhbnMgd2UgbmVlZCB0byBjaGVjayBmb3IgdGhpcyBjYXNlIGV4cGxpY2l0bHkgaW4gdGhpcyBjYXRjaCBibG9jaywgYW5kIGNsYXNzaWZ5XG4gICAgICAgICAgICAgICAqIHRoZXNlIHR5cGVzIG9mIG91dHB1dHMgYXMgaW50ZXJuYWwgaW5zdGVhZCBvZiBleHRlcm5hbC4gRmFpbGluZyB0byBkbyBzbyB3b3VsZCBjYXVzZSB0aGVcbiAgICAgICAgICAgICAgICogdHJhbnNhY3Rpb24ncyBpbXBsaWNpdCBleHRlcm5hbCBvdXRwdXRzIChpZSwgb3V0cHV0cyB3aGljaCBnbyB0byBhZGRyZXNzZXMgbm90IHNwZWNpZmllZCBpblxuICAgICAgICAgICAgICAgKiB0aGUgcmVjaXBpZW50cyBhcnJheSkgdG8gYWRkIHVwIHRvIG1vcmUgdGhhbiB0aGUgMTUwIGJhc2lzIHBvaW50IGxpbWl0IHdoaWNoIHdlIGVuZm9yY2Ugb25cbiAgICAgICAgICAgICAgICogcGF5LWFzLXlvdS1nbyBvdXRwdXRzICh3aGljaCBzaG91bGQgYmUgdGhlIG9ubHkgaW1wbGljaXQgZXh0ZXJuYWwgb3V0cHV0cyBvbiBvdXIgdHJhbnNhY3Rpb25zKS5cbiAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICogVGhlIDE1MCBiYXNpcyBwb2ludCBsaW1pdCBmb3IgaW1wbGljaXQgZXh0ZXJuYWwgc2VuZHMgaXMgZW5mb3JjZWQgaW4gdmVyaWZ5VHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAqIHdoaWNoIGNhbGxzIHRoaXMgZnVuY3Rpb24gdG8gZ2V0IGluZm9ybWF0aW9uIG9uIHRoZSB0b3RhbCBleHRlcm5hbC9pbnRlcm5hbCBzcGVuZCBhbW91bnRzXG4gICAgICAgICAgICAgICAqIGZvciBhIHRyYW5zYWN0aW9uLiBUaGUgaWRlYSBoZXJlIGlzIHRvIHByb3RlY3QgZnJvbSB0aGUgdHJhbnNhY3Rpb24gYmVpbmcgbWFsaWNpb3VzbHkgbW9kaWZpZWRcbiAgICAgICAgICAgICAgICogdG8gYWRkIG1vcmUgaW1wbGljaXQgZXh0ZXJuYWwgc3BlbmRzIChlZywgdG8gYW4gYXR0YWNrZXItY29udHJvbGxlZCB3YWxsZXQpLlxuICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgKiBTZWUgdmVyaWZ5VHJhbnNhY3Rpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IHRyYW5zYWN0aW9uIHByZWJ1aWxkcyBhcmUgdmVyaWZpZWQgYmVmb3JlIHNpZ25pbmcuXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgIGlmIChfLmlzU3RyaW5nKHdhbGxldC5taWdyYXRlZEZyb20oKSkgJiYgd2FsbGV0Lm1pZ3JhdGVkRnJvbSgpID09PSBjdXJyZW50QWRkcmVzcykge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdmb3VuZCBhZGRyZXNzICVzIHdoaWNoIHdhcyBtaWdyYXRlZCBmcm9tIHYxIHdhbGxldCwgYWRkcmVzcyBpcyBub3QgZXh0ZXJuYWwnLCBjdXJyZW50QWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKHt9LCBjdXJyZW50T3V0cHV0LCB7IGV4dGVybmFsOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRlYnVnKCdBZGRyZXNzICVzIHdhcyBmb3VuZCBvbiB3YWxsZXQgYnV0IGNvdWxkIG5vdCBiZSByZWNvbnN0cnVjdGVkJywgY3VycmVudEFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0aGUgYWRkcmVzcyB3YXMgZm91bmQsIGJ1dCBub3Qgb24gdGhlIHdhbGxldCwgd2hpY2ggc2ltcGx5IG1lYW5zIGl0J3MgZXh0ZXJuYWxcbiAgICAgICAgICAgIGRlYnVnKCdBZGRyZXNzICVzIHByZXN1bWVkIGV4dGVybmFsJywgY3VycmVudEFkZHJlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKHt9LCBjdXJyZW50T3V0cHV0LCB7IGV4dGVybmFsOiB0cnVlIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZSBpbnN0YW5jZW9mIGVycm9ycy5JbnZhbGlkQWRkcmVzc0Rlcml2YXRpb25Qcm9wZXJ0eUVycm9yICYmIGN1cnJlbnRBZGRyZXNzID09PSB0eFBhcmFtcy5jaGFuZ2VBZGRyZXNzKSB7XG4gICAgICAgICAgICAvLyBleHBlY3QgdG8gc2VlIHRoaXMgZXJyb3Igd2hlbiBwYXNzaW5nIGluIGEgY3VzdG9tIGNoYW5nZUFkZHJlc3Mgd2l0aCBubyBjaGFpbiBvciBpbmRleFxuICAgICAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKHt9LCBjdXJyZW50T3V0cHV0LCB7IGV4dGVybmFsOiBmYWxzZSB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWJ1ZygnQWRkcmVzcyAlcyB2ZXJpZmljYXRpb24gZmFpbGVkJywgY3VycmVudEFkZHJlc3MpO1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEl0IG1pZ2h0IGJlIGEgY29tcGxldGVseSBpbnZhbGlkIGFkZHJlc3Mgb3IgYSBiYWQgdmFsaWRhdGlvbiBhdHRlbXB0IG9yIHNvbWV0aGluZyBlbHNlIGNvbXBsZXRlbHksIGluXG4gICAgICAgICAgICogd2hpY2ggY2FzZSB3ZSBkbyBub3QgcHJvY2VlZCBhbmQgcmF0aGVyIHJldGhyb3cgdGhlIGVycm9yLCB3aGljaCBpcyBzYWZlciB0aGFuIGFzc3VtaW5nIHRoYXQgdGhlIGFkZHJlc3NcbiAgICAgICAgICAgKiB2YWxpZGF0aW9uIGZhaWxlZCBzaW1wbHkgYmVjYXVzZSBpdCdzIGV4dGVybmFsIHRvIHRoZSB3YWxsZXQuXG4gICAgICAgICAgICovXG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfSkuYmluZCh0aGlzKSk7XG5cbiAgICAgIGNvbnN0IGNoYW5nZU91dHB1dHMgPSBfLmZpbHRlcihhbGxPdXRwdXREZXRhaWxzLCB7IGV4dGVybmFsOiBmYWxzZSB9KTtcblxuICAgICAgLy8gdGhlc2UgYXJlIGFsbCB0aGUgb3V0cHV0cyB0aGF0IHdlcmUgbm90IG9yaWdpbmFsbHkgZXhwbGljaXRseSBzcGVjaWZpZWQgaW4gcmVjaXBpZW50c1xuICAgICAgY29uc3QgaW1wbGljaXRPdXRwdXRzID0gQWJzdHJhY3RVdHhvQ29pbi5maW5kTWlzc2luZ091dHB1dHMoYWxsT3V0cHV0RGV0YWlscywgZXhwZWN0ZWRPdXRwdXRzKTtcblxuICAgICAgY29uc3QgZXhwbGljaXRPdXRwdXRzID0gQWJzdHJhY3RVdHhvQ29pbi5maW5kTWlzc2luZ091dHB1dHMoYWxsT3V0cHV0RGV0YWlscywgaW1wbGljaXRPdXRwdXRzKTtcblxuICAgICAgLy8gdGhlc2UgYXJlIGFsbCB0aGUgbm9uLXdhbGxldCBvdXRwdXRzIHRoYXQgaGFkIGJlZW4gb3JpZ2luYWxseSBleHBsaWNpdGx5IHNwZWNpZmllZCBpbiByZWNpcGllbnRzXG4gICAgICBjb25zdCBleHBsaWNpdEV4dGVybmFsT3V0cHV0cyA9IF8uZmlsdGVyKGV4cGxpY2l0T3V0cHV0cywgeyBleHRlcm5hbDogdHJ1ZSB9KTtcblxuICAgICAgLy8gdGhpcyBpcyB0aGUgc3VtIG9mIGFsbCB0aGUgb3JpZ2luYWxseSBleHBsaWNpdGx5IHNwZWNpZmllZCBub24td2FsbGV0IG91dHB1dCB2YWx1ZXNcbiAgICAgIGNvbnN0IGV4cGxpY2l0RXh0ZXJuYWxTcGVuZEFtb3VudCA9IF8uc3VtQnkoZXhwbGljaXRFeHRlcm5hbE91dHB1dHMsICdhbW91bnQnKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgY2FsY3VsYXRpb24gb2YgdGhlIGltcGxpY2l0IGV4dGVybmFsIHNwZW5kIGFtb3VudCBwZXJ0YWlucyB0byB2ZXJpZnlpbmcgdGhlIHBheS1hcy15b3UtZ28tZmVlIEJpdEdvXG4gICAgICAgKiBhdXRvbWF0aWNhbGx5IGFwcGxpZXMgdG8gdHJhbnNhY3Rpb25zIHNlbmRpbmcgbW9uZXkgb3V0IG9mIHRoZSB3YWxsZXQuIFRoZSBsb2dpYyBpcyBmYWlybHkgc3RyYWlnaHRmb3J3YXJkXG4gICAgICAgKiBpbiB0aGF0IHdlIGNvbXBhcmUgdGhlIGV4dGVybmFsIHNwZW5kIGFtb3VudCB0aGF0IHdhcyBzcGVjaWZpZWQgZXhwbGljaXRseSBieSB0aGUgdXNlciB0byB0aGUgcG9ydGlvblxuICAgICAgICogdGhhdCB3YXMgc3BlY2lmaWVkIGltcGxpY2l0bHkuIFRvIHByb3RlY3QgY3VzdG9tZXJzIGZyb20gcGVvcGxlIHRhbXBlcmluZyB3aXRoIHRoZSB0cmFuc2FjdGlvbiBvdXRwdXRzLCB3ZVxuICAgICAgICogZGVmaW5lIGEgdGhyZXNob2xkIGZvciB0aGUgbWF4aW11bSBwZXJjZW50YWdlIG9mIHRoZSBpbXBsaWNpdCBleHRlcm5hbCBzcGVuZCBpbiByZWxhdGlvbiB0byB0aGUgZXhwbGljaXRcbiAgICAgICAqIGV4dGVybmFsIHNwZW5kLlxuICAgICAgICovXG5cbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IGFsbCB0aGUgZXh0cmEgYWRkcmVzc2VzIGFyZSBjaGFuZ2UgYWRkcmVzc2VzXG4gICAgICAvLyBnZXQgYWxsIHRoZSBhZGRpdGlvbmFsIGV4dGVybmFsIG91dHB1dHMgdGhlIHNlcnZlciBhZGRlZCBhbmQgY2FsY3VsYXRlIHRoZWlyIHZhbHVlc1xuICAgICAgY29uc3QgaW1wbGljaXRFeHRlcm5hbE91dHB1dHMgPSBfLmZpbHRlcihpbXBsaWNpdE91dHB1dHMsIHsgZXh0ZXJuYWw6IHRydWUgfSk7XG4gICAgICBjb25zdCBpbXBsaWNpdEV4dGVybmFsU3BlbmRBbW91bnQgPSBfLnN1bUJ5KGltcGxpY2l0RXh0ZXJuYWxPdXRwdXRzLCAnYW1vdW50Jyk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdDogUGFyc2VkVHJhbnNhY3Rpb24gPSB7XG4gICAgICAgIGtleWNoYWlucyxcbiAgICAgICAga2V5U2lnbmF0dXJlcyxcbiAgICAgICAgb3V0cHV0czogYWxsT3V0cHV0RGV0YWlscyxcbiAgICAgICAgbWlzc2luZ091dHB1dHMsXG4gICAgICAgIGV4cGxpY2l0RXh0ZXJuYWxPdXRwdXRzLFxuICAgICAgICBpbXBsaWNpdEV4dGVybmFsT3V0cHV0cyxcbiAgICAgICAgY2hhbmdlT3V0cHV0cyxcbiAgICAgICAgZXhwbGljaXRFeHRlcm5hbFNwZW5kQW1vdW50LFxuICAgICAgICBpbXBsaWNpdEV4dGVybmFsU3BlbmRBbW91bnQsXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSB0aGF0IGEgdHJhbnNhY3Rpb24gcHJlYnVpbGQgY29tcGxpZXMgd2l0aCB0aGUgb3JpZ2luYWwgaW50ZW50aW9uXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy50eFBhcmFtcyBwYXJhbXMgb2JqZWN0IHBhc3NlZCB0byBzZW5kXG4gICAqIEBwYXJhbSBwYXJhbXMudHhQcmVidWlsZCBwcmVidWlsZCBvYmplY3QgcmV0dXJuZWQgYnkgc2VydmVyXG4gICAqIEBwYXJhbSBwYXJhbXMudHhQcmVidWlsZC50eEhleCBwcmVidWlsdCB0cmFuc2FjdGlvbidzIHR4SGV4IGZvcm1cbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXQgV2FsbGV0IG9iamVjdCB0byBvYnRhaW4ga2V5cyB0byB2ZXJpZnkgYWdhaW5zdFxuICAgKiBAcGFyYW0gcGFyYW1zLnZlcmlmaWNhdGlvbiBPYmplY3Qgc3BlY2lmeWluZyBzb21lIHZlcmlmaWNhdGlvbiBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSBwYXJhbXMudmVyaWZpY2F0aW9uLmRpc2FibGVOZXR3b3JraW5nIERpc2FsbG93IGZldGNoaW5nIGFueSBkYXRhIGZyb20gdGhlIGludGVybmV0IGZvciB2ZXJpZmljYXRpb24gcHVycG9zZXNcbiAgICogQHBhcmFtIHBhcmFtcy52ZXJpZmljYXRpb24ua2V5Y2hhaW5zIFBhc3Mga2V5Y2hhaW5zIG1hbnVhbGx5IHJhdGhlciB0aGFuIGZldGNoaW5nIHRoZW0gYnkgaWRcbiAgICogQHBhcmFtIHBhcmFtcy52ZXJpZmljYXRpb24uYWRkcmVzc2VzIEFkZHJlc3MgZGV0YWlscyB0byBwYXNzIGluIGZvciBvdXQtb2YtYmFuZCB2ZXJpZmljYXRpb25cbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgdmVyaWZ5VHJhbnNhY3Rpb24ocGFyYW1zOiBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGJvb2xlYW4+KTogQmx1ZWJpcmQ8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxib29sZWFuPihmdW5jdGlvbiAqKCkge1xuICAgICAgY29uc3QgeyB0eFBhcmFtcywgdHhQcmVidWlsZCwgd2FsbGV0LCB2ZXJpZmljYXRpb24gPSB7fSwgcmVxSWQgfSA9IHBhcmFtcztcbiAgICAgIGNvbnN0IGRpc2FibGVOZXR3b3JraW5nID0gISF2ZXJpZmljYXRpb24uZGlzYWJsZU5ldHdvcmtpbmc7XG4gICAgICBjb25zdCBwYXJzZWRUcmFuc2FjdGlvbiA9IHlpZWxkIHNlbGYucGFyc2VUcmFuc2FjdGlvbih7IHR4UGFyYW1zLCB0eFByZWJ1aWxkLCB3YWxsZXQsIHZlcmlmaWNhdGlvbiwgcmVxSWQgfSk7XG5cbiAgICAgIGNvbnN0IGtleWNoYWlucyA9IHBhcnNlZFRyYW5zYWN0aW9uLmtleWNoYWlucztcblxuICAgICAgLy8gbGV0J3MgdmVyaWZ5IHRoZXNlIGtleWNoYWluc1xuICAgICAgY29uc3Qga2V5U2lnbmF0dXJlcyA9IHBhcnNlZFRyYW5zYWN0aW9uLmtleVNpZ25hdHVyZXM7XG4gICAgICBpZiAoIV8uaXNFbXB0eShrZXlTaWduYXR1cmVzKSkge1xuICAgICAgICAvLyBmaXJzdCwgbGV0J3MgdmVyaWZ5IHRoZSBpbnRlZ3JpdHkgb2YgdGhlIHVzZXIga2V5LCB3aG9zZSBwdWJsaWMga2V5IGlzIHVzZWQgZm9yIHN1YnNlcXVlbnQgdmVyaWZpY2F0aW9uc1xuICAgICAgICBjb25zdCB1c2VyUHViID0ga2V5Y2hhaW5zLnVzZXIucHViO1xuICAgICAgICBjb25zdCB1c2VyS2V5ID0gYml0Y29pbi5IRE5vZGUuZnJvbUJhc2U1OCh1c2VyUHViKTtcbiAgICAgICAgbGV0IHVzZXJQcnYgPSBrZXljaGFpbnMudXNlci5wcnY7XG4gICAgICAgIGlmIChfLmlzRW1wdHkodXNlclBydikpIHtcbiAgICAgICAgICBjb25zdCBlbmNyeXB0ZWRQcnYgPSBrZXljaGFpbnMudXNlci5lbmNyeXB0ZWRQcnY7XG4gICAgICAgICAgaWYgKCFfLmlzRW1wdHkoZW5jcnlwdGVkUHJ2KSkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGRlY3J5cHRpb24gZmFpbHMsIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgICAgIHVzZXJQcnYgPSBzZWxmLmJpdGdvLmRlY3J5cHQoe1xuICAgICAgICAgICAgICBpbnB1dDogZW5jcnlwdGVkUHJ2LFxuICAgICAgICAgICAgICBwYXNzd29yZDogdHhQYXJhbXMud2FsbGV0UGFzc3BocmFzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoXy5pc0VtcHR5KHVzZXJQcnYpKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gJ3VzZXIgcHJpdmF0ZSBrZXkgdW5hdmFpbGFibGUgZm9yIHZlcmlmaWNhdGlvbic7XG4gICAgICAgICAgaWYgKGRpc2FibGVOZXR3b3JraW5nKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgdXNlclByaXZhdGVLZXkgPSBiaXRjb2luLkhETm9kZS5mcm9tQmFzZTU4KHVzZXJQcnYpO1xuICAgICAgICAgIGlmICh1c2VyUHJpdmF0ZUtleS50b0Jhc2U1OCgpID09PSB1c2VyUHJpdmF0ZUtleS5uZXV0ZXJlZCgpLnRvQmFzZTU4KCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndXNlciBwcml2YXRlIGtleSBpcyBvbmx5IHB1YmxpYycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodXNlclByaXZhdGVLZXkubmV1dGVyZWQoKS50b0Jhc2U1OCgpICE9PSB1c2VyUHViKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZXIgcHJpdmF0ZSBrZXkgZG9lcyBub3QgbWF0Y2ggcHVibGljIGtleScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJhY2t1cFB1YlNpZ25hdHVyZSA9IGtleVNpZ25hdHVyZXMuYmFja3VwUHViO1xuICAgICAgICBjb25zdCBiaXRnb1B1YlNpZ25hdHVyZSA9IGtleVNpZ25hdHVyZXMuYml0Z29QdWI7XG5cbiAgICAgICAgLy8gdmVyaWZ5IHRoZSBzaWduYXR1cmVzIGFnYWluc3QgdGhlIHVzZXIgcHVibGljIGtleVxuICAgICAgICBjb25zdCBzaWduaW5nQWRkcmVzcyA9IHVzZXJLZXkua2V5UGFpci5nZXRBZGRyZXNzKCk7XG5cbiAgICAgICAgLy8gQkctNTcwMzogdXNlIEJUQyBtYWlubmV0IHByZWZpeCBmb3IgYWxsIGtleSBzaWduYXR1cmUgb3BlcmF0aW9uc1xuICAgICAgICAvLyAodGhpcyBtZWFucyBkbyBub3QgcGFzcyBhIHByZWZpeCBwYXJhbWV0ZXIsIGFuZCBsZXQgaXQgdXNlIHRoZSBkZWZhdWx0IHByZWZpeCBpbnN0ZWFkKVxuICAgICAgICBjb25zdCBpc1ZhbGlkQmFja3VwU2lnbmF0dXJlID0gYml0Y29pbk1lc3NhZ2UudmVyaWZ5KGtleWNoYWlucy5iYWNrdXAucHViLCBzaWduaW5nQWRkcmVzcywgQnVmZmVyLmZyb20oYmFja3VwUHViU2lnbmF0dXJlLCAnaGV4JykpO1xuICAgICAgICBjb25zdCBpc1ZhbGlkQml0Z29TaWduYXR1cmUgPSBiaXRjb2luTWVzc2FnZS52ZXJpZnkoa2V5Y2hhaW5zLmJpdGdvLnB1Yiwgc2lnbmluZ0FkZHJlc3MsIEJ1ZmZlci5mcm9tKGJpdGdvUHViU2lnbmF0dXJlLCAnaGV4JykpO1xuXG4gICAgICAgIGlmICghaXNWYWxpZEJhY2t1cFNpZ25hdHVyZSB8fCAhaXNWYWxpZEJpdGdvU2lnbmF0dXJlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZWNvbmRhcnkgcHVibGljIGtleSBzaWduYXR1cmVzIGludmFsaWQnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghZGlzYWJsZU5ldHdvcmtpbmcpIHtcbiAgICAgICAgLy8gdGhlc2Uga2V5cyB3ZXJlIG9idGFpbmVkIG9ubGluZSBhbmQgdGhlaXIgc2lnbmF0dXJlcyB3ZXJlIG5vdCB2ZXJpZmllZFxuICAgICAgICAvLyB0aGlzIGNvdWxkIGJlIGRhbmdlcm91c1xuICAgICAgICBjb25zb2xlLmxvZygndW5zaWduZWQga2V5cyBvYnRhaW5lZCBvbmxpbmUgYXJlIGJlaW5nIHVzZWQgZm9yIGFkZHJlc3MgdmVyaWZpY2F0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1pc3NpbmdPdXRwdXRzID0gcGFyc2VkVHJhbnNhY3Rpb24ubWlzc2luZ091dHB1dHM7XG4gICAgICBpZiAobWlzc2luZ091dHB1dHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIC8vIHRoZXJlIGFyZSBzb21lIG91dHB1dHMgaW4gdGhlIHJlY2lwaWVudHMgbGlzdCB0aGF0IGhhdmUgbm90IG1hZGUgaXQgaW50byB0aGUgYWN0dWFsIHRyYW5zYWN0aW9uXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgb3V0cHV0cyBtaXNzaW5nIGluIHRyYW5zYWN0aW9uIHByZWJ1aWxkJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGludGVuZGVkRXh0ZXJuYWxTcGVuZCA9IHBhcnNlZFRyYW5zYWN0aW9uLmV4cGxpY2l0RXh0ZXJuYWxTcGVuZEFtb3VudDtcblxuICAgICAgLy8gdGhpcyBpcyBhIGxpbWl0IHdlIGltcG9zZSBmb3IgdGhlIHRvdGFsIHZhbHVlIHRoYXQgaXMgYW1lbmRlZCB0byB0aGUgdHJhbnNhY3Rpb24gYmV5b25kIHdoYXQgd2FzIG9yaWdpbmFsbHkgaW50ZW5kZWRcbiAgICAgIGNvbnN0IHBheUFzWW91R29MaW1pdCA9IGludGVuZGVkRXh0ZXJuYWxTcGVuZCAqIDAuMDE1OyAvLyAxNTAgYmFzaXMgcG9pbnRzIGlzIHRoZSBhYnNvbHV0ZSBwZXJtaXR0ZWQgbWF4aW11bVxuXG4gICAgICAvKlxuICAgICAgU29tZSBleHBsYW5hdGlvbiBmb3Igd2h5IHdlJ3JlIGRvaW5nIHdoYXQgd2UncmUgZG9pbmc6XG4gICAgICBTb21lIGN1c3RvbWVycyB3aWxsIGhhdmUgYW4gb3V0cHV0IHRvIEJpdEdvJ3MgUEFZR28gd2FsbGV0IGFkZGVkIHRvIHRoZWlyIHRyYW5zYWN0aW9uLCBhbmQgd2UgbmVlZCB0byBhY2NvdW50IGZvclxuICAgICAgaXQgaGVyZS4gVG8gcHJvdGVjdCBzb21lb25lIHRhbXBlcmluZyB3aXRoIHRoZSBvdXRwdXQgdG8gbWFrZSBpdCBzZW5kIG1vcmUgdGhhbiBpdCBzaG91bGQgdG8gQml0R28sIHdlIGRlZmluZSBhXG4gICAgICB0aHJlc2hvbGQgZm9yIHRoZSBvdXRwdXQncyB2YWx1ZSBhYm92ZSB3aGljaCB3ZSdsbCB0aHJvdyBhbiBlcnJvciwgYmVjYXVzZSB0aGUgcGF5Z28gb3V0cHV0IHNob3VsZCBuZXZlciBiZSB0aGF0XG4gICAgICBoaWdoLlxuICAgICAgICovXG5cbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IGFsbCB0aGUgZXh0cmEgYWRkcmVzc2VzIGFyZSBjaGFuZ2UgYWRkcmVzc2VzXG4gICAgICAvLyBnZXQgYWxsIHRoZSBhZGRpdGlvbmFsIGV4dGVybmFsIG91dHB1dHMgdGhlIHNlcnZlciBhZGRlZCBhbmQgY2FsY3VsYXRlIHRoZWlyIHZhbHVlc1xuICAgICAgY29uc3Qgbm9uQ2hhbmdlQW1vdW50ID0gcGFyc2VkVHJhbnNhY3Rpb24uaW1wbGljaXRFeHRlcm5hbFNwZW5kQW1vdW50O1xuXG4gICAgICAvLyB0aGUgYWRkaXRpb25hbCBleHRlcm5hbCBvdXRwdXRzIGNhbiBvbmx5IGJlIEJpdEdvJ3MgcGF5LWFzLXlvdS1nbyBmZWUsIGJ1dCB3ZSBjYW5ub3QgdmVyaWZ5IHRoZSB3YWxsZXQgYWRkcmVzc1xuICAgICAgaWYgKG5vbkNoYW5nZUFtb3VudCA+IHBheUFzWW91R29MaW1pdCkge1xuICAgICAgICAvLyB0aGVyZSBhcmUgc29tZSBhZGRyZXNzZXMgdGhhdCBhcmUgb3V0c2lkZSB0aGUgc2NvcGUgb2YgaW50ZW5kZWQgcmVjaXBpZW50cyB0aGF0IGFyZSBub3QgY2hhbmdlIGFkZHJlc3Nlc1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZWJ1aWxkIGF0dGVtcHRzIHRvIHNwZW5kIHRvIHVuaW50ZW5kZWQgZXh0ZXJuYWwgcmVjaXBpZW50cycpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhbGxPdXRwdXRzID0gcGFyc2VkVHJhbnNhY3Rpb24ub3V0cHV0cztcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gYml0Y29pbi5UcmFuc2FjdGlvbi5mcm9tSGV4KHR4UHJlYnVpbGQudHhIZXgsIHNlbGYubmV0d29yayk7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbkNhY2hlID0ge307XG4gICAgICBjb25zdCBpbnB1dHMgPSB5aWVsZCBCbHVlYmlyZC5tYXAodHJhbnNhY3Rpb24uaW5zLCBjbyhmdW5jdGlvbiAqKGN1cnJlbnRJbnB1dCkge1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbklkID0gKEJ1ZmZlci5mcm9tKGN1cnJlbnRJbnB1dC5oYXNoKS5yZXZlcnNlKCkgYXMgQnVmZmVyKS50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgIGNvbnN0IHR4SGV4ID0gXy5nZXQodHhQcmVidWlsZCwgYHR4SW5mby50eEhleGVzLiR7dHJhbnNhY3Rpb25JZH1gKTtcbiAgICAgICAgaWYgKHR4SGV4KSB7XG4gICAgICAgICAgY29uc3QgbG9jYWxUeCA9IGJpdGNvaW4uVHJhbnNhY3Rpb24uZnJvbUhleCh0eEhleCwgc2VsZi5uZXR3b3JrKTtcbiAgICAgICAgICBpZiAobG9jYWxUeC5nZXRJZCgpICE9PSB0cmFuc2FjdGlvbklkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IHRyYW5zYWN0aW9uIGhleCBkb2VzIG5vdCBtYXRjaCBpZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjdXJyZW50T3V0cHV0ID0gbG9jYWxUeC5vdXRzW2N1cnJlbnRJbnB1dC5pbmRleF07XG4gICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGJpdGNvaW4uYWRkcmVzcy5mcm9tT3V0cHV0U2NyaXB0KGN1cnJlbnRPdXRwdXQuc2NyaXB0LCBzZWxmLm5ldHdvcmspO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgdmFsdWU6IGN1cnJlbnRPdXRwdXQudmFsdWUsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICghdHJhbnNhY3Rpb25DYWNoZVt0cmFuc2FjdGlvbklkXSkge1xuICAgICAgICAgIGlmIChkaXNhYmxlTmV0d29ya2luZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdHRlbXB0aW5nIHRvIHJldHJpZXZlIHRyYW5zYWN0aW9uIGRldGFpbHMgZXh0ZXJuYWxseSB3aXRoIG5ldHdvcmtpbmcgZGlzYWJsZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlcUlkKSB7XG4gICAgICAgICAgICBzZWxmLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocmVxSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cmFuc2FjdGlvbkNhY2hlW3RyYW5zYWN0aW9uSWRdID0geWllbGQgc2VsZi5iaXRnby5nZXQoc2VsZi51cmwoYC9wdWJsaWMvdHgvJHt0cmFuc2FjdGlvbklkfWApKS5yZXN1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbkRldGFpbHMgPSB0cmFuc2FjdGlvbkNhY2hlW3RyYW5zYWN0aW9uSWRdO1xuICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25EZXRhaWxzLm91dHB1dHNbY3VycmVudElucHV0LmluZGV4XTtcbiAgICAgIH0pLmJpbmQodGhpcykpO1xuXG4gICAgICBjb25zdCBpbnB1dEFtb3VudCA9IF8uc3VtQnkoaW5wdXRzLCAndmFsdWUnKTtcbiAgICAgIGNvbnN0IG91dHB1dEFtb3VudCA9IF8uc3VtQnkoYWxsT3V0cHV0cywgJ2Ftb3VudCcpO1xuICAgICAgY29uc3QgZmVlID0gaW5wdXRBbW91bnQgLSBvdXRwdXRBbW91bnQ7XG5cbiAgICAgIGlmIChmZWUgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYXR0ZW1wdGluZyB0byBzcGVuZCAke291dHB1dEFtb3VudH0gc2F0b3NoaXMsIHdoaWNoIGV4Y2VlZHMgdGhlIGlucHV0IGFtb3VudCAoJHtpbnB1dEFtb3VudH0gc2F0b3NoaXMpIGJ5ICR7LWZlZX1gKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIHN1cmUgYW4gYWRkcmVzcyBpcyB2YWxpZCBhbmQgdGhyb3cgYW4gZXJyb3IgaWYgaXQncyBub3QuXG4gICAqIEBwYXJhbSBwYXJhbXMuYWRkcmVzcyBUaGUgYWRkcmVzcyBzdHJpbmcgb24gdGhlIG5ldHdvcmtcbiAgICogQHBhcmFtIHBhcmFtcy5hZGRyZXNzVHlwZVxuICAgKiBAcGFyYW0gcGFyYW1zLmtleWNoYWlucyBLZXljaGFpbiBvYmplY3RzIHdpdGggeHB1YnNcbiAgICogQHBhcmFtIHBhcmFtcy5jb2luU3BlY2lmaWMgQ29pbi1zcGVjaWZpYyBkZXRhaWxzIGZvciB0aGUgYWRkcmVzcyBzdWNoIGFzIGEgd2l0bmVzcyBzY3JpcHRcbiAgICogQHBhcmFtIHBhcmFtcy5jaGFpbiBEZXJpdmF0aW9uIGNoYWluXG4gICAqIEBwYXJhbSBwYXJhbXMuaW5kZXggRGVyaXZhdGlvbiBpbmRleFxuICAgKiBAdGhyb3dzIHtJbnZhbGlkQWRkcmVzc0Vycm9yfVxuICAgKiBAdGhyb3dzIHtJbnZhbGlkQWRkcmVzc0Rlcml2YXRpb25Qcm9wZXJ0eUVycm9yfVxuICAgKiBAdGhyb3dzIHtVbmV4cGVjdGVkQWRkcmVzc0Vycm9yfVxuICAgKi9cbiAgdmVyaWZ5QWRkcmVzcyhwYXJhbXM6IFZlcmlmeUFkZHJlc3NPcHRpb25zKTogYm9vbGVhbiB7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBhZGRyZXNzVHlwZSwga2V5Y2hhaW5zLCBjb2luU3BlY2lmaWMsIGNoYWluLCBpbmRleCB9ID0gcGFyYW1zO1xuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWRBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgZXJyb3JzLkludmFsaWRBZGRyZXNzRXJyb3IoYGludmFsaWQgYWRkcmVzczogJHthZGRyZXNzfWApO1xuICAgIH1cblxuICAgIGlmICgoXy5pc1VuZGVmaW5lZChjaGFpbikgJiYgXy5pc1VuZGVmaW5lZChpbmRleCkpIHx8ICghKF8uaXNGaW5pdGUoY2hhaW4pICYmIF8uaXNGaW5pdGUoaW5kZXgpKSkpIHtcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuSW52YWxpZEFkZHJlc3NEZXJpdmF0aW9uUHJvcGVydHlFcnJvcihgYWRkcmVzcyB2YWxpZGF0aW9uIGZhaWx1cmU6IGludmFsaWQgY2hhaW4gKCR7Y2hhaW59KSBvciBpbmRleCAoJHtpbmRleH0pYCk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzT2JqZWN0KGNvaW5TcGVjaWZpYykpIHtcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuSW52YWxpZEFkZHJlc3NWZXJpZmljYXRpb25PYmplY3RQcm9wZXJ0eUVycm9yKCdhZGRyZXNzIHZhbGlkYXRpb24gZmFpbHVyZTogY29pblNwZWNpZmljIGZpZWxkIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgaWYgKCFrZXljaGFpbnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBwYXJhbSBrZXljaGFpbnMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBleHBlY3RlZEFkZHJlc3MgPSB0aGlzLmdlbmVyYXRlQWRkcmVzcyh7XG4gICAgICBhZGRyZXNzVHlwZSxcbiAgICAgIGtleWNoYWlucyxcbiAgICAgIHRocmVzaG9sZDogMixcbiAgICAgIGNoYWluLFxuICAgICAgaW5kZXgsXG4gICAgfSk7XG5cbiAgICBpZiAoZXhwZWN0ZWRBZGRyZXNzLmFkZHJlc3MgIT09IGFkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuVW5leHBlY3RlZEFkZHJlc3NFcnJvcihgYWRkcmVzcyB2YWxpZGF0aW9uIGZhaWx1cmU6IGV4cGVjdGVkICR7ZXhwZWN0ZWRBZGRyZXNzLmFkZHJlc3N9IGJ1dCBnb3QgJHthZGRyZXNzfWApO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGNvaW4gc3VwcG9ydHMgYSBibG9jayB0YXJnZXRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdXBwb3J0c0Jsb2NrVGFyZ2V0KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGEgY29pbiBzdXBwb3J0cyB3cmFwcGVkIHNlZ3dpdCBvdXRwdXRzXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3VwcG9ydHNQMnNoUDJ3c2goKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGEgY29pbiBzdXBwb3J0cyBuYXRpdmUgc2Vnd2l0IG91dHB1dHNcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdXBwb3J0c1Ayd3NoKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUT0RPKEJHLTExNDg3KTogUmVtb3ZlIGFkZHJlc3NUeXBlLCBzZWd3aXQsIGFuZCBiZWNoMzIgcGFyYW1zIGluIFNES3Y2XG4gICAqIEdlbmVyYXRlIGFuIGFkZHJlc3MgZm9yIGEgd2FsbGV0IGJhc2VkIG9uIGEgc2V0IG9mIGNvbmZpZ3VyYXRpb25zXG4gICAqIEBwYXJhbSBwYXJhbXMuYWRkcmVzc1R5cGUge3N0cmluZ30gICBEZXByZWNhdGVkXG4gICAqIEBwYXJhbSBwYXJhbXMua2V5Y2hhaW5zICAge1tvYmplY3RdfSBBcnJheSBvZiBvYmplY3RzIHdpdGggeHB1YnNcbiAgICogQHBhcmFtIHBhcmFtcy50aHJlc2hvbGQgICB7bnVtYmVyfSAgIE1pbmltdW0gbnVtYmVyIG9mIHNpZ25hdHVyZXNcbiAgICogQHBhcmFtIHBhcmFtcy5jaGFpbiAgICAgICB7bnVtYmVyfSAgIERlcml2YXRpb24gY2hhaW4gKHNlZSBodHRwczovL2dpdGh1Yi5jb20vQml0R28vdW5zcGVudHMvYmxvYi9tYXN0ZXIvc3JjL2NvZGVzLnRzIGZvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgY29ycmVzcG9uZGluZyBhZGRyZXNzIHR5cGUgb2YgYSBnaXZlbiBjaGFpbiBjb2RlKVxuICAgKiBAcGFyYW0gcGFyYW1zLmluZGV4ICAgICAgIHtudW1iZXJ9ICAgRGVyaXZhdGlvbiBpbmRleFxuICAgKiBAcGFyYW0gcGFyYW1zLnNlZ3dpdCAgICAgIHtib29sZWFufSAgRGVwcmVjYXRlZFxuICAgKiBAcGFyYW0gcGFyYW1zLmJlY2gzMiAgICAgIHtib29sZWFufSAgRGVwcmVjYXRlZFxuICAgKiBAcmV0dXJucyB7e2NoYWluOiBudW1iZXIsIGluZGV4OiBudW1iZXIsIGNvaW46IG51bWJlciwgY29pblNwZWNpZmljOiB7b3V0cHV0U2NyaXB0LCByZWRlZW1TY3JpcHR9fX1cbiAgICovXG4gIGdlbmVyYXRlQWRkcmVzcyhwYXJhbXM6IEdlbmVyYXRlQWRkcmVzc09wdGlvbnMpOiBBZGRyZXNzRGV0YWlscyB7XG4gICAgY29uc3QgeyBrZXljaGFpbnMsIHRocmVzaG9sZCwgY2hhaW4sIGluZGV4LCBzZWd3aXQgPSBmYWxzZSwgYmVjaDMyID0gZmFsc2UgfSA9IHBhcmFtcztcbiAgICBsZXQgZGVyaXZhdGlvbkNoYWluID0gMDtcbiAgICBpZiAoXy5pc051bWJlcihjaGFpbikgJiYgXy5pc0ludGVnZXIoY2hhaW4pICYmIGNoYWluID4gMCkge1xuICAgICAgZGVyaXZhdGlvbkNoYWluID0gY2hhaW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udmVydEZsYWdzVG9BZGRyZXNzVHlwZSgpOiBzdHJpbmcge1xuICAgICAgaWYgKF8uaXNCb29sZWFuKHNlZ3dpdCkgJiYgc2Vnd2l0KSB7XG4gICAgICAgIHJldHVybiBDb2Rlcy5VbnNwZW50VHlwZVRjb21iKCdwMnNoUDJ3c2gnKTtcbiAgICAgIH0gZWxzZSBpZiAoXy5pc0Jvb2xlYW4oYmVjaDMyKSAmJiBiZWNoMzIpIHtcbiAgICAgICAgcmV0dXJuIENvZGVzLlVuc3BlbnRUeXBlVGNvbWIoJ3Ayd3NoJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gQ29kZXMuVW5zcGVudFR5cGVUY29tYigncDJzaCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGFkZHJlc3NUeXBlID0gcGFyYW1zLmFkZHJlc3NUeXBlIHx8IGNvbnZlcnRGbGFnc1RvQWRkcmVzc1R5cGUoKTtcblxuICAgIHN3aXRjaCAoYWRkcmVzc1R5cGUpIHtcbiAgICAgIGNhc2UgQ29kZXMuVW5zcGVudFR5cGVUY29tYigncDJzaCcpOlxuICAgICAgICBpZiAoIUNvZGVzLmlzUDJzaChkZXJpdmF0aW9uQ2hhaW4pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5BZGRyZXNzVHlwZUNoYWluTWlzbWF0Y2hFcnJvcihhZGRyZXNzVHlwZSwgZGVyaXZhdGlvbkNoYWluKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ29kZXMuVW5zcGVudFR5cGVUY29tYigncDJzaFAyd3NoJyk6XG4gICAgICAgIGlmICghdGhpcy5zdXBwb3J0c1Ayc2hQMndzaCgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5QMnNoUDJ3c2hVbnN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUNvZGVzLmlzUDJzaFAyd3NoKGRlcml2YXRpb25DaGFpbikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkFkZHJlc3NUeXBlQ2hhaW5NaXNtYXRjaEVycm9yKGFkZHJlc3NUeXBlLCBkZXJpdmF0aW9uQ2hhaW4pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDb2Rlcy5VbnNwZW50VHlwZVRjb21iKCdwMndzaCcpOlxuICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydHNQMndzaCgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5QMndzaFVuc3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQ29kZXMuaXNQMndzaChkZXJpdmF0aW9uQ2hhaW4pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5BZGRyZXNzVHlwZUNoYWluTWlzbWF0Y2hFcnJvcihhZGRyZXNzVHlwZSwgZGVyaXZhdGlvbkNoYWluKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnMuVW5zdXBwb3J0ZWRBZGRyZXNzVHlwZUVycm9yKCk7XG4gICAgfVxuXG4gICAgbGV0IHNpZ25hdHVyZVRocmVzaG9sZCA9IDI7XG4gICAgaWYgKF8uaXNJbnRlZ2VyKHRocmVzaG9sZCkpIHtcbiAgICAgIHNpZ25hdHVyZVRocmVzaG9sZCA9IHRocmVzaG9sZDtcbiAgICAgIGlmIChzaWduYXR1cmVUaHJlc2hvbGQgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RocmVzaG9sZCBoYXMgdG8gYmUgcG9zaXRpdmUnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaWduYXR1cmVUaHJlc2hvbGQgPiBrZXljaGFpbnMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndGhyZXNob2xkIGNhbm5vdCBleGNlZWQgbnVtYmVyIG9mIGtleXMnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgZGVyaXZhdGlvbkluZGV4ID0gMDtcbiAgICBpZiAoXy5pc0ludGVnZXIoaW5kZXgpICYmIGluZGV4ID4gMCkge1xuICAgICAgZGVyaXZhdGlvbkluZGV4ID0gaW5kZXg7XG4gICAgfVxuXG4gICAgY29uc3QgcGF0aCA9ICdtLzAvMC8nICsgZGVyaXZhdGlvbkNoYWluICsgJy8nICsgZGVyaXZhdGlvbkluZGV4O1xuICAgIGNvbnN0IGhkTm9kZXMgPSBrZXljaGFpbnMubWFwKCh7IHB1YiB9KSA9PiBiaXRjb2luLkhETm9kZS5mcm9tQmFzZTU4KHB1YikpO1xuICAgIGNvbnN0IGRlcml2ZWRLZXlzID0gaGROb2Rlcy5tYXAoaGROb2RlID0+IGhkUGF0aChoZE5vZGUpLmRlcml2ZUtleShwYXRoKS5nZXRQdWJsaWNLZXlCdWZmZXIoKSk7XG5cbiAgICBjb25zdCB7IG91dHB1dFNjcmlwdCwgcmVkZWVtU2NyaXB0LCB3aXRuZXNzU2NyaXB0LCBhZGRyZXNzIH0gPVxuICAgICAgdGhpcy5jcmVhdGVNdWx0aVNpZ0FkZHJlc3MoYWRkcmVzc1R5cGUsIHNpZ25hdHVyZVRocmVzaG9sZCwgZGVyaXZlZEtleXMpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZHJlc3MsXG4gICAgICBjaGFpbjogZGVyaXZhdGlvbkNoYWluLFxuICAgICAgaW5kZXg6IGRlcml2YXRpb25JbmRleCxcbiAgICAgIGNvaW46IHRoaXMuZ2V0Q2hhaW4oKSxcbiAgICAgIGNvaW5TcGVjaWZpYzoge1xuICAgICAgICBvdXRwdXRTY3JpcHQ6IG91dHB1dFNjcmlwdC50b1N0cmluZygnaGV4JyksXG4gICAgICAgIHJlZGVlbVNjcmlwdDogcmVkZWVtU2NyaXB0ICYmIHJlZGVlbVNjcmlwdC50b1N0cmluZygnaGV4JyksXG4gICAgICAgIHdpdG5lc3NTY3JpcHQ6IHdpdG5lc3NTY3JpcHQgJiYgd2l0bmVzc1NjcmlwdC50b1N0cmluZygnaGV4JyksXG4gICAgICB9LFxuICAgICAgYWRkcmVzc1R5cGUsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlbWJsZSBrZXljaGFpbiBhbmQgaGFsZi1zaWduIHByZWJ1aWx0IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy50eFByZWJ1aWxkIHRyYW5zYWN0aW9uIHByZWJ1aWxkIGZyb20gYml0Z28gc2VydmVyXG4gICAqIEBwYXJhbSBwYXJhbXMucHJ2IHByaXZhdGUga2V5IHRvIGJlIHVzZWQgZm9yIHNpZ25pbmdcbiAgICogQHBhcmFtIHBhcmFtcy5pc0xhc3RTaWduYXR1cmUgVHJ1ZSBpZiBgVHJhbnNhY3Rpb25CdWlsZGVyLmJ1aWxkKClgIHNob3VsZCBiZSBjYWxsZWQgYW5kIG5vdCBgVHJhbnNhY3Rpb25CdWlsZGVyLmJ1aWxkSW5jb21wbGV0ZSgpYFxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge0JsdWViaXJkPFNpZ25lZFRyYW5zYWN0aW9uPn1cbiAgICovXG4gIHNpZ25UcmFuc2FjdGlvbihwYXJhbXM6IFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFNpZ25lZFRyYW5zYWN0aW9uPik6IEJsdWViaXJkPFNpZ25lZFRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPFNpZ25lZFRyYW5zYWN0aW9uPihmdW5jdGlvbiAqKCkge1xuICAgICAgY29uc3QgdHhQcmVidWlsZCA9IHBhcmFtcy50eFByZWJ1aWxkO1xuICAgICAgY29uc3QgdXNlclBydiA9IHBhcmFtcy5wcnY7XG5cbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHR4UHJlYnVpbGQpIHx8ICFfLmlzT2JqZWN0KHR4UHJlYnVpbGQpKSB7XG4gICAgICAgIGlmICghXy5pc1VuZGVmaW5lZCh0eFByZWJ1aWxkKSAmJiAhXy5pc09iamVjdCh0eFByZWJ1aWxkKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdHhQcmVidWlsZCBtdXN0IGJlIGFuIG9iamVjdCwgZ290IHR5cGUgJHt0eXBlb2YgdHhQcmVidWlsZH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgdHhQcmVidWlsZCBwYXJhbWV0ZXInKTtcbiAgICAgIH1cbiAgICAgIGxldCB0cmFuc2FjdGlvbiA9IGJpdGNvaW4uVHJhbnNhY3Rpb24uZnJvbUhleCh0eFByZWJ1aWxkLnR4SGV4LCBzZWxmLm5ldHdvcmspO1xuXG4gICAgICBpZiAodHJhbnNhY3Rpb24uaW5zLmxlbmd0aCAhPT0gdHhQcmVidWlsZC50eEluZm8udW5zcGVudHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbGVuZ3RoIG9mIHVuc3BlbnRzIGFycmF5IHNob3VsZCBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIHRyYW5zYWN0aW9uIGlucHV0cycpO1xuICAgICAgfVxuXG4gICAgICBsZXQgaXNMYXN0U2lnbmF0dXJlID0gZmFsc2U7XG4gICAgICBpZiAoXy5pc0Jvb2xlYW4ocGFyYW1zLmlzTGFzdFNpZ25hdHVyZSkpIHtcbiAgICAgICAgLy8gaWYgYnVpbGQgaXMgY2FsbGVkIGluc3RlYWQgb2YgYnVpbGRJbmNvbXBsZXRlLCBubyBzaWduYXR1cmUgcGxhY2Vob2xkZXJzIGFyZSBsZWZ0IGluIHRoZSBzaWcgc2NyaXB0XG4gICAgICAgIGlzTGFzdFNpZ25hdHVyZSA9IHBhcmFtcy5pc0xhc3RTaWduYXR1cmU7XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHVzZXJQcnYpIHx8ICFfLmlzU3RyaW5nKHVzZXJQcnYpKSB7XG4gICAgICAgIGlmICghXy5pc1VuZGVmaW5lZCh1c2VyUHJ2KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcHJ2IG11c3QgYmUgYSBzdHJpbmcsIGdvdCB0eXBlICR7dHlwZW9mIHVzZXJQcnZ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHBydiBwYXJhbWV0ZXIgdG8gc2lnbiB0cmFuc2FjdGlvbicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBrZXljaGFpbiA9IGJpdGNvaW4uSEROb2RlLmZyb21CYXNlNTgodXNlclBydik7XG4gICAgICBjb25zdCBrZXljaGFpbkhkUGF0aCA9IGhkUGF0aChrZXljaGFpbik7XG4gICAgICBjb25zdCB0eGIgPSBiaXRjb2luLlRyYW5zYWN0aW9uQnVpbGRlci5mcm9tVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIHNlbGYubmV0d29yayk7XG4gICAgICBzZWxmLnByZXBhcmVUcmFuc2FjdGlvbkJ1aWxkZXIodHhiKTtcblxuICAgICAgY29uc3QgZ2V0U2lnbmF0dXJlQ29udGV4dCA9ICh0eFByZWJ1aWxkOiBUcmFuc2FjdGlvblByZWJ1aWxkLCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRVbnNwZW50ID0gdHhQcmVidWlsZC50eEluZm8udW5zcGVudHNbaW5kZXhdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlucHV0SW5kZXg6IGluZGV4LFxuICAgICAgICAgIHVuc3BlbnQ6IGN1cnJlbnRVbnNwZW50LFxuICAgICAgICAgIHBhdGg6ICdtLzAvMC8nICsgY3VycmVudFVuc3BlbnQuY2hhaW4gKyAnLycgKyBjdXJyZW50VW5zcGVudC5pbmRleCxcbiAgICAgICAgICBpc1Ayd3NoOiAhY3VycmVudFVuc3BlbnQucmVkZWVtU2NyaXB0LFxuICAgICAgICAgIGlzQml0R29UYWludGVkVW5zcGVudDogc2VsZi5pc0JpdEdvVGFpbnRlZFVuc3BlbnQoY3VycmVudFVuc3BlbnQpLFxuICAgICAgICAgIGVycm9yOiB1bmRlZmluZWQgYXMgRXJyb3IgfCB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzaWduYXR1cmVJc3N1ZXM6IFJldHVyblR5cGU8dHlwZW9mIGdldFNpZ25hdHVyZUNvbnRleHQ+W10gPSBbXTtcbiAgICAgIC8vIFNpZ24gaW5wdXRzXG4gICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdHJhbnNhY3Rpb24uaW5zLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICBkZWJ1ZygnU2lnbmluZyBpbnB1dCAlZCBvZiAlZCcsIGluZGV4ICsgMSwgdHJhbnNhY3Rpb24uaW5zLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZUNvbnRleHQgPSBnZXRTaWduYXR1cmVDb250ZXh0KHR4UHJlYnVpbGQsIGluZGV4KTtcbiAgICAgICAgaWYgKHNpZ25hdHVyZUNvbnRleHQuaXNCaXRHb1RhaW50ZWRVbnNwZW50KSB7XG4gICAgICAgICAgZGVidWcoXG4gICAgICAgICAgICAnU2tpcHBpbmcgaW5wdXQgJWQgb2YgJWQgKHVuc3BlbnQgZnJvbSByZXBsYXkgcHJvdGVjdGlvbiBhZGRyZXNzIHdoaWNoIGlzIHBsYXRmb3JtIHNpZ25lZCBvbmx5KScsXG4gICAgICAgICAgICBpbmRleCArIDEsIHRyYW5zYWN0aW9uLmlucy5sZW5ndGhcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByaXZLZXkgPSBrZXljaGFpbkhkUGF0aC5kZXJpdmVLZXkoc2lnbmF0dXJlQ29udGV4dC5wYXRoKTtcbiAgICAgICAgcHJpdktleS5uZXR3b3JrID0gc2VsZi5uZXR3b3JrO1xuXG4gICAgICAgIGRlYnVnKCdJbnB1dCBkZXRhaWxzOiAlTycsIHNpZ25hdHVyZUNvbnRleHQpO1xuXG4gICAgICAgIGNvbnN0IHNpZ0hhc2hUeXBlID0gc2VsZi5kZWZhdWx0U2lnSGFzaFR5cGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHNpZ25hdHVyZUNvbnRleHQuaXNQMndzaCkge1xuICAgICAgICAgICAgZGVidWcoJ1NpZ25pbmcgcDJ3c2ggaW5wdXQnKTtcbiAgICAgICAgICAgIGNvbnN0IHdpdG5lc3NTY3JpcHQgPSBCdWZmZXIuZnJvbShzaWduYXR1cmVDb250ZXh0LnVuc3BlbnQud2l0bmVzc1NjcmlwdCwgJ2hleCcpO1xuICAgICAgICAgICAgY29uc3Qgd2l0bmVzc1NjcmlwdEhhc2ggPSBiaXRjb2luLmNyeXB0by5zaGEyNTYod2l0bmVzc1NjcmlwdCk7XG4gICAgICAgICAgICBjb25zdCBwcmV2T3V0U2NyaXB0ID0gYml0Y29pbi5zY3JpcHQud2l0bmVzc1NjcmlwdEhhc2gub3V0cHV0LmVuY29kZSh3aXRuZXNzU2NyaXB0SGFzaCk7XG4gICAgICAgICAgICB0eGIuc2lnbihpbmRleCwgcHJpdktleSwgcHJldk91dFNjcmlwdCwgc2lnSGFzaFR5cGUsIHNpZ25hdHVyZUNvbnRleHQudW5zcGVudC52YWx1ZSwgd2l0bmVzc1NjcmlwdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdCA9IG5ldyBCdWZmZXIoc2lnbmF0dXJlQ29udGV4dC51bnNwZW50LnJlZGVlbVNjcmlwdCwgJ2hleCcpO1xuICAgICAgICAgICAgY29uc3QgaXNQMnNoUDJ3c2ggPSAhIXNpZ25hdHVyZUNvbnRleHQudW5zcGVudC53aXRuZXNzU2NyaXB0O1xuICAgICAgICAgICAgaWYgKGlzUDJzaFAyd3NoKSB7XG4gICAgICAgICAgICAgIGRlYnVnKCdTaWduaW5nIHAyc2hQMndzaCBpbnB1dCcpO1xuICAgICAgICAgICAgICBjb25zdCB3aXRuZXNzU2NyaXB0ID0gQnVmZmVyLmZyb20oc2lnbmF0dXJlQ29udGV4dC51bnNwZW50LndpdG5lc3NTY3JpcHQsICdoZXgnKTtcbiAgICAgICAgICAgICAgdHhiLnNpZ24oaW5kZXgsIHByaXZLZXksIHN1YnNjcmlwdCwgc2lnSGFzaFR5cGUsIHNpZ25hdHVyZUNvbnRleHQudW5zcGVudC52YWx1ZSwgd2l0bmVzc1NjcmlwdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkZWJ1ZygnU2lnbmluZyBwMnNoIGlucHV0Jyk7XG4gICAgICAgICAgICAgIHR4Yi5zaWduKGluZGV4LCBwcml2S2V5LCBzdWJzY3JpcHQsIHNpZ0hhc2hUeXBlLCBzaWduYXR1cmVDb250ZXh0LnVuc3BlbnQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcoJ0ZhaWxlZCB0byBzaWduIGlucHV0OicsIGUpO1xuICAgICAgICAgIHNpZ25hdHVyZUNvbnRleHQuZXJyb3IgPSBlO1xuICAgICAgICAgIHNpZ25hdHVyZUlzc3Vlcy5wdXNoKHNpZ25hdHVyZUNvbnRleHQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKCdTdWNjZXNzZnVsbHkgc2lnbmVkIGlucHV0ICVkIG9mICVkJywgaW5kZXggKyAxLCB0cmFuc2FjdGlvbi5pbnMubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzTGFzdFNpZ25hdHVyZSkge1xuICAgICAgICB0cmFuc2FjdGlvbiA9IHR4Yi5idWlsZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNhY3Rpb24gPSB0eGIuYnVpbGRJbmNvbXBsZXRlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFZlcmlmeSBpbnB1dCBzaWduYXR1cmVzXG4gICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdHJhbnNhY3Rpb24uaW5zLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICBkZWJ1ZygnVmVyaWZ5aW5nIGlucHV0IHNpZ25hdHVyZSAlZCBvZiAlZCcsIGluZGV4ICsgMSwgdHJhbnNhY3Rpb24uaW5zLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZUNvbnRleHQgPSBnZXRTaWduYXR1cmVDb250ZXh0KHR4UHJlYnVpbGQsIGluZGV4KTtcbiAgICAgICAgaWYgKHNpZ25hdHVyZUNvbnRleHQuaXNCaXRHb1RhaW50ZWRVbnNwZW50KSB7XG4gICAgICAgICAgZGVidWcoXG4gICAgICAgICAgICAnU2tpcHBpbmcgaW5wdXQgc2lnbmF0dXJlICVkIG9mICVkICh1bnNwZW50IGZyb20gcmVwbGF5IHByb3RlY3Rpb24gYWRkcmVzcyB3aGljaCBpcyBwbGF0Zm9ybSBzaWduZWQgb25seSknLFxuICAgICAgICAgICAgaW5kZXggKyAxLCB0cmFuc2FjdGlvbi5pbnMubGVuZ3RoXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaWduYXR1cmVDb250ZXh0LmlzUDJ3c2gpIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5zZXRJbnB1dFNjcmlwdChpbmRleCwgQnVmZmVyLmFsbG9jKDApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzVmFsaWRTaWduYXR1cmUgPSBzZWxmLnZlcmlmeVNpZ25hdHVyZSh0cmFuc2FjdGlvbiwgaW5kZXgsIHNpZ25hdHVyZUNvbnRleHQudW5zcGVudC52YWx1ZSk7XG4gICAgICAgIGlmICghaXNWYWxpZFNpZ25hdHVyZSkge1xuICAgICAgICAgIGRlYnVnKCdJbnZhbGlkIHNpZ25hdHVyZScpO1xuICAgICAgICAgIHNpZ25hdHVyZUNvbnRleHQuZXJyb3IgPSBuZXcgRXJyb3IoJ2ludmFsaWQgc2lnbmF0dXJlJyk7XG4gICAgICAgICAgc2lnbmF0dXJlSXNzdWVzLnB1c2goc2lnbmF0dXJlQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNpZ25hdHVyZUlzc3Vlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGZhaWxlZEluZGljZXMgPSBzaWduYXR1cmVJc3N1ZXMubWFwKGN1cnJlbnRJc3N1ZSA9PiBjdXJyZW50SXNzdWUuaW5wdXRJbmRleCk7XG4gICAgICAgIGNvbnN0IGVycm9yOiBhbnkgPSBuZXcgRXJyb3IoYEZhaWxlZCB0byBzaWduIGlucHV0cyBhdCBpbmRpY2VzICR7ZmFpbGVkSW5kaWNlcy5qb2luKCcsICcpfWApO1xuICAgICAgICBlcnJvci5jb2RlID0gJ2lucHV0X3NpZ25hdHVyZV9mYWlsdXJlJztcbiAgICAgICAgZXJyb3Iuc2lnbmluZ0Vycm9ycyA9IHNpZ25hdHVyZUlzc3VlcztcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR4SGV4OiB0cmFuc2FjdGlvbi50b0J1ZmZlcigpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIH07XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQWx3YXlzIGZhbHNlIGZvciBjb2lucyBvdGhlciB0aGFuIEJDSCBhbmQgVEJDSC5cbiAgICogQHBhcmFtIHVuc3BlbnRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc0JpdEdvVGFpbnRlZFVuc3BlbnQodW5zcGVudDogVW5zcGVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2RpZnkgdGhlIHRyYW5zYWN0aW9uIGJ1aWxkZXIgdG8gY29tcGx5IHdpdGggdGhlIHNwZWNpZmljIGNvaW4ncyByZXF1aXJlbWVudHMgc3VjaCBhcyB2ZXJzaW9uIGFuZCBicmFuY2ggaWRcbiAgICogQHBhcmFtIHR4QnVpbGRlclxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHByZXBhcmVUcmFuc2FjdGlvbkJ1aWxkZXIodHhCdWlsZGVyOiBhbnkpOiBhbnkge1xuICAgIHJldHVybiB0eEJ1aWxkZXI7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IHNpZ2hhc2ggdHlwZSB0byBiZSB1c2VkIHdoZW4gc2lnbmluZyB0cmFuc2FjdGlvbnNcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGdldCBkZWZhdWx0U2lnSGFzaFR5cGUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gYml0Y29pbi5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhIHRyYW5zYWN0aW9uJ3Mgc2lnbmF0dXJlIHNjcmlwdCB0byBvYnRhaW4gcHVibGljIGtleXMsIHNpZ25hdHVyZXMsIHRoZSBzaWcgc2NyaXB0LCBhbmQgb3RoZXIgcHJvcGVydGllc1xuICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIGlucHV0SW5kZXhcbiAgICogQHJldHVybnMgeyBpc1NlZ3dpdElucHV0OiBib29sZWFuLCBpbnB1dENsYXNzaWZpY2F0aW9uOiBzdHJpbmcsIHNpZ25hdHVyZXM6IFtCdWZmZXJdLCBwdWJsaWNLZXlzOiBbQnVmZmVyXSwgcHViU2NyaXB0OiBCdWZmZXIgfVxuICAgKi9cbiAgcGFyc2VTaWduYXR1cmVTY3JpcHQodHJhbnNhY3Rpb246IGFueSwgaW5wdXRJbmRleDogbnVtYmVyKTogUGFyc2VkU2lnbmF0dXJlU2NyaXB0IHtcbiAgICBjb25zdCBjdXJyZW50SW5wdXQgPSB0cmFuc2FjdGlvbi5pbnNbaW5wdXRJbmRleF07XG4gICAgY29uc3QgaXNTZWd3aXRJbnB1dCA9IGN1cnJlbnRJbnB1dC53aXRuZXNzLmxlbmd0aCA+IDA7XG4gICAgY29uc3QgaXNOYXRpdmVTZWd3aXRJbnB1dCA9IGN1cnJlbnRJbnB1dC5zY3JpcHQubGVuZ3RoID09PSAwO1xuICAgIGxldCBkZWNvbXBpbGVkU2lnU2NyaXB0LCBpbnB1dENsYXNzaWZpY2F0aW9uO1xuICAgIGlmIChpc1NlZ3dpdElucHV0KSB7XG4gICAgICAvLyBUaGUgZGVjb21waWxlZFNpZ1NjcmlwdCBpcyB0aGUgc2NyaXB0IGNvbnRhaW5pbmcgdGhlIHNpZ25hdHVyZXMsIHB1YmxpYyBrZXlzLCBhbmQgdGhlIHNjcmlwdCB0aGF0IHdhcyBjb21taXR0ZWRcbiAgICAgIC8vIHRvIChwdWJTY3JpcHQpLiBJZiB0aGlzIGlzIGEgc2Vnd2l0IGlucHV0IHRoZSBkZWNvbXBpbGVkU2lnU2NyaXB0IGlzIGluIHRoZSB3aXRuZXNzLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgaXRcbiAgICAgIC8vIGlzIG5hdGl2ZSBvciBub3QuIFRoZSBpbnB1dENsYXNzaWZpY2F0aW9uIGlzIGRldGVybWluZWQgYmFzZWQgb24gd2hldGhlciBvciBub3QgdGhlIGlucHV0IGlzIG5hdGl2ZSB0byBnaXZlIGFuXG4gICAgICAvLyBhY2N1cmF0ZSBjbGFzc2lmaWNhdGlvbi4gTm90ZSB0aGF0IHAyc2hQMndzaCBpbnB1dHMgd2lsbCBiZSBjbGFzc2lmaWVkIGFzIHAyc2ggYW5kIG5vdCBwMndzaC5cbiAgICAgIGRlY29tcGlsZWRTaWdTY3JpcHQgPSBjdXJyZW50SW5wdXQud2l0bmVzcztcbiAgICAgIGlmIChpc05hdGl2ZVNlZ3dpdElucHV0KSB7XG4gICAgICAgIGlucHV0Q2xhc3NpZmljYXRpb24gPSBiaXRjb2luLnNjcmlwdC5jbGFzc2lmeVdpdG5lc3MoYml0Y29pbi5zY3JpcHQuY29tcGlsZShkZWNvbXBpbGVkU2lnU2NyaXB0KSwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dENsYXNzaWZpY2F0aW9uID0gYml0Y29pbi5zY3JpcHQuY2xhc3NpZnlJbnB1dChjdXJyZW50SW5wdXQuc2NyaXB0LCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXRDbGFzc2lmaWNhdGlvbiA9IGJpdGNvaW4uc2NyaXB0LmNsYXNzaWZ5SW5wdXQoY3VycmVudElucHV0LnNjcmlwdCwgdHJ1ZSk7XG4gICAgICBkZWNvbXBpbGVkU2lnU2NyaXB0ID0gYml0Y29pbi5zY3JpcHQuZGVjb21waWxlKGN1cnJlbnRJbnB1dC5zY3JpcHQpO1xuICAgIH1cblxuICAgIGlmIChpbnB1dENsYXNzaWZpY2F0aW9uID09PSBiaXRjb2luLnNjcmlwdC50eXBlcy5QMlBLSCkge1xuICAgICAgY29uc3QgW3NpZ25hdHVyZSwgcHVibGljS2V5XSA9IGRlY29tcGlsZWRTaWdTY3JpcHQ7XG4gICAgICBjb25zdCBwdWJsaWNLZXlzID0gW3B1YmxpY0tleV07XG4gICAgICBjb25zdCBzaWduYXR1cmVzID0gW3NpZ25hdHVyZV07XG4gICAgICBjb25zdCBwdWJTY3JpcHQgPSBiaXRjb2luLnNjcmlwdC5wdWJLZXlIYXNoLm91dHB1dC5lbmNvZGUoYml0Y29pbi5jcnlwdG8uaGFzaDE2MChwdWJsaWNLZXkpKTtcblxuICAgICAgcmV0dXJuIHsgaXNTZWd3aXRJbnB1dCwgaW5wdXRDbGFzc2lmaWNhdGlvbiwgc2lnbmF0dXJlcywgcHVibGljS2V5cywgcHViU2NyaXB0IH07XG4gICAgfSBlbHNlIGlmIChpbnB1dENsYXNzaWZpY2F0aW9uID09PSBiaXRjb2luLnNjcmlwdC50eXBlcy5QMlNIXG4gICAgICAgIHx8IGlucHV0Q2xhc3NpZmljYXRpb24gPT09IGJpdGNvaW4uc2NyaXB0LnR5cGVzLlAyV1NIKSB7XG4gICAgICAvLyBOb3RlIHRoZSBhc3N1bXB0aW9uIGhlcmUgdGhhdCBpZiB3ZSBoYXZlIGEgcDJzaCBvciBwMndzaCBpbnB1dCBpdCB3aWxsIGJlIG11bHRpc2lnIChhcHByb3ByaWF0ZSBiZWNhdXNlIHRoZVxuICAgICAgLy8gQml0R28gcGxhdGZvcm0gb25seSBzdXBwb3J0cyBtdWx0aXNpZyB3aXRoaW4gdGhlc2UgdHlwZXMgb2YgaW5wdXRzKS4gU2lnbmF0dXJlcyBhcmUgYWxsIGJ1dCB0aGUgbGFzdCBlbnRyeSBpblxuICAgICAgLy8gdGhlIGRlY29tcGlsZWRTaWdTY3JpcHQuIFRoZSByZWRlZW1TY3JpcHQvd2l0bmVzc1NjcmlwdCAoZGVwZW5kaW5nIG9uIHdoaWNoIHR5cGUgb2YgaW5wdXQgdGhpcyBpcykgaXMgdGhlIGxhc3RcbiAgICAgIC8vIGVudHJ5IGluIHRoZSBkZWNvbXBpbGVkU2lnU2NyaXB0IChkZW5vdGVkIGhlcmUgYXMgdGhlIHB1YlNjcmlwdCkuIFRoZSBwdWJsaWMga2V5cyBhcmUgdGhlIHNlY29uZCB0aHJvdWdoXG4gICAgICAvLyBhbnRlcGVudWx0aW1hdGUgZW50cmllcyBpbiB0aGUgZGVjb21waWxlZFB1YlNjcmlwdC4gU2VlIGJlbG93IGZvciBhIHZpc3VhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdHlwaWNhbCAyLW9mLTNcbiAgICAgIC8vIG11bHRpc2lnIHNldHVwOlxuICAgICAgLy9cbiAgICAgIC8vIGRlY29tcGlsZWRTaWdTY3JpcHQgPSAwIDxzaWcxPiA8c2lnMj4gPHB1YlNjcmlwdD5cbiAgICAgIC8vIGRlY29tcGlsZWRQdWJTY3JpcHQgPSAyIDxwdWIxPiA8cHViMj4gPHB1YjM+IDMgT1BfQ0hFQ0tNVUxUSVNJR1xuICAgICAgY29uc3Qgc2lnbmF0dXJlcyA9IGRlY29tcGlsZWRTaWdTY3JpcHQuc2xpY2UoMCwgLTEpO1xuICAgICAgY29uc3QgcHViU2NyaXB0ID0gXy5sYXN0PEJ1ZmZlcj4oZGVjb21waWxlZFNpZ1NjcmlwdCk7XG4gICAgICBjb25zdCBkZWNvbXBpbGVkUHViU2NyaXB0ID0gYml0Y29pbi5zY3JpcHQuZGVjb21waWxlKHB1YlNjcmlwdCk7XG4gICAgICBjb25zdCBwdWJsaWNLZXlzID0gZGVjb21waWxlZFB1YlNjcmlwdC5zbGljZSgxLCAtMik7XG5cbiAgICAgIC8vIE9wIGNvZGVzIDgxIHRocm91Z2ggOTYgcmVwcmVzZW50IG51bWJlcnMgMSB0aHJvdWdoIDE2IChzZWUgaHR0cHM6Ly9lbi5iaXRjb2luLml0L3dpa2kvU2NyaXB0I09wY29kZXMpLCB3aGljaCBpc1xuICAgICAgLy8gd2h5IHdlIHN1YnRyYWN0IGJ5IDgwIHRvIGdldCB0aGUgbnVtYmVyIG9mIHNpZ25hdHVyZXMgKG4pIGFuZCB0aGUgbnVtYmVyIG9mIHB1YmxpYyBrZXlzIChtKSBpbiBhbiBuLW9mLW0gc2V0dXAuXG4gICAgICBjb25zdCBsZW4gPSBkZWNvbXBpbGVkUHViU2NyaXB0Lmxlbmd0aDtcbiAgICAgIGNvbnN0IG5TaWduYXR1cmVzID0gZGVjb21waWxlZFB1YlNjcmlwdFswXSAtIDgwO1xuICAgICAgY29uc3QgblB1YktleXMgPSBkZWNvbXBpbGVkUHViU2NyaXB0W2xlbiAtIDJdIC0gODA7XG5cbiAgICAgIC8vIER1ZSB0byBhIGJ1ZyBpbiB0aGUgaW1wbGVtZW50YXRpb24gb2YgbXVsdGlzaWduYXR1cmUgaW4gdGhlIGJpdGNvaW4gcHJvdG9jb2wsIGEgMCBpcyBhZGRlZCB0byB0aGUgc2lnbmF0dXJlXG4gICAgICAvLyBzY3JpcHQsIHNvIHdlIGFkZCAxIHdoZW4gYXNzZXJ0aW5nIHRoZSBudW1iZXIgb2Ygc2lnbmF0dXJlcyBtYXRjaGVzIHRoZSBudW1iZXIgb2Ygc2lnbmF0dXJlcyBleHBlY3RlZCBieSB0aGVcbiAgICAgIC8vIHB1YiBzY3JpcHQuIEFsc28sIG5vdGUgdGhhdCB3ZSBjb25zaWRlciBhIHNpZ25hdHVyZSBzY3JpcHQgd2l0aCB0aGUgdGhlIHNhbWUgbnVtYmVyIG9mIHNpZ25hdHVyZXMgYXMgcHVibGljXG4gICAgICAvLyBrZXlzICgrMSBhcyBub3RlZCBhYm92ZSkgdmFsaWQgYmVjYXVzZSB3ZSB1c2UgcGxhY2Vob2xkZXIgc2lnbmF0dXJlcyB3aGVuIHBhcnNpbmcgYSBoYWxmLXNpZ25lZCBzaWduYXR1cmVcbiAgICAgIC8vIHNjcmlwdC5cbiAgICAgIGlmIChzaWduYXR1cmVzLmxlbmd0aCAhPT0gblNpZ25hdHVyZXMgKyAxICYmIHNpZ25hdHVyZXMubGVuZ3RoICE9PSBuUHViS2V5cyArIDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke25TaWduYXR1cmVzfSBvciAke25QdWJLZXlzfSBzaWduYXR1cmVzLCBnb3QgJHtzaWduYXR1cmVzLmxlbmd0aCAtIDF9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwdWJsaWNLZXlzLmxlbmd0aCAhPT0gblB1YktleXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke25QdWJLZXlzfSBwdWJsaWMga2V5cywgZ290ICR7cHVibGljS2V5cy5sZW5ndGh9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxhc3RPcENvZGUgPSBkZWNvbXBpbGVkUHViU2NyaXB0W2xlbiAtIDFdO1xuICAgICAgaWYgKGxhc3RPcENvZGUgIT09IGJpdGNvaW4ub3Bjb2Rlcy5PUF9DSEVDS01VTFRJU0lHKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgb3Bjb2RlICMke2JpdGNvaW4ub3Bjb2Rlcy5PUF9DSEVDS01VTFRJU0lHfSwgZ290IG9wY29kZSAjJHtsYXN0T3BDb2RlfWApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBpc1NlZ3dpdElucHV0LCBpbnB1dENsYXNzaWZpY2F0aW9uLCBzaWduYXR1cmVzLCBwdWJsaWNLZXlzLCBwdWJTY3JpcHQgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgaXNTZWd3aXRJbnB1dCwgaW5wdXRDbGFzc2lmaWNhdGlvbiB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGhhc2ggdG8gdmVyaWZ5IHRoZSBzaWduYXR1cmUgYWdhaW5zdFxuICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gVHJhbnNhY3Rpb24gb2JqZWN0XG4gICAqIEBwYXJhbSBpbnB1dEluZGV4XG4gICAqIEBwYXJhbSBwdWJTY3JpcHRcbiAgICogQHBhcmFtIGFtb3VudCBUaGUgcHJldmlvdXMgb3V0cHV0J3MgYW1vdW50XG4gICAqIEBwYXJhbSBoYXNoVHlwZVxuICAgKiBAcGFyYW0gaXNTZWd3aXRJbnB1dFxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGNhbGN1bGF0ZVNpZ25hdHVyZUhhc2godHJhbnNhY3Rpb246IGFueSwgaW5wdXRJbmRleDogbnVtYmVyLCBwdWJTY3JpcHQ6IEJ1ZmZlciwgYW1vdW50OiBudW1iZXIsIGhhc2hUeXBlOiBudW1iZXIsIGlzU2Vnd2l0SW5wdXQ6IGJvb2xlYW4pOiBCdWZmZXIge1xuICAgIGlmIChpc1NlZ3dpdElucHV0KSB7XG4gICAgICByZXR1cm4gdHJhbnNhY3Rpb24uaGFzaEZvcldpdG5lc3NWMChpbnB1dEluZGV4LCBwdWJTY3JpcHQsIGFtb3VudCwgaGFzaFR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJhbnNhY3Rpb24uaGFzaEZvclNpZ25hdHVyZShpbnB1dEluZGV4LCBwdWJTY3JpcHQsIGhhc2hUeXBlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IHRoZSBzaWduYXR1cmUgb24gYSAoaGFsZi1zaWduZWQpIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB0cmFuc2FjdGlvbiBiaXRjb2luanMtbGliIHR4IG9iamVjdFxuICAgKiBAcGFyYW0gaW5wdXRJbmRleCBUaGUgaW5wdXQgd2hlcmVyZm9yZSB0byBjaGVjayB0aGUgc2lnbmF0dXJlXG4gICAqIEBwYXJhbSBhbW91bnQgRm9yIHNlZ3dpdCBhbmQgQkNILCB0aGUgaW5wdXQgYW1vdW50IG5lZWRzIHRvIGJlIGtub3duIGZvciBzaWduYXR1cmUgdmVyaWZpY2F0aW9uXG4gICAqIEBwYXJhbSB2ZXJpZmljYXRpb25TZXR0aW5nc1xuICAgKiBAcGFyYW0gdmVyaWZpY2F0aW9uU2V0dGluZ3Muc2lnbmF0dXJlSW5kZXggVGhlIGluZGV4IG9mIHRoZSBzaWduYXR1cmUgdG8gdmVyaWZ5IChvbmx5IGl0ZXJhdGVzIG92ZXIgbm9uLWVtcHR5IHNpZ25hdHVyZXMpXG4gICAqIEBwYXJhbSB2ZXJpZmljYXRpb25TZXR0aW5ncy5wdWJsaWNLZXkgVGhlIGhleCBvZiB0aGUgcHVibGljIGtleSB0byB2ZXJpZnkgKHdpbGwgdmVyaWZ5IGFsbCBzaWduYXR1cmVzKVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHZlcmlmeVNpZ25hdHVyZSh0cmFuc2FjdGlvbjogYW55LCBpbnB1dEluZGV4OiBudW1iZXIsIGFtb3VudDogbnVtYmVyLCB2ZXJpZmljYXRpb25TZXR0aW5nczoge1xuICAgIHNpZ25hdHVyZUluZGV4PzogbnVtYmVyO1xuICAgIHB1YmxpY0tleT86IHN0cmluZztcbiAgfSA9IHt9KTogYm9vbGVhbiB7XG4gICAgY29uc3QgeyBzaWduYXR1cmVzLCBwdWJsaWNLZXlzLCBpc1NlZ3dpdElucHV0LCBpbnB1dENsYXNzaWZpY2F0aW9uLCBwdWJTY3JpcHQgfSA9XG4gICAgICAgIHRoaXMucGFyc2VTaWduYXR1cmVTY3JpcHQodHJhbnNhY3Rpb24sIGlucHV0SW5kZXgpO1xuXG4gICAgaWYgKCFbYml0Y29pbi5zY3JpcHQudHlwZXMuUDJXU0gsIGJpdGNvaW4uc2NyaXB0LnR5cGVzLlAyU0gsIGJpdGNvaW4uc2NyaXB0LnR5cGVzLlAyUEtIXS5pbmNsdWRlcyhpbnB1dENsYXNzaWZpY2F0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghcHVibGljS2V5cyB8fCBwdWJsaWNLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpc1NlZ3dpdElucHV0ICYmICFhbW91bnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIGZpcnN0IG5vbi1lbXB0eSBzaWduYXR1cmUgYW5kIHZlcmlmeSBpdCBhZ2FpbnN0IGFsbCBwdWJsaWMga2V5c1xuICAgIGNvbnN0IG5vbkVtcHR5U2lnbmF0dXJlcyA9IF8uZmlsdGVyKHNpZ25hdHVyZXMsIHMgPT4gIV8uaXNFbXB0eShzKSk7XG5cbiAgICAvKlxuICAgIFdlIGVpdGhlciB3YW50IHRvIHZlcmlmeSBhbGwgc2lnbmF0dXJlL3B1YmtleSBjb21iaW5hdGlvbnMsIG9yIGRvIGFuIGV4cGxpY2l0IGNvbWJpbmF0aW9uXG5cbiAgICBJZiBhIHNpZ25hdHVyZSBpbmRleCBpcyBzcGVjaWZpZWQsIG9ubHkgdGhhdCBzaWduYXR1cmUgaXMgY2hlY2tlZC4gSXQncyB2ZXJpZmllZCBhZ2FpbnN0IGFsbCBwdWJsaWMga2V5cy5cbiAgICBJZiBhIHNpbmdsZSBwdWJsaWMga2V5IGlzIGZvdW5kIHRvIGJlIHZhbGlkLCB0aGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlLlxuXG4gICAgSWYgYSBwdWJsaWMga2V5IGlzIHNwZWNpZmllZCwgd2UgaXRlcmF0ZSBvdmVyIGFsbCBzaWduYXR1cmVzLiBJZiBhIHNpbmdsZSBvbmUgbWF0Y2hlcyB0aGUgcHVibGljIGtleSwgdGhlIGZ1bmN0aW9uXG4gICAgcmV0dXJucyB0cnVlLlxuXG4gICAgSWYgbmVpdGhlciBpcyBzcGVjaWZpZWQsIGFsbCBzaWduYXR1cmVzIGFyZSBjaGVja2VkIGFnYWluc3QgYWxsIHB1YmxpYyBrZXlzLiBFYWNoIHNpZ25hdHVyZSBtdXN0IGhhdmUgaXRzIG93biBkaXN0aW5jdFxuICAgIHB1YmxpYyBrZXkgdGhhdCBpdCBtYXRjaGVzIGZvciB0aGUgZnVuY3Rpb24gdG8gcmV0dXJuIHRydWUuXG4gICAgICovXG4gICAgbGV0IHNpZ25hdHVyZXNUb0NoZWNrID0gbm9uRW1wdHlTaWduYXR1cmVzO1xuICAgIGlmICghXy5pc1VuZGVmaW5lZCh2ZXJpZmljYXRpb25TZXR0aW5ncy5zaWduYXR1cmVJbmRleCkpIHtcbiAgICAgIHNpZ25hdHVyZXNUb0NoZWNrID0gW25vbkVtcHR5U2lnbmF0dXJlc1t2ZXJpZmljYXRpb25TZXR0aW5ncy5zaWduYXR1cmVJbmRleF1dO1xuICAgIH1cblxuICAgIGNvbnN0IHB1YmxpY0tleUhleCA9IHZlcmlmaWNhdGlvblNldHRpbmdzLnB1YmxpY0tleTtcbiAgICBjb25zdCBtYXRjaGVkUHVibGljS2V5SW5kaWNlcyA9IHt9O1xuICAgIGxldCBhcmVBbGxTaWduYXR1cmVzVmFsaWQgPSB0cnVlO1xuXG4gICAgLy8gZ28gb3ZlciBhbGwgc2lnbmF0dXJlc1xuICAgIGZvciAoY29uc3Qgc2lnbmF0dXJlQnVmZmVyIG9mIHNpZ25hdHVyZXNUb0NoZWNrKSB7XG5cbiAgICAgIGxldCBpc1NpZ25hdHVyZVZhbGlkID0gZmFsc2U7XG5cbiAgICAgIGNvbnN0IGhhc1NpZ25hdHVyZUJ1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcihzaWduYXR1cmVCdWZmZXIpICYmIHNpZ25hdHVyZUJ1ZmZlci5sZW5ndGggPiAwO1xuICAgICAgaWYgKGhhc1NpZ25hdHVyZUJ1ZmZlciAmJiBCdWZmZXIuaXNCdWZmZXIocHViU2NyaXB0KSAmJiBwdWJTY3JpcHQubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBzbGljZSB0aGUgbGFzdCBieXRlIGZyb20gdGhlIHNpZ25hdHVyZSBoYXNoIGlucHV0IGJlY2F1c2UgaXQncyB0aGUgaGFzaCB0eXBlXG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGJpdGNvaW4uRUNTaWduYXR1cmUuZnJvbURFUihzaWduYXR1cmVCdWZmZXIuc2xpY2UoMCwgLTEpKTtcbiAgICAgICAgY29uc3QgaGFzaFR5cGUgPSBfLmxhc3Qoc2lnbmF0dXJlQnVmZmVyKTtcbiAgICAgICAgaWYgKCFoYXNoVHlwZSkge1xuICAgICAgICAgIC8vIG1pc3NpbmcgaGFzaFR5cGUgYnl0ZSAtIHNpZ25hdHVyZSBjYW5ub3QgYmUgdmFsaWRhdGVkXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZUhhc2ggPSB0aGlzLmNhbGN1bGF0ZVNpZ25hdHVyZUhhc2godHJhbnNhY3Rpb24sIGlucHV0SW5kZXgsIHB1YlNjcmlwdCwgYW1vdW50LCBoYXNoVHlwZSwgaXNTZWd3aXRJbnB1dCk7XG5cbiAgICAgICAgZm9yIChsZXQgcHVibGljS2V5SW5kZXggPSAwOyBwdWJsaWNLZXlJbmRleCA8IHB1YmxpY0tleXMubGVuZ3RoOyBwdWJsaWNLZXlJbmRleCsrKSB7XG4gICAgICAgICAgY29uc3QgcHVibGljS2V5QnVmZmVyID0gcHVibGljS2V5c1twdWJsaWNLZXlJbmRleF07XG4gICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHB1YmxpY0tleUhleCkgJiYgcHVibGljS2V5QnVmZmVyLnRvU3RyaW5nKCdoZXgnKSAhPT0gcHVibGljS2V5SGV4KSB7XG4gICAgICAgICAgICAvLyB3ZSBhcmUgb25seSBsb29raW5nIHRvIHZlcmlmeSBvbmUgc3BlY2lmaWMgcHVibGljIGtleSdzIHNpZ25hdHVyZSAocHVibGljS2V5SGV4KVxuICAgICAgICAgICAgLy8gdGhpcyBwYXJ0aWN1bGFyIHB1YmxpYyBrZXkgaXMgbm90IHRoZSBvbmUgd2hvc2Ugc2lnbmF0dXJlIHdlJ3JlIHRyeWluZyB0byB2ZXJpZnlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtYXRjaGVkUHVibGljS2V5SW5kaWNlc1twdWJsaWNLZXlJbmRleF0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IGJpdGNvaW4uRUNQYWlyLmZyb21QdWJsaWNLZXlCdWZmZXIocHVibGljS2V5QnVmZmVyKTtcbiAgICAgICAgICBpZiAocHVibGljS2V5LnZlcmlmeShzaWduYXR1cmVIYXNoLCBzaWduYXR1cmUpKSB7XG4gICAgICAgICAgICBpc1NpZ25hdHVyZVZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgIG1hdGNoZWRQdWJsaWNLZXlJbmRpY2VzW3B1YmxpY0tleUluZGV4XSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHB1YmxpY0tleUhleCkgJiYgaXNTaWduYXR1cmVWYWxpZCkge1xuICAgICAgICAvLyBXZSB3ZXJlIHRyeWluZyB0byBzZWUgaWYgYW55IG9mIHRoZSBzaWduYXR1cmVzIHdhcyB2YWxpZCBmb3IgdGhlIGdpdmVuIHB1YmxpYyBrZXkuIEV2aWRlbnRseSB5ZXMuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzU2lnbmF0dXJlVmFsaWQgJiYgXy5pc1VuZGVmaW5lZChwdWJsaWNLZXlIZXgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgYXJlQWxsU2lnbmF0dXJlc1ZhbGlkID0gaXNTaWduYXR1cmVWYWxpZCAmJiBhcmVBbGxTaWduYXR1cmVzVmFsaWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyZUFsbFNpZ25hdHVyZXNWYWxpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXBvc2UgYSByYXcgdHJhbnNhY3Rpb24gaW50byB1c2VmdWwgaW5mb3JtYXRpb24sIHN1Y2ggYXMgdGhlIHRvdGFsIGFtb3VudHMsXG4gICAqIGNoYW5nZSBhbW91bnRzLCBhbmQgdHJhbnNhY3Rpb24gb3V0cHV0cy5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGV4cGxhaW5UcmFuc2FjdGlvbihwYXJhbXM6IEV4cGxhaW5UcmFuc2FjdGlvbk9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFRyYW5zYWN0aW9uRXhwbGFuYXRpb24+KTogQmx1ZWJpcmQ8VHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxUcmFuc2FjdGlvbkV4cGxhbmF0aW9uPihmdW5jdGlvbiAqKCkge1xuICAgICAgY29uc3QgdHhIZXggPSBfLmdldChwYXJhbXMsICd0eEhleCcpO1xuICAgICAgaWYgKCF0eEhleCB8fCAhXy5pc1N0cmluZyh0eEhleCkgfHwgIXR4SGV4Lm1hdGNoKC9eKFthLWYwLTldezJ9KSskL2kpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB0cmFuc2FjdGlvbiBoZXgsIG11c3QgYmUgYSB2YWxpZCBoZXggc3RyaW5nJyk7XG4gICAgICB9XG5cbiAgICAgIGxldCB0cmFuc2FjdGlvbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRyYW5zYWN0aW9uID0gYml0Y29pbi5UcmFuc2FjdGlvbi5mcm9tSGV4KHR4SGV4LCBzZWxmLm5ldHdvcmspO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBwYXJzZSB0cmFuc2FjdGlvbiBoZXgnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaWQgPSB0cmFuc2FjdGlvbi5nZXRJZCgpO1xuICAgICAgbGV0IGNoYW5nZUFkZHJlc3Nlczogc3RyaW5nW10gPSBbXTtcbiAgICAgIGxldCBzcGVuZEFtb3VudCA9IDA7XG4gICAgICBsZXQgY2hhbmdlQW1vdW50ID0gMDtcbiAgICAgIGNvbnN0IHR4SW5mbyA9IF8uZ2V0KHBhcmFtcywgJ3R4SW5mbycpO1xuICAgICAgaWYgKHR4SW5mbyAmJiB0eEluZm8uY2hhbmdlQWRkcmVzc2VzKSB7XG4gICAgICAgIGNoYW5nZUFkZHJlc3NlcyA9IHR4SW5mby5jaGFuZ2VBZGRyZXNzZXM7XG4gICAgICB9XG4gICAgICBjb25zdCBleHBsYW5hdGlvbjogYW55ID0ge1xuICAgICAgICBkaXNwbGF5T3JkZXI6IFsnaWQnLCAnb3V0cHV0QW1vdW50JywgJ2NoYW5nZUFtb3VudCcsICdvdXRwdXRzJywgJ2NoYW5nZU91dHB1dHMnXSxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgY2hhbmdlT3V0cHV0czogW10sXG4gICAgICB9O1xuXG4gICAgICB0cmFuc2FjdGlvbi5vdXRzLmZvckVhY2goKGN1cnJlbnRPdXRwdXQpID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudEFkZHJlc3MgPSBzZWxmLmdldENvaW5MaWJyYXJ5KCkuYWRkcmVzcy5mcm9tT3V0cHV0U2NyaXB0KGN1cnJlbnRPdXRwdXQuc2NyaXB0LCBzZWxmLm5ldHdvcmspO1xuICAgICAgICBjb25zdCBjdXJyZW50QW1vdW50ID0gY3VycmVudE91dHB1dC52YWx1ZTtcblxuICAgICAgICBpZiAoY2hhbmdlQWRkcmVzc2VzLmluZGV4T2YoY3VycmVudEFkZHJlc3MpICE9PSAtMSkge1xuICAgICAgICAgIC8vIHRoaXMgaXMgY2hhbmdlXG4gICAgICAgICAgY2hhbmdlQW1vdW50ICs9IGN1cnJlbnRBbW91bnQ7XG4gICAgICAgICAgZXhwbGFuYXRpb24uY2hhbmdlT3V0cHV0cy5wdXNoKHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGN1cnJlbnRBZGRyZXNzLFxuICAgICAgICAgICAgYW1vdW50OiBjdXJyZW50QW1vdW50LFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNwZW5kQW1vdW50ICs9IGN1cnJlbnRBbW91bnQ7XG4gICAgICAgIGV4cGxhbmF0aW9uLm91dHB1dHMucHVzaCh7XG4gICAgICAgICAgYWRkcmVzczogY3VycmVudEFkZHJlc3MsXG4gICAgICAgICAgYW1vdW50OiBjdXJyZW50QW1vdW50LFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgZXhwbGFuYXRpb24ub3V0cHV0QW1vdW50ID0gc3BlbmRBbW91bnQ7XG4gICAgICBleHBsYW5hdGlvbi5jaGFuZ2VBbW91bnQgPSBjaGFuZ2VBbW91bnQ7XG5cbiAgICAgIC8vIGFkZCBmZWUgaW5mbyBpZiBhdmFpbGFibGVcbiAgICAgIGlmIChwYXJhbXMuZmVlSW5mbykge1xuICAgICAgICBleHBsYW5hdGlvbi5kaXNwbGF5T3JkZXIucHVzaCgnZmVlJyk7XG4gICAgICAgIGV4cGxhbmF0aW9uLmZlZSA9IHBhcmFtcy5mZWVJbmZvO1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5pc0ludGVnZXIodHJhbnNhY3Rpb24ubG9ja3RpbWUpICYmIHRyYW5zYWN0aW9uLmxvY2t0aW1lID4gMCkge1xuICAgICAgICBleHBsYW5hdGlvbi5sb2NrdGltZSA9IHRyYW5zYWN0aW9uLmxvY2t0aW1lO1xuICAgICAgICBleHBsYW5hdGlvbi5kaXNwbGF5T3JkZXIucHVzaCgnbG9ja3RpbWUnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdW5zcGVudFZhbHVlcyA9IHt9O1xuXG4gICAgICAvLyBnZXQgaW5mb3JtYXRpb24gb24gdHggaW5wdXRzXG4gICAgICBjb25zdCBpbnB1dFNpZ25hdHVyZXMgPSB0cmFuc2FjdGlvbi5pbnMubWFwKChpbnB1dCwgaWR4KSA9PiB7XG4gICAgICAgIGNvbnN0IGhhc1NpZ1NjcmlwdCA9ICFfLmlzRW1wdHkoaW5wdXQuc2NyaXB0KTtcbiAgICAgICAgY29uc3QgaGFzV2l0bmVzc1NjcmlwdCA9ICFfLmlzRW1wdHkoaW5wdXQud2l0bmVzcyk7XG5cbiAgICAgICAgaWYgKCFoYXNTaWdTY3JpcHQgJiYgIWhhc1dpdG5lc3NTY3JpcHQpIHtcbiAgICAgICAgICAvLyBubyBzaWcgc2NyaXB0IG9yIHdpdG5lc3MgZGF0YSBmb3IgdGhpcyBpbnB1dFxuICAgICAgICAgIGRlYnVnKCdubyBzaWduYXR1cmUgc2NyaXB0IG9yIHdpdG5lc3Mgc2NyaXB0IGRhdGEgZm9yIGlucHV0ICVzJywgaWR4KTtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwYXJzZWRTaWdTY3JpcHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcGFyc2VkU2lnU2NyaXB0ID0gc2VsZi5wYXJzZVNpZ25hdHVyZVNjcmlwdCh0cmFuc2FjdGlvbiwgaWR4KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNXaXRuZXNzU2NyaXB0KSB7XG4gICAgICAgICAgaWYgKCF0eEluZm8gfHwgIXR4SW5mby51bnNwZW50cykge1xuICAgICAgICAgICAgLy8gc2Vnd2l0IHR4cyByZXF1aXJlIGlucHV0IHZhbHVlcywgY2Fubm90IHZhbGlkYXRlIHNpZ25hdHVyZXNcbiAgICAgICAgICAgIGRlYnVnKCd1bmFibGUgdG8gcmV0cmlldmUgaW5wdXQgYW1vdW50cyBmcm9tIHVuc3BlbnRzIC0gY2Fubm90IHZhbGlkYXRlIHNlZ3dpdCBpbnB1dCBzaWduYXR1cmVzJyk7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBsYXppbHkgcG9wdWxhdGUgdW5zcGVudCB2YWx1ZXNcbiAgICAgICAgICBpZiAoXy5pc0VtcHR5KHVuc3BlbnRWYWx1ZXMpKSB7XG4gICAgICAgICAgICB0eEluZm8udW5zcGVudHMuZm9yRWFjaCgodW5zcGVudCkgPT4ge1xuICAgICAgICAgICAgICB1bnNwZW50VmFsdWVzW3Vuc3BlbnQuaWRdID0gdW5zcGVudC52YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5vbkVtcHR5U2lnbmF0dXJlcyA9IHBhcnNlZFNpZ1NjcmlwdC5zaWduYXR1cmVzLmZpbHRlcigoc2lnKSA9PiAhXy5pc0VtcHR5KHNpZykpO1xuICAgICAgICBjb25zdCB2YWxpZFNpZ25hdHVyZXMgPSBub25FbXB0eVNpZ25hdHVyZXMubWFwKChzaWcsIHNpZ0luZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKF8uaXNFbXB0eShzaWcpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcGFyZW50VHhJZCA9IChCdWZmZXIuZnJvbShpbnB1dC5oYXNoKS5yZXZlcnNlKCkgYXMgQnVmZmVyKS50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgICAgY29uc3QgaW5wdXRJZCA9IGAke3BhcmVudFR4SWR9OiR7aW5wdXQuaW5kZXh9YDtcbiAgICAgICAgICBjb25zdCBhbW91bnQgPSB1bnNwZW50VmFsdWVzW2lucHV0SWRdO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnZlcmlmeVNpZ25hdHVyZSh0cmFuc2FjdGlvbiwgaWR4LCBhbW91bnQsIHsgc2lnbmF0dXJlSW5kZXg6IHNpZ0luZGV4IH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB2YWxpZFNpZ25hdHVyZXMucmVkdWNlKCh2YWxpZENvdW50LCBpc1ZhbGlkKSA9PiBpc1ZhbGlkID8gdmFsaWRDb3VudCArIDEgOiB2YWxpZENvdW50LCAwKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBsYW5hdGlvbi5pbnB1dFNpZ25hdHVyZXMgPSBpbnB1dFNpZ25hdHVyZXM7XG4gICAgICBleHBsYW5hdGlvbi5zaWduYXR1cmVzID0gXy5tYXgoaW5wdXRTaWduYXR1cmVzKTtcbiAgICAgIHJldHVybiBleHBsYW5hdGlvbjtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG11bHRpc2lnIGFkZHJlc3Mgb2YgYSBnaXZlbiB0eXBlIGZyb20gYSBsaXN0IG9mIGtleWNoYWlucyBhbmQgYSBzaWduaW5nIHRocmVzaG9sZFxuICAgKiBAcGFyYW0gYWRkcmVzc1R5cGVcbiAgICogQHBhcmFtIHNpZ25hdHVyZVRocmVzaG9sZFxuICAgKiBAcGFyYW0ga2V5c1xuICAgKi9cbiAgY3JlYXRlTXVsdGlTaWdBZGRyZXNzKGFkZHJlc3NUeXBlOiBzdHJpbmcsIHNpZ25hdHVyZVRocmVzaG9sZDogbnVtYmVyLCBrZXlzOiBCdWZmZXJbXSk6IE11bHRpU2lnQWRkcmVzcyB7XG4gICAgZnVuY3Rpb24gY3JlYXRlV2l0bmVzc1Byb2dyYW0oaW5wdXRTY3JpcHQpIHtcbiAgICAgIGNvbnN0IHdpdG5lc3NTY3JpcHRIYXNoID0gYml0Y29pbi5jcnlwdG8uc2hhMjU2KGlucHV0U2NyaXB0KTtcbiAgICAgIHJldHVybiBiaXRjb2luLnNjcmlwdC53aXRuZXNzU2NyaXB0SGFzaC5vdXRwdXQuZW5jb2RlKHdpdG5lc3NTY3JpcHRIYXNoKTtcbiAgICB9XG5cbiAgICBjb25zdCBtdWx0aVNpZ1NjcmlwdCA9IGJpdGNvaW4uc2NyaXB0Lm11bHRpc2lnLm91dHB1dC5lbmNvZGUoc2lnbmF0dXJlVGhyZXNob2xkLCBrZXlzKTtcbiAgICBsZXQgb3V0cHV0U2NyaXB0LCByZWRlZW1TY3JpcHQsIHdpdG5lc3NTY3JpcHQ7XG4gICAgc3dpdGNoIChhZGRyZXNzVHlwZSkge1xuICAgICAgY2FzZSBDb2Rlcy5VbnNwZW50VHlwZVRjb21iKCdwMnNoJyk6XG4gICAgICAgIGNvbnN0IG11bHRpc2lnU2NyaXB0SGFzaCA9IGJpdGNvaW4uY3J5cHRvLmhhc2gxNjAobXVsdGlTaWdTY3JpcHQpO1xuICAgICAgICBvdXRwdXRTY3JpcHQgPSBiaXRjb2luLnNjcmlwdC5zY3JpcHRIYXNoLm91dHB1dC5lbmNvZGUobXVsdGlzaWdTY3JpcHRIYXNoKTtcbiAgICAgICAgcmVkZWVtU2NyaXB0ID0gbXVsdGlTaWdTY3JpcHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDb2Rlcy5VbnNwZW50VHlwZVRjb21iKCdwMnNoUDJ3c2gnKTpcbiAgICAgICAgY29uc3Qgd2l0bmVzc1Byb2dyYW0gPSBjcmVhdGVXaXRuZXNzUHJvZ3JhbShtdWx0aVNpZ1NjcmlwdCk7XG4gICAgICAgIGNvbnN0IHdpdG5lc3NQcm9ncmFtSGFzaCA9IGJpdGNvaW4uY3J5cHRvLmhhc2gxNjAod2l0bmVzc1Byb2dyYW0pO1xuICAgICAgICBvdXRwdXRTY3JpcHQgPSBiaXRjb2luLnNjcmlwdC5zY3JpcHRIYXNoLm91dHB1dC5lbmNvZGUod2l0bmVzc1Byb2dyYW1IYXNoKTtcbiAgICAgICAgcmVkZWVtU2NyaXB0ID0gd2l0bmVzc1Byb2dyYW07XG4gICAgICAgIHdpdG5lc3NTY3JpcHQgPSBtdWx0aVNpZ1NjcmlwdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENvZGVzLlVuc3BlbnRUeXBlVGNvbWIoJ3Ayd3NoJyk6XG4gICAgICAgIG91dHB1dFNjcmlwdCA9IGNyZWF0ZVdpdG5lc3NQcm9ncmFtKG11bHRpU2lnU2NyaXB0KTtcbiAgICAgICAgd2l0bmVzc1NjcmlwdCA9IG11bHRpU2lnU2NyaXB0O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCBhZGRyZXNzVHlwZSAke2FkZHJlc3NUeXBlfWApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBvdXRwdXRTY3JpcHQsXG4gICAgICByZWRlZW1TY3JpcHQsXG4gICAgICB3aXRuZXNzU2NyaXB0LFxuICAgICAgYWRkcmVzczogYml0Y29pbi5hZGRyZXNzLmZyb21PdXRwdXRTY3JpcHQob3V0cHV0U2NyaXB0LCB0aGlzLm5ldHdvcmspLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHNjcmlwdEhhc2hTY3JpcHRcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIC8vIFRPRE8oQkctMTE2MzgpOiByZW1vdmUgaW4gbmV4dCBTREsgbWFqb3IgdmVyc2lvbiByZWxlYXNlXG4gIGNhbGN1bGF0ZVJlY292ZXJ5QWRkcmVzcyhzY3JpcHRIYXNoU2NyaXB0OiBCdWZmZXIpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDb2luTGlicmFyeSgpLmFkZHJlc3MuZnJvbU91dHB1dFNjcmlwdChzY3JpcHRIYXNoU2NyaXB0LCB0aGlzLm5ldHdvcmspO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHN0YXRpYyBmZWUgcmF0ZSB3aGljaCBpcyB1c2VkIGluIHJlY292ZXJ5IHNpdHVhdGlvbnNcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGdldFJlY292ZXJ5RmVlUGVyQnl0ZXMoKTogQmx1ZWJpcmQ8bnVtYmVyPiB7XG4gICAgcmV0dXJuIEJsdWViaXJkLnJlc29sdmUoMTAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB1cmwgd2hpY2ggY2FuIGJlIHVzZWQgZm9yIGRldGVybWluaW5nIHJlY292ZXJ5IGZlZSByYXRlc1xuICAgKi9cbiAgZ2V0UmVjb3ZlcnlGZWVSZWNvbW1lbmRhdGlvbkFwaUJhc2VVcmwoKTogQmx1ZWJpcmQ8c3RyaW5nPiB7XG4gICAgcmV0dXJuIEJsdWViaXJkLnJlamVjdChuZXcgRXJyb3IoJ0FidHJhY3RVdHhvQ29pbiBtZXRob2Qgbm90IGltcGxlbWVudGVkJykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBtYXJrZXQgcHJpY2UgZnJvbSBhIHRoaXJkIHBhcnR5IHRvIGJlIHVzZWQgZm9yIHJlY292ZXJ5XG4gICAqL1xuICBnZXRSZWNvdmVyeU1hcmtldFByaWNlKCk6IEJsdWViaXJkPHN0cmluZz4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxzdHJpbmc+KGZ1bmN0aW9uICpnZXRSZWNvdmVyeU1hcmtldFByaWNlKCkge1xuICAgICAgY29uc3QgZmFtaWx5TmFtZXNUb0NvaW5HZWNrb0lkcyA9IG5ldyBNYXAoKVxuICAgICAgICAuc2V0KCdCVEMnLCAnYml0Y29pbicpXG4gICAgICAgIC5zZXQoJ0xUQycsICdsaXRlY29pbicpXG4gICAgICAgIC5zZXQoJ0JDSCcsICdiaXRjb2luLWNhc2gnKVxuICAgICAgICAuc2V0KCdaRUMnLCAnemNhc2gnKVxuICAgICAgICAuc2V0KCdEQVNIJywgJ2Rhc2gnKTtcbiAgICAgIGNvbnN0IGNvaW5HZWNrb0lkID0gZmFtaWx5TmFtZXNUb0NvaW5HZWNrb0lkcy5nZXQoc2VsZi5nZXRGYW1pbHkoKS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgIGlmICghY29pbkdlY2tvSWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBpcyBubyBDb2luR2Vja28gaWQgZm9yIGZhbWlseSBuYW1lICR7c2VsZi5nZXRGYW1pbHkoKS50b1VwcGVyQ2FzZSgpfS5gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvaW5HZWNrb1VybCA9IGNvbmZpZy5jb2luR2Vja29CYXNlVXJsICsgYHNpbXBsZS9wcmljZT9pZHM9JHtjb2luR2Vja29JZH0mdnNfY3VycmVuY2llcz1VU0RgO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCByZXF1ZXN0LmdldChjb2luR2Vja29VcmwpLnJldHJ5KDIpLnJlc3VsdCgpO1xuXG4gICAgICAvLyBBbiBleGFtcGxlIG9mIHJlc3BvbnNlXG4gICAgICAvLyB7XG4gICAgICAvLyAgIFwiZXRoZXJldW1cIjoge1xuICAgICAgLy8gICAgIFwidXNkXCI6IDIyMC42NFxuICAgICAgLy8gICB9XG4gICAgICAvLyB9XG4gICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHJlYWNoIENvaW4gR2Vja28gQVBJIGZvciBwcmljZSBkYXRhJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXJlc3BvbnNlW2NvaW5HZWNrb0lkXVsndXNkJ10gfHwgdHlwZW9mIHJlc3BvbnNlW2NvaW5HZWNrb0lkXVsndXNkJ10gIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCByZXNwb25zZSBmcm9tIENvaW4gR2Vja28gQVBJIGZvciBwcmljZSBkYXRhJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZVtjb2luR2Vja29JZF1bJ3VzZCddO1xuICAgIH0pLmNhbGwodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIGZvciByZWNvdmVyKClcbiAgICogVGhpcyB0cmFuc2Zvcm1zIHRoZSB0eEluZm8gZnJvbSByZWNvdmVyIGludG8gdGhlIGZvcm1hdCB0aGF0IG9mZmxpbmUtc2lnbmluZy10b29sIGV4cGVjdHNcbiAgICogQHBhcmFtIHR4SW5mb1xuICAgKiBAcGFyYW0gdHhIZXhcbiAgICogQHJldHVybnMge3t0eEhleDogKiwgdHhJbmZvOiB7dW5zcGVudHM6ICp9LCBmZWVJbmZvOiB7fSwgY29pbjogdm9pZH19XG4gICAqL1xuICBmb3JtYXRGb3JPZmZsaW5lVmF1bHQodHhJbmZvOiBPZmZsaW5lVmF1bHRUeEluZm8sIHR4SGV4OiBzdHJpbmcpOiBGb3JtYXR0ZWRPZmZsaW5lVmF1bHRUeEluZm8ge1xuICAgIGNvbnN0IHJlc3BvbnNlOiBGb3JtYXR0ZWRPZmZsaW5lVmF1bHRUeEluZm8gPSB7XG4gICAgICB0eEhleCxcbiAgICAgIHR4SW5mbzoge1xuICAgICAgICB1bnNwZW50czogdHhJbmZvLmlucHV0cyxcbiAgICAgIH0sXG4gICAgICBmZWVJbmZvOiB7fSxcbiAgICAgIGNvaW46IHRoaXMuZ2V0Q2hhaW4oKSxcbiAgICB9O1xuICAgIF8ubWFwKHJlc3BvbnNlLnR4SW5mby51bnNwZW50cywgZnVuY3Rpb24odW5zcGVudCkge1xuICAgICAgY29uc3QgcGF0aEFycmF5ID0gdW5zcGVudC5jaGFpblBhdGguc3BsaXQoJy8nKTtcbiAgICAgIC8vIE5vdGUgdGhpcyBjb2RlIHdvcmtzIGJlY2F1c2Ugd2UgYXNzdW1lIG91ciBjaGFpblBhdGggaXMgbS8wLzAvY2hhaW4vaW5kZXggLSB0aGlzIHdpbGwgYmUgaW5jb3JyZWN0IGZvciBjdXN0b20gZGVyaXZhdGlvbiBzY2hlbWVzXG4gICAgICB1bnNwZW50LmluZGV4ID0gcGF0aEFycmF5WzRdO1xuICAgICAgdW5zcGVudC5jaGFpbiA9IHBhdGhBcnJheVszXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cblxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgZ2V0QWRkcmVzc0luZm9Gcm9tRXhwbG9yZXIoYWRkcmVzczogc3RyaW5nKTogQmx1ZWJpcmQ8QWRkcmVzc0luZm8+O1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgZ2V0VW5zcGVudEluZm9Gcm9tRXhwbG9yZXIoYWRkcmVzczogc3RyaW5nKTogQmx1ZWJpcmQ8VW5zcGVudEluZm9bXT47XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhIGZ1bmRzIHJlY292ZXJ5IHRyYW5zYWN0aW9uIHdpdGhvdXQgQml0R29cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiAtIHVzZXJLZXk6IFtlbmNyeXB0ZWRdIHhwcnYsIG9yIHhwdWJcbiAgICogLSBiYWNrdXBLZXk6IFtlbmNyeXB0ZWRdIHhwcnYsIG9yIHhwdWIgaWYgdGhlIHhwcnYgaXMgaGVsZCBieSBhIEtSUyBwcm92aWRlclxuICAgKiAtIHdhbGxldFBhc3NwaHJhc2U6IG5lY2Vzc2FyeSBpZiBvbmUgb2YgdGhlIHhwcnZzIGlzIGVuY3J5cHRlZFxuICAgKiAtIGJpdGdvS2V5OiB4cHViXG4gICAqIC0ga3JzUHJvdmlkZXI6IG5lY2Vzc2FyeSBpZiBiYWNrdXAga2V5IGlzIGhlbGQgYnkgS1JTXG4gICAqIC0gcmVjb3ZlcnlEZXN0aW5hdGlvbjogdGFyZ2V0IGFkZHJlc3MgdG8gc2VuZCByZWNvdmVyZWQgZnVuZHMgdG9cbiAgICogLSBzY2FuOiB0aGUgYW1vdW50IG9mIGNvbnNlY3V0aXZlIGFkZHJlc3NlcyB3aXRob3V0IHVuc3BlbnRzIHRvIHNjYW4gdGhyb3VnaCBiZWZvcmUgc3RvcHBpbmdcbiAgICogLSBpZ25vcmVBZGRyZXNzVHlwZXM6IChvcHRpb25hbCkgYXJyYXkgb2YgQWRkcmVzc1R5cGVzIHRvIGlnbm9yZSwgdGhlc2UgYXJlIHN0cmluZ3MgZGVmaW5lZCBpbiBDb2Rlcy5VbnNwZW50VHlwZVRjb21iXG4gICAqICAgICAgICBmb3IgZXhhbXBsZTogWydwMnNoUDJ3c2gnLCAncDJ3c2gnXSB3aWxsIHByZXZlbnQgY29kZSBmcm9tIGNoZWNraW5nIGZvciB3cmFwcGVkLXNlZ3dpdCBhbmQgbmF0aXZlLXNlZ3dpdCBjaGFpbnMgb24gdGhlIHB1YmxpYyBibG9jayBleHBsb3JlcnNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICByZWNvdmVyKHBhcmFtczogUmVjb3ZlclBhcmFtcywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqcmVjb3ZlcigpIHtcbiAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT1IRUxQRVIgRlVOQ1RJT05TPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgZnVuY3Rpb24gZGVyaXZlS2V5cyhrZXlBcnJheTogYml0Y29pbi5IRE5vZGVbXSwgaW5kZXg6IG51bWJlcikge1xuICAgICAgICByZXR1cm4ga2V5QXJyYXkubWFwKChrKSA9PiBrLmRlcml2ZShpbmRleCkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBxdWVyeUJsb2NrY2hhaW5VbnNwZW50c1BhdGgoa2V5QXJyYXk6IGJpdGNvaW4uSEROb2RlW10sIGJhc2VQYXRoOiBzdHJpbmcsIGFkZHJlc3Nlc0J5SWQpIHtcbiAgICAgICAgcmV0dXJuIGNvKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgY29uc3QgTUFYX1NFUVVFTlRJQUxfQUREUkVTU0VTX1dJVEhPVVRfVFhTID0gcGFyYW1zLnNjYW4gfHwgMjA7XG4gICAgICAgICAgbGV0IG51bVNlcXVlbnRpYWxBZGRyZXNzZXNXaXRob3V0VHhzID0gMDtcblxuICAgICAgICAgIC8vIGdldCB1bnNwZW50cyBmb3IgdGhlc2UgYWRkcmVzc2VzXG4gICAgICAgICAgY29uc3QgZ2F0aGVyVW5zcGVudHMgPSBjbyhmdW5jdGlvbiogY29HYXRoZXJVbnNwZW50cyhhZGRySW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlcml2ZWRLZXlzID0gZGVyaXZlS2V5cyhrZXlBcnJheSwgYWRkckluZGV4KTtcblxuICAgICAgICAgICAgY29uc3QgY2hhaW4gPSBOdW1iZXIoYmFzZVBhdGguc3BsaXQoJy8nKS5wb3AoKSk7IC8vIGV4dHJhY3RzIHRoZSBjaGFpbiBmcm9tIHRoZSBiYXNlUGF0aFxuICAgICAgICAgICAgY29uc3Qga2V5cyA9IGRlcml2ZWRLZXlzLm1hcChrID0+IGsuZ2V0UHVibGljS2V5QnVmZmVyKCkpO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzczogYW55ID0gc2VsZi5jcmVhdGVNdWx0aVNpZ0FkZHJlc3MoQ29kZXMudHlwZUZvckNvZGUoY2hhaW4pLCAyLCBrZXlzKTtcblxuICAgICAgICAgICAgY29uc3QgYWRkckluZm86IEFkZHJlc3NJbmZvID0geWllbGQgc2VsZi5nZXRBZGRyZXNzSW5mb0Zyb21FeHBsb3JlcihhZGRyZXNzLmFkZHJlc3MpO1xuXG4gICAgICAgICAgICBpZiAoYWRkckluZm8udHhDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICBudW1TZXF1ZW50aWFsQWRkcmVzc2VzV2l0aG91dFR4cysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbnVtU2VxdWVudGlhbEFkZHJlc3Nlc1dpdGhvdXRUeHMgPSAwO1xuXG4gICAgICAgICAgICAgIGlmIChhZGRySW5mby50b3RhbEJhbGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBhZGRyZXNzIGhhcyBhIGJhbGFuY2UuXG4gICAgICAgICAgICAgICAgYWRkcmVzcy5jaGFpblBhdGggPSBiYXNlUGF0aCArICcvJyArIGFkZHJJbmRleDtcbiAgICAgICAgICAgICAgICBhZGRyZXNzLnVzZXJLZXkgPSBkZXJpdmVkS2V5c1swXTtcbiAgICAgICAgICAgICAgICBhZGRyZXNzLmJhY2t1cEtleSA9IGRlcml2ZWRLZXlzWzFdO1xuICAgICAgICAgICAgICAgIGFkZHJlc3Nlc0J5SWRbYWRkcmVzcy5hZGRyZXNzXSA9IGFkZHJlc3M7XG5cbiAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZmluZCB1bnNwZW50cyBvbiBpdC5cbiAgICAgICAgICAgICAgICBjb25zdCBhZGRyZXNzVW5zcGVudHM6IFVuc3BlbnRJbmZvW10gPSB5aWVsZCBzZWxmLmdldFVuc3BlbnRJbmZvRnJvbUV4cGxvcmVyKGFkZHJlc3MuYWRkcmVzcyk7XG5cbiAgICAgICAgICAgICAgICBhZGRyZXNzVW5zcGVudHMuZm9yRWFjaChmdW5jdGlvbiBhZGRBZGRyZXNzVG9VbnNwZW50KHVuc3BlbnQpIHtcbiAgICAgICAgICAgICAgICAgIHVuc3BlbnQuYWRkcmVzcyA9IGFkZHJlc3MuYWRkcmVzcztcbiAgICAgICAgICAgICAgICAgIHdhbGxldFVuc3BlbnRzLnB1c2godW5zcGVudCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG51bVNlcXVlbnRpYWxBZGRyZXNzZXNXaXRob3V0VHhzID49IE1BWF9TRVFVRU5USUFMX0FERFJFU1NFU19XSVRIT1VUX1RYUykge1xuICAgICAgICAgICAgICAvLyBzdG9wIHNlYXJjaGluZyBmb3IgYWRkcmVzc2VzIHdpdGggdW5zcGVudHMgaW4gdGhlbSwgd2UndmUgZm91bmQgNSBpbiBhIHJvdyB3aXRoIG5vbmVcbiAgICAgICAgICAgICAgLy8gd2UgYXJlIGRvbmVcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZ2F0aGVyVW5zcGVudHMoYWRkckluZGV4ICsgMSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjb25zdCB3YWxsZXRVbnNwZW50czogVW5zcGVudEluZm9bXSA9IFtdO1xuICAgICAgICAgIC8vIFRoaXMgd2lsbCBwb3B1bGF0ZSB3YWxsZXRBZGRyZXNzZXNcbiAgICAgICAgICB5aWVsZCBnYXRoZXJVbnNwZW50cygwKTtcblxuICAgICAgICAgIGlmICh3YWxsZXRVbnNwZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIENvdWxkbid0IGZpbmQgYW55IGFkZHJlc3NlcyB3aXRoIGZ1bmRzXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHdhbGxldFVuc3BlbnRzO1xuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09TE9HSUM9PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMudXNlcktleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHVzZXJLZXknKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLmJhY2t1cEtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGJhY2t1cEtleScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbikgfHwgIXNlbGYuaXNWYWxpZEFkZHJlc3MocGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCByZWNvdmVyeURlc3RpbmF0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuc2NhbikgJiYgKCFfLmlzSW50ZWdlcihwYXJhbXMuc2NhbikgfHwgcGFyYW1zLnNjYW4gPCAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NjYW4gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNLcnNSZWNvdmVyeSA9IHBhcmFtcy5iYWNrdXBLZXkuc3RhcnRzV2l0aCgneHB1YicpICYmICFwYXJhbXMudXNlcktleS5zdGFydHNXaXRoKCd4cHViJyk7XG4gICAgICBjb25zdCBpc1Vuc2lnbmVkU3dlZXAgPSBwYXJhbXMuYmFja3VwS2V5LnN0YXJ0c1dpdGgoJ3hwdWInKSAmJiBwYXJhbXMudXNlcktleS5zdGFydHNXaXRoKCd4cHViJyk7XG4gICAgICBjb25zdCBrcnNQcm92aWRlciA9IGNvbmZpZy5rcnNQcm92aWRlcnNbcGFyYW1zLmtyc1Byb3ZpZGVyXTtcblxuICAgICAgaWYgKGlzS3JzUmVjb3ZlcnkgJiYgXy5pc1VuZGVmaW5lZChrcnNQcm92aWRlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGtleSByZWNvdmVyeSBzZXJ2aWNlIHByb3ZpZGVyJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0tyc1JlY292ZXJ5ICYmICEoa3JzUHJvdmlkZXIuc3VwcG9ydGVkQ29pbnMuaW5jbHVkZXMoc2VsZi5nZXRGYW1pbHkoKSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3BlY2lmaWVkIGtleSByZWNvdmVyeSBzZXJ2aWNlIGRvZXMgbm90IHN1cHBvcnQgcmVjb3ZlcmllcyBmb3IgdGhpcyBjb2luJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGtleXMgPSB5aWVsZCBzZWxmLmluaXRpYXRlUmVjb3ZlcnkocGFyYW1zKTtcblxuICAgICAgY29uc3QgYmFzZUtleVBhdGggPSBkZXJpdmVLZXlzKGRlcml2ZUtleXMoa2V5cywgMCksIDApO1xuXG4gICAgICBjb25zdCBxdWVyaWVzOiBhbnlbXSA9IFtdO1xuICAgICAgY29uc3QgYWRkcmVzc2VzQnlJZCA9IHt9O1xuXG4gICAgICBfLmZvckVhY2goT2JqZWN0LmtleXMoQ29kZXMuVW5zcGVudFR5cGVUY29tYi5tZXRhLm1hcCksIGZ1bmN0aW9uKGFkZHJlc3NUeXBlKSB7XG4gICAgICAgIC8vIElmIHdlIGFyZW4ndCBpZ25vcmluZyB0aGUgYWRkcmVzcyB0eXBlLCB3ZSBkZXJpdmUgdGhlIHB1YmxpYyBrZXkgYW5kIGNvbnN0cnVjdCB0aGUgcXVlcnkgZm9yIHRoZSBleHRlcm5hbCBhbmRcbiAgICAgICAgLy8gaW50ZXJuYWwgaW5kaWNlc1xuICAgICAgICBpZiAoIV8uaW5jbHVkZXMocGFyYW1zLmlnbm9yZUFkZHJlc3NUeXBlcywgYWRkcmVzc1R5cGUpKSB7XG4gICAgICAgICAgaWYgKGFkZHJlc3NUeXBlID09PSBDb2Rlcy5VbnNwZW50VHlwZVRjb21iKCdwMnNoUDJ3c2gnKSAmJiAhc2VsZi5zdXBwb3J0c1Ayc2hQMndzaCgpKSB7XG4gICAgICAgICAgICAvLyBQMnNoUDJ3c2ggaXMgbm90IHN1cHBvcnRlZC4gU2tpcC5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYWRkcmVzc1R5cGUgPT09IENvZGVzLlVuc3BlbnRUeXBlVGNvbWIoJ3Ayd3NoJykgJiYgIXNlbGYuc3VwcG9ydHNQMndzaCgpKSB7XG4gICAgICAgICAgICAvLyBQMndzaCBpcyBub3Qgc3VwcG9ydGVkLiBTa2lwLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBjb2RlcztcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29kZXMgPSBDb2Rlcy5mb3JUeXBlKENvZGVzLlVuc3BlbnRUeXBlVGNvbWIoYWRkcmVzc1R5cGUpIGFzIGFueSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gVGhlIHVuc3BlbnQgdHlwZSBpcyBub3Qgc3VwcG9ydGVkIGJ5IGJpdGdvIHNvIGF0dGVtcHRpbmcgdG8gZ2V0IGl0cyBjaGFpbiBjb2RlcyB0aHJvd3MuIENhdGNoIHRoYXQgZXJyb3JcbiAgICAgICAgICAgIC8vIGFuZCBjb250aW51ZS5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZXh0ZXJuYWxDaGFpbkNvZGUgPSBjb2Rlcy5leHRlcm5hbDtcbiAgICAgICAgICBjb25zdCBpbnRlcm5hbENoYWluQ29kZSA9IGNvZGVzLmludGVybmFsO1xuICAgICAgICAgIGNvbnN0IGV4dGVybmFsS2V5ID0gZGVyaXZlS2V5cyhiYXNlS2V5UGF0aCwgZXh0ZXJuYWxDaGFpbkNvZGUpO1xuICAgICAgICAgIGNvbnN0IGludGVybmFsS2V5ID0gZGVyaXZlS2V5cyhiYXNlS2V5UGF0aCwgaW50ZXJuYWxDaGFpbkNvZGUpO1xuICAgICAgICAgIHF1ZXJpZXMucHVzaChxdWVyeUJsb2NrY2hhaW5VbnNwZW50c1BhdGgoZXh0ZXJuYWxLZXksICcvMC8wLycgKyBleHRlcm5hbENoYWluQ29kZSwgYWRkcmVzc2VzQnlJZCkpO1xuICAgICAgICAgIHF1ZXJpZXMucHVzaChxdWVyeUJsb2NrY2hhaW5VbnNwZW50c1BhdGgoaW50ZXJuYWxLZXksICcvMC8wLycgKyBpbnRlcm5hbENoYWluQ29kZSwgYWRkcmVzc2VzQnlJZCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gRXhlY3V0ZSB0aGUgcXVlcmllcyBhbmQgZ2F0aGVyIHRoZSB1bnNwZW50c1xuICAgICAgY29uc3QgcXVlcnlSZXNwb25zZXMgPSB5aWVsZCBQcm9taXNlLmFsbChxdWVyaWVzKTtcbiAgICAgIGNvbnN0IHVuc3BlbnRzOiBhbnlbXSA9IF8uZmxhdHRlbihxdWVyeVJlc3BvbnNlcyk7IC8vIHRoaXMgZmxhdHRlbnMgdGhlIGFycmF5ICh0dXJucyBhbiBhcnJheSBvZiBhcnJheXMgaW50byBqdXN0IG9uZSBhcnJheSlcbiAgICAgIGNvbnN0IHRvdGFsSW5wdXRBbW91bnQgPSBfLnN1bUJ5KHVuc3BlbnRzLCAnYW1vdW50Jyk7XG4gICAgICBpZiAodG90YWxJbnB1dEFtb3VudCA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gaW5wdXQgdG8gcmVjb3ZlciAtIGFib3J0aW5nIScpO1xuICAgICAgfVxuXG4gICAgICAvLyBCdWlsZCB0aGUgdHJhbnNhY3Rpb25cbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uQnVpbGRlciA9IG5ldyBiaXRjb2luLlRyYW5zYWN0aW9uQnVpbGRlcihzZWxmLm5ldHdvcmspO1xuICAgICAgc2VsZi5wcmVwYXJlVHJhbnNhY3Rpb25CdWlsZGVyKHRyYW5zYWN0aW9uQnVpbGRlcik7XG4gICAgICBjb25zdCB0eEluZm86IGFueSA9IHt9O1xuXG4gICAgICBjb25zdCBmZWVQZXJCeXRlID0geWllbGQgc2VsZi5nZXRSZWNvdmVyeUZlZVBlckJ5dGVzKCk7XG5cbiAgICAgIC8vIEtSUyByZWNvdmVyeSB0cmFuc2FjdGlvbnMgaGF2ZSBhIDJuZCBvdXRwdXQgdG8gcGF5IHRoZSByZWNvdmVyeSBmZWUsIGxpa2UgcGF5Z28gZmVlcy4gVXNlIHAyd3NoIG91dHB1dHMgYmVjYXVzZVxuICAgICAgLy8gdGhleSBhcmUgdGhlIGxhcmdlc3Qgb3V0cHV0cyBhbmQgdGh1cyB0aGUgbW9zdCBjb25zZXJ2YXRpdmUgZXN0aW1hdGUgdG8gdXNlIGluIGNhbGN1bGF0aW5nIGZlZXMuIEFsc28gdXNlXG4gICAgICAvLyBzZWd3aXQgb3ZlcmhlYWQgc2l6ZSBhbmQgcDJzaCBpbnB1dHMgZm9yIHRoZSBzYW1lIHJlYXNvbi5cbiAgICAgIGNvbnN0IG91dHB1dFNpemUgPSAoaXNLcnNSZWNvdmVyeSA/IDIgOiAxKSAqIFZpcnR1YWxTaXplcy50eFAyd3NoT3V0cHV0U2l6ZTtcbiAgICAgIGNvbnN0IGFwcHJveGltYXRlU2l6ZSA9XG4gICAgICAgIFZpcnR1YWxTaXplcy50eFNlZ092ZXJoZWFkVlNpemUgKyBvdXRwdXRTaXplICsgKFZpcnR1YWxTaXplcy50eFAyc2hJbnB1dFNpemUgKiB1bnNwZW50cy5sZW5ndGgpO1xuICAgICAgY29uc3QgYXBwcm94aW1hdGVGZWUgPSBhcHByb3hpbWF0ZVNpemUgKiBmZWVQZXJCeXRlO1xuXG4gICAgICAvLyBDb25zdHJ1Y3QgYSB0cmFuc2FjdGlvblxuICAgICAgdHhJbmZvLmlucHV0cyA9IHVuc3BlbnRzLm1hcChmdW5jdGlvbiBhZGRJbnB1dEZvclVuc3BlbnQodW5zcGVudCkge1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gYWRkcmVzc2VzQnlJZFt1bnNwZW50LmFkZHJlc3NdO1xuXG4gICAgICAgIHRyYW5zYWN0aW9uQnVpbGRlci5hZGRJbnB1dCh1bnNwZW50LnR4aWQsIHVuc3BlbnQubiwgMHhmZmZmZmZmZiwgYWRkcmVzcy5vdXRwdXRTY3JpcHQpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hhaW5QYXRoOiBhZGRyZXNzLmNoYWluUGF0aCxcbiAgICAgICAgICByZWRlZW1TY3JpcHQ6IGFkZHJlc3MucmVkZWVtU2NyaXB0ICYmIGFkZHJlc3MucmVkZWVtU2NyaXB0LnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICB3aXRuZXNzU2NyaXB0OiBhZGRyZXNzLndpdG5lc3NTY3JpcHQgJiYgYWRkcmVzcy53aXRuZXNzU2NyaXB0LnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICB2YWx1ZTogdW5zcGVudC5hbW91bnQsXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgbGV0IHJlY292ZXJ5QW1vdW50ID0gdG90YWxJbnB1dEFtb3VudCAtIGFwcHJveGltYXRlRmVlO1xuICAgICAgbGV0IGtyc0ZlZTtcbiAgICAgIGlmIChpc0tyc1JlY292ZXJ5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAga3JzRmVlID0geWllbGQgc2VsZi5jYWxjdWxhdGVGZWVBbW91bnQoeyBwcm92aWRlcjogcGFyYW1zLmtyc1Byb3ZpZGVyLCBhbW91bnQ6IHJlY292ZXJ5QW1vdW50IH0pO1xuICAgICAgICAgIHJlY292ZXJ5QW1vdW50IC09IGtyc0ZlZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgLy8gRG9uJ3QgbGV0IHRoaXMgZXJyb3IgYmxvY2sgdGhlIHJlY292ZXJ5IC1cbiAgICAgICAgICBjb25zb2xlLmRpcihlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvdmVyeUFtb3VudCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGlzIHdhbGxldFxcJ3MgYmFsYW5jZSBpcyB0b28gbG93IHRvIHBheSB0aGUgZmVlcyBzcGVjaWZpZWQgYnkgdGhlIEtSUyBwcm92aWRlcicpO1xuICAgICAgfVxuXG4gICAgICB0cmFuc2FjdGlvbkJ1aWxkZXIuYWRkT3V0cHV0KHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uLCByZWNvdmVyeUFtb3VudCk7XG5cbiAgICAgIGlmIChpc0tyc1JlY292ZXJ5ICYmIGtyc0ZlZSA+IDApIHtcbiAgICAgICAgY29uc3Qga3JzRmVlQWRkcmVzcyA9IGtyc1Byb3ZpZGVyLmZlZUFkZHJlc3Nlc1tzZWxmLmdldENoYWluKCldO1xuXG4gICAgICAgIGlmICgha3JzRmVlQWRkcmVzcykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGhpcyBLUlMgcHJvdmlkZXIgaGFzIG5vdCBjb25maWd1cmVkIHRoZWlyIGZlZSBzdHJ1Y3R1cmUgeWV0IC0gcmVjb3ZlcnkgY2Fubm90IGJlIGNvbXBsZXRlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhbnNhY3Rpb25CdWlsZGVyLmFkZE91dHB1dChrcnNGZWVBZGRyZXNzLCBrcnNGZWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNVbnNpZ25lZFN3ZWVwKSB7XG4gICAgICAgIGNvbnN0IHR4SGV4ID0gdHJhbnNhY3Rpb25CdWlsZGVyLmJ1aWxkSW5jb21wbGV0ZSgpLnRvQnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICByZXR1cm4gc2VsZi5mb3JtYXRGb3JPZmZsaW5lVmF1bHQodHhJbmZvLCB0eEhleCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzaWduZWRUeCA9IHNlbGYuc2lnblJlY292ZXJ5VHJhbnNhY3Rpb24odHJhbnNhY3Rpb25CdWlsZGVyLCB1bnNwZW50cywgYWRkcmVzc2VzQnlJZCwgIWlzS3JzUmVjb3ZlcnkpO1xuICAgICAgICB0eEluZm8udHJhbnNhY3Rpb25IZXggPSBzaWduZWRUeC5idWlsZCgpLnRvQnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHR4SW5mby50eCA9IHlpZWxkIHNlbGYudmVyaWZ5UmVjb3ZlcnlUcmFuc2FjdGlvbih0eEluZm8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG5cbiAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgZXJyb3JzLk1ldGhvZE5vdEltcGxlbWVudGVkRXJyb3IpKSB7XG4gICAgICAgICAgICAvLyBzb21lIGNvaW5zIGRvbid0IGhhdmUgYSByZWxpYWJsZSB0aGlyZCBwYXJ0eSB2ZXJpZmljYXRpb24gZW5kcG9pbnQsIHNvIHdlIGNvbnRpbnVlIHdpdGhvdXQgdmVyaWZpY2F0aW9uIGZvciB0aG9zZSBjb2luc1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgdmVyaWZ5IHJlY292ZXJ5IHRyYW5zYWN0aW9uJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0tyc1JlY292ZXJ5KSB7XG4gICAgICAgIHR4SW5mby5jb2luID0gc2VsZi5nZXRDaGFpbigpO1xuICAgICAgICB0eEluZm8uYmFja3VwS2V5ID0gcGFyYW1zLmJhY2t1cEtleTtcbiAgICAgICAgdHhJbmZvLnJlY292ZXJ5QW1vdW50ID0gcmVjb3ZlcnlBbW91bnQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0eEluZm87XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBzaWduYXR1cmVzIHRvIGEgZnVuZHMgcmVjb3ZlcnkgdHJhbnNhY3Rpb24gdXNpbmcgdXNlciArIGJhY2t1cCBrZXlcbiAgICogQHBhcmFtIHR4YiB7T2JqZWN0fSBhIHRyYW5zYWN0aW9uIGJ1aWxkZXIgb2JqZWN0ICh3aXRoIGlucHV0cyBhbmQgb3V0cHV0cylcbiAgICogQHBhcmFtIHVuc3BlbnRzIHtBcnJheX0gdGhlIHVuc3BlbnRzIHRvIHVzZSBpbiB0aGUgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIGFkZHJlc3NlcyB7QXJyYXl9IHRoZSBhZGRyZXNzIGFuZCByZWRlZW0gc2NyaXB0IGluZm8gZm9yIHRoZSB1bnNwZW50c1xuICAgKiBAcGFyYW0gY29zaWduIHtCb29sZWFufSB3aGV0aGVyIHRvIGNvc2lnbiB0aGlzIHRyYW5zYWN0aW9uIHdpdGggdGhlIHVzZXIncyBiYWNrdXAga2V5IChmYWxzZSBpZiBLUlMgcmVjb3ZlcnkpXG4gICAqIEByZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiBidWlsZGVyIG9yaWdpbmFsbHkgcGFzc2VkIGluIGFzIHRoZSBmaXJzdCBhcmd1bWVudFxuICAgKi9cbiAgc2lnblJlY292ZXJ5VHJhbnNhY3Rpb24odHhiOiBhbnksIHVuc3BlbnRzOiBPdXRwdXRbXSwgYWRkcmVzc2VzOiBhbnksIGNvc2lnbjogYm9vbGVhbik6IGFueSB7XG4gICAgaW50ZXJmYWNlIFNpZ25hdHVyZUlzc3VlIHtcbiAgICAgIGlucHV0SW5kZXg6IG51bWJlcjtcbiAgICAgIHVuc3BlbnQ6IE91dHB1dDtcbiAgICAgIGVycm9yOiBFcnJvciB8IG51bGw7XG4gICAgfVxuXG4gICAgY29uc3Qgc2lnbmF0dXJlSXNzdWVzOiBTaWduYXR1cmVJc3N1ZVtdID0gW107XG4gICAgdW5zcGVudHMuZm9yRWFjaCgodW5zcGVudCwgaSkgPT4ge1xuICAgICAgY29uc3QgYWRkcmVzcyA9IGFkZHJlc3Nlc1t1bnNwZW50LmFkZHJlc3NdO1xuICAgICAgY29uc3QgYmFja3VwUHJpdmF0ZUtleSA9IGFkZHJlc3MuYmFja3VwS2V5LmtleVBhaXI7XG4gICAgICBjb25zdCB1c2VyUHJpdmF0ZUtleSA9IGFkZHJlc3MudXNlcktleS5rZXlQYWlyO1xuICAgICAgLy8gZm9yY2Utb3ZlcnJpZGUgbmV0d29ya3NcbiAgICAgIGJhY2t1cFByaXZhdGVLZXkubmV0d29yayA9IHRoaXMubmV0d29yaztcbiAgICAgIHVzZXJQcml2YXRlS2V5Lm5ldHdvcmsgPSB0aGlzLm5ldHdvcms7XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRTaWduYXR1cmVJc3N1ZTogU2lnbmF0dXJlSXNzdWUgPSB7XG4gICAgICAgIGlucHV0SW5kZXg6IGksXG4gICAgICAgIHVuc3BlbnQ6IHVuc3BlbnQsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfTtcblxuICAgICAgaWYgKGNvc2lnbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHR4Yi5zaWduKGksIGJhY2t1cFByaXZhdGVLZXksIGFkZHJlc3MucmVkZWVtU2NyaXB0LCB0aGlzLmRlZmF1bHRTaWdIYXNoVHlwZSwgdW5zcGVudC5hbW91bnQsIGFkZHJlc3Mud2l0bmVzc1NjcmlwdCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjdXJyZW50U2lnbmF0dXJlSXNzdWUuZXJyb3IgPSBlO1xuICAgICAgICAgIHNpZ25hdHVyZUlzc3Vlcy5wdXNoKGN1cnJlbnRTaWduYXR1cmVJc3N1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgdHhiLnNpZ24oaSwgdXNlclByaXZhdGVLZXksIGFkZHJlc3MucmVkZWVtU2NyaXB0LCB0aGlzLmRlZmF1bHRTaWdIYXNoVHlwZSwgdW5zcGVudC5hbW91bnQsIGFkZHJlc3Mud2l0bmVzc1NjcmlwdCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGN1cnJlbnRTaWduYXR1cmVJc3N1ZS5lcnJvciA9IGU7XG4gICAgICAgIHNpZ25hdHVyZUlzc3Vlcy5wdXNoKGN1cnJlbnRTaWduYXR1cmVJc3N1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoc2lnbmF0dXJlSXNzdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGZhaWxlZEluZGljZXMgPSBzaWduYXR1cmVJc3N1ZXMubWFwKGN1cnJlbnRJc3N1ZSA9PiBjdXJyZW50SXNzdWUuaW5wdXRJbmRleCk7XG4gICAgICBjb25zdCBlcnJvcjogYW55ID0gbmV3IEVycm9yKGBGYWlsZWQgdG8gc2lnbiBpbnB1dHMgYXQgaW5kaWNlcyAke2ZhaWxlZEluZGljZXMuam9pbignLCAnKX1gKTtcbiAgICAgIGVycm9yLmNvZGUgPSAnaW5wdXRfc2lnbmF0dXJlX2ZhaWx1cmUnO1xuICAgICAgZXJyb3Iuc2lnbmluZ0Vycm9ycyA9IHNpZ25hdHVyZUlzc3VlcztcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHJldHVybiB0eGI7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgYW1vdW50IChpbiBiYXNlIHVuaXRzKSB0byBwYXkgYSBLUlMgcHJvdmlkZXIgd2hlbiBidWlsZGluZyBhIHJlY292ZXJ5IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy5wcm92aWRlciB7U3RyaW5nfSB0aGUgS1JTIHByb3ZpZGVyIHRoYXQgaG9sZHMgdGhlIGJhY2t1cCBrZXlcbiAgICogQHBhcmFtIHBhcmFtcy5hbW91bnQge051bWJlcn0gYW1vdW50IChpbiBiYXNlIHVuaXRzKSB0byBiZSByZWNvdmVyZWRcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgY2FsY3VsYXRlRmVlQW1vdW50KHBhcmFtczogeyBwcm92aWRlcjogc3RyaW5nLCBhbW91bnQ/OiBudW1iZXIgfSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8bnVtYmVyPik6IEJsdWViaXJkPG51bWJlcj4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxudW1iZXI+KGZ1bmN0aW9uICpjYWxjdWxhdGVGZWVBbW91bnQoKSB7XG4gICAgICBjb25zdCBrcnNQcm92aWRlciA9IGNvbmZpZy5rcnNQcm92aWRlcnNbcGFyYW1zLnByb3ZpZGVyXTtcblxuICAgICAgaWYgKGtyc1Byb3ZpZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBubyBmZWUgc3RydWN0dXJlIHNwZWNpZmllZCBmb3IgcHJvdmlkZXIgJHtwYXJhbXMucHJvdmlkZXJ9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChrcnNQcm92aWRlci5mZWVUeXBlID09PSAnZmxhdFVzZCcpIHtcbiAgICAgICAgY29uc3QgZmVlQW1vdW50VXNkID0ga3JzUHJvdmlkZXIuZmVlQW1vdW50O1xuICAgICAgICBjb25zdCBjdXJyZW50UHJpY2UgPSB5aWVsZCBzZWxmLmdldFJlY292ZXJ5TWFya2V0UHJpY2UoKTtcblxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChmZWVBbW91bnRVc2QgLyBjdXJyZW50UHJpY2UgKiBzZWxmLmdldEJhc2VGYWN0b3IoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3ZSBjYW4gYWRkIG1vcmUgZmVlIHN0cnVjdHVyZXMgaGVyZSBhcyBuZWVkZWQgZm9yIGRpZmZlcmVudCBwcm92aWRlcnMsIHN1Y2ggYXMgcGVyY2VudGFnZSBvZiByZWNvdmVyeSBhbW91bnRcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGZWUgc3RydWN0dXJlIG5vdCBpbXBsZW1lbnRlZCcpO1xuICAgICAgfVxuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogUmVjb3ZlciBCVEMgdGhhdCB3YXMgc2VudCB0byB0aGUgd3JvbmcgY2hhaW5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLnR4aWQgVGhlIHR4aWQgb2YgdGhlIGZhdWx0eSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gcGFyYW1zLnJlY292ZXJ5QWRkcmVzcyBhZGRyZXNzIHRvIHNlbmQgcmVjb3ZlcmVkIGZ1bmRzIHRvXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0IHRoZSB3YWxsZXQgdGhhdCByZWNlaXZlZCB0aGUgZnVuZHNcbiAgICogQHBhcmFtIHBhcmFtcy5yZWNvdmVyeUNvaW4gdGhlIGNvaW4gdHlwZSBvZiB0aGUgd2FsbGV0IHRoYXQgcmVjZWl2ZWQgdGhlIGZ1bmRzXG4gICAqIEBwYXJhbSBwYXJhbXMuc2lnbmVkIHJldHVybiBhIGhhbGYtc2lnbmVkIHRyYW5zYWN0aW9uIChkZWZhdWx0PXRydWUpXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSB0aGUgd2FsbGV0IHBhc3NwaHJhc2VcbiAgICogQHBhcmFtIHBhcmFtcy54cHJ2IHRoZSB1bmVuY3J5cHRlZCB4cHJ2ICh1c2VkIGluc3RlYWQgb2Ygd2FsbGV0IHBhc3NwaHJhc2UpXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHJlY292ZXJGcm9tV3JvbmdDaGFpbihwYXJhbXM6IFJlY292ZXJGcm9tV3JvbmdDaGFpbk9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24gKnJlY292ZXJGcm9tV3JvbmdDaGFpbigpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHhpZCxcbiAgICAgICAgcmVjb3ZlcnlBZGRyZXNzLFxuICAgICAgICB3YWxsZXQsXG4gICAgICAgIHdhbGxldFBhc3NwaHJhc2UsXG4gICAgICAgIHhwcnYsXG4gICAgICB9ID0gcGFyYW1zO1xuXG4gICAgICAvLyBwYXJhbXMucmVjb3ZlcnlDb2luIHVzZWQgdG8gYmUgcGFyYW1zLmNvaW4sIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICBjb25zdCByZWNvdmVyeUNvaW4gPSBwYXJhbXMuY29pbiB8fCBwYXJhbXMucmVjb3ZlcnlDb2luO1xuICAgICAgaWYgKCFyZWNvdmVyeUNvaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIG9iamVjdCByZWNvdmVyeUNvaW4nKTtcbiAgICAgIH1cbiAgICAgIC8vIHNpZ25lZCBzaG91bGQgZGVmYXVsdCB0byB0cnVlLCBhbmQgb25seSBiZSBkaXNhYmxlZCBpZiBleHBsaWNpdGx5IHNldCB0byBmYWxzZSAobm90IHVuZGVmaW5lZClcbiAgICAgIGNvbnN0IHNpZ25lZCA9IHBhcmFtcy5zaWduZWQgIT09IGZhbHNlO1xuXG4gICAgICBjb25zdCBzb3VyY2VDb2luRmFtaWx5ID0gc2VsZi5nZXRGYW1pbHkoKTtcbiAgICAgIGNvbnN0IHJlY292ZXJ5Q29pbkZhbWlseSA9IHJlY292ZXJ5Q29pbi5nZXRGYW1pbHkoKTtcbiAgICAgIGNvbnN0IHN1cHBvcnRlZFJlY292ZXJ5Q29pbnMgPSBjb25maWcuc3VwcG9ydGVkQ3Jvc3NDaGFpblJlY292ZXJpZXNbc291cmNlQ29pbkZhbWlseV07XG5cbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHN1cHBvcnRlZFJlY292ZXJ5Q29pbnMpIHx8ICFzdXBwb3J0ZWRSZWNvdmVyeUNvaW5zLmluY2x1ZGVzKHJlY292ZXJ5Q29pbkZhbWlseSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWNvdmVyeSBvZiAke3NvdXJjZUNvaW5GYW1pbHl9IGJhbGFuY2VzIGZyb20gJHtyZWNvdmVyeUNvaW5GYW1pbHl9IHdhbGxldHMgaXMgbm90IHN1cHBvcnRlZC5gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVjb3ZlcnlUb29sID0gbmV3IENyb3NzQ2hhaW5SZWNvdmVyeVRvb2woe1xuICAgICAgICBiaXRnbzogc2VsZi5iaXRnbyxcbiAgICAgICAgc291cmNlQ29pbjogc2VsZixcbiAgICAgICAgcmVjb3ZlcnlDb2luOiByZWNvdmVyeUNvaW4sXG4gICAgICAgIGxvZ2dpbmc6IGZhbHNlLFxuICAgICAgfSk7XG5cbiAgICAgIHlpZWxkIHJlY292ZXJ5VG9vbC5idWlsZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgd2FsbGV0OiB3YWxsZXQsXG4gICAgICAgIGZhdWx0eVR4SWQ6IHR4aWQsXG4gICAgICAgIHJlY292ZXJ5QWRkcmVzczogcmVjb3ZlcnlBZGRyZXNzLFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChzaWduZWQpIHtcbiAgICAgICAgeWllbGQgcmVjb3ZlcnlUb29sLnNpZ25UcmFuc2FjdGlvbih7IHBhc3NwaHJhc2U6IHdhbGxldFBhc3NwaHJhc2UsIHBydjogeHBydiB9KTtcbiAgICAgICAgcmV0dXJuIHJlY292ZXJ5VG9vbC5leHBvcnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB5aWVsZCByZWNvdmVyeVRvb2wuYnVpbGRVbnNpZ25lZCgpO1xuICAgICAgfVxuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgc2VjcDI1NmsxIGtleSBwYWlyXG4gICAqXG4gICAqIEBwYXJhbSBzZWVkXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdCB3aXRoIGdlbmVyYXRlZCBwdWIgYW5kIHBydlxuICAgKi9cbiAgZ2VuZXJhdGVLZXlQYWlyKHNlZWQ6IEJ1ZmZlcik6IHsgcHViOiBzdHJpbmcsIHBydjogc3RyaW5nIH0ge1xuICAgIGlmICghc2VlZCkge1xuICAgICAgLy8gQW4gZXh0ZW5kZWQgcHJpdmF0ZSBrZXkgaGFzIGJvdGggYSBub3JtYWwgMjU2IGJpdCBwcml2YXRlIGtleSBhbmQgYSAyNTZcbiAgICAgIC8vIGJpdCBjaGFpbiBjb2RlLCBib3RoIG9mIHdoaWNoIG11c3QgYmUgcmFuZG9tLiA1MTIgYml0cyBpcyB0aGVyZWZvcmUgdGhlXG4gICAgICAvLyBtYXhpbXVtIGVudHJvcHkgYW5kIGdpdmVzIHVzIG1heGltdW0gc2VjdXJpdHkgYWdhaW5zdCBjcmFja2luZy5cbiAgICAgIHNlZWQgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoNTEyIC8gOCk7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuZGVkS2V5ID0gYml0Y29pbi5IRE5vZGUuZnJvbVNlZWRCdWZmZXIoc2VlZCk7XG4gICAgY29uc3QgeHB1YiA9IGV4dGVuZGVkS2V5Lm5ldXRlcmVkKCkudG9CYXNlNTgoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcHViOiB4cHViLFxuICAgICAgcHJ2OiBleHRlbmRlZEtleS50b0Jhc2U1OCgpLFxuICAgIH07XG4gIH1cblxuICBnZXRFeHRyYVByZWJ1aWxkUGFyYW1zKGJ1aWxkUGFyYW1zOiBFeHRyYVByZWJ1aWxkUGFyYW1zT3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIHJldHVybiBCbHVlYmlyZC5yZXNvbHZlKHt9KS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIHByZUNyZWF0ZUJpdEdvKHBhcmFtczogUHJlY3JlYXRlQml0R29PcHRpb25zKTogdm9pZCB7fVxuXG4gIHByZXNpZ25UcmFuc2FjdGlvbihwYXJhbXM6IFByZXNpZ25UcmFuc2FjdGlvbk9wdGlvbnMsIGNhbGxiYWNrPzogKGVycjogRXJyb3IsIHJlczogYW55KSA9PiB2b2lkKTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcmV0dXJuIEJsdWViaXJkLnJlc29sdmUocGFyYW1zKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIHN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldCh3YWxsZXRQYXJhbXM6IFN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldE9wdGlvbnMsIGtleWNoYWluczogS2V5Y2hhaW5zVHJpcGxldCk6IEJsdWViaXJkPGFueT4ge1xuICAgIHJldHVybiBCbHVlYmlyZC5yZXNvbHZlKHdhbGxldFBhcmFtcyk7XG4gIH1cblxuICB0cmFuc2FjdGlvbkRhdGFBbGxvd2VkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhbHVlbGVzc1RyYW5zZmVyQWxsb3dlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2ZXJpZnlSZWNvdmVyeVRyYW5zYWN0aW9uKHR4SW5mbzogVmVyaWZ5UmVjb3ZlcnlUcmFuc2FjdGlvbk9wdGlvbnMpOiBCbHVlYmlyZDxhbnk+IHtcbiAgICByZXR1cm4gQmx1ZWJpcmQucmVqZWN0KG5ldyBlcnJvcnMuTWV0aG9kTm90SW1wbGVtZW50ZWRFcnJvcigpKTtcbiAgfVxuXG4gIHNpZ25NZXNzYWdlKGtleTogeyBwcnY6IHN0cmluZyB9LCBtZXNzYWdlOiBzdHJpbmcgfCBCdWZmZXIsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPEJ1ZmZlcj4pOiBCbHVlYmlyZDxCdWZmZXI+IHtcbiAgICByZXR1cm4gY288QnVmZmVyPihmdW5jdGlvbiogY29zaWduTWVzc2FnZSgpIHtcbiAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSBiaXRjb2luLkhETm9kZS5mcm9tQmFzZTU4KGtleS5wcnYpLmdldEtleSgpO1xuICAgICAgY29uc3QgcHJpdmF0ZUtleUJ1ZmZlciA9IHByaXZhdGVLZXkuZC50b0J1ZmZlcigzMik7XG4gICAgICBjb25zdCBpc0NvbXByZXNzZWQgPSBwcml2YXRlS2V5LmNvbXByZXNzZWQ7XG4gICAgICBjb25zdCBwcmVmaXggPSBiaXRjb2luLm5ldHdvcmtzLmJpdGNvaW4ubWVzc2FnZVByZWZpeDtcbiAgICAgIHJldHVybiBiaXRjb2luTWVzc2FnZS5zaWduKG1lc3NhZ2UsIHByaXZhdGVLZXlCdWZmZXIsIGlzQ29tcHJlc3NlZCwgcHJlZml4KTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxufVxuIl19