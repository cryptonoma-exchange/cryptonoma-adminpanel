"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @prettier
 */
var bignumber_js_1 = require("bignumber.js");
var utxoLib = require("bitgo-utxo-lib");
var Bluebird = require("bluebird");
var crypto = require("crypto");
var debugLib = require("debug");
var Keccak = require("keccak");
var _ = require("lodash");
var secp256k1 = require("secp256k1");
var request = require("superagent");
var baseCoin_1 = require("../baseCoin");
var erc20Token_1 = require("./erc20Token");
var wallet_1 = require("../wallet");
var common = require("../../common");
var config = require("../../config");
var util_1 = require("../internal/util");
var errors_1 = require("../../errors");
var co = Bluebird.coroutine;
var debug = debugLib('bitgo:v2:eth');
exports.optionalDeps = {
    get ethAbi() {
        try {
            return require('ethereumjs-abi');
        }
        catch (e) {
            debug('unable to load ethereumjs-abi:');
            debug(e.stack);
            throw new errors_1.EthereumLibraryUnavailableError("ethereumjs-abi");
        }
    },
    get ethUtil() {
        try {
            return require('ethereumjs-util');
        }
        catch (e) {
            debug('unable to load ethereumjs-util:');
            debug(e.stack);
            throw new errors_1.EthereumLibraryUnavailableError("ethereumjs-util");
        }
    },
    get EthTx() {
        try {
            return require('ethereumjs-tx');
        }
        catch (e) {
            debug('unable to load ethereumjs-tx:');
            debug(e.stack);
            throw new errors_1.EthereumLibraryUnavailableError("ethereumjs-tx");
        }
    },
};
var Eth = /** @class */ (function (_super) {
    __extends(Eth, _super);
    function Eth() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Eth.createInstance = function (bitgo) {
        return new Eth(bitgo);
    };
    /**
     * Returns the factor between the base unit and its smallest subdivison
     * @return {number}
     */
    Eth.prototype.getBaseFactor = function () {
        // 10^18
        return '1000000000000000000';
    };
    Eth.prototype.getChain = function () {
        return 'eth';
    };
    Eth.prototype.getFamily = function () {
        return 'eth';
    };
    Eth.prototype.getFullName = function () {
        return 'Ethereum';
    };
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    Eth.prototype.valuelessTransferAllowed = function () {
        return true;
    };
    /**
     * Flag for sending data along with transactions
     * @returns {boolean} True if okay to send tx data (ETH), false otherwise
     */
    Eth.prototype.transactionDataAllowed = function () {
        return true;
    };
    /**
     * Evaluates whether an address string is valid for this coin
     * @param address
     */
    Eth.prototype.isValidAddress = function (address) {
        return exports.optionalDeps.ethUtil.isValidAddress(exports.optionalDeps.ethUtil.addHexPrefix(address));
    };
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    Eth.prototype.isValidPub = function (pub) {
        try {
            utxoLib.HDNode.fromBase58(pub);
            return true;
        }
        catch (e) {
            return false;
        }
    };
    /**
     * Default gas price from platform
     * @returns {BigNumber}
     */
    Eth.prototype.getRecoveryGasPrice = function () {
        return new exports.optionalDeps.ethUtil.BN('20000000000');
    };
    /**
     * Default gas limit from platform
     * @returns {BigNumber}
     */
    Eth.prototype.getRecoveryGasLimit = function () {
        return new exports.optionalDeps.ethUtil.BN('500000');
    };
    /**
     * Default expire time for a contract call (1 week)
     * @returns {number} Time in seconds
     */
    Eth.prototype.getDefaultExpireTime = function () {
        return Math.floor(new Date().getTime() / 1000) + 60 * 60 * 24 * 7;
    };
    /**
     * Query Etherscan for the balance of an address
     * @param address {String} the ETH address
     * @param callback
     * @returns {BigNumber} address balance
     */
    Eth.prototype.queryAddressBalance = function (address, callback) {
        var self = this;
        return co(function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, self.recoveryBlockchainExplorerQuery({
                            module: 'account',
                            action: 'balance',
                            address: address,
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, new exports.optionalDeps.ethUtil.BN(result.result, 10)];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Query Etherscan for the balance of an address for a token
     * @param tokenContractAddress {String} address where the token smart contract is hosted
     * @param walletContractAddress {String} address of the wallet
     * @param callback
     * @returns {BigNumber} token balaance in base units
     */
    Eth.prototype.queryAddressTokenBalance = function (tokenContractAddress, walletContractAddress, callback) {
        var self = this;
        return co(function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!exports.optionalDeps.ethUtil.isValidAddress(tokenContractAddress)) {
                            throw new Error('cannot get balance for invalid token address');
                        }
                        if (!exports.optionalDeps.ethUtil.isValidAddress(walletContractAddress)) {
                            throw new Error('cannot get token balance for invalid wallet address');
                        }
                        return [4 /*yield*/, self.recoveryBlockchainExplorerQuery({
                                module: 'account',
                                action: 'tokenbalance',
                                contractaddress: tokenContractAddress,
                                address: walletContractAddress,
                                tag: 'latest',
                            })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, new exports.optionalDeps.ethUtil.BN(result.result, 10)];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Get transfer operation for coin
     * @param recipient recipient info
     * @param expireTime expiry time
     * @param contractSequenceId sequence id
     * @returns {Array} operation array
     */
    Eth.prototype.getOperation = function (recipient, expireTime, contractSequenceId) {
        return [
            ['string', 'address', 'uint', 'bytes', 'uint', 'uint'],
            [
                'ETHER',
                new exports.optionalDeps.ethUtil.BN(exports.optionalDeps.ethUtil.stripHexPrefix(recipient.address), 16),
                recipient.amount,
                new Buffer(exports.optionalDeps.ethUtil.stripHexPrefix(recipient.data) || '', 'hex'),
                expireTime,
                contractSequenceId,
            ],
        ];
    };
    Eth.prototype.getOperationSha3ForExecuteAndConfirm = function (recipients, expireTime, contractSequenceId) {
        var _a;
        if (!recipients || !Array.isArray(recipients)) {
            throw new Error('expecting array of recipients');
        }
        // Right now we only support 1 recipient
        if (recipients.length !== 1) {
            throw new Error('must send to exactly 1 recipient');
        }
        if (!_.isNumber(expireTime)) {
            throw new Error('expireTime must be number of seconds since epoch');
        }
        if (!_.isNumber(contractSequenceId)) {
            throw new Error('contractSequenceId must be number');
        }
        // Check inputs
        recipients.forEach(function (recipient) {
            if (!_.isString(recipient.address) ||
                !exports.optionalDeps.ethUtil.isValidAddress(exports.optionalDeps.ethUtil.addHexPrefix(recipient.address))) {
                throw new Error('Invalid address: ' + recipient.address);
            }
            var amount;
            try {
                amount = new bignumber_js_1.BigNumber(recipient.amount);
            }
            catch (e) {
                throw new Error('Invalid amount for: ' + recipient.address + ' - should be numeric');
            }
            recipient.amount = amount.toFixed(0);
            if (recipient.data && !_.isString(recipient.data)) {
                throw new Error('Data for recipient ' + recipient.address + ' - should be of type hex string');
            }
        });
        var recipient = recipients[0];
        return exports.optionalDeps.ethUtil.bufferToHex((_a = exports.optionalDeps.ethAbi).soliditySHA3.apply(_a, this.getOperation(recipient, expireTime, contractSequenceId)));
    };
    /**
     * Queries the contract (via Etherscan) for the next sequence ID
     * @param address {String} address of the contract
     * @param callback
     * @returns {Number} sequence ID
     */
    Eth.prototype.querySequenceId = function (address, callback) {
        var self = this;
        return co(function () {
            var sequenceIdMethodSignature, sequenceIdArgs, sequenceIdData, result, sequenceIdHex;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        sequenceIdMethodSignature = exports.optionalDeps.ethAbi.methodID('getNextSequenceId', []);
                        sequenceIdArgs = exports.optionalDeps.ethAbi.rawEncode([], []);
                        sequenceIdData = Buffer.concat([sequenceIdMethodSignature, sequenceIdArgs]).toString('hex');
                        return [4 /*yield*/, self.recoveryBlockchainExplorerQuery({
                                module: 'proxy',
                                action: 'eth_call',
                                to: address,
                                data: sequenceIdData,
                                tag: 'latest',
                            })];
                    case 1:
                        result = _a.sent();
                        sequenceIdHex = result.result;
                        return [2 /*return*/, new exports.optionalDeps.ethUtil.BN(sequenceIdHex.slice(2), 16).toNumber()];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Helper function for signTransaction for the rare case that SDK is doing the second signature
     * Note: we are expecting this to be called from the offline vault
     * @param params.txPrebuild
     * @param params.signingKeyNonce
     * @param params.walletContractAddress
     * @param params.prv
     * @returns {{txHex: *}}
     */
    Eth.prototype.signFinal = function (params) {
        var txPrebuild = params.txPrebuild;
        if (!_.isNumber(params.signingKeyNonce)) {
            throw new Error('must have signingKeyNonce as a parameter, and it must be a number');
        }
        if (_.isUndefined(params.walletContractAddress)) {
            throw new Error('params must include walletContractAddress, but got undefined');
        }
        var signingNode = utxoLib.HDNode.fromBase58(params.prv);
        var signingKey = signingNode.getKey().getPrivateKeyBuffer();
        var txInfo = {
            recipient: txPrebuild.recipients[0],
            expireTime: txPrebuild.halfSigned.expireTime,
            contractSequenceId: txPrebuild.halfSigned.contractSequenceId,
            signature: txPrebuild.halfSigned.signature,
        };
        var sendMethodArgs = this.getSendMethodArgs(txInfo);
        var methodSignature = exports.optionalDeps.ethAbi.methodID('sendMultiSig', _.map(sendMethodArgs, 'type'));
        var encodedArgs = exports.optionalDeps.ethAbi.rawEncode(_.map(sendMethodArgs, 'type'), _.map(sendMethodArgs, 'value'));
        var sendData = Buffer.concat([methodSignature, encodedArgs]);
        var ethTxParams = {
            to: params.walletContractAddress,
            nonce: params.signingKeyNonce,
            value: 0,
            gasPrice: new exports.optionalDeps.ethUtil.BN(txPrebuild.gasPrice),
            gasLimit: new exports.optionalDeps.ethUtil.BN(txPrebuild.gasLimit),
            data: sendData,
            spendAmount: params.recipients[0].amount,
        };
        var ethTx = new exports.optionalDeps.EthTx(ethTxParams);
        ethTx.sign(signingKey);
        return { txHex: ethTx.serialize().toString('hex') };
    };
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * - txPrebuild
     * - prv
     * @param callback
     * @returns {Bluebird<SignedTransaction>}
     */
    Eth.prototype.signTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            var txPrebuild, userPrv, EXPIRETIME_DEFAULT, secondsSinceEpoch, expireTime, sequenceId, operationHash, signature, txParams;
            return __generator(this, function (_a) {
                txPrebuild = params.txPrebuild;
                userPrv = params.prv;
                EXPIRETIME_DEFAULT = 60 * 60 * 24 * 7;
                if (_.isUndefined(txPrebuild) || !_.isObject(txPrebuild)) {
                    if (!_.isUndefined(txPrebuild) && !_.isObject(txPrebuild)) {
                        throw new Error("txPrebuild must be an object, got type " + typeof txPrebuild);
                    }
                    throw new Error('missing txPrebuild parameter');
                }
                if (_.isUndefined(userPrv) || !_.isString(userPrv)) {
                    if (!_.isUndefined(userPrv) && !_.isString(userPrv)) {
                        throw new Error("prv must be a string, got type " + typeof userPrv);
                    }
                    throw new Error('missing prv parameter to sign transaction');
                }
                params.recipients = txPrebuild.recipients || params.recipients;
                // if no recipients in either params or txPrebuild, then throw an error
                if (!params.recipients || !Array.isArray(params.recipients)) {
                    throw new Error('recipients missing or not array');
                }
                // Normally the SDK provides the first signature for an ETH tx, but occasionally it provides the second and final one.
                if (params.isLastSignature) {
                    // In this case when we're doing the second (final) signature, the logic is different.
                    return [2 /*return*/, self.signFinal(params)];
                }
                secondsSinceEpoch = Math.floor(new Date().getTime() / 1000);
                expireTime = params.expireTime || secondsSinceEpoch + EXPIRETIME_DEFAULT;
                sequenceId = txPrebuild.nextContractSequenceId;
                if (_.isUndefined(sequenceId)) {
                    throw new Error('transaction prebuild missing required property nextContractSequenceId');
                }
                operationHash = self.getOperationSha3ForExecuteAndConfirm(params.recipients, expireTime, sequenceId);
                signature = util_1.Util.ethSignMsgHash(operationHash, util_1.Util.xprvToEthPrivateKey(userPrv));
                txParams = {
                    recipients: params.recipients,
                    expireTime: expireTime,
                    contractSequenceId: sequenceId,
                    sequenceId: params.sequenceId,
                    operationHash: operationHash,
                    signature: signature,
                    gasLimit: params.gasLimit,
                    gasPrice: params.gasPrice,
                    hopTransaction: txPrebuild.hopTransaction,
                };
                return [2 /*return*/, { halfSigned: txParams }];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Ensure either enterprise or newFeeAddress is passed, to know whether to create new key or use enterprise key
     * @param params
     * @param params.enterprise {String} the enterprise id to associate with this key
     * @param params.newFeeAddress {Boolean} create a new fee address (enterprise not needed in this case)
     */
    Eth.prototype.preCreateBitGo = function (params) {
        // We always need params object, since either enterprise or newFeeAddress is required
        if (!_.isObject(params)) {
            throw new Error("preCreateBitGo must be passed a params object. Got " + params + " (type " + typeof params + ")");
        }
        if (_.isUndefined(params.enterprise) && _.isUndefined(params.newFeeAddress)) {
            throw new Error('expecting enterprise when adding BitGo key. If you want to create a new ETH bitgo key, set the newFeeAddress parameter to true.');
        }
        // Check whether key should be an enterprise key or a BitGo key for a new fee address
        if (!_.isUndefined(params.enterprise) && !_.isUndefined(params.newFeeAddress)) {
            throw new Error("Incompatible arguments - cannot pass both enterprise and newFeeAddress parameter.");
        }
        if (!_.isUndefined(params.enterprise) && !_.isString(params.enterprise)) {
            throw new Error("enterprise should be a string - got " + params.enterprise + " (type " + typeof params.enterprise + ")");
        }
        if (!_.isUndefined(params.newFeeAddress) && !_.isBoolean(params.newFeeAddress)) {
            throw new Error("newFeeAddress should be a boolean - got " + params.newFeeAddress + " (type " + typeof params.newFeeAddress + ")");
        }
    };
    /**
     * Queries public block explorer to get the next ETH nonce that should be used for the given ETH address
     * @param address
     * @param callback
     * @returns {*}
     */
    Eth.prototype.getAddressNonce = function (address, callback) {
        var self = this;
        return co(function () {
            var nonce, result, backupKeyTxList, outgoingTxs;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        nonce = 0;
                        return [4 /*yield*/, self.recoveryBlockchainExplorerQuery({
                                module: 'account',
                                action: 'txlist',
                                address: address,
                            })];
                    case 1:
                        result = _a.sent();
                        backupKeyTxList = result.result;
                        if (backupKeyTxList.length > 0) {
                            outgoingTxs = backupKeyTxList.filter(function (tx) { return tx.from === address; });
                            nonce = outgoingTxs.length;
                        }
                        return [2 /*return*/, nonce];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Helper function for recover()
     * This transforms the unsigned transaction information into a format the BitGo offline vault expects
     * @param txInfo
     * @param ethTx
     * @param userKey
     * @param backupKey
     * @param gasPrice
     * @param gasLimit
     * @param callback
     * @returns {{tx: *, userKey: *, backupKey: *, coin: string, amount: string, gasPrice: string, gasLimit: string, recipients: ({address, amount}|{address: ({address, amount}|string), amount: string}|string)[]}}
     */
    Eth.prototype.formatForOfflineVault = function (txInfo, ethTx, userKey, backupKey, gasPrice, gasLimit, callback) {
        var self = this;
        return co(function () {
            var backupHDNode, backupSigningKey, response, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        backupHDNode = utxoLib.HDNode.fromBase58(backupKey);
                        backupSigningKey = backupHDNode.getKey().getPublicKeyBuffer();
                        _a = {
                            tx: ethTx.serialize().toString('hex'),
                            userKey: userKey,
                            backupKey: backupKey,
                            coin: self.getChain(),
                            gasPrice: exports.optionalDeps.ethUtil.bufferToInt(gasPrice).toFixed(),
                            gasLimit: gasLimit,
                            recipients: [txInfo.recipient],
                            walletContractAddress: '0x' + ethTx.to.toString('hex'),
                            amount: txInfo.recipient.amount
                        };
                        return [4 /*yield*/, self.getAddressNonce("0x" + exports.optionalDeps.ethUtil.publicToAddress(backupSigningKey, true).toString('hex'))];
                    case 1:
                        response = (_a.backupKeyNonce = _b.sent(),
                            _a);
                        _.extend(response, txInfo);
                        response.nextContractSequenceId = response.contractSequenceId;
                        return [2 /*return*/, response];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * @param params.userKey {String} [encrypted] xprv
     * @param params.backupKey {String} [encrypted] xprv or xpub if the xprv is held by a KRS provider
     * @param params.walletPassphrase {String} used to decrypt userKey and backupKey
     * @param params.walletContractAddress {String} the ETH address of the wallet contract
     * @param params.krsProvider {String} necessary if backup key is held by KRS
     * @param params.recoveryDestination {String} target address to send recovered funds to
     * @param callback
     */
    Eth.prototype.recover = function (params, callback) {
        var self = this;
        return co(function recover() {
            var isKrsRecovery, isUnsignedSweep, userKey, backupKey, gasPrice, gasLimit, backupKeyAddress, backupSigningKey, backupHDNode, backupPrv, backupHDNode, backupKeyNonce, backupKeyBalance, txAmount, recipients, sequenceId, operationHash, signature, txInfo, sendMethodArgs, methodSignature, encodedArgs, sendData, tx, signedTx;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (_.isUndefined(params.userKey)) {
                            throw new Error('missing userKey');
                        }
                        if (_.isUndefined(params.backupKey)) {
                            throw new Error('missing backupKey');
                        }
                        if (_.isUndefined(params.walletPassphrase) && !params.userKey.startsWith('xpub')) {
                            throw new Error('missing wallet passphrase');
                        }
                        if (_.isUndefined(params.walletContractAddress) || !self.isValidAddress(params.walletContractAddress)) {
                            throw new Error('invalid walletContractAddress');
                        }
                        if (_.isUndefined(params.recoveryDestination) || !self.isValidAddress(params.recoveryDestination)) {
                            throw new Error('invalid recoveryDestination');
                        }
                        isKrsRecovery = params.backupKey.startsWith('xpub') && !params.userKey.startsWith('xpub');
                        isUnsignedSweep = params.backupKey.startsWith('xpub') && params.userKey.startsWith('xpub');
                        if (isKrsRecovery && params.krsProvider && _.isUndefined(config.krsProviders[params.krsProvider])) {
                            throw new Error('unknown key recovery service provider');
                        }
                        userKey = params.userKey.replace(/\s/g, '');
                        backupKey = params.backupKey.replace(/\s/g, '');
                        gasPrice = self.getRecoveryGasPrice();
                        gasLimit = self.getRecoveryGasLimit();
                        // Decrypt private keys from KeyCard values if necessary
                        if (!userKey.startsWith('xpub') && !userKey.startsWith('xprv')) {
                            try {
                                userKey = self.bitgo.decrypt({
                                    input: userKey,
                                    password: params.walletPassphrase,
                                });
                            }
                            catch (e) {
                                throw new Error("Error decrypting user keychain: " + e.message);
                            }
                        }
                        if (isKrsRecovery || isUnsignedSweep) {
                            backupHDNode = utxoLib.HDNode.fromBase58(backupKey);
                            backupSigningKey = backupHDNode.getKey().getPublicKeyBuffer();
                            backupKeyAddress = "0x" + exports.optionalDeps.ethUtil.publicToAddress(backupSigningKey, true).toString('hex');
                        }
                        else {
                            backupPrv = void 0;
                            try {
                                backupPrv = self.bitgo.decrypt({
                                    input: backupKey,
                                    password: params.walletPassphrase,
                                });
                            }
                            catch (e) {
                                throw new Error("Error decrypting backup keychain: " + e.message);
                            }
                            backupHDNode = utxoLib.HDNode.fromBase58(backupPrv);
                            backupSigningKey = backupHDNode.getKey().getPrivateKeyBuffer();
                            backupKeyAddress = "0x" + exports.optionalDeps.ethUtil.privateToAddress(backupSigningKey).toString('hex');
                        }
                        return [4 /*yield*/, self.getAddressNonce(backupKeyAddress)];
                    case 1:
                        backupKeyNonce = _a.sent();
                        return [4 /*yield*/, self.queryAddressBalance(backupKeyAddress)];
                    case 2:
                        backupKeyBalance = _a.sent();
                        if (backupKeyBalance.lt(gasPrice.mul(gasLimit))) {
                            throw new Error("Backup key address " + backupKeyAddress + " has balance " + backupKeyBalance.toString(10) + ". This address must have a balance of at least 0.01 ETH to perform recoveries. Try sending some ETH to this address then retry.");
                        }
                        return [4 /*yield*/, self.queryAddressBalance(params.walletContractAddress)];
                    case 3:
                        txAmount = _a.sent();
                        recipients = [
                            {
                                address: params.recoveryDestination,
                                amount: txAmount.toString(10),
                            },
                        ];
                        return [4 /*yield*/, self.querySequenceId(params.walletContractAddress)];
                    case 4:
                        sequenceId = _a.sent();
                        // Get operation hash and sign it
                        if (!isUnsignedSweep) {
                            operationHash = self.getOperationSha3ForExecuteAndConfirm(recipients, self.getDefaultExpireTime(), sequenceId);
                            signature = util_1.Util.ethSignMsgHash(operationHash, util_1.Util.xprvToEthPrivateKey(userKey));
                            try {
                                util_1.Util.ecRecoverEthAddress(operationHash, signature);
                            }
                            catch (e) {
                                throw new Error('Invalid signature');
                            }
                        }
                        txInfo = {
                            recipient: recipients[0],
                            expireTime: self.getDefaultExpireTime(),
                            contractSequenceId: sequenceId,
                            operationHash: operationHash,
                            signature: signature,
                            gasLimit: gasLimit.toString(10),
                        };
                        sendMethodArgs = self.getSendMethodArgs(txInfo);
                        methodSignature = exports.optionalDeps.ethAbi.methodID('sendMultiSig', _.map(sendMethodArgs, 'type'));
                        encodedArgs = exports.optionalDeps.ethAbi.rawEncode(_.map(sendMethodArgs, 'type'), _.map(sendMethodArgs, 'value'));
                        sendData = Buffer.concat([methodSignature, encodedArgs]);
                        tx = new exports.optionalDeps.EthTx({
                            to: params.walletContractAddress,
                            nonce: backupKeyNonce,
                            value: 0,
                            gasPrice: gasPrice,
                            gasLimit: gasLimit,
                            data: sendData,
                            spendAmount: txAmount,
                        });
                        if (isUnsignedSweep) {
                            return [2 /*return*/, self.formatForOfflineVault(txInfo, tx, userKey, backupKey, gasPrice, gasLimit)];
                        }
                        if (!isKrsRecovery) {
                            tx.sign(backupSigningKey);
                        }
                        signedTx = {
                            id: exports.optionalDeps.ethUtil.bufferToHex(tx.hash(true)),
                            tx: tx.serialize().toString('hex'),
                        };
                        if (isKrsRecovery) {
                            signedTx.backupKey = backupKey;
                            signedTx.coin = self.getChain();
                        }
                        return [2 /*return*/, signedTx];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Recover an unsupported token from a BitGo multisig wallet
     * This builds a half-signed transaction, for which there will be an admin route to co-sign and broadcast. Optionally
     * the user can set params.broadcast = true and the half-signed tx will be sent to BitGo for cosigning and broadcasting
     * @param params
     * @param params.wallet the wallet to recover the token from
     * @param params.tokenContractAddress the contract address of the unsupported token
     * @param params.recipient the destination address recovered tokens should be sent to
     * @param params.walletPassphrase the wallet passphrase
     * @param params.prv the xprv
     * @param params.broadcast if true, we will automatically submit the half-signed tx to BitGo for cosigning and broadcasting
     * @param callback
     */
    Eth.prototype.recoverToken = function (params, callback) {
        var self = this;
        return co(function () {
            var coinSpecific, recoveryAmount, sendMethodArgs, methodSignature, encodedArgs, sendData, broadcastParams, recipient, expireTime, _a, nextContractSequenceId, gasPrice, gasLimit, safeSequenceId, operationTypes, operationArgs, operationHash, userPrv, signature, result;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!_.isObject(params)) {
                            throw new Error("recoverToken must be passed a params object. Got " + params + " (type " + typeof params + ")");
                        }
                        if (_.isUndefined(params.tokenContractAddress) || !_.isString(params.tokenContractAddress)) {
                            throw new Error("tokenContractAddress must be a string, got " + params.tokenContractAddress + " (type " + typeof params.tokenContractAddress + ")");
                        }
                        if (!self.isValidAddress(params.tokenContractAddress)) {
                            throw new Error('tokenContractAddress not a valid address');
                        }
                        if (_.isUndefined(params.wallet) || !(params.wallet instanceof wallet_1.Wallet)) {
                            throw new Error("wallet must be a wallet instance, got " + params.wallet + " (type " + typeof params.wallet + ")");
                        }
                        if (_.isUndefined(params.recipient) || !_.isString(params.recipient)) {
                            throw new Error("recipient must be a string, got " + params.recipient + " (type " + typeof params.recipient + ")");
                        }
                        if (!self.isValidAddress(params.recipient)) {
                            throw new Error('recipient not a valid address');
                        }
                        if (!exports.optionalDeps.ethUtil.bufferToHex || !exports.optionalDeps.ethAbi.soliditySHA3) {
                            throw new Error('ethereum not fully supported in this environment');
                        }
                        coinSpecific = params.wallet.coinSpecific();
                        if (!coinSpecific || !_.isString(coinSpecific.baseAddress)) {
                            throw new Error('missing required coin specific property baseAddress');
                        }
                        return [4 /*yield*/, self.queryAddressTokenBalance(params.tokenContractAddress, coinSpecific.baseAddress)];
                    case 1:
                        recoveryAmount = _b.sent();
                        if (!params.broadcast) return [3 /*break*/, 3];
                        sendMethodArgs = [
                            {
                                name: '_to',
                                type: 'address',
                                value: params.recipient,
                            },
                            {
                                name: '_value',
                                type: 'uint256',
                                value: recoveryAmount.toString(10),
                            },
                        ];
                        methodSignature = exports.optionalDeps.ethAbi.methodID('transfer', _.map(sendMethodArgs, 'type'));
                        encodedArgs = exports.optionalDeps.ethAbi.rawEncode(_.map(sendMethodArgs, 'type'), _.map(sendMethodArgs, 'value'));
                        sendData = Buffer.concat([methodSignature, encodedArgs]);
                        broadcastParams = {
                            address: params.tokenContractAddress,
                            amount: '0',
                            data: sendData.toString('hex'),
                        };
                        if (params.walletPassphrase) {
                            broadcastParams.walletPassphrase = params.walletPassphrase;
                        }
                        else if (params.prv) {
                            broadcastParams.prv = params.prv;
                        }
                        return [4 /*yield*/, params.wallet.send(broadcastParams)];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        recipient = {
                            address: params.recipient,
                            amount: recoveryAmount.toString(10),
                        };
                        expireTime = Math.floor(new Date().getTime() / 1000) + 60 * 60 * 24 * 7;
                        return [4 /*yield*/, params.wallet.prebuildTransaction({
                                recipients: [
                                    {
                                        address: params.recipient,
                                        amount: '1',
                                    },
                                ],
                            })];
                    case 4:
                        _a = _b.sent(), nextContractSequenceId = _a.nextContractSequenceId, gasPrice = _a.gasPrice, gasLimit = _a.gasLimit;
                        safeSequenceId = nextContractSequenceId + 1000;
                        operationTypes = ['string', 'address', 'uint', 'address', 'uint', 'uint'];
                        operationArgs = [
                            // "ERC20" has been added here so that ether operation hashes, signatures cannot be re-used for tokenSending
                            'ERC20',
                            new exports.optionalDeps.ethUtil.BN(exports.optionalDeps.ethUtil.stripHexPrefix(recipient.address), 16),
                            recipient.amount,
                            new exports.optionalDeps.ethUtil.BN(exports.optionalDeps.ethUtil.stripHexPrefix(params.tokenContractAddress), 16),
                            expireTime,
                            safeSequenceId,
                        ];
                        operationHash = exports.optionalDeps.ethUtil.bufferToHex(exports.optionalDeps.ethAbi.soliditySHA3(operationTypes, operationArgs));
                        return [4 /*yield*/, params.wallet.getPrv({
                                prv: params.prv,
                                walletPassphrase: params.walletPassphrase,
                            })];
                    case 5:
                        userPrv = _b.sent();
                        signature = util_1.Util.ethSignMsgHash(operationHash, util_1.Util.xprvToEthPrivateKey(userPrv));
                        result = {
                            halfSigned: {
                                recipient: recipient,
                                expireTime: expireTime,
                                contractSequenceId: safeSequenceId,
                                operationHash: operationHash,
                                signature: signature,
                                gasLimit: gasLimit,
                                gasPrice: gasPrice,
                                tokenContractAddress: params.tokenContractAddress,
                                walletId: params.wallet.id(),
                            },
                        };
                        return [2 /*return*/, result];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Build arguments to call the send method on the wallet contract
     * @param txInfo
     */
    Eth.prototype.getSendMethodArgs = function (txInfo) {
        // Method signature is
        // sendMultiSig(address toAddress, uint value, bytes data, uint expireTime, uint sequenceId, bytes signature)
        return [
            {
                name: 'toAddress',
                type: 'address',
                value: txInfo.recipient.address,
            },
            {
                name: 'value',
                type: 'uint',
                value: txInfo.recipient.amount,
            },
            {
                name: 'data',
                type: 'bytes',
                value: exports.optionalDeps.ethUtil.toBuffer(txInfo.recipient.data || ''),
            },
            {
                name: 'expireTime',
                type: 'uint',
                value: txInfo.expireTime,
            },
            {
                name: 'sequenceId',
                type: 'uint',
                value: txInfo.contractSequenceId,
            },
            {
                name: 'signature',
                type: 'bytes',
                value: exports.optionalDeps.ethUtil.toBuffer(txInfo.signature),
            },
        ];
    };
    /**
     * Make a query to Etherscan for information such as balance, token balance, solidity calls
     * @param query {Object} key-value pairs of parameters to append after /api
     * @param callback
     * @returns {Object} response from Etherscan
     */
    Eth.prototype.recoveryBlockchainExplorerQuery = function (query, callback) {
        var self = this;
        return co(function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, request
                            .get(common.Environments[self.bitgo.getEnv()].etherscanBaseUrl + '/api')
                            .query(query)];
                    case 1:
                        response = _a.sent();
                        if (!response.ok) {
                            throw new Error('could not reach Etherscan');
                        }
                        return [2 /*return*/, response.body];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Creates the extra parameters needed to build a hop transaction
     * @param buildParams The original build parameters
     * @param callback
     * @returns extra parameters object to merge with the original build parameters object and send to the platform
     */
    Eth.prototype.createHopTransactionParams = function (buildParams, callback) {
        var self = this;
        return co(function () {
            var wallet, recipients, walletPassphrase, userKeychain, userPrv, userPrvBuffer, recipientAddress, recipientAmount, feeEstimateParams, feeEstimate, gasLimit, gasPrice, gasPriceMax, paymentId, hopDigest, userReqSig, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        wallet = buildParams.wallet;
                        recipients = buildParams.recipients;
                        walletPassphrase = buildParams.walletPassphrase;
                        return [4 /*yield*/, self.keychains().get({ id: wallet.keyIds()[0] })];
                    case 1:
                        userKeychain = _a.sent();
                        userPrv = wallet.getUserPrv({ keychain: userKeychain, walletPassphrase: walletPassphrase });
                        userPrvBuffer = utxoLib.HDNode.fromBase58(userPrv)
                            .getKey()
                            .getPrivateKeyBuffer();
                        if (!recipients || !Array.isArray(recipients)) {
                            throw new Error('expecting array of recipients');
                        }
                        // Right now we only support 1 recipient
                        if (recipients.length !== 1) {
                            throw new Error('must send to exactly 1 recipient');
                        }
                        recipientAddress = recipients[0].address;
                        recipientAmount = recipients[0].amount;
                        feeEstimateParams = {
                            recipient: recipientAddress,
                            amount: recipientAmount,
                            hop: true,
                        };
                        return [4 /*yield*/, self.feeEstimate(feeEstimateParams)];
                    case 2:
                        feeEstimate = _a.sent();
                        gasLimit = feeEstimate.gasLimitEstimate;
                        gasPrice = Math.round(feeEstimate.feeEstimate / gasLimit);
                        gasPriceMax = gasPrice * 5;
                        paymentId = Math.floor(Math.random() * 10000000000).toString();
                        hopDigest = Eth.getHopDigest([
                            recipientAddress,
                            recipientAmount,
                            gasPriceMax.toString(),
                            gasLimit.toString(),
                            paymentId,
                        ]);
                        userReqSig = exports.optionalDeps.ethUtil.addHexPrefix(secp256k1.sign(hopDigest, userPrvBuffer).signature.toString('hex'));
                        result = {
                            hopParams: {
                                gasPriceMax: gasPriceMax,
                                userReqSig: userReqSig,
                                paymentId: paymentId,
                            },
                            gasLimit: gasLimit,
                        };
                        return [2 /*return*/, result];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Validates that the hop prebuild from the HSM is valid and correct
     * @param wallet The wallet that the prebuild is for
     * @param hopPrebuild The prebuild to validate
     * @param originalParams The original parameters passed to prebuildTransaction
     * @param callback
     * @returns void
     * @throws Error if The prebuild is invalid
     */
    Eth.prototype.validateHopPrebuild = function (wallet, hopPrebuild, originalParams, callback) {
        var self = this;
        return co(function () {
            var tx, id, signature, serverXpub, serverPubkeyBuffer, signatureBuffer, messageBuffer, isValidSignature, builtHopTx, recipients, originalAmount, originalDestination, hopAmount, hopDestination;
            return __generator(this, function (_a) {
                tx = hopPrebuild.tx, id = hopPrebuild.id, signature = hopPrebuild.signature;
                serverXpub = common.Environments[self.bitgo.getEnv()].hsmXpub;
                serverPubkeyBuffer = utxoLib.HDNode.fromBase58(serverXpub).getPublicKeyBuffer();
                signatureBuffer = Buffer.from(exports.optionalDeps.ethUtil.stripHexPrefix(signature), 'hex');
                messageBuffer = Buffer.from(exports.optionalDeps.ethUtil.stripHexPrefix(id), 'hex');
                isValidSignature = secp256k1.verify(messageBuffer, signatureBuffer.slice(1), serverPubkeyBuffer);
                if (!isValidSignature) {
                    throw new Error("Hop txid signature invalid");
                }
                builtHopTx = new exports.optionalDeps.EthTx(tx);
                // If original params are given, we can check them against the transaction prebuild params
                if (!_.isNil(originalParams)) {
                    recipients = originalParams.recipients;
                    originalAmount = new bignumber_js_1.BigNumber(recipients[0].amount);
                    originalDestination = recipients[0].address;
                    hopAmount = new bignumber_js_1.BigNumber(exports.optionalDeps.ethUtil.bufferToHex(builtHopTx.value));
                    hopDestination = exports.optionalDeps.ethUtil.bufferToHex(builtHopTx.to);
                    if (!hopAmount.eq(originalAmount)) {
                        throw new Error("Hop amount: " + hopAmount + " does not equal original amount: " + originalAmount);
                    }
                    if (hopDestination.toLowerCase() !== originalDestination.toLowerCase()) {
                        throw new Error("Hop destination: " + hopDestination + " does not equal original recipient: " + hopDestination);
                    }
                }
                if (!builtHopTx.verifySignature()) {
                    // We dont want to continue at all in this case, at risk of ETH being stuck on the hop address
                    throw new Error("Invalid hop transaction signature, txid: " + id);
                }
                if (exports.optionalDeps.ethUtil.addHexPrefix(builtHopTx.hash().toString('hex')) !== id) {
                    throw new Error("Signed hop txid does not equal actual txid");
                }
                return [2 /*return*/];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Gets the hop digest for the user to sign. This is validated in the HSM to prove that the user requested this tx
     * @param paramsArr The parameters to hash together for the digest
     */
    Eth.getHopDigest = function (paramsArr) {
        var hash = new Keccak('keccak256');
        hash.update([Eth.hopTransactionSalt].concat(paramsArr).join('$'));
        return hash.digest();
    };
    /**
     * Modify prebuild before sending it to the server. Add things like hop transaction params
     * @param buildParams The whitelisted parameters for this prebuild
     * @param buildParams.hop True if this should prebuild a hop tx, else false
     * @param buildParams.recipients The recipients array of this transaction
     * @param buildParams.wallet The wallet sending this tx
     * @param buildParams.walletPassphrase the passphrase for this wallet
     * @param callback
     */
    Eth.prototype.getExtraPrebuildParams = function (buildParams, callback) {
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(!_.isUndefined(buildParams.hop) &&
                            buildParams.hop &&
                            !_.isUndefined(buildParams.wallet) &&
                            !_.isUndefined(buildParams.recipients) &&
                            !_.isUndefined(buildParams.walletPassphrase))) return [3 /*break*/, 2];
                        if (this instanceof erc20Token_1.Erc20Token) {
                            throw new Error("Hop transactions are not enabled for ERC-20 tokens, nor are they necessary. Please remove the 'hop' parameter and try again.");
                        }
                        return [4 /*yield*/, self.createHopTransactionParams({
                                wallet: buildParams.wallet,
                                recipients: buildParams.recipients,
                                walletPassphrase: buildParams.walletPassphrase,
                            })];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2: return [2 /*return*/, {}];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Modify prebuild after receiving it from the server. Add things like nlocktime
     */
    Eth.prototype.postProcessPrebuild = function (params, callback) {
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(!_.isUndefined(params.hopTransaction) &&
                            !_.isUndefined(params.wallet) &&
                            !_.isUndefined(params.buildParams))) return [3 /*break*/, 2];
                        return [4 /*yield*/, self.validateHopPrebuild(params.wallet, params.hopTransaction, params.buildParams)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/, params];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Coin-specific things done before signing a transaction, i.e. verification
     * @param params
     * @param callback
     */
    Eth.prototype.presignTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(!_.isUndefined(params.hopTransaction) &&
                            !_.isUndefined(params.wallet) &&
                            !_.isUndefined(params.buildParams))) return [3 /*break*/, 2];
                        return [4 /*yield*/, self.validateHopPrebuild(params.wallet, params.hopTransaction)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/, params];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Fetch fee estimate information from the server
     * @param {Object} params The params passed into the function
     * @param {Boolean} [params.hop] True if we should estimate fee for a hop transaction
     * @param {String} [params.recipient] The recipient of the transaction to estimate a send to
     * @param {String} [params.data] The ETH tx data to estimate a send for
     * @param callback
     * @returns {Object} The fee info returned from the server
     */
    Eth.prototype.feeEstimate = function (params, callback) {
        var self = this;
        return co(function coFeeEstimate() {
            var query;
            return __generator(this, function (_a) {
                query = {};
                if (params && params.hop) {
                    query.hop = params.hop;
                }
                if (params && params.recipient) {
                    query.recipient = params.recipient;
                }
                if (params && params.data) {
                    query.data = params.data;
                }
                if (params && params.amount) {
                    query.amount = params.amount;
                }
                return [2 /*return*/, self.bitgo
                        .get(self.url('/tx/fee'))
                        .query(query)
                        .result()];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Generate secp256k1 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub and prv
     */
    Eth.prototype.generateKeyPair = function (seed) {
        if (!seed) {
            // An extended private key has both a normal 256 bit private key and a 256
            // bit chain code, both of which must be random. 512 bits is therefore the
            // maximum entropy and gives us maximum security against cracking.
            seed = crypto.randomBytes(512 / 8);
        }
        var extendedKey = utxoLib.HDNode.fromSeedBuffer(seed);
        var xpub = extendedKey.neutered().toBase58();
        return {
            pub: xpub,
            prv: extendedKey.toBase58(),
        };
    };
    Eth.prototype.parseTransaction = function (params, callback) {
        return Bluebird.resolve({}).asCallback(callback);
    };
    Eth.prototype.verifyAddress = function (params) {
        return true;
    };
    Eth.prototype.verifyTransaction = function (params, callback) {
        return Bluebird.resolve(true).asCallback(callback);
    };
    Eth.hopTransactionSalt = 'bitgoHopAddressRequestSalt';
    return Eth;
}(baseCoin_1.BaseCoin));
exports.Eth = Eth;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXRoLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3YyL2NvaW5zL2V0aC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7R0FFRztBQUNILDZDQUF5QztBQUN6Qyx3Q0FBMEM7QUFDMUMsbUNBQXFDO0FBQ3JDLCtCQUFpQztBQUNqQyxnQ0FBa0M7QUFDbEMsK0JBQWlDO0FBQ2pDLDBCQUE0QjtBQUM1QixxQ0FBdUM7QUFDdkMsb0NBQXNDO0FBRXRDLHdDQVVxQjtBQUNyQiwyQ0FBMEM7QUFHMUMsb0NBQW1DO0FBQ25DLHFDQUF1QztBQUN2QyxxQ0FBdUM7QUFDdkMseUNBQXdDO0FBQ3hDLHVDQUErRDtBQUUvRCxJQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDO0FBQzlCLElBQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUUxQixRQUFBLFlBQVksR0FBRztJQUMxQixJQUFJLE1BQU07UUFDUixJQUFJO1lBQ0YsT0FBTyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztTQUNsQztRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsS0FBSyxDQUFDLGdDQUFnQyxDQUFDLENBQUM7WUFDeEMsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNmLE1BQU0sSUFBSSx3Q0FBK0IsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1NBQzdEO0lBQ0gsQ0FBQztJQUVELElBQUksT0FBTztRQUNULElBQUk7WUFDRixPQUFPLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1NBQ25DO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixLQUFLLENBQUMsaUNBQWlDLENBQUMsQ0FBQztZQUN6QyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ2YsTUFBTSxJQUFJLHdDQUErQixDQUFDLGlCQUFpQixD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Q3BDO1FBQ0QsSUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDeEQsSUFBTSxJQUFJLEdBQUcsV0FBVyxDQUFDLFFBQVEsRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQy9DLE9BQU87WUFDTCxHQUFHLEVBQUUsSUFBSTtZQUNULEdBQUcsRUFBRSxXQUFXLENBQUMsUUFBUSxFQUFFO1NBQzVCLENBQUM7SUFDSixDQUFDO0lBRUQsOEJBQWdCLEdBQWhCLFVBQ0UsTUFBK0IsRUFDL0IsUUFBMEM7UUFFMUMsT0FBTyxRQUFRLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBRUQsMkJBQWEsR0FBYixVQUFjLE1BQTRCO1FBQ3hDLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVELCtCQUFpQixHQUFqQixVQUFrQixNQUFnQyxFQUFFLFFBQWdDO1FBQ2xGLE9BQU8sUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDckQsQ0FBQztJQXBwQ00sc0JBQWtCLEdBQUcsNEJBQTRCLENBQUM7SUFxcEMzRCxVQUFDO0NBQUEsQUF0cENELENBQXlCLG1CQUFRLEdBc3BDaEM7QUF0cENZLGtCQUFHIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJldHRpZXJcbiAqL1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCAqIGFzIHV0eG9MaWIgZnJvbSAnYml0Z28tdXR4by1saWInO1xuaW1wb3J0ICogYXMgQmx1ZWJpcmQgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0ICogYXMgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgKiBhcyBkZWJ1Z0xpYiBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgKiBhcyBLZWNjYWsgZnJvbSAna2VjY2FrJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCAqIGFzIHNlY3AyNTZrMSBmcm9tICdzZWNwMjU2azEnO1xuaW1wb3J0ICogYXMgcmVxdWVzdCBmcm9tICdzdXBlcmFnZW50JztcblxuaW1wb3J0IHtcbiAgQmFzZUNvaW4sXG4gIEZlZUVzdGltYXRlT3B0aW9ucyxcbiAgS2V5UGFpcixcbiAgUGFyc2VkVHJhbnNhY3Rpb24sXG4gIFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zLFxuICBWZXJpZnlBZGRyZXNzT3B0aW9ucyxcbiAgVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLFxuICBUcmFuc2FjdGlvblByZWJ1aWxkIGFzIEJhc2VUcmFuc2FjdGlvblByZWJ1aWxkLFxuICBIYWxmU2lnbmVkVHJhbnNhY3Rpb24gYXMgQmFzZUhhbGZTaWduZWRUcmFuc2FjdGlvbixcbn0gZnJvbSAnLi4vYmFzZUNvaW4nO1xuaW1wb3J0IHsgRXJjMjBUb2tlbiB9IGZyb20gJy4vZXJjMjBUb2tlbic7XG5pbXBvcnQgeyBCaXRHbyB9IGZyb20gJy4uLy4uL2JpdGdvJztcbmltcG9ydCB7IE5vZGVDYWxsYmFjayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IFdhbGxldCB9IGZyb20gJy4uL3dhbGxldCc7XG5pbXBvcnQgKiBhcyBjb21tb24gZnJvbSAnLi4vLi4vY29tbW9uJztcbmltcG9ydCAqIGFzIGNvbmZpZyBmcm9tICcuLi8uLi9jb25maWcnO1xuaW1wb3J0IHsgVXRpbCB9IGZyb20gJy4uL2ludGVybmFsL3V0aWwnO1xuaW1wb3J0IHsgRXRoZXJldW1MaWJyYXJ5VW5hdmFpbGFibGVFcnJvciB9IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5cbmNvbnN0IGNvID0gQmx1ZWJpcmQuY29yb3V0aW5lO1xuY29uc3QgZGVidWcgPSBkZWJ1Z0xpYignYml0Z286djI6ZXRoJyk7XG5cbmV4cG9ydCBjb25zdCBvcHRpb25hbERlcHMgPSB7XG4gIGdldCBldGhBYmkoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiByZXF1aXJlKCdldGhlcmV1bWpzLWFiaScpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlYnVnKCd1bmFibGUgdG8gbG9hZCBldGhlcmV1bWpzLWFiaTonKTtcbiAgICAgIGRlYnVnKGUuc3RhY2spO1xuICAgICAgdGhyb3cgbmV3IEV0aGVyZXVtTGlicmFyeVVuYXZhaWxhYmxlRXJyb3IoYGV0aGVyZXVtanMtYWJpYCk7XG4gICAgfVxuICB9LFxuXG4gIGdldCBldGhVdGlsKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcmVxdWlyZSgnZXRoZXJldW1qcy11dGlsJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVidWcoJ3VuYWJsZSB0byBsb2FkIGV0aGVyZXVtanMtdXRpbDonKTtcbiAgICAgIGRlYnVnKGUuc3RhY2spO1xuICAgICAgdGhyb3cgbmV3IEV0aGVyZXVtTGlicmFyeVVuYXZhaWxhYmxlRXJyb3IoYGV0aGVyZXVtanMtdXRpbGApO1xuICAgIH1cbiAgfSxcblxuICBnZXQgRXRoVHgoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiByZXF1aXJlKCdldGhlcmV1bWpzLXR4Jyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVidWcoJ3VuYWJsZSB0byBsb2FkIGV0aGVyZXVtanMtdHg6Jyk7XG4gICAgICBkZWJ1ZyhlLnN0YWNrKTtcbiAgICAgIHRocm93IG5ldyBFdGhlcmV1bUxpYnJhcnlVbmF2YWlsYWJsZUVycm9yKGBldGhlcmV1bWpzLXR4YCk7XG4gICAgfVxuICB9LFxufTtcblxuLyoqXG4gKiBUaGUgZXh0cmEgcGFyYW1ldGVycyB0byBzZW5kIHRvIHBsYXRmb3JtIGJ1aWxkIHJvdXRlIGZvciBob3AgdHJhbnNhY3Rpb25zXG4gKi9cbmludGVyZmFjZSBIb3BQYXJhbXMge1xuICBob3BQYXJhbXM6IHtcbiAgICBnYXNQcmljZU1heDogbnVtYmVyO1xuICAgIHVzZXJSZXFTaWc6IHN0cmluZztcbiAgICBwYXltZW50SWQ6IHN0cmluZztcbiAgfTtcbiAgZ2FzTGltaXQ6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBUaGUgcHJlYnVpbHQgaG9wIHRyYW5zYWN0aW9uIHJldHVybmVkIGZyb20gdGhlIEhTTVxuICovXG5pbnRlcmZhY2UgSG9wUHJlYnVpbGQge1xuICB0eDogc3RyaW5nO1xuICBpZDogc3RyaW5nO1xuICBzaWduYXR1cmU6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFJlY2lwaWVudCB7XG4gIGFkZHJlc3M6IHN0cmluZztcbiAgYW1vdW50OiBzdHJpbmc7XG4gIGRhdGE/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBTaWduRmluYWxPcHRpb25zIHtcbiAgdHhQcmVidWlsZDoge1xuICAgIGdhc1ByaWNlOiBzdHJpbmc7XG4gICAgZ2FzTGltaXQ6IHN0cmluZztcbiAgICByZWNpcGllbnRzOiBSZWNpcGllbnRbXTtcbiAgICBoYWxmU2lnbmVkOiB7XG4gICAgICBleHBpcmVUaW1lOiBudW1iZXI7XG4gICAgICBjb250cmFjdFNlcXVlbmNlSWQ6IG51bWJlcjtcbiAgICAgIHNpZ25hdHVyZTogc3RyaW5nO1xuICAgIH07XG4gICAgbmV4dENvbnRyYWN0U2VxdWVuY2VJZD86IG51bWJlcjtcbiAgICBob3BUcmFuc2FjdGlvbj86IHN0cmluZztcbiAgfTtcbiAgc2lnbmluZ0tleU5vbmNlOiBudW1iZXI7XG4gIHdhbGxldENvbnRyYWN0QWRkcmVzczogc3RyaW5nO1xuICBwcnY6IHN0cmluZztcbiAgcmVjaXBpZW50czogUmVjaXBpZW50W107XG59XG5cbmludGVyZmFjZSBTaWduVHJhbnNhY3Rpb25PcHRpb25zIGV4dGVuZHMgU2lnbkZpbmFsT3B0aW9ucyB7XG4gIGlzTGFzdFNpZ25hdHVyZT86IGJvb2xlYW47XG4gIGV4cGlyZVRpbWU6IG51bWJlcjtcbiAgc2VxdWVuY2VJZDogbnVtYmVyO1xuICBnYXNMaW1pdDogbnVtYmVyO1xuICBnYXNQcmljZTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhhbGZTaWduZWRUcmFuc2FjdGlvbiBleHRlbmRzIEJhc2VIYWxmU2lnbmVkVHJhbnNhY3Rpb24ge1xuICBoYWxmU2lnbmVkOiB7XG4gICAgcmVjaXBpZW50czogUmVjaXBpZW50W107XG4gICAgZXhwaXJlVGltZTogbnVtYmVyO1xuICAgIGNvbnRyYWN0U2VxdWVuY2VJZDogbnVtYmVyO1xuICAgIHNlcXVlbmNlSWQ6IG51bWJlcjtcbiAgICB0eEhleD86IG5ldmVyO1xuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZ1bGx5U2lnbmVkVHJhbnNhY3Rpb24ge1xuICB0eEhleDogc3RyaW5nO1xufVxuXG5leHBvcnQgdHlwZSBTaWduZWRUcmFuc2FjdGlvbiA9IEhhbGZTaWduZWRUcmFuc2FjdGlvbiB8IEZ1bGx5U2lnbmVkVHJhbnNhY3Rpb247XG5cbmludGVyZmFjZSBQcmVjcmVhdGVCaXRHb09wdGlvbnMge1xuICBlbnRlcnByaXNlPzogc3RyaW5nO1xuICBuZXdGZWVBZGRyZXNzPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgT2ZmbGluZVZhdWx0VHhJbmZvIHtcbiAgbmV4dENvbnRyYWN0U2VxdWVuY2VJZD86IHN0cmluZztcbiAgY29udHJhY3RTZXF1ZW5jZUlkPzogc3RyaW5nO1xuICB0eDogc3RyaW5nO1xuICB1c2VyS2V5OiBzdHJpbmc7XG4gIGJhY2t1cEtleTogc3RyaW5nO1xuICBjb2luOiBzdHJpbmc7XG4gIGdhc1ByaWNlOiBudW1iZXI7XG4gIGdhc0xpbWl0OiBudW1iZXI7XG4gIHJlY2lwaWVudHM6IFJlY2lwaWVudFtdO1xuICB3YWxsZXRDb250cmFjdEFkZHJlc3M6IHN0cmluZztcbiAgYW1vdW50OiBzdHJpbmc7XG4gIGJhY2t1cEtleU5vbmNlOiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBVbmZvcm1hdHRlZFR4SW5mbyB7XG4gIHJlY2lwaWVudDogUmVjaXBpZW50O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlY292ZXJPcHRpb25zIHtcbiAgdXNlcktleTogc3RyaW5nO1xuICBiYWNrdXBLZXk6IHN0cmluZztcbiAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbiAgd2FsbGV0Q29udHJhY3RBZGRyZXNzOiBzdHJpbmc7XG4gIHJlY292ZXJ5RGVzdGluYXRpb246IHN0cmluZztcbiAga3JzUHJvdmlkZXI/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVjb3ZlcnlJbmZvIHtcbiAgaWQ6IHN0cmluZztcbiAgdHg6IHN0cmluZztcbiAgYmFja3VwS2V5Pzogc3RyaW5nO1xuICBjb2luPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgUmVjb3ZlclRva2VuT3B0aW9ucyB7XG4gIHRva2VuQ29udHJhY3RBZGRyZXNzOiBzdHJpbmc7XG4gIHdhbGxldDogV2FsbGV0O1xuICByZWNpcGllbnQ6IHN0cmluZztcbiAgYnJvYWRjYXN0PzogYm9vbGVhbjtcbiAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbiAgcHJ2Pzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgR2V0U2VuZE1ldGhvZEFyZ3NPcHRpb25zIHtcbiAgcmVjaXBpZW50OiBSZWNpcGllbnQ7XG4gIGV4cGlyZVRpbWU6IG51bWJlcjtcbiAgY29udHJhY3RTZXF1ZW5jZUlkOiBudW1iZXI7XG4gIHNpZ25hdHVyZTogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgU2VuZE1ldGhvZEFyZ3Mge1xuICBuYW1lOiBzdHJpbmc7XG4gIHR5cGU6IHN0cmluZztcbiAgdmFsdWU6IGFueTtcbn1cblxuaW50ZXJmYWNlIEhvcFRyYW5zYWN0aW9uQnVpbGRPcHRpb25zIHtcbiAgd2FsbGV0OiBXYWxsZXQ7XG4gIHJlY2lwaWVudHM6IFJlY2lwaWVudFtdO1xuICB3YWxsZXRQYXNzcGhyYXNlOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBCdWlsZE9wdGlvbnMge1xuICBob3A/OiBib29sZWFuO1xuICB3YWxsZXQ/OiBXYWxsZXQ7XG4gIHJlY2lwaWVudHM/OiBSZWNpcGllbnRbXTtcbiAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEZlZUVzdGltYXRlIHtcbiAgZ2FzTGltaXRFc3RpbWF0ZTogbnVtYmVyO1xuICBmZWVFc3RpbWF0ZTogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgVHJhbnNhY3Rpb25QcmVidWlsZCBleHRlbmRzIEJhc2VUcmFuc2FjdGlvblByZWJ1aWxkIHtcbiAgaG9wVHJhbnNhY3Rpb24/OiBIb3BQcmVidWlsZDtcbiAgYnVpbGRQYXJhbXM6IHtcbiAgICByZWNpcGllbnRzOiBSZWNpcGllbnRbXTtcbiAgfTtcbn1cblxuaW50ZXJmYWNlIFJlY292ZXJUb2tlblRyYW5zYWN0aW9uIHtcbiAgaGFsZlNpZ25lZDoge1xuICAgIHJlY2lwaWVudDogUmVjaXBpZW50O1xuICAgIGV4cGlyZVRpbWU6IG51bWJlcjtcbiAgICBjb250cmFjdFNlcXVlbmNlSWQ6IG51bWJlcjtcbiAgICBvcGVyYXRpb25IYXNoOiBzdHJpbmc7XG4gICAgc2lnbmF0dXJlOiBzdHJpbmc7XG4gICAgZ2FzTGltaXQ6IG51bWJlcjtcbiAgICBnYXNQcmljZTogbnVtYmVyO1xuICAgIHRva2VuQ29udHJhY3RBZGRyZXNzOiBzdHJpbmc7XG4gICAgd2FsbGV0SWQ6IHN0cmluZztcbiAgfTtcbn1cblxuZXhwb3J0IGNsYXNzIEV0aCBleHRlbmRzIEJhc2VDb2luIHtcbiAgc3RhdGljIGhvcFRyYW5zYWN0aW9uU2FsdCA9ICdiaXRnb0hvcEFkZHJlc3NSZXF1ZXN0U2FsdCc7XG5cbiAgc3RhdGljIGNyZWF0ZUluc3RhbmNlKGJpdGdvOiBCaXRHbyk6IEJhc2VDb2luIHtcbiAgICByZXR1cm4gbmV3IEV0aChiaXRnbyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmFjdG9yIGJldHdlZW4gdGhlIGJhc2UgdW5pdCBhbmQgaXRzIHNtYWxsZXN0IHN1YmRpdmlzb25cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0QmFzZUZhY3RvcigpOiBzdHJpbmcge1xuICAgIC8vIDEwXjE4XG4gICAgcmV0dXJuICcxMDAwMDAwMDAwMDAwMDAwMDAwJztcbiAgfVxuXG4gIGdldENoYWluKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdldGgnO1xuICB9XG5cbiAgZ2V0RmFtaWx5KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdldGgnO1xuICB9XG5cbiAgZ2V0RnVsbE5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ0V0aGVyZXVtJztcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGFnIGZvciBzZW5kaW5nIHZhbHVlIG9mIDBcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgb2theSB0byBzZW5kIDAgdmFsdWUsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgdmFsdWVsZXNzVHJhbnNmZXJBbGxvd2VkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEZsYWcgZm9yIHNlbmRpbmcgZGF0YSBhbG9uZyB3aXRoIHRyYW5zYWN0aW9uc1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBva2F5IHRvIHNlbmQgdHggZGF0YSAoRVRIKSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICB0cmFuc2FjdGlvbkRhdGFBbGxvd2VkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlcyB3aGV0aGVyIGFuIGFkZHJlc3Mgc3RyaW5nIGlzIHZhbGlkIGZvciB0aGlzIGNvaW5cbiAgICogQHBhcmFtIGFkZHJlc3NcbiAgICovXG4gIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBvcHRpb25hbERlcHMuZXRoVXRpbC5pc1ZhbGlkQWRkcmVzcyhvcHRpb25hbERlcHMuZXRoVXRpbC5hZGRIZXhQcmVmaXgoYWRkcmVzcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBwdWJsaWMga2V5IGZvciB0aGUgY29pbi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHB1YiB0aGUgcHViIHRvIGJlIGNoZWNrZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGlzIGl0IHZhbGlkP1xuICAgKi9cbiAgaXNWYWxpZFB1YihwdWI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICB1dHhvTGliLkhETm9kZS5mcm9tQmFzZTU4KHB1Yik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgZ2FzIHByaWNlIGZyb20gcGxhdGZvcm1cbiAgICogQHJldHVybnMge0JpZ051bWJlcn1cbiAgICovXG4gIGdldFJlY292ZXJ5R2FzUHJpY2UoKTogYW55IHtcbiAgICByZXR1cm4gbmV3IG9wdGlvbmFsRGVwcy5ldGhVdGlsLkJOKCcyMDAwMDAwMDAwMCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgZ2FzIGxpbWl0IGZyb20gcGxhdGZvcm1cbiAgICogQHJldHVybnMge0JpZ051bWJlcn1cbiAgICovXG4gIGdldFJlY292ZXJ5R2FzTGltaXQoKTogYW55IHtcbiAgICByZXR1cm4gbmV3IG9wdGlvbmFsRGVwcy5ldGhVdGlsLkJOKCc1MDAwMDAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IGV4cGlyZSB0aW1lIGZvciBhIGNvbnRyYWN0IGNhbGwgKDEgd2VlaylcbiAgICogQHJldHVybnMge251bWJlcn0gVGltZSBpbiBzZWNvbmRzXG4gICAqL1xuICBnZXREZWZhdWx0RXhwaXJlVGltZSgpOiBudW1iZXIge1xuICAgIHJldHVybiBNYXRoLmZsb29yKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCkgKyA2MCAqIDYwICogMjQgKiA3O1xuICB9XG5cbiAgLyoqXG4gICAqIFF1ZXJ5IEV0aGVyc2NhbiBmb3IgdGhlIGJhbGFuY2Ugb2YgYW4gYWRkcmVzc1xuICAgKiBAcGFyYW0gYWRkcmVzcyB7U3RyaW5nfSB0aGUgRVRIIGFkZHJlc3NcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtCaWdOdW1iZXJ9IGFkZHJlc3MgYmFsYW5jZVxuICAgKi9cbiAgcXVlcnlBZGRyZXNzQmFsYW5jZShhZGRyZXNzOiBzdHJpbmcsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24qKCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgc2VsZi5yZWNvdmVyeUJsb2NrY2hhaW5FeHBsb3JlclF1ZXJ5KHtcbiAgICAgICAgbW9kdWxlOiAnYWNjb3VudCcsXG4gICAgICAgIGFjdGlvbjogJ2JhbGFuY2UnLFxuICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IG9wdGlvbmFsRGVwcy5ldGhVdGlsLkJOKHJlc3VsdC5yZXN1bHQsIDEwKTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWVyeSBFdGhlcnNjYW4gZm9yIHRoZSBiYWxhbmNlIG9mIGFuIGFkZHJlc3MgZm9yIGEgdG9rZW5cbiAgICogQHBhcmFtIHRva2VuQ29udHJhY3RBZGRyZXNzIHtTdHJpbmd9IGFkZHJlc3Mgd2hlcmUgdGhlIHRva2VuIHNtYXJ0IGNvbnRyYWN0IGlzIGhvc3RlZFxuICAgKiBAcGFyYW0gd2FsbGV0Q29udHJhY3RBZGRyZXNzIHtTdHJpbmd9IGFkZHJlc3Mgb2YgdGhlIHdhbGxldFxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge0JpZ051bWJlcn0gdG9rZW4gYmFsYWFuY2UgaW4gYmFzZSB1bml0c1xuICAgKi9cbiAgcXVlcnlBZGRyZXNzVG9rZW5CYWxhbmNlKFxuICAgIHRva2VuQ29udHJhY3RBZGRyZXNzOiBzdHJpbmcsXG4gICAgd2FsbGV0Q29udHJhY3RBZGRyZXNzOiBzdHJpbmcsXG4gICAgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55PlxuICApOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24qKCkge1xuICAgICAgaWYgKCFvcHRpb25hbERlcHMuZXRoVXRpbC5pc1ZhbGlkQWRkcmVzcyh0b2tlbkNvbnRyYWN0QWRkcmVzcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgZ2V0IGJhbGFuY2UgZm9yIGludmFsaWQgdG9rZW4gYWRkcmVzcycpO1xuICAgICAgfVxuICAgICAgaWYgKCFvcHRpb25hbERlcHMuZXRoVXRpbC5pc1ZhbGlkQWRkcmVzcyh3YWxsZXRDb250cmFjdEFkZHJlc3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGdldCB0b2tlbiBiYWxhbmNlIGZvciBpbnZhbGlkIHdhbGxldCBhZGRyZXNzJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHNlbGYucmVjb3ZlcnlCbG9ja2NoYWluRXhwbG9yZXJRdWVyeSh7XG4gICAgICAgIG1vZHVsZTogJ2FjY291bnQnLFxuICAgICAgICBhY3Rpb246ICd0b2tlbmJhbGFuY2UnLFxuICAgICAgICBjb250cmFjdGFkZHJlc3M6IHRva2VuQ29udHJhY3RBZGRyZXNzLFxuICAgICAgICBhZGRyZXNzOiB3YWxsZXRDb250cmFjdEFkZHJlc3MsXG4gICAgICAgIHRhZzogJ2xhdGVzdCcsXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG5ldyBvcHRpb25hbERlcHMuZXRoVXRpbC5CTihyZXN1bHQucmVzdWx0LCAxMCk7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRyYW5zZmVyIG9wZXJhdGlvbiBmb3IgY29pblxuICAgKiBAcGFyYW0gcmVjaXBpZW50IHJlY2lwaWVudCBpbmZvXG4gICAqIEBwYXJhbSBleHBpcmVUaW1lIGV4cGlyeSB0aW1lXG4gICAqIEBwYXJhbSBjb250cmFjdFNlcXVlbmNlSWQgc2VxdWVuY2UgaWRcbiAgICogQHJldHVybnMge0FycmF5fSBvcGVyYXRpb24gYXJyYXlcbiAgICovXG4gIGdldE9wZXJhdGlvbihyZWNpcGllbnQ6IFJlY2lwaWVudCwgZXhwaXJlVGltZTogbnVtYmVyLCBjb250cmFjdFNlcXVlbmNlSWQ6IG51bWJlcik6IChzdHJpbmcgfCBCdWZmZXIpW11bXSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIFsnc3RyaW5nJywgJ2FkZHJlc3MnLCAndWludCcsICdieXRlcycsICd1aW50JywgJ3VpbnQnXSxcbiAgICAgIFtcbiAgICAgICAgJ0VUSEVSJyxcbiAgICAgICAgbmV3IG9wdGlvbmFsRGVwcy5ldGhVdGlsLkJOKG9wdGlvbmFsRGVwcy5ldGhVdGlsLnN0cmlwSGV4UHJlZml4KHJlY2lwaWVudC5hZGRyZXNzKSwgMTYpLFxuICAgICAgICByZWNpcGllbnQuYW1vdW50LFxuICAgICAgICBuZXcgQnVmZmVyKG9wdGlvbmFsRGVwcy5ldGhVdGlsLnN0cmlwSGV4UHJlZml4KHJlY2lwaWVudC5kYXRhKSB8fCAnJywgJ2hleCcpLFxuICAgICAgICBleHBpcmVUaW1lLFxuICAgICAgICBjb250cmFjdFNlcXVlbmNlSWQsXG4gICAgICBdLFxuICAgIF07XG4gIH1cblxuICBnZXRPcGVyYXRpb25TaGEzRm9yRXhlY3V0ZUFuZENvbmZpcm0oXG4gICAgcmVjaXBpZW50czogUmVjaXBpZW50W10sXG4gICAgZXhwaXJlVGltZTogbnVtYmVyLFxuICAgIGNvbnRyYWN0U2VxdWVuY2VJZDogbnVtYmVyXG4gICk6IHN0cmluZyB7XG4gICAgaWYgKCFyZWNpcGllbnRzIHx8ICFBcnJheS5pc0FycmF5KHJlY2lwaWVudHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGluZyBhcnJheSBvZiByZWNpcGllbnRzJyk7XG4gICAgfVxuXG4gICAgLy8gUmlnaHQgbm93IHdlIG9ubHkgc3VwcG9ydCAxIHJlY2lwaWVudFxuICAgIGlmIChyZWNpcGllbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHNlbmQgdG8gZXhhY3RseSAxIHJlY2lwaWVudCcpO1xuICAgIH1cblxuICAgIGlmICghXy5pc051bWJlcihleHBpcmVUaW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBpcmVUaW1lIG11c3QgYmUgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgZXBvY2gnKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNOdW1iZXIoY29udHJhY3RTZXF1ZW5jZUlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb250cmFjdFNlcXVlbmNlSWQgbXVzdCBiZSBudW1iZXInKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpbnB1dHNcbiAgICByZWNpcGllbnRzLmZvckVhY2goZnVuY3Rpb24ocmVjaXBpZW50KSB7XG4gICAgICBpZiAoXG4gICAgICAgICFfLmlzU3RyaW5nKHJlY2lwaWVudC5hZGRyZXNzKSB8fFxuICAgICAgICAhb3B0aW9uYWxEZXBzLmV0aFV0aWwuaXNWYWxpZEFkZHJlc3Mob3B0aW9uYWxEZXBzLmV0aFV0aWwuYWRkSGV4UHJlZml4KHJlY2lwaWVudC5hZGRyZXNzKSlcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWRkcmVzczogJyArIHJlY2lwaWVudC5hZGRyZXNzKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGFtb3VudDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGFtb3VudCA9IG5ldyBCaWdOdW1iZXIocmVjaXBpZW50LmFtb3VudCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhbW91bnQgZm9yOiAnICsgcmVjaXBpZW50LmFkZHJlc3MgKyAnIC0gc2hvdWxkIGJlIG51bWVyaWMnKTtcbiAgICAgIH1cblxuICAgICAgcmVjaXBpZW50LmFtb3VudCA9IGFtb3VudC50b0ZpeGVkKDApO1xuXG4gICAgICBpZiAocmVjaXBpZW50LmRhdGEgJiYgIV8uaXNTdHJpbmcocmVjaXBpZW50LmRhdGEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBmb3IgcmVjaXBpZW50ICcgKyByZWNpcGllbnQuYWRkcmVzcyArICcgLSBzaG91bGQgYmUgb2YgdHlwZSBoZXggc3RyaW5nJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCByZWNpcGllbnQgPSByZWNpcGllbnRzWzBdO1xuICAgIHJldHVybiBvcHRpb25hbERlcHMuZXRoVXRpbC5idWZmZXJUb0hleChcbiAgICAgIG9wdGlvbmFsRGVwcy5ldGhBYmkuc29saWRpdHlTSEEzKC4uLnRoaXMuZ2V0T3BlcmF0aW9uKHJlY2lwaWVudCwgZXhwaXJlVGltZSwgY29udHJhY3RTZXF1ZW5jZUlkKSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1ZXJpZXMgdGhlIGNvbnRyYWN0ICh2aWEgRXRoZXJzY2FuKSBmb3IgdGhlIG5leHQgc2VxdWVuY2UgSURcbiAgICogQHBhcmFtIGFkZHJlc3Mge1N0cmluZ30gYWRkcmVzcyBvZiB0aGUgY29udHJhY3RcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHNlcXVlbmNlIElEXG4gICAqL1xuICBxdWVyeVNlcXVlbmNlSWQoYWRkcmVzczogc3RyaW5nLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxudW1iZXI+KTogQmx1ZWJpcmQ8bnVtYmVyPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPG51bWJlcj4oZnVuY3Rpb24qKCkge1xuICAgICAgLy8gR2V0IHNlcXVlbmNlIElEIHVzaW5nIGNvbnRyYWN0IGNhbGxcbiAgICAgIGNvbnN0IHNlcXVlbmNlSWRNZXRob2RTaWduYXR1cmUgPSBvcHRpb25hbERlcHMuZXRoQWJpLm1ldGhvZElEKCdnZXROZXh0U2VxdWVuY2VJZCcsIFtdKTtcbiAgICAgIGNvbnN0IHNlcXVlbmNlSWRBcmdzID0gb3B0aW9uYWxEZXBzLmV0aEFiaS5yYXdFbmNvZGUoW10sIFtdKTtcbiAgICAgIGNvbnN0IHNlcXVlbmNlSWREYXRhID0gQnVmZmVyLmNvbmNhdChbc2VxdWVuY2VJZE1ldGhvZFNpZ25hdHVyZSwgc2VxdWVuY2VJZEFyZ3NdKS50b1N0cmluZygnaGV4Jyk7XG4gICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBzZWxmLnJlY292ZXJ5QmxvY2tjaGFpbkV4cGxvcmVyUXVlcnkoe1xuICAgICAgICBtb2R1bGU6ICdwcm94eScsXG4gICAgICAgIGFjdGlvbjogJ2V0aF9jYWxsJyxcbiAgICAgICAgdG86IGFkZHJlc3MsXG4gICAgICAgIGRhdGE6IHNlcXVlbmNlSWREYXRhLFxuICAgICAgICB0YWc6ICdsYXRlc3QnLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBzZXF1ZW5jZUlkSGV4ID0gcmVzdWx0LnJlc3VsdDtcbiAgICAgIHJldHVybiBuZXcgb3B0aW9uYWxEZXBzLmV0aFV0aWwuQk4oc2VxdWVuY2VJZEhleC5zbGljZSgyKSwgMTYpLnRvTnVtYmVyKCk7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBzaWduVHJhbnNhY3Rpb24gZm9yIHRoZSByYXJlIGNhc2UgdGhhdCBTREsgaXMgZG9pbmcgdGhlIHNlY29uZCBzaWduYXR1cmVcbiAgICogTm90ZTogd2UgYXJlIGV4cGVjdGluZyB0aGlzIHRvIGJlIGNhbGxlZCBmcm9tIHRoZSBvZmZsaW5lIHZhdWx0XG4gICAqIEBwYXJhbSBwYXJhbXMudHhQcmVidWlsZFxuICAgKiBAcGFyYW0gcGFyYW1zLnNpZ25pbmdLZXlOb25jZVxuICAgKiBAcGFyYW0gcGFyYW1zLndhbGxldENvbnRyYWN0QWRkcmVzc1xuICAgKiBAcGFyYW0gcGFyYW1zLnBydlxuICAgKiBAcmV0dXJucyB7e3R4SGV4OiAqfX1cbiAgICovXG4gIHNpZ25GaW5hbChwYXJhbXM6IFNpZ25GaW5hbE9wdGlvbnMpOiBGdWxseVNpZ25lZFRyYW5zYWN0aW9uIHtcbiAgICBjb25zdCB0eFByZWJ1aWxkID0gcGFyYW1zLnR4UHJlYnVpbGQ7XG5cbiAgICBpZiAoIV8uaXNOdW1iZXIocGFyYW1zLnNpZ25pbmdLZXlOb25jZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBoYXZlIHNpZ25pbmdLZXlOb25jZSBhcyBhIHBhcmFtZXRlciwgYW5kIGl0IG11c3QgYmUgYSBudW1iZXInKTtcbiAgICB9XG4gICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLndhbGxldENvbnRyYWN0QWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncGFyYW1zIG11c3QgaW5jbHVkZSB3YWxsZXRDb250cmFjdEFkZHJlc3MsIGJ1dCBnb3QgdW5kZWZpbmVkJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2lnbmluZ05vZGUgPSB1dHhvTGliLkhETm9kZS5mcm9tQmFzZTU4KHBhcmFtcy5wcnYpO1xuICAgIGNvbnN0IHNpZ25pbmdLZXkgPSBzaWduaW5nTm9kZS5nZXRLZXkoKS5nZXRQcml2YXRlS2V5QnVmZmVyKCk7XG5cbiAgICBjb25zdCB0eEluZm8gPSB7XG4gICAgICByZWNpcGllbnQ6IHR4UHJlYnVpbGQucmVjaXBpZW50c1swXSxcbiAgICAgIGV4cGlyZVRpbWU6IHR4UHJlYnVpbGQuaGFsZlNpZ25lZC5leHBpcmVUaW1lLFxuICAgICAgY29udHJhY3RTZXF1ZW5jZUlkOiB0eFByZWJ1aWxkLmhhbGZTaWduZWQuY29udHJhY3RTZXF1ZW5jZUlkLFxuICAgICAgc2lnbmF0dXJlOiB0eFByZWJ1aWxkLmhhbGZTaWduZWQuc2lnbmF0dXJlLFxuICAgIH07XG5cbiAgICBjb25zdCBzZW5kTWV0aG9kQXJncyA9IHRoaXMuZ2V0U2VuZE1ldGhvZEFyZ3ModHhJbmZvKTtcbiAgICBjb25zdCBtZXRob2RTaWduYXR1cmUgPSBvcHRpb25hbERlcHMuZXRoQWJpLm1ldGhvZElEKCdzZW5kTXVsdGlTaWcnLCBfLm1hcChzZW5kTWV0aG9kQXJncywgJ3R5cGUnKSk7XG4gICAgY29uc3QgZW5jb2RlZEFyZ3MgPSBvcHRpb25hbERlcHMuZXRoQWJpLnJhd0VuY29kZShfLm1hcChzZW5kTWV0aG9kQXJncywgJ3R5cGUnKSwgXy5tYXAoc2VuZE1ldGhvZEFyZ3MsICd2YWx1ZScpKTtcbiAgICBjb25zdCBzZW5kRGF0YSA9IEJ1ZmZlci5jb25jYXQoW21ldGhvZFNpZ25hdHVyZSwgZW5jb2RlZEFyZ3NdKTtcblxuICAgIGNvbnN0IGV0aFR4UGFyYW1zID0ge1xuICAgICAgdG86IHBhcmFtcy53YWxsZXRDb250cmFjdEFkZHJlc3MsXG4gICAgICBub25jZTogcGFyYW1zLnNpZ25pbmdLZXlOb25jZSxcbiAgICAgIHZhbHVlOiAwLFxuICAgICAgZ2FzUHJpY2U6IG5ldyBvcHRpb25hbERlcHMuZXRoVXRpbC5CTih0eFByZWJ1aWxkLmdhc1ByaWNlKSxcbiAgICAgIGdhc0xpbWl0OiBuZXcgb3B0aW9uYWxEZXBzLmV0aFV0aWwuQk4odHhQcmVidWlsZC5nYXNMaW1pdCksXG4gICAgICBkYXRhOiBzZW5kRGF0YSxcbiAgICAgIHNwZW5kQW1vdW50OiBwYXJhbXMucmVjaXBpZW50c1swXS5hbW91bnQsXG4gICAgfTtcblxuICAgIGNvbnN0IGV0aFR4ID0gbmV3IG9wdGlvbmFsRGVwcy5FdGhUeChldGhUeFBhcmFtcyk7XG4gICAgZXRoVHguc2lnbihzaWduaW5nS2V5KTtcbiAgICByZXR1cm4geyB0eEhleDogZXRoVHguc2VyaWFsaXplKCkudG9TdHJpbmcoJ2hleCcpIH07XG4gIH1cblxuICAvKipcbiAgICogQXNzZW1ibGUga2V5Y2hhaW4gYW5kIGhhbGYtc2lnbiBwcmVidWlsdCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIC0gdHhQcmVidWlsZFxuICAgKiAtIHBydlxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge0JsdWViaXJkPFNpZ25lZFRyYW5zYWN0aW9uPn1cbiAgICovXG4gIHNpZ25UcmFuc2FjdGlvbihcbiAgICBwYXJhbXM6IFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMsXG4gICAgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8U2lnbmVkVHJhbnNhY3Rpb24+XG4gICk6IEJsdWViaXJkPFNpZ25lZFRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPFNpZ25lZFRyYW5zYWN0aW9uPihmdW5jdGlvbiooKSB7XG4gICAgICBjb25zdCB0eFByZWJ1aWxkID0gcGFyYW1zLnR4UHJlYnVpbGQ7XG4gICAgICBjb25zdCB1c2VyUHJ2ID0gcGFyYW1zLnBydjtcbiAgICAgIGNvbnN0IEVYUElSRVRJTUVfREVGQVVMVCA9IDYwICogNjAgKiAyNCAqIDc7IC8vIFRoaXMgc2lnbmF0dXJlIHdpbGwgYmUgdmFsaWQgZm9yIDEgd2Vla1xuXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZCh0eFByZWJ1aWxkKSB8fCAhXy5pc09iamVjdCh0eFByZWJ1aWxkKSkge1xuICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQodHhQcmVidWlsZCkgJiYgIV8uaXNPYmplY3QodHhQcmVidWlsZCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHR4UHJlYnVpbGQgbXVzdCBiZSBhbiBvYmplY3QsIGdvdCB0eXBlICR7dHlwZW9mIHR4UHJlYnVpbGR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHR4UHJlYnVpbGQgcGFyYW1ldGVyJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHVzZXJQcnYpIHx8ICFfLmlzU3RyaW5nKHVzZXJQcnYpKSB7XG4gICAgICAgIGlmICghXy5pc1VuZGVmaW5lZCh1c2VyUHJ2KSAmJiAhXy5pc1N0cmluZyh1c2VyUHJ2KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcHJ2IG11c3QgYmUgYSBzdHJpbmcsIGdvdCB0eXBlICR7dHlwZW9mIHVzZXJQcnZ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHBydiBwYXJhbWV0ZXIgdG8gc2lnbiB0cmFuc2FjdGlvbicpO1xuICAgICAgfVxuXG4gICAgICBwYXJhbXMucmVjaXBpZW50cyA9IHR4UHJlYnVpbGQucmVjaXBpZW50cyB8fCBwYXJhbXMucmVjaXBpZW50cztcblxuICAgICAgLy8gaWYgbm8gcmVjaXBpZW50cyBpbiBlaXRoZXIgcGFyYW1zIG9yIHR4UHJlYnVpbGQsIHRoZW4gdGhyb3cgYW4gZXJyb3JcbiAgICAgIGlmICghcGFyYW1zLnJlY2lwaWVudHMgfHwgIUFycmF5LmlzQXJyYXkocGFyYW1zLnJlY2lwaWVudHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjaXBpZW50cyBtaXNzaW5nIG9yIG5vdCBhcnJheScpO1xuICAgICAgfVxuXG4gICAgICAvLyBOb3JtYWxseSB0aGUgU0RLIHByb3ZpZGVzIHRoZSBmaXJzdCBzaWduYXR1cmUgZm9yIGFuIEVUSCB0eCwgYnV0IG9jY2FzaW9uYWxseSBpdCBwcm92aWRlcyB0aGUgc2Vjb25kIGFuZCBmaW5hbCBvbmUuXG4gICAgICBpZiAocGFyYW1zLmlzTGFzdFNpZ25hdHVyZSkge1xuICAgICAgICAvLyBJbiB0aGlzIGNhc2Ugd2hlbiB3ZSdyZSBkb2luZyB0aGUgc2Vjb25kIChmaW5hbCkgc2lnbmF0dXJlLCB0aGUgbG9naWMgaXMgZGlmZmVyZW50LlxuICAgICAgICByZXR1cm4gc2VsZi5zaWduRmluYWwocGFyYW1zKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2Vjb25kc1NpbmNlRXBvY2ggPSBNYXRoLmZsb29yKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCk7XG4gICAgICBjb25zdCBleHBpcmVUaW1lID0gcGFyYW1zLmV4cGlyZVRpbWUgfHwgc2Vjb25kc1NpbmNlRXBvY2ggKyBFWFBJUkVUSU1FX0RFRkFVTFQ7XG4gICAgICBjb25zdCBzZXF1ZW5jZUlkID0gdHhQcmVidWlsZC5uZXh0Q29udHJhY3RTZXF1ZW5jZUlkO1xuXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChzZXF1ZW5jZUlkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zYWN0aW9uIHByZWJ1aWxkIG1pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgbmV4dENvbnRyYWN0U2VxdWVuY2VJZCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvcGVyYXRpb25IYXNoID0gc2VsZi5nZXRPcGVyYXRpb25TaGEzRm9yRXhlY3V0ZUFuZENvbmZpcm0ocGFyYW1zLnJlY2lwaWVudHMsIGV4cGlyZVRpbWUsIHNlcXVlbmNlSWQpO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gVXRpbC5ldGhTaWduTXNnSGFzaChvcGVyYXRpb25IYXNoLCBVdGlsLnhwcnZUb0V0aFByaXZhdGVLZXkodXNlclBydikpO1xuXG4gICAgICBjb25zdCB0eFBhcmFtcyA9IHtcbiAgICAgICAgcmVjaXBpZW50czogcGFyYW1zLnJlY2lwaWVudHMsXG4gICAgICAgIGV4cGlyZVRpbWU6IGV4cGlyZVRpbWUsXG4gICAgICAgIGNvbnRyYWN0U2VxdWVuY2VJZDogc2VxdWVuY2VJZCxcbiAgICAgICAgc2VxdWVuY2VJZDogcGFyYW1zLnNlcXVlbmNlSWQsXG4gICAgICAgIG9wZXJhdGlvbkhhc2g6IG9wZXJhdGlvbkhhc2gsXG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlLFxuICAgICAgICBnYXNMaW1pdDogcGFyYW1zLmdhc0xpbWl0LFxuICAgICAgICBnYXNQcmljZTogcGFyYW1zLmdhc1ByaWNlLFxuICAgICAgICBob3BUcmFuc2FjdGlvbjogdHhQcmVidWlsZC5ob3BUcmFuc2FjdGlvbixcbiAgICAgIH07XG4gICAgICByZXR1cm4geyBoYWxmU2lnbmVkOiB0eFBhcmFtcyB9O1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuc3VyZSBlaXRoZXIgZW50ZXJwcmlzZSBvciBuZXdGZWVBZGRyZXNzIGlzIHBhc3NlZCwgdG8ga25vdyB3aGV0aGVyIHRvIGNyZWF0ZSBuZXcga2V5IG9yIHVzZSBlbnRlcnByaXNlIGtleVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMuZW50ZXJwcmlzZSB7U3RyaW5nfSB0aGUgZW50ZXJwcmlzZSBpZCB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIGtleVxuICAgKiBAcGFyYW0gcGFyYW1zLm5ld0ZlZUFkZHJlc3Mge0Jvb2xlYW59IGNyZWF0ZSBhIG5ldyBmZWUgYWRkcmVzcyAoZW50ZXJwcmlzZSBub3QgbmVlZGVkIGluIHRoaXMgY2FzZSlcbiAgICovXG4gIHByZUNyZWF0ZUJpdEdvKHBhcmFtczogUHJlY3JlYXRlQml0R29PcHRpb25zKTogdm9pZCB7XG4gICAgLy8gV2UgYWx3YXlzIG5lZWQgcGFyYW1zIG9iamVjdCwgc2luY2UgZWl0aGVyIGVudGVycHJpc2Ugb3IgbmV3RmVlQWRkcmVzcyBpcyByZXF1aXJlZFxuICAgIGlmICghXy5pc09iamVjdChwYXJhbXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHByZUNyZWF0ZUJpdEdvIG11c3QgYmUgcGFzc2VkIGEgcGFyYW1zIG9iamVjdC4gR290ICR7cGFyYW1zfSAodHlwZSAke3R5cGVvZiBwYXJhbXN9KWApO1xuICAgIH1cblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5lbnRlcnByaXNlKSAmJiBfLmlzVW5kZWZpbmVkKHBhcmFtcy5uZXdGZWVBZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnZXhwZWN0aW5nIGVudGVycHJpc2Ugd2hlbiBhZGRpbmcgQml0R28ga2V5LiBJZiB5b3Ugd2FudCB0byBjcmVhdGUgYSBuZXcgRVRIIGJpdGdvIGtleSwgc2V0IHRoZSBuZXdGZWVBZGRyZXNzIHBhcmFtZXRlciB0byB0cnVlLidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgd2hldGhlciBrZXkgc2hvdWxkIGJlIGFuIGVudGVycHJpc2Uga2V5IG9yIGEgQml0R28ga2V5IGZvciBhIG5ldyBmZWUgYWRkcmVzc1xuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuZW50ZXJwcmlzZSkgJiYgIV8uaXNVbmRlZmluZWQocGFyYW1zLm5ld0ZlZUFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEluY29tcGF0aWJsZSBhcmd1bWVudHMgLSBjYW5ub3QgcGFzcyBib3RoIGVudGVycHJpc2UgYW5kIG5ld0ZlZUFkZHJlc3MgcGFyYW1ldGVyLmApO1xuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuZW50ZXJwcmlzZSkgJiYgIV8uaXNTdHJpbmcocGFyYW1zLmVudGVycHJpc2UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGVudGVycHJpc2Ugc2hvdWxkIGJlIGEgc3RyaW5nIC0gZ290ICR7cGFyYW1zLmVudGVycHJpc2V9ICh0eXBlICR7dHlwZW9mIHBhcmFtcy5lbnRlcnByaXNlfSlgKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLm5ld0ZlZUFkZHJlc3MpICYmICFfLmlzQm9vbGVhbihwYXJhbXMubmV3RmVlQWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYG5ld0ZlZUFkZHJlc3Mgc2hvdWxkIGJlIGEgYm9vbGVhbiAtIGdvdCAke3BhcmFtcy5uZXdGZWVBZGRyZXNzfSAodHlwZSAke3R5cGVvZiBwYXJhbXMubmV3RmVlQWRkcmVzc30pYFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUXVlcmllcyBwdWJsaWMgYmxvY2sgZXhwbG9yZXIgdG8gZ2V0IHRoZSBuZXh0IEVUSCBub25jZSB0aGF0IHNob3VsZCBiZSB1c2VkIGZvciB0aGUgZ2l2ZW4gRVRIIGFkZHJlc3NcbiAgICogQHBhcmFtIGFkZHJlc3NcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgZ2V0QWRkcmVzc05vbmNlKGFkZHJlc3M6IHN0cmluZywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8bnVtYmVyPik6IEJsdWViaXJkPG51bWJlcj4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxudW1iZXI+KGZ1bmN0aW9uKigpIHtcbiAgICAgIC8vIEdldCBub25jZSBmb3IgYmFja3VwIGtleSAoc2hvdWxkIGJlIDApXG4gICAgICBsZXQgbm9uY2UgPSAwO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBzZWxmLnJlY292ZXJ5QmxvY2tjaGFpbkV4cGxvcmVyUXVlcnkoe1xuICAgICAgICBtb2R1bGU6ICdhY2NvdW50JyxcbiAgICAgICAgYWN0aW9uOiAndHhsaXN0JyxcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgYmFja3VwS2V5VHhMaXN0ID0gcmVzdWx0LnJlc3VsdDtcbiAgICAgIGlmIChiYWNrdXBLZXlUeExpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBDYWxjdWxhdGUgbGFzdCBub25jZSB1c2VkXG4gICAgICAgIGNvbnN0IG91dGdvaW5nVHhzID0gYmFja3VwS2V5VHhMaXN0LmZpbHRlcih0eCA9PiB0eC5mcm9tID09PSBhZGRyZXNzKTtcbiAgICAgICAgbm9uY2UgPSBvdXRnb2luZ1R4cy5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9uY2U7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIGZvciByZWNvdmVyKClcbiAgICogVGhpcyB0cmFuc2Zvcm1zIHRoZSB1bnNpZ25lZCB0cmFuc2FjdGlvbiBpbmZvcm1hdGlvbiBpbnRvIGEgZm9ybWF0IHRoZSBCaXRHbyBvZmZsaW5lIHZhdWx0IGV4cGVjdHNcbiAgICogQHBhcmFtIHR4SW5mb1xuICAgKiBAcGFyYW0gZXRoVHhcbiAgICogQHBhcmFtIHVzZXJLZXlcbiAgICogQHBhcmFtIGJhY2t1cEtleVxuICAgKiBAcGFyYW0gZ2FzUHJpY2VcbiAgICogQHBhcmFtIGdhc0xpbWl0XG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7e3R4OiAqLCB1c2VyS2V5OiAqLCBiYWNrdXBLZXk6ICosIGNvaW46IHN0cmluZywgYW1vdW50OiBzdHJpbmcsIGdhc1ByaWNlOiBzdHJpbmcsIGdhc0xpbWl0OiBzdHJpbmcsIHJlY2lwaWVudHM6ICh7YWRkcmVzcywgYW1vdW50fXx7YWRkcmVzczogKHthZGRyZXNzLCBhbW91bnR9fHN0cmluZyksIGFtb3VudDogc3RyaW5nfXxzdHJpbmcpW119fVxuICAgKi9cbiAgZm9ybWF0Rm9yT2ZmbGluZVZhdWx0KFxuICAgIHR4SW5mbzogVW5mb3JtYXR0ZWRUeEluZm8sXG4gICAgZXRoVHg6IGFueSxcbiAgICB1c2VyS2V5OiBzdHJpbmcsXG4gICAgYmFja3VwS2V5OiBzdHJpbmcsXG4gICAgZ2FzUHJpY2U6IEJ1ZmZlcixcbiAgICBnYXNMaW1pdDogbnVtYmVyLFxuICAgIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPE9mZmxpbmVWYXVsdFR4SW5mbz5cbiAgKTogQmx1ZWJpcmQ8T2ZmbGluZVZhdWx0VHhJbmZvPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPE9mZmxpbmVWYXVsdFR4SW5mbz4oZnVuY3Rpb24qKCkge1xuICAgICAgY29uc3QgYmFja3VwSEROb2RlID0gdXR4b0xpYi5IRE5vZGUuZnJvbUJhc2U1OChiYWNrdXBLZXkpO1xuICAgICAgY29uc3QgYmFja3VwU2lnbmluZ0tleSA9IGJhY2t1cEhETm9kZS5nZXRLZXkoKS5nZXRQdWJsaWNLZXlCdWZmZXIoKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlOiBPZmZsaW5lVmF1bHRUeEluZm8gPSB7XG4gICAgICAgIHR4OiBldGhUeC5zZXJpYWxpemUoKS50b1N0cmluZygnaGV4JyksXG4gICAgICAgIHVzZXJLZXksXG4gICAgICAgIGJhY2t1cEtleSxcbiAgICAgICAgY29pbjogc2VsZi5nZXRDaGFpbigpLFxuICAgICAgICBnYXNQcmljZTogb3B0aW9uYWxEZXBzLmV0aFV0aWwuYnVmZmVyVG9JbnQoZ2FzUHJpY2UpLnRvRml4ZWQoKSxcbiAgICAgICAgZ2FzTGltaXQsXG4gICAgICAgIHJlY2lwaWVudHM6IFt0eEluZm8ucmVjaXBpZW50XSxcbiAgICAgICAgd2FsbGV0Q29udHJhY3RBZGRyZXNzOiAnMHgnICsgZXRoVHgudG8udG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICBhbW91bnQ6IHR4SW5mby5yZWNpcGllbnQuYW1vdW50LFxuICAgICAgICBiYWNrdXBLZXlOb25jZTogeWllbGQgc2VsZi5nZXRBZGRyZXNzTm9uY2UoXG4gICAgICAgICAgYDB4JHtvcHRpb25hbERlcHMuZXRoVXRpbC5wdWJsaWNUb0FkZHJlc3MoYmFja3VwU2lnbmluZ0tleSwgdHJ1ZSkudG9TdHJpbmcoJ2hleCcpfWBcbiAgICAgICAgKSxcbiAgICAgIH07XG4gICAgICBfLmV4dGVuZChyZXNwb25zZSwgdHhJbmZvKTtcbiAgICAgIHJlc3BvbnNlLm5leHRDb250cmFjdFNlcXVlbmNlSWQgPSByZXNwb25zZS5jb250cmFjdFNlcXVlbmNlSWQ7XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGEgZnVuZHMgcmVjb3ZlcnkgdHJhbnNhY3Rpb24gd2l0aG91dCBCaXRHb1xuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMudXNlcktleSB7U3RyaW5nfSBbZW5jcnlwdGVkXSB4cHJ2XG4gICAqIEBwYXJhbSBwYXJhbXMuYmFja3VwS2V5IHtTdHJpbmd9IFtlbmNyeXB0ZWRdIHhwcnYgb3IgeHB1YiBpZiB0aGUgeHBydiBpcyBoZWxkIGJ5IGEgS1JTIHByb3ZpZGVyXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSB7U3RyaW5nfSB1c2VkIHRvIGRlY3J5cHQgdXNlcktleSBhbmQgYmFja3VwS2V5XG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0Q29udHJhY3RBZGRyZXNzIHtTdHJpbmd9IHRoZSBFVEggYWRkcmVzcyBvZiB0aGUgd2FsbGV0IGNvbnRyYWN0XG4gICAqIEBwYXJhbSBwYXJhbXMua3JzUHJvdmlkZXIge1N0cmluZ30gbmVjZXNzYXJ5IGlmIGJhY2t1cCBrZXkgaXMgaGVsZCBieSBLUlNcbiAgICogQHBhcmFtIHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uIHtTdHJpbmd9IHRhcmdldCBhZGRyZXNzIHRvIHNlbmQgcmVjb3ZlcmVkIGZ1bmRzIHRvXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgcmVjb3ZlcihcbiAgICBwYXJhbXM6IFJlY292ZXJPcHRpb25zLFxuICAgIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFJlY292ZXJ5SW5mbyB8IE9mZmxpbmVWYXVsdFR4SW5mbz5cbiAgKTogQmx1ZWJpcmQ8UmVjb3ZlcnlJbmZvIHwgT2ZmbGluZVZhdWx0VHhJbmZvPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPFJlY292ZXJ5SW5mbyB8IE9mZmxpbmVWYXVsdFR4SW5mbz4oZnVuY3Rpb24qIHJlY292ZXIoKSB7XG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMudXNlcktleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHVzZXJLZXknKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLmJhY2t1cEtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGJhY2t1cEtleScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMud2FsbGV0UGFzc3BocmFzZSkgJiYgIXBhcmFtcy51c2VyS2V5LnN0YXJ0c1dpdGgoJ3hwdWInKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3Npbmcgd2FsbGV0IHBhc3NwaHJhc2UnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLndhbGxldENvbnRyYWN0QWRkcmVzcykgfHwgIXNlbGYuaXNWYWxpZEFkZHJlc3MocGFyYW1zLndhbGxldENvbnRyYWN0QWRkcmVzcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHdhbGxldENvbnRyYWN0QWRkcmVzcycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbikgfHwgIXNlbGYuaXNWYWxpZEFkZHJlc3MocGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCByZWNvdmVyeURlc3RpbmF0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzS3JzUmVjb3ZlcnkgPSBwYXJhbXMuYmFja3VwS2V5LnN0YXJ0c1dpdGgoJ3hwdWInKSAmJiAhcGFyYW1zLnVzZXJLZXkuc3RhcnRzV2l0aCgneHB1YicpO1xuICAgICAgY29uc3QgaXNVbnNpZ25lZFN3ZWVwID0gcGFyYW1zLmJhY2t1cEtleS5zdGFydHNXaXRoKCd4cHViJykgJiYgcGFyYW1zLnVzZXJLZXkuc3RhcnRzV2l0aCgneHB1YicpO1xuXG4gICAgICBpZiAoaXNLcnNSZWNvdmVyeSAmJiBwYXJhbXMua3JzUHJvdmlkZXIgJiYgXy5pc1VuZGVmaW5lZChjb25maWcua3JzUHJvdmlkZXJzW3BhcmFtcy5rcnNQcm92aWRlcl0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBrZXkgcmVjb3Zlcnkgc2VydmljZSBwcm92aWRlcicpO1xuICAgICAgfVxuXG4gICAgICAvLyBDbGVhbiB1cCB3aGl0ZXNwYWNlIGZyb20gZW50ZXJlZCB2YWx1ZXNcbiAgICAgIGxldCB1c2VyS2V5ID0gcGFyYW1zLnVzZXJLZXkucmVwbGFjZSgvXFxzL2csICcnKTtcbiAgICAgIGNvbnN0IGJhY2t1cEtleSA9IHBhcmFtcy5iYWNrdXBLZXkucmVwbGFjZSgvXFxzL2csICcnKTtcblxuICAgICAgLy8gU2V0IG5ldyBldGggdHggZmVlcyAodXNpbmcgZGVmYXVsdCBjb25maWcgdmFsdWVzIGZyb20gcGxhdGZvcm0pXG4gICAgICBjb25zdCBnYXNQcmljZSA9IHNlbGYuZ2V0UmVjb3ZlcnlHYXNQcmljZSgpO1xuICAgICAgY29uc3QgZ2FzTGltaXQgPSBzZWxmLmdldFJlY292ZXJ5R2FzTGltaXQoKTtcblxuICAgICAgLy8gRGVjcnlwdCBwcml2YXRlIGtleXMgZnJvbSBLZXlDYXJkIHZhbHVlcyBpZiBuZWNlc3NhcnlcbiAgICAgIGlmICghdXNlcktleS5zdGFydHNXaXRoKCd4cHViJykgJiYgIXVzZXJLZXkuc3RhcnRzV2l0aCgneHBydicpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdXNlcktleSA9IHNlbGYuYml0Z28uZGVjcnlwdCh7XG4gICAgICAgICAgICBpbnB1dDogdXNlcktleSxcbiAgICAgICAgICAgIHBhc3N3b3JkOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZGVjcnlwdGluZyB1c2VyIGtleWNoYWluOiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgYmFja3VwS2V5QWRkcmVzcztcbiAgICAgIGxldCBiYWNrdXBTaWduaW5nS2V5O1xuXG4gICAgICBpZiAoaXNLcnNSZWNvdmVyeSB8fCBpc1Vuc2lnbmVkU3dlZXApIHtcbiAgICAgICAgY29uc3QgYmFja3VwSEROb2RlID0gdXR4b0xpYi5IRE5vZGUuZnJvbUJhc2U1OChiYWNrdXBLZXkpO1xuICAgICAgICBiYWNrdXBTaWduaW5nS2V5ID0gYmFja3VwSEROb2RlLmdldEtleSgpLmdldFB1YmxpY0tleUJ1ZmZlcigpO1xuICAgICAgICBiYWNrdXBLZXlBZGRyZXNzID0gYDB4JHtvcHRpb25hbERlcHMuZXRoVXRpbC5wdWJsaWNUb0FkZHJlc3MoYmFja3VwU2lnbmluZ0tleSwgdHJ1ZSkudG9TdHJpbmcoJ2hleCcpfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEZWNyeXB0IGJhY2t1cCBwcml2YXRlIGtleSBhbmQgZ2V0IGFkZHJlc3NcbiAgICAgICAgbGV0IGJhY2t1cFBydjtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGJhY2t1cFBydiA9IHNlbGYuYml0Z28uZGVjcnlwdCh7XG4gICAgICAgICAgICBpbnB1dDogYmFja3VwS2V5LFxuICAgICAgICAgICAgcGFzc3dvcmQ6IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBkZWNyeXB0aW5nIGJhY2t1cCBrZXljaGFpbjogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBiYWNrdXBIRE5vZGUgPSB1dHhvTGliLkhETm9kZS5mcm9tQmFzZTU4KGJhY2t1cFBydik7XG4gICAgICAgIGJhY2t1cFNpZ25pbmdLZXkgPSBiYWNrdXBIRE5vZGUuZ2V0S2V5KCkuZ2V0UHJpdmF0ZUtleUJ1ZmZlcigpO1xuICAgICAgICBiYWNrdXBLZXlBZGRyZXNzID0gYDB4JHtvcHRpb25hbERlcHMuZXRoVXRpbC5wcml2YXRlVG9BZGRyZXNzKGJhY2t1cFNpZ25pbmdLZXkpLnRvU3RyaW5nKCdoZXgnKX1gO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBiYWNrdXBLZXlOb25jZSA9IHlpZWxkIHNlbGYuZ2V0QWRkcmVzc05vbmNlKGJhY2t1cEtleUFkZHJlc3MpO1xuXG4gICAgICAvLyBnZXQgYmFsYW5jZSBvZiBiYWNrdXBLZXkgdG8gZW5zdXJlIGZ1bmRzIGFyZSBhdmFpbGFibGUgdG8gcGF5IGZlZXNcbiAgICAgIGNvbnN0IGJhY2t1cEtleUJhbGFuY2UgPSB5aWVsZCBzZWxmLnF1ZXJ5QWRkcmVzc0JhbGFuY2UoYmFja3VwS2V5QWRkcmVzcyk7XG5cbiAgICAgIGlmIChiYWNrdXBLZXlCYWxhbmNlLmx0KGdhc1ByaWNlLm11bChnYXNMaW1pdCkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQmFja3VwIGtleSBhZGRyZXNzICR7YmFja3VwS2V5QWRkcmVzc30gaGFzIGJhbGFuY2UgJHtiYWNrdXBLZXlCYWxhbmNlLnRvU3RyaW5nKFxuICAgICAgICAgICAgMTBcbiAgICAgICAgICApfS4gVGhpcyBhZGRyZXNzIG11c3QgaGF2ZSBhIGJhbGFuY2Ugb2YgYXQgbGVhc3QgMC4wMSBFVEggdG8gcGVyZm9ybSByZWNvdmVyaWVzLiBUcnkgc2VuZGluZyBzb21lIEVUSCB0byB0aGlzIGFkZHJlc3MgdGhlbiByZXRyeS5gXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGdldCBiYWxhbmNlIG9mIHdhbGxldCBhbmQgZGVkdWN0IGZlZXMgdG8gZ2V0IHRyYW5zYWN0aW9uIGFtb3VudFxuICAgICAgY29uc3QgdHhBbW91bnQgPSB5aWVsZCBzZWxmLnF1ZXJ5QWRkcmVzc0JhbGFuY2UocGFyYW1zLndhbGxldENvbnRyYWN0QWRkcmVzcyk7XG5cbiAgICAgIC8vIGJ1aWxkIHJlY2lwaWVudHMgb2JqZWN0XG4gICAgICBjb25zdCByZWNpcGllbnRzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgYWRkcmVzczogcGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24sXG4gICAgICAgICAgYW1vdW50OiB0eEFtb3VudC50b1N0cmluZygxMCksXG4gICAgICAgIH0sXG4gICAgICBdO1xuXG4gICAgICAvLyBHZXQgc2VxdWVuY2UgSUQgdXNpbmcgY29udHJhY3QgY2FsbFxuICAgICAgY29uc3Qgc2VxdWVuY2VJZCA9IHlpZWxkIHNlbGYucXVlcnlTZXF1ZW5jZUlkKHBhcmFtcy53YWxsZXRDb250cmFjdEFkZHJlc3MpO1xuXG4gICAgICBsZXQgb3BlcmF0aW9uSGFzaCwgc2lnbmF0dXJlO1xuICAgICAgLy8gR2V0IG9wZXJhdGlvbiBoYXNoIGFuZCBzaWduIGl0XG4gICAgICBpZiAoIWlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgICBvcGVyYXRpb25IYXNoID0gc2VsZi5nZXRPcGVyYXRpb25TaGEzRm9yRXhlY3V0ZUFuZENvbmZpcm0ocmVjaXBpZW50cywgc2VsZi5nZXREZWZhdWx0RXhwaXJlVGltZSgpLCBzZXF1ZW5jZUlkKTtcbiAgICAgICAgc2lnbmF0dXJlID0gVXRpbC5ldGhTaWduTXNnSGFzaChvcGVyYXRpb25IYXNoLCBVdGlsLnhwcnZUb0V0aFByaXZhdGVLZXkodXNlcktleSkpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgVXRpbC5lY1JlY292ZXJFdGhBZGRyZXNzKG9wZXJhdGlvbkhhc2gsIHNpZ25hdHVyZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdHhJbmZvID0ge1xuICAgICAgICByZWNpcGllbnQ6IHJlY2lwaWVudHNbMF0sXG4gICAgICAgIGV4cGlyZVRpbWU6IHNlbGYuZ2V0RGVmYXVsdEV4cGlyZVRpbWUoKSxcbiAgICAgICAgY29udHJhY3RTZXF1ZW5jZUlkOiBzZXF1ZW5jZUlkLFxuICAgICAgICBvcGVyYXRpb25IYXNoOiBvcGVyYXRpb25IYXNoLFxuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSxcbiAgICAgICAgZ2FzTGltaXQ6IGdhc0xpbWl0LnRvU3RyaW5nKDEwKSxcbiAgICAgIH07XG5cbiAgICAgIC8vIGNhbGN1bGF0ZSBzZW5kIGRhdGFcbiAgICAgIGNvbnN0IHNlbmRNZXRob2RBcmdzID0gc2VsZi5nZXRTZW5kTWV0aG9kQXJncyh0eEluZm8pO1xuICAgICAgY29uc3QgbWV0aG9kU2lnbmF0dXJlID0gb3B0aW9uYWxEZXBzLmV0aEFiaS5tZXRob2RJRCgnc2VuZE11bHRpU2lnJywgXy5tYXAoc2VuZE1ldGhvZEFyZ3MsICd0eXBlJykpO1xuICAgICAgY29uc3QgZW5jb2RlZEFyZ3MgPSBvcHRpb25hbERlcHMuZXRoQWJpLnJhd0VuY29kZShfLm1hcChzZW5kTWV0aG9kQXJncywgJ3R5cGUnKSwgXy5tYXAoc2VuZE1ldGhvZEFyZ3MsICd2YWx1ZScpKTtcbiAgICAgIGNvbnN0IHNlbmREYXRhID0gQnVmZmVyLmNvbmNhdChbbWV0aG9kU2lnbmF0dXJlLCBlbmNvZGVkQXJnc10pO1xuXG4gICAgICAvLyBCdWlsZCBjb250cmFjdCBjYWxsIGFuZCBzaWduIGl0XG4gICAgICBjb25zdCB0eCA9IG5ldyBvcHRpb25hbERlcHMuRXRoVHgoe1xuICAgICAgICB0bzogcGFyYW1zLndhbGxldENvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgbm9uY2U6IGJhY2t1cEtleU5vbmNlLFxuICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgZ2FzUHJpY2U6IGdhc1ByaWNlLFxuICAgICAgICBnYXNMaW1pdDogZ2FzTGltaXQsXG4gICAgICAgIGRhdGE6IHNlbmREYXRhLFxuICAgICAgICBzcGVuZEFtb3VudDogdHhBbW91bnQsXG4gICAgICB9KTtcblxuICAgICAgaWYgKGlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgICByZXR1cm4gc2VsZi5mb3JtYXRGb3JPZmZsaW5lVmF1bHQodHhJbmZvLCB0eCwgdXNlcktleSwgYmFja3VwS2V5LCBnYXNQcmljZSwgZ2FzTGltaXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzS3JzUmVjb3ZlcnkpIHtcbiAgICAgICAgdHguc2lnbihiYWNrdXBTaWduaW5nS2V5KTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2lnbmVkVHg6IFJlY292ZXJ5SW5mbyA9IHtcbiAgICAgICAgaWQ6IG9wdGlvbmFsRGVwcy5ldGhVdGlsLmJ1ZmZlclRvSGV4KHR4Lmhhc2godHJ1ZSkpLFxuICAgICAgICB0eDogdHguc2VyaWFsaXplKCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgfTtcblxuICAgICAgaWYgKGlzS3JzUmVjb3ZlcnkpIHtcbiAgICAgICAgc2lnbmVkVHguYmFja3VwS2V5ID0gYmFja3VwS2V5O1xuICAgICAgICBzaWduZWRUeC5jb2luID0gc2VsZi5nZXRDaGFpbigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2lnbmVkVHg7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogUmVjb3ZlciBhbiB1bnN1cHBvcnRlZCB0b2tlbiBmcm9tIGEgQml0R28gbXVsdGlzaWcgd2FsbGV0XG4gICAqIFRoaXMgYnVpbGRzIGEgaGFsZi1zaWduZWQgdHJhbnNhY3Rpb24sIGZvciB3aGljaCB0aGVyZSB3aWxsIGJlIGFuIGFkbWluIHJvdXRlIHRvIGNvLXNpZ24gYW5kIGJyb2FkY2FzdC4gT3B0aW9uYWxseVxuICAgKiB0aGUgdXNlciBjYW4gc2V0IHBhcmFtcy5icm9hZGNhc3QgPSB0cnVlIGFuZCB0aGUgaGFsZi1zaWduZWQgdHggd2lsbCBiZSBzZW50IHRvIEJpdEdvIGZvciBjb3NpZ25pbmcgYW5kIGJyb2FkY2FzdGluZ1xuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0IHRoZSB3YWxsZXQgdG8gcmVjb3ZlciB0aGUgdG9rZW4gZnJvbVxuICAgKiBAcGFyYW0gcGFyYW1zLnRva2VuQ29udHJhY3RBZGRyZXNzIHRoZSBjb250cmFjdCBhZGRyZXNzIG9mIHRoZSB1bnN1cHBvcnRlZCB0b2tlblxuICAgKiBAcGFyYW0gcGFyYW1zLnJlY2lwaWVudCB0aGUgZGVzdGluYXRpb24gYWRkcmVzcyByZWNvdmVyZWQgdG9rZW5zIHNob3VsZCBiZSBzZW50IHRvXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSB0aGUgd2FsbGV0IHBhc3NwaHJhc2VcbiAgICogQHBhcmFtIHBhcmFtcy5wcnYgdGhlIHhwcnZcbiAgICogQHBhcmFtIHBhcmFtcy5icm9hZGNhc3QgaWYgdHJ1ZSwgd2Ugd2lsbCBhdXRvbWF0aWNhbGx5IHN1Ym1pdCB0aGUgaGFsZi1zaWduZWQgdHggdG8gQml0R28gZm9yIGNvc2lnbmluZyBhbmQgYnJvYWRjYXN0aW5nXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgcmVjb3ZlclRva2VuKFxuICAgIHBhcmFtczogUmVjb3ZlclRva2VuT3B0aW9ucyxcbiAgICBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxSZWNvdmVyVG9rZW5UcmFuc2FjdGlvbj5cbiAgKTogQmx1ZWJpcmQ8UmVjb3ZlclRva2VuVHJhbnNhY3Rpb24+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288UmVjb3ZlclRva2VuVHJhbnNhY3Rpb24+KGZ1bmN0aW9uKigpIHtcbiAgICAgIGlmICghXy5pc09iamVjdChwYXJhbXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcmVjb3ZlclRva2VuIG11c3QgYmUgcGFzc2VkIGEgcGFyYW1zIG9iamVjdC4gR290ICR7cGFyYW1zfSAodHlwZSAke3R5cGVvZiBwYXJhbXN9KWApO1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMudG9rZW5Db250cmFjdEFkZHJlc3MpIHx8ICFfLmlzU3RyaW5nKHBhcmFtcy50b2tlbkNvbnRyYWN0QWRkcmVzcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGB0b2tlbkNvbnRyYWN0QWRkcmVzcyBtdXN0IGJlIGEgc3RyaW5nLCBnb3QgJHtcbiAgICAgICAgICAgIHBhcmFtcy50b2tlbkNvbnRyYWN0QWRkcmVzc1xuICAgICAgICAgIH0gKHR5cGUgJHt0eXBlb2YgcGFyYW1zLnRva2VuQ29udHJhY3RBZGRyZXNzfSlgXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICghc2VsZi5pc1ZhbGlkQWRkcmVzcyhwYXJhbXMudG9rZW5Db250cmFjdEFkZHJlc3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndG9rZW5Db250cmFjdEFkZHJlc3Mgbm90IGEgdmFsaWQgYWRkcmVzcycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMud2FsbGV0KSB8fCAhKHBhcmFtcy53YWxsZXQgaW5zdGFuY2VvZiBXYWxsZXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgd2FsbGV0IG11c3QgYmUgYSB3YWxsZXQgaW5zdGFuY2UsIGdvdCAke3BhcmFtcy53YWxsZXR9ICh0eXBlICR7dHlwZW9mIHBhcmFtcy53YWxsZXR9KWApO1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMucmVjaXBpZW50KSB8fCAhXy5pc1N0cmluZyhwYXJhbXMucmVjaXBpZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHJlY2lwaWVudCBtdXN0IGJlIGEgc3RyaW5nLCBnb3QgJHtwYXJhbXMucmVjaXBpZW50fSAodHlwZSAke3R5cGVvZiBwYXJhbXMucmVjaXBpZW50fSlgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzZWxmLmlzVmFsaWRBZGRyZXNzKHBhcmFtcy5yZWNpcGllbnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjaXBpZW50IG5vdCBhIHZhbGlkIGFkZHJlc3MnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFvcHRpb25hbERlcHMuZXRoVXRpbC5idWZmZXJUb0hleCB8fCAhb3B0aW9uYWxEZXBzLmV0aEFiaS5zb2xpZGl0eVNIQTMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdldGhlcmV1bSBub3QgZnVsbHkgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQnKTtcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IHRva2VuIGJhbGFuY2UgZnJvbSBleHRlcm5hbCBBUElcbiAgICAgIGNvbnN0IGNvaW5TcGVjaWZpYyA9IHBhcmFtcy53YWxsZXQuY29pblNwZWNpZmljKCk7XG4gICAgICBpZiAoIWNvaW5TcGVjaWZpYyB8fCAhXy5pc1N0cmluZyhjb2luU3BlY2lmaWMuYmFzZUFkZHJlc3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBjb2luIHNwZWNpZmljIHByb3BlcnR5IGJhc2VBZGRyZXNzJyk7XG4gICAgICB9XG4gICAgICBjb25zdCByZWNvdmVyeUFtb3VudCA9IHlpZWxkIHNlbGYucXVlcnlBZGRyZXNzVG9rZW5CYWxhbmNlKHBhcmFtcy50b2tlbkNvbnRyYWN0QWRkcmVzcywgY29pblNwZWNpZmljLmJhc2VBZGRyZXNzKTtcblxuICAgICAgaWYgKHBhcmFtcy5icm9hZGNhc3QpIHtcbiAgICAgICAgLy8gV2UncmUgZ29pbmcgdG8gY3JlYXRlIGEgbm9ybWFsIEVUSCB0cmFuc2FjdGlvbiB0aGF0IHNlbmRzIGFuIGFtb3VudCBvZiAwIEVUSCB0byB0aGVcbiAgICAgICAgLy8gdG9rZW5Db250cmFjdEFkZHJlc3MgYW5kIGVuY29kZSB0aGUgdW5zdXBwb3J0ZWQtdG9rZW4tc2VuZCBkYXRhIGluIHRoZSBkYXRhIGZpZWxkXG4gICAgICAgIC8vICN0cmlja3N5XG4gICAgICAgIGNvbnN0IHNlbmRNZXRob2RBcmdzID0gW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdfdG8nLFxuICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgdmFsdWU6IHBhcmFtcy5yZWNpcGllbnQsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnX3ZhbHVlJyxcbiAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgIHZhbHVlOiByZWNvdmVyeUFtb3VudC50b1N0cmluZygxMCksXG4gICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgbWV0aG9kU2lnbmF0dXJlID0gb3B0aW9uYWxEZXBzLmV0aEFiaS5tZXRob2RJRCgndHJhbnNmZXInLCBfLm1hcChzZW5kTWV0aG9kQXJncywgJ3R5cGUnKSk7XG4gICAgICAgIGNvbnN0IGVuY29kZWRBcmdzID0gb3B0aW9uYWxEZXBzLmV0aEFiaS5yYXdFbmNvZGUoXG4gICAgICAgICAgXy5tYXAoc2VuZE1ldGhvZEFyZ3MsICd0eXBlJyksXG4gICAgICAgICAgXy5tYXAoc2VuZE1ldGhvZEFyZ3MsICd2YWx1ZScpXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHNlbmREYXRhID0gQnVmZmVyLmNvbmNhdChbbWV0aG9kU2lnbmF0dXJlLCBlbmNvZGVkQXJnc10pO1xuXG4gICAgICAgIGNvbnN0IGJyb2FkY2FzdFBhcmFtczogYW55ID0ge1xuICAgICAgICAgIGFkZHJlc3M6IHBhcmFtcy50b2tlbkNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICBhbW91bnQ6ICcwJyxcbiAgICAgICAgICBkYXRhOiBzZW5kRGF0YS50b1N0cmluZygnaGV4JyksXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlKSB7XG4gICAgICAgICAgYnJvYWRjYXN0UGFyYW1zLndhbGxldFBhc3NwaHJhc2UgPSBwYXJhbXMud2FsbGV0UGFzc3BocmFzZTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMucHJ2KSB7XG4gICAgICAgICAgYnJvYWRjYXN0UGFyYW1zLnBydiA9IHBhcmFtcy5wcnY7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geWllbGQgcGFyYW1zLndhbGxldC5zZW5kKGJyb2FkY2FzdFBhcmFtcyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlY2lwaWVudCA9IHtcbiAgICAgICAgYWRkcmVzczogcGFyYW1zLnJlY2lwaWVudCxcbiAgICAgICAgYW1vdW50OiByZWNvdmVyeUFtb3VudC50b1N0cmluZygxMCksXG4gICAgICB9O1xuXG4gICAgICAvLyBUaGlzIHNpZ25hdHVyZSB3aWxsIGJlIHZhbGlkIGZvciBvbmUgd2Vla1xuICAgICAgY29uc3QgZXhwaXJlVGltZSA9IE1hdGguZmxvb3IobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKSArIDYwICogNjAgKiAyNCAqIDc7XG5cbiAgICAgIC8vIEdldCBzZXF1ZW5jZSBJRC4gV2UgZG8gdGhpcyBieSBidWlsZGluZyBhICdmYWtlJyBldGggdHJhbnNhY3Rpb24sIHNvIHRoZSBwbGF0Zm9ybSB3aWxsIGluY3JlbWVudCBhbmQgcmV0dXJuIHVzIHRoZSBuZXcgc2VxdWVuY2UgaWRcbiAgICAgIC8vIFRoaXMgX2RvZXNfIHJlcXVpcmUgdGhlIHVzZXIgdG8gaGF2ZSBhIG5vbi16ZXJvIHdhbGxldCBiYWxhbmNlXG4gICAgICBjb25zdCB7IG5leHRDb250cmFjdFNlcXVlbmNlSWQsIGdhc1ByaWNlLCBnYXNMaW1pdCB9ID0geWllbGQgcGFyYW1zLndhbGxldC5wcmVidWlsZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgcmVjaXBpZW50czogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGFkZHJlc3M6IHBhcmFtcy5yZWNpcGllbnQsXG4gICAgICAgICAgICBhbW91bnQ6ICcxJyxcbiAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIHRoZXNlIHJlY292ZXJpZXMgbmVlZCB0byBiZSBwcm9jZXNzZWQgYnkgc3VwcG9ydCwgYnV0IGlmIHRoZSBjdXN0b21lciBzZW5kcyBhbnkgdHJhbnNhY3Rpb25zIGJlZm9yZSByZWNvdmVyeSBpc1xuICAgICAgLy8gY29tcGxldGUgdGhlIHNlcXVlbmNlIElEIHdpbGwgYmUgaW52YWxpZC4gYXJ0aWZpY2lhbGx5IGluZmxhdGUgdGhlIHNlcXVlbmNlIElEIHRvIGFsbG93IG1vcmUgdGltZSBmb3IgcHJvY2Vzc2luZ1xuICAgICAgY29uc3Qgc2FmZVNlcXVlbmNlSWQgPSBuZXh0Q29udHJhY3RTZXF1ZW5jZUlkICsgMTAwMDtcblxuICAgICAgLy8gQnVpbGQgc2VuZERhdGEgZm9yIGV0aGVyZXVtIHR4XG4gICAgICBjb25zdCBvcGVyYXRpb25UeXBlcyA9IFsnc3RyaW5nJywgJ2FkZHJlc3MnLCAndWludCcsICdhZGRyZXNzJywgJ3VpbnQnLCAndWludCddO1xuICAgICAgY29uc3Qgb3BlcmF0aW9uQXJncyA9IFtcbiAgICAgICAgLy8gXCJFUkMyMFwiIGhhcyBiZWVuIGFkZGVkIGhlcmUgc28gdGhhdCBldGhlciBvcGVyYXRpb24gaGFzaGVzLCBzaWduYXR1cmVzIGNhbm5vdCBiZSByZS11c2VkIGZvciB0b2tlblNlbmRpbmdcbiAgICAgICAgJ0VSQzIwJyxcbiAgICAgICAgbmV3IG9wdGlvbmFsRGVwcy5ldGhVdGlsLkJOKG9wdGlvbmFsRGVwcy5ldGhVdGlsLnN0cmlwSGV4UHJlZml4KHJlY2lwaWVudC5hZGRyZXNzKSwgMTYpLFxuICAgICAgICByZWNpcGllbnQuYW1vdW50LFxuICAgICAgICBuZXcgb3B0aW9uYWxEZXBzLmV0aFV0aWwuQk4ob3B0aW9uYWxEZXBzLmV0aFV0aWwuc3RyaXBIZXhQcmVmaXgocGFyYW1zLnRva2VuQ29udHJhY3RBZGRyZXNzKSwgMTYpLFxuICAgICAgICBleHBpcmVUaW1lLFxuICAgICAgICBzYWZlU2VxdWVuY2VJZCxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IG9wZXJhdGlvbkhhc2ggPSBvcHRpb25hbERlcHMuZXRoVXRpbC5idWZmZXJUb0hleChcbiAgICAgICAgb3B0aW9uYWxEZXBzLmV0aEFiaS5zb2xpZGl0eVNIQTMob3BlcmF0aW9uVHlwZXMsIG9wZXJhdGlvbkFyZ3MpXG4gICAgICApO1xuXG4gICAgICBjb25zdCB1c2VyUHJ2ID0geWllbGQgcGFyYW1zLndhbGxldC5nZXRQcnYoe1xuICAgICAgICBwcnY6IHBhcmFtcy5wcnYsXG4gICAgICAgIHdhbGxldFBhc3NwaHJhc2U6IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IFV0aWwuZXRoU2lnbk1zZ0hhc2gob3BlcmF0aW9uSGFzaCwgVXRpbC54cHJ2VG9FdGhQcml2YXRlS2V5KHVzZXJQcnYpKTtcblxuICAgICAgY29uc3QgcmVzdWx0OiBSZWNvdmVyVG9rZW5UcmFuc2FjdGlvbiA9IHtcbiAgICAgICAgaGFsZlNpZ25lZDoge1xuICAgICAgICAgIHJlY2lwaWVudDogcmVjaXBpZW50LFxuICAgICAgICAgIGV4cGlyZVRpbWU6IGV4cGlyZVRpbWUsXG4gICAgICAgICAgY29udHJhY3RTZXF1ZW5jZUlkOiBzYWZlU2VxdWVuY2VJZCxcbiAgICAgICAgICBvcGVyYXRpb25IYXNoOiBvcGVyYXRpb25IYXNoLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlLFxuICAgICAgICAgIGdhc0xpbWl0OiBnYXNMaW1pdCxcbiAgICAgICAgICBnYXNQcmljZTogZ2FzUHJpY2UsXG4gICAgICAgICAgdG9rZW5Db250cmFjdEFkZHJlc3M6IHBhcmFtcy50b2tlbkNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICB3YWxsZXRJZDogcGFyYW1zLndhbGxldC5pZCgpLFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZCBhcmd1bWVudHMgdG8gY2FsbCB0aGUgc2VuZCBtZXRob2Qgb24gdGhlIHdhbGxldCBjb250cmFjdFxuICAgKiBAcGFyYW0gdHhJbmZvXG4gICAqL1xuICBnZXRTZW5kTWV0aG9kQXJncyh0eEluZm86IEdldFNlbmRNZXRob2RBcmdzT3B0aW9ucyk6IFNlbmRNZXRob2RBcmdzW10ge1xuICAgIC8vIE1ldGhvZCBzaWduYXR1cmUgaXNcbiAgICAvLyBzZW5kTXVsdGlTaWcoYWRkcmVzcyB0b0FkZHJlc3MsIHVpbnQgdmFsdWUsIGJ5dGVzIGRhdGEsIHVpbnQgZXhwaXJlVGltZSwgdWludCBzZXF1ZW5jZUlkLCBieXRlcyBzaWduYXR1cmUpXG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3RvQWRkcmVzcycsXG4gICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgdmFsdWU6IHR4SW5mby5yZWNpcGllbnQuYWRkcmVzcyxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICd2YWx1ZScsXG4gICAgICAgIHR5cGU6ICd1aW50JyxcbiAgICAgICAgdmFsdWU6IHR4SW5mby5yZWNpcGllbnQuYW1vdW50LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2RhdGEnLFxuICAgICAgICB0eXBlOiAnYnl0ZXMnLFxuICAgICAgICB2YWx1ZTogb3B0aW9uYWxEZXBzLmV0aFV0aWwudG9CdWZmZXIodHhJbmZvLnJlY2lwaWVudC5kYXRhIHx8ICcnKSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdleHBpcmVUaW1lJyxcbiAgICAgICAgdHlwZTogJ3VpbnQnLFxuICAgICAgICB2YWx1ZTogdHhJbmZvLmV4cGlyZVRpbWUsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnc2VxdWVuY2VJZCcsXG4gICAgICAgIHR5cGU6ICd1aW50JyxcbiAgICAgICAgdmFsdWU6IHR4SW5mby5jb250cmFjdFNlcXVlbmNlSWQsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnc2lnbmF0dXJlJyxcbiAgICAgICAgdHlwZTogJ2J5dGVzJyxcbiAgICAgICAgdmFsdWU6IG9wdGlvbmFsRGVwcy5ldGhVdGlsLnRvQnVmZmVyKHR4SW5mby5zaWduYXR1cmUpLFxuICAgICAgfSxcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBxdWVyeSB0byBFdGhlcnNjYW4gZm9yIGluZm9ybWF0aW9uIHN1Y2ggYXMgYmFsYW5jZSwgdG9rZW4gYmFsYW5jZSwgc29saWRpdHkgY2FsbHNcbiAgICogQHBhcmFtIHF1ZXJ5IHtPYmplY3R9IGtleS12YWx1ZSBwYWlycyBvZiBwYXJhbWV0ZXJzIHRvIGFwcGVuZCBhZnRlciAvYXBpXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fSByZXNwb25zZSBmcm9tIEV0aGVyc2NhblxuICAgKi9cbiAgcmVjb3ZlcnlCbG9ja2NoYWluRXhwbG9yZXJRdWVyeShxdWVyeTogYW55LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uKigpIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgcmVxdWVzdFxuICAgICAgICAuZ2V0KGNvbW1vbi5FbnZpcm9ubWVudHNbc2VsZi5iaXRnby5nZXRFbnYoKV0uZXRoZXJzY2FuQmFzZVVybCArICcvYXBpJylcbiAgICAgICAgLnF1ZXJ5KHF1ZXJ5KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFjaCBFdGhlcnNjYW4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNwb25zZS5ib2R5O1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIGV4dHJhIHBhcmFtZXRlcnMgbmVlZGVkIHRvIGJ1aWxkIGEgaG9wIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBidWlsZFBhcmFtcyBUaGUgb3JpZ2luYWwgYnVpbGQgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMgZXh0cmEgcGFyYW1ldGVycyBvYmplY3QgdG8gbWVyZ2Ugd2l0aCB0aGUgb3JpZ2luYWwgYnVpbGQgcGFyYW1ldGVycyBvYmplY3QgYW5kIHNlbmQgdG8gdGhlIHBsYXRmb3JtXG4gICAqL1xuICBjcmVhdGVIb3BUcmFuc2FjdGlvblBhcmFtcyhcbiAgICBidWlsZFBhcmFtczogSG9wVHJhbnNhY3Rpb25CdWlsZE9wdGlvbnMsXG4gICAgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8SG9wUGFyYW1zPlxuICApOiBCbHVlYmlyZDxIb3BQYXJhbXM+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288SG9wUGFyYW1zPihmdW5jdGlvbiooKSB7XG4gICAgICBjb25zdCB3YWxsZXQgPSBidWlsZFBhcmFtcy53YWxsZXQ7XG4gICAgICBjb25zdCByZWNpcGllbnRzID0gYnVpbGRQYXJhbXMucmVjaXBpZW50cztcbiAgICAgIGNvbnN0IHdhbGxldFBhc3NwaHJhc2UgPSBidWlsZFBhcmFtcy53YWxsZXRQYXNzcGhyYXNlO1xuXG4gICAgICBjb25zdCB1c2VyS2V5Y2hhaW4gPSB5aWVsZCBzZWxmLmtleWNoYWlucygpLmdldCh7IGlkOiB3YWxsZXQua2V5SWRzKClbMF0gfSk7XG4gICAgICBjb25zdCB1c2VyUHJ2ID0gd2FsbGV0LmdldFVzZXJQcnYoeyBrZXljaGFpbjogdXNlcktleWNoYWluLCB3YWxsZXRQYXNzcGhyYXNlIH0pO1xuICAgICAgY29uc3QgdXNlclBydkJ1ZmZlciA9IHV0eG9MaWIuSEROb2RlLmZyb21CYXNlNTgodXNlclBydilcbiAgICAgICAgLmdldEtleSgpXG4gICAgICAgIC5nZXRQcml2YXRlS2V5QnVmZmVyKCk7XG4gICAgICBpZiAoIXJlY2lwaWVudHMgfHwgIUFycmF5LmlzQXJyYXkocmVjaXBpZW50cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RpbmcgYXJyYXkgb2YgcmVjaXBpZW50cycpO1xuICAgICAgfVxuXG4gICAgICAvLyBSaWdodCBub3cgd2Ugb25seSBzdXBwb3J0IDEgcmVjaXBpZW50XG4gICAgICBpZiAocmVjaXBpZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHNlbmQgdG8gZXhhY3RseSAxIHJlY2lwaWVudCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVjaXBpZW50QWRkcmVzcyA9IHJlY2lwaWVudHNbMF0uYWRkcmVzcztcbiAgICAgIGNvbnN0IHJlY2lwaWVudEFtb3VudCA9IHJlY2lwaWVudHNbMF0uYW1vdW50O1xuICAgICAgY29uc3QgZmVlRXN0aW1hdGVQYXJhbXMgPSB7XG4gICAgICAgIHJlY2lwaWVudDogcmVjaXBpZW50QWRkcmVzcyxcbiAgICAgICAgYW1vdW50OiByZWNpcGllbnRBbW91bnQsXG4gICAgICAgIGhvcDogdHJ1ZSxcbiAgICAgIH07XG4gICAgICBjb25zdCBmZWVFc3RpbWF0ZTogRmVlRXN0aW1hdGUgPSB5aWVsZCBzZWxmLmZlZUVzdGltYXRlKGZlZUVzdGltYXRlUGFyYW1zKTtcblxuICAgICAgY29uc3QgZ2FzTGltaXQgPSBmZWVFc3RpbWF0ZS5nYXNMaW1pdEVzdGltYXRlO1xuICAgICAgY29uc3QgZ2FzUHJpY2UgPSBNYXRoLnJvdW5kKGZlZUVzdGltYXRlLmZlZUVzdGltYXRlIC8gZ2FzTGltaXQpO1xuICAgICAgY29uc3QgZ2FzUHJpY2VNYXggPSBnYXNQcmljZSAqIDU7XG4gICAgICAvLyBQYXltZW50IGlkIGEgcmFuZG9tIG51bWJlciBzbyBpdHMgZGlmZmVyZW50IGZvciBldmVyeSB0eFxuICAgICAgY29uc3QgcGF5bWVudElkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMDAwMDApLnRvU3RyaW5nKCk7XG4gICAgICBjb25zdCBob3BEaWdlc3Q6IEJ1ZmZlciA9IEV0aC5nZXRIb3BEaWdlc3QoW1xuICAgICAgICByZWNpcGllbnRBZGRyZXNzLFxuICAgICAgICByZWNpcGllbnRBbW91bnQsXG4gICAgICAgIGdhc1ByaWNlTWF4LnRvU3RyaW5nKCksXG4gICAgICAgIGdhc0xpbWl0LnRvU3RyaW5nKCksXG4gICAgICAgIHBheW1lbnRJZCxcbiAgICAgIF0pO1xuXG4gICAgICBjb25zdCB1c2VyUmVxU2lnID0gb3B0aW9uYWxEZXBzLmV0aFV0aWwuYWRkSGV4UHJlZml4KFxuICAgICAgICBzZWNwMjU2azEuc2lnbihob3BEaWdlc3QsIHVzZXJQcnZCdWZmZXIpLnNpZ25hdHVyZS50b1N0cmluZygnaGV4JylcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdDogSG9wUGFyYW1zID0ge1xuICAgICAgICBob3BQYXJhbXM6IHtcbiAgICAgICAgICBnYXNQcmljZU1heCxcbiAgICAgICAgICB1c2VyUmVxU2lnLFxuICAgICAgICAgIHBheW1lbnRJZCxcbiAgICAgICAgfSxcbiAgICAgICAgZ2FzTGltaXQsXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGF0IHRoZSBob3AgcHJlYnVpbGQgZnJvbSB0aGUgSFNNIGlzIHZhbGlkIGFuZCBjb3JyZWN0XG4gICAqIEBwYXJhbSB3YWxsZXQgVGhlIHdhbGxldCB0aGF0IHRoZSBwcmVidWlsZCBpcyBmb3JcbiAgICogQHBhcmFtIGhvcFByZWJ1aWxkIFRoZSBwcmVidWlsZCB0byB2YWxpZGF0ZVxuICAgKiBAcGFyYW0gb3JpZ2luYWxQYXJhbXMgVGhlIG9yaWdpbmFsIHBhcmFtZXRlcnMgcGFzc2VkIHRvIHByZWJ1aWxkVHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHZvaWRcbiAgICogQHRocm93cyBFcnJvciBpZiBUaGUgcHJlYnVpbGQgaXMgaW52YWxpZFxuICAgKi9cbiAgdmFsaWRhdGVIb3BQcmVidWlsZChcbiAgICB3YWxsZXQ6IFdhbGxldCxcbiAgICBob3BQcmVidWlsZDogSG9wUHJlYnVpbGQsXG4gICAgb3JpZ2luYWxQYXJhbXM/OiB7IHJlY2lwaWVudHM6IFJlY2lwaWVudFtdIH0sXG4gICAgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8dm9pZD5cbiAgKTogQmx1ZWJpcmQ8dm9pZD4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzx2b2lkPihmdW5jdGlvbiooKSB7XG4gICAgICBjb25zdCB7IHR4LCBpZCwgc2lnbmF0dXJlIH0gPSBob3BQcmVidWlsZDtcblxuICAgICAgLy8gZmlyc3QsIHZhbGlkYXRlIHRoZSBIU00gc2lnbmF0dXJlXG4gICAgICBjb25zdCBzZXJ2ZXJYcHViID0gY29tbW9uLkVudmlyb25tZW50c1tzZWxmLmJpdGdvLmdldEVudigpXS5oc21YcHViO1xuICAgICAgY29uc3Qgc2VydmVyUHVia2V5QnVmZmVyOiBCdWZmZXIgPSB1dHhvTGliLkhETm9kZS5mcm9tQmFzZTU4KHNlcnZlclhwdWIpLmdldFB1YmxpY0tleUJ1ZmZlcigpO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlQnVmZmVyOiBCdWZmZXIgPSBCdWZmZXIuZnJvbShvcHRpb25hbERlcHMuZXRoVXRpbC5zdHJpcEhleFByZWZpeChzaWduYXR1cmUpLCAnaGV4Jyk7XG4gICAgICBjb25zdCBtZXNzYWdlQnVmZmVyOiBCdWZmZXIgPSBCdWZmZXIuZnJvbShvcHRpb25hbERlcHMuZXRoVXRpbC5zdHJpcEhleFByZWZpeChpZCksICdoZXgnKTtcblxuICAgICAgY29uc3QgaXNWYWxpZFNpZ25hdHVyZTogYm9vbGVhbiA9IHNlY3AyNTZrMS52ZXJpZnkobWVzc2FnZUJ1ZmZlciwgc2lnbmF0dXJlQnVmZmVyLnNsaWNlKDEpLCBzZXJ2ZXJQdWJrZXlCdWZmZXIpO1xuICAgICAgaWYgKCFpc1ZhbGlkU2lnbmF0dXJlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSG9wIHR4aWQgc2lnbmF0dXJlIGludmFsaWRgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYnVpbHRIb3BUeCA9IG5ldyBvcHRpb25hbERlcHMuRXRoVHgodHgpO1xuICAgICAgLy8gSWYgb3JpZ2luYWwgcGFyYW1zIGFyZSBnaXZlbiwgd2UgY2FuIGNoZWNrIHRoZW0gYWdhaW5zdCB0aGUgdHJhbnNhY3Rpb24gcHJlYnVpbGQgcGFyYW1zXG4gICAgICBpZiAoIV8uaXNOaWwob3JpZ2luYWxQYXJhbXMpKSB7XG4gICAgICAgIGNvbnN0IHsgcmVjaXBpZW50cyB9ID0gb3JpZ2luYWxQYXJhbXM7XG5cbiAgICAgICAgLy8gVGhlbiB2YWxpZGF0ZSB0aGF0IHRoZSB0eCBwYXJhbXMgYWN0dWFsbHkgZXF1YWwgdGhlIHJlcXVlc3RlZCBwYXJhbXNcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxBbW91bnQgPSBuZXcgQmlnTnVtYmVyKHJlY2lwaWVudHNbMF0uYW1vdW50KTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxEZXN0aW5hdGlvbjogc3RyaW5nID0gcmVjaXBpZW50c1swXS5hZGRyZXNzO1xuXG4gICAgICAgIGNvbnN0IGhvcEFtb3VudCA9IG5ldyBCaWdOdW1iZXIob3B0aW9uYWxEZXBzLmV0aFV0aWwuYnVmZmVyVG9IZXgoYnVpbHRIb3BUeC52YWx1ZSkpO1xuICAgICAgICBjb25zdCBob3BEZXN0aW5hdGlvbjogc3RyaW5nID0gb3B0aW9uYWxEZXBzLmV0aFV0aWwuYnVmZmVyVG9IZXgoYnVpbHRIb3BUeC50byk7XG4gICAgICAgIGlmICghaG9wQW1vdW50LmVxKG9yaWdpbmFsQW1vdW50KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSG9wIGFtb3VudDogJHtob3BBbW91bnR9IGRvZXMgbm90IGVxdWFsIG9yaWdpbmFsIGFtb3VudDogJHtvcmlnaW5hbEFtb3VudH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9wRGVzdGluYXRpb24udG9Mb3dlckNhc2UoKSAhPT0gb3JpZ2luYWxEZXN0aW5hdGlvbi50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIb3AgZGVzdGluYXRpb246ICR7aG9wRGVzdGluYXRpb259IGRvZXMgbm90IGVxdWFsIG9yaWdpbmFsIHJlY2lwaWVudDogJHtob3BEZXN0aW5hdGlvbn1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWJ1aWx0SG9wVHgudmVyaWZ5U2lnbmF0dXJlKCkpIHtcbiAgICAgICAgLy8gV2UgZG9udCB3YW50IHRvIGNvbnRpbnVlIGF0IGFsbCBpbiB0aGlzIGNhc2UsIGF0IHJpc2sgb2YgRVRIIGJlaW5nIHN0dWNrIG9uIHRoZSBob3AgYWRkcmVzc1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaG9wIHRyYW5zYWN0aW9uIHNpZ25hdHVyZSwgdHhpZDogJHtpZH1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25hbERlcHMuZXRoVXRpbC5hZGRIZXhQcmVmaXgoYnVpbHRIb3BUeC5oYXNoKCkudG9TdHJpbmcoJ2hleCcpKSAhPT0gaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTaWduZWQgaG9wIHR4aWQgZG9lcyBub3QgZXF1YWwgYWN0dWFsIHR4aWRgKTtcbiAgICAgIH1cbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBob3AgZGlnZXN0IGZvciB0aGUgdXNlciB0byBzaWduLiBUaGlzIGlzIHZhbGlkYXRlZCBpbiB0aGUgSFNNIHRvIHByb3ZlIHRoYXQgdGhlIHVzZXIgcmVxdWVzdGVkIHRoaXMgdHhcbiAgICogQHBhcmFtIHBhcmFtc0FyciBUaGUgcGFyYW1ldGVycyB0byBoYXNoIHRvZ2V0aGVyIGZvciB0aGUgZGlnZXN0XG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBnZXRIb3BEaWdlc3QocGFyYW1zQXJyOiBzdHJpbmdbXSk6IEJ1ZmZlciB7XG4gICAgY29uc3QgaGFzaCA9IG5ldyBLZWNjYWsoJ2tlY2NhazI1NicpO1xuICAgIGhhc2gudXBkYXRlKFtFdGguaG9wVHJhbnNhY3Rpb25TYWx0LCAuLi5wYXJhbXNBcnJdLmpvaW4oJyQnKSk7XG4gICAgcmV0dXJuIGhhc2guZGlnZXN0KCk7XG4gIH1cblxuICAvKipcbiAgICogTW9kaWZ5IHByZWJ1aWxkIGJlZm9yZSBzZW5kaW5nIGl0IHRvIHRoZSBzZXJ2ZXIuIEFkZCB0aGluZ3MgbGlrZSBob3AgdHJhbnNhY3Rpb24gcGFyYW1zXG4gICAqIEBwYXJhbSBidWlsZFBhcmFtcyBUaGUgd2hpdGVsaXN0ZWQgcGFyYW1ldGVycyBmb3IgdGhpcyBwcmVidWlsZFxuICAgKiBAcGFyYW0gYnVpbGRQYXJhbXMuaG9wIFRydWUgaWYgdGhpcyBzaG91bGQgcHJlYnVpbGQgYSBob3AgdHgsIGVsc2UgZmFsc2VcbiAgICogQHBhcmFtIGJ1aWxkUGFyYW1zLnJlY2lwaWVudHMgVGhlIHJlY2lwaWVudHMgYXJyYXkgb2YgdGhpcyB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gYnVpbGRQYXJhbXMud2FsbGV0IFRoZSB3YWxsZXQgc2VuZGluZyB0aGlzIHR4XG4gICAqIEBwYXJhbSBidWlsZFBhcmFtcy53YWxsZXRQYXNzcGhyYXNlIHRoZSBwYXNzcGhyYXNlIGZvciB0aGlzIHdhbGxldFxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGdldEV4dHJhUHJlYnVpbGRQYXJhbXMoYnVpbGRQYXJhbXM6IEJ1aWxkT3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8QnVpbGRPcHRpb25zPik6IEJsdWViaXJkPEJ1aWxkT3B0aW9ucz4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxCdWlsZE9wdGlvbnM+KGZ1bmN0aW9uKigpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIV8uaXNVbmRlZmluZWQoYnVpbGRQYXJhbXMuaG9wKSAmJlxuICAgICAgICBidWlsZFBhcmFtcy5ob3AgJiZcbiAgICAgICAgIV8uaXNVbmRlZmluZWQoYnVpbGRQYXJhbXMud2FsbGV0KSAmJlxuICAgICAgICAhXy5pc1VuZGVmaW5lZChidWlsZFBhcmFtcy5yZWNpcGllbnRzKSAmJlxuICAgICAgICAhXy5pc1VuZGVmaW5lZChidWlsZFBhcmFtcy53YWxsZXRQYXNzcGhyYXNlKVxuICAgICAgKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgRXJjMjBUb2tlbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBIb3AgdHJhbnNhY3Rpb25zIGFyZSBub3QgZW5hYmxlZCBmb3IgRVJDLTIwIHRva2Vucywgbm9yIGFyZSB0aGV5IG5lY2Vzc2FyeS4gUGxlYXNlIHJlbW92ZSB0aGUgJ2hvcCcgcGFyYW1ldGVyIGFuZCB0cnkgYWdhaW4uYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHlpZWxkIHNlbGYuY3JlYXRlSG9wVHJhbnNhY3Rpb25QYXJhbXMoe1xuICAgICAgICAgIHdhbGxldDogYnVpbGRQYXJhbXMud2FsbGV0LFxuICAgICAgICAgIHJlY2lwaWVudHM6IGJ1aWxkUGFyYW1zLnJlY2lwaWVudHMsXG4gICAgICAgICAgd2FsbGV0UGFzc3BocmFzZTogYnVpbGRQYXJhbXMud2FsbGV0UGFzc3BocmFzZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogTW9kaWZ5IHByZWJ1aWxkIGFmdGVyIHJlY2VpdmluZyBpdCBmcm9tIHRoZSBzZXJ2ZXIuIEFkZCB0aGluZ3MgbGlrZSBubG9ja3RpbWVcbiAgICovXG4gIHBvc3RQcm9jZXNzUHJlYnVpbGQoXG4gICAgcGFyYW1zOiBUcmFuc2FjdGlvblByZWJ1aWxkLFxuICAgIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFRyYW5zYWN0aW9uUHJlYnVpbGQ+XG4gICk6IEJsdWViaXJkPFRyYW5zYWN0aW9uUHJlYnVpbGQ+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288VHJhbnNhY3Rpb25QcmVidWlsZD4oZnVuY3Rpb24qKCkge1xuICAgICAgaWYgKFxuICAgICAgICAhXy5pc1VuZGVmaW5lZChwYXJhbXMuaG9wVHJhbnNhY3Rpb24pICYmXG4gICAgICAgICFfLmlzVW5kZWZpbmVkKHBhcmFtcy53YWxsZXQpICYmXG4gICAgICAgICFfLmlzVW5kZWZpbmVkKHBhcmFtcy5idWlsZFBhcmFtcylcbiAgICAgICkge1xuICAgICAgICB5aWVsZCBzZWxmLnZhbGlkYXRlSG9wUHJlYnVpbGQocGFyYW1zLndhbGxldCwgcGFyYW1zLmhvcFRyYW5zYWN0aW9uLCBwYXJhbXMuYnVpbGRQYXJhbXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb2luLXNwZWNpZmljIHRoaW5ncyBkb25lIGJlZm9yZSBzaWduaW5nIGEgdHJhbnNhY3Rpb24sIGkuZS4gdmVyaWZpY2F0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBwcmVzaWduVHJhbnNhY3Rpb24oXG4gICAgcGFyYW1zOiBUcmFuc2FjdGlvblByZWJ1aWxkLFxuICAgIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFRyYW5zYWN0aW9uUHJlYnVpbGQ+XG4gICk6IEJsdWViaXJkPFRyYW5zYWN0aW9uUHJlYnVpbGQ+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288VHJhbnNhY3Rpb25QcmVidWlsZD4oZnVuY3Rpb24qKCkge1xuICAgICAgaWYgKFxuICAgICAgICAhXy5pc1VuZGVmaW5lZChwYXJhbXMuaG9wVHJhbnNhY3Rpb24pICYmXG4gICAgICAgICFfLmlzVW5kZWZpbmVkKHBhcmFtcy53YWxsZXQpICYmXG4gICAgICAgICFfLmlzVW5kZWZpbmVkKHBhcmFtcy5idWlsZFBhcmFtcylcbiAgICAgICkge1xuICAgICAgICB5aWVsZCBzZWxmLnZhbGlkYXRlSG9wUHJlYnVpbGQocGFyYW1zLndhbGxldCwgcGFyYW1zLmhvcFRyYW5zYWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggZmVlIGVzdGltYXRlIGluZm9ybWF0aW9uIGZyb20gdGhlIHNlcnZlclxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIFRoZSBwYXJhbXMgcGFzc2VkIGludG8gdGhlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtcy5ob3BdIFRydWUgaWYgd2Ugc2hvdWxkIGVzdGltYXRlIGZlZSBmb3IgYSBob3AgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMucmVjaXBpZW50XSBUaGUgcmVjaXBpZW50IG9mIHRoZSB0cmFuc2FjdGlvbiB0byBlc3RpbWF0ZSBhIHNlbmQgdG9cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMuZGF0YV0gVGhlIEVUSCB0eCBkYXRhIHRvIGVzdGltYXRlIGEgc2VuZCBmb3JcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBmZWUgaW5mbyByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXJcbiAgICovXG4gIGZlZUVzdGltYXRlKHBhcmFtczogRmVlRXN0aW1hdGVPcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxGZWVFc3RpbWF0ZT4pOiBCbHVlYmlyZDxGZWVFc3RpbWF0ZT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxGZWVFc3RpbWF0ZT4oZnVuY3Rpb24qIGNvRmVlRXN0aW1hdGUoKSB7XG4gICAgICBjb25zdCBxdWVyeTogRmVlRXN0aW1hdGVPcHRpb25zID0ge307XG4gICAgICBpZiAocGFyYW1zICYmIHBhcmFtcy5ob3ApIHtcbiAgICAgICAgcXVlcnkuaG9wID0gcGFyYW1zLmhvcDtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLnJlY2lwaWVudCkge1xuICAgICAgICBxdWVyeS5yZWNpcGllbnQgPSBwYXJhbXMucmVjaXBpZW50O1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMuZGF0YSkge1xuICAgICAgICBxdWVyeS5kYXRhID0gcGFyYW1zLmRhdGE7XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zICYmIHBhcmFtcy5hbW91bnQpIHtcbiAgICAgICAgcXVlcnkuYW1vdW50ID0gcGFyYW1zLmFtb3VudDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuYml0Z29cbiAgICAgICAgLmdldChzZWxmLnVybCgnL3R4L2ZlZScpKVxuICAgICAgICAucXVlcnkocXVlcnkpXG4gICAgICAgIC5yZXN1bHQoKTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBzZWNwMjU2azEga2V5IHBhaXJcbiAgICpcbiAgICogQHBhcmFtIHNlZWRcbiAgICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IHdpdGggZ2VuZXJhdGVkIHB1YiBhbmQgcHJ2XG4gICAqL1xuICBnZW5lcmF0ZUtleVBhaXIoc2VlZDogQnVmZmVyKTogS2V5UGFpciB7XG4gICAgaWYgKCFzZWVkKSB7XG4gICAgICAvLyBBbiBleHRlbmRlZCBwcml2YXRlIGtleSBoYXMgYm90aCBhIG5vcm1hbCAyNTYgYml0IHByaXZhdGUga2V5IGFuZCBhIDI1NlxuICAgICAgLy8gYml0IGNoYWluIGNvZGUsIGJvdGggb2Ygd2hpY2ggbXVzdCBiZSByYW5kb20uIDUxMiBiaXRzIGlzIHRoZXJlZm9yZSB0aGVcbiAgICAgIC8vIG1heGltdW0gZW50cm9weSBhbmQgZ2l2ZXMgdXMgbWF4aW11bSBzZWN1cml0eSBhZ2FpbnN0IGNyYWNraW5nLlxuICAgICAgc2VlZCA9IGNyeXB0by5yYW5kb21CeXRlcyg1MTIgLyA4KTtcbiAgICB9XG4gICAgY29uc3QgZXh0ZW5kZWRLZXkgPSB1dHhvTGliLkhETm9kZS5mcm9tU2VlZEJ1ZmZlcihzZWVkKTtcbiAgICBjb25zdCB4cHViID0gZXh0ZW5kZWRLZXkubmV1dGVyZWQoKS50b0Jhc2U1OCgpO1xuICAgIHJldHVybiB7XG4gICAgICBwdWI6IHhwdWIsXG4gICAgICBwcnY6IGV4dGVuZGVkS2V5LnRvQmFzZTU4KCksXG4gICAgfTtcbiAgfVxuXG4gIHBhcnNlVHJhbnNhY3Rpb24oXG4gICAgcGFyYW1zOiBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgICBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxQYXJzZWRUcmFuc2FjdGlvbj5cbiAgKTogQmx1ZWJpcmQ8UGFyc2VkVHJhbnNhY3Rpb24+IHtcbiAgICByZXR1cm4gQmx1ZWJpcmQucmVzb2x2ZSh7fSkuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICB2ZXJpZnlBZGRyZXNzKHBhcmFtczogVmVyaWZ5QWRkcmVzc09wdGlvbnMpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZlcmlmeVRyYW5zYWN0aW9uKHBhcmFtczogVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxib29sZWFuPik6IEJsdWViaXJkPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gQmx1ZWJpcmQucmVzb2x2ZSh0cnVlKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxufVxuIl19