"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var bitcoin_1 = require("../../bitcoin");
var errors_1 = require("../../errors");
var abstractUtxoCoin_1 = require("./abstractUtxoCoin");
var _ = require("lodash");
var Bluebird = require("bluebird");
var co = Bluebird.coroutine;
var prova = require('../../prova');
var Rmg = /** @class */ (function (_super) {
    __extends(Rmg, _super);
    function Rmg(bitgo, network) {
        var _this = this;
        // TODO: move to bitgo-utxo-lib (BG-6821)
        prova.networks.rmg.coin = 'rmg';
        _this = _super.call(this, bitgo, network || prova.networks.rmg) || this;
        return _this;
    }
    Rmg.createInstance = function (bitgo) {
        return new Rmg(bitgo);
    };
    /**
     * Returns the factor between the base unit and its smallest subdivison
     * @return {number}
     */
    Rmg.prototype.getBaseFactor = function () {
        return 1e6;
    };
    Rmg.prototype.getChain = function () {
        return 'rmg';
    };
    Rmg.prototype.getFamily = function () {
        return 'rmg';
    };
    Rmg.prototype.getFullName = function () {
        return 'Royal Mint Gold';
    };
    Rmg.prototype.isValidAddress = function (address) {
        return prova.Address.validateBase58(address, this.network);
    };
    /**
     * Make sure an address is valid and throw an error if it's not.
     * @param address The address string on the network
     * @param keychains Keychain objects with xpubs
     * @param chain Derivation chain
     * @param index Derivation index
     */
    Rmg.prototype.verifyAddress = function (params) {
        if (!params.keychains) {
            throw new Error('missing required param keychains');
        }
        if (!this.isValidAddress(params.address)) {
            throw new Error("invalid address: " + params.address);
        }
        var expectedAddress = this.generateAddress({
            keychains: params.keychains,
            threshold: 2,
            chain: params.chain,
            index: params.index,
        });
        if (expectedAddress.address !== params.address) {
            throw new Error("address validation failure: expected " + expectedAddress.address + " but got " + params.address);
        }
        return true;
    };
    /**
     * Generate an address for a wallet based on a set of configurations
     * @param keychains Array of objects with xpubs
     * @param threshold Minimum number of signatures
     * @param chain Derivation chain
     * @param index Derivation index
     * @returns {{chain: number, index: number, coin: number, coinSpecific: {outputScript}}}
     */
    Rmg.prototype.generateAddress = function (params) {
        var signatureThreshold = 2;
        if (_.isInteger(params.threshold)) {
            signatureThreshold = params.threshold;
            if (signatureThreshold <= 0) {
                throw new Error('threshold has to be positive');
            }
            if (signatureThreshold > params.keychains.length) {
                throw new Error('threshold cannot exceed number of keys');
            }
        }
        var derivationChain = 0;
        if (_.isNumber(params.chain) && _.isInteger(params.chain) && params.chain > 0) {
            derivationChain = params.chain;
        }
        var derivationIndex = 0;
        if (_.isInteger(params.index) && params.index > 0) {
            derivationIndex = params.index;
        }
        var path = 'm/0/0/' + derivationChain + '/' + derivationIndex;
        // do not modify the original argument
        var keychainCopy = _.cloneDeep(params.keychains);
        var userKey = keychainCopy.shift();
        if (!userKey) {
            throw new Error('invalid required param keychains - missing user key');
        }
        var aspKeyIds = keychainCopy.map(function (key) { return key.aspKeyId; });
        var userKeyNode = prova.HDNode.fromBase58(userKey.pub);
        var derivedUserKey = bitcoin_1.hdPath(userKeyNode).deriveKey(path).getPublicKeyBuffer();
        var provaAddress = new prova.Address(derivedUserKey, aspKeyIds, this.network);
        provaAddress.signatureCount = signatureThreshold;
        var addressDetails = {
            chain: derivationChain,
            index: derivationIndex,
            coin: this.getChain(),
            coinSpecific: {
                outputScript: provaAddress.toScript().toString('hex')
            },
        };
        try {
            addressDetails.address = provaAddress.toString();
        }
        catch (e) {
            // non-(n-1)/n signature count
            addressDetails.address = null;
        }
        return addressDetails;
    };
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * - txPrebuild
     * - prv
     * @param callback
     * @returns {Bluebird<SignedTransaction>}
     */
    Rmg.prototype.signTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            var txPrebuild, userPrv, transaction, keychain, signatureIssues, keychainHdPath, index, currentUnspent, path, privKey, currentSignatureIssue, unspentAddress, subscript, txb, isValidSignature, failedIndices, error;
            return __generator(this, function (_a) {
                txPrebuild = params.txPrebuild;
                userPrv = params.prv;
                if (_.isUndefined(txPrebuild) || !_.isObject(txPrebuild)) {
                    if (!_.isUndefined(txPrebuild) && !_.isObject(txPrebuild)) {
                        throw new Error("txPrebuild must be an object, got type " + typeof txPrebuild);
                    }
                    throw new Error('missing txPrebuild parameter');
                }
                transaction = prova.Transaction.fromHex(txPrebuild.txHex);
                if (transaction.ins.length !== txPrebuild.txInfo.unspents.length) {
                    throw new Error('length of unspents array should equal to the number of transaction inputs');
                }
                if (_.isUndefined(userPrv) || !_.isString(userPrv)) {
                    if (!_.isUndefined(userPrv) && !_.isString(userPrv)) {
                        throw new Error("prv must be a string, got type " + typeof userPrv);
                    }
                    throw new Error('missing prv parameter to sign transaction');
                }
                keychain = prova.HDNode.fromBase58(userPrv, self.network);
                signatureIssues = [];
                keychainHdPath = bitcoin_1.hdPath(keychain);
                for (index = 0; index < transaction.ins.length; ++index) {
                    currentUnspent = txPrebuild.txInfo.unspents[index];
                    path = 'm/0/0/' + currentUnspent.chain + '/' + currentUnspent.index;
                    privKey = keychainHdPath.deriveKey(path);
                    currentSignatureIssue = {
                        inputIndex: index,
                        unspent: currentUnspent,
                        path: path
                    };
                    unspentAddress = prova.Address.fromBase58(currentUnspent.address);
                    subscript = unspentAddress.toScript();
                    txb = prova.TransactionBuilder.fromTransaction(transaction, self.network);
                    try {
                        txb.sign(index, privKey, subscript, currentUnspent.value);
                    }
                    catch (e) {
                        currentSignatureIssue.error = e;
                        signatureIssues.push(currentSignatureIssue);
                        continue;
                    }
                    transaction = txb.buildIncomplete();
                    isValidSignature = self.verifySignature(transaction, index, currentUnspent.value);
                    if (!isValidSignature) {
                        currentSignatureIssue.error = new Error('invalid signature');
                        signatureIssues.push(currentSignatureIssue);
                    }
                }
                if (signatureIssues.length > 0) {
                    failedIndices = signatureIssues.map(function (currentIssue) { return currentIssue.inputIndex; });
                    error = new Error("Failed to sign inputs at indices " + failedIndices.join(', '));
                    error.code = 'input_signature_failure';
                    error.signingErrors = signatureIssues;
                    throw error;
                }
                return [2 /*return*/, {
                        txHex: transaction.toHex()
                    }];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Verify the signature(s) on a (half-signed) transaction
     * @param transaction provajs-lib tx object
     * @param inputIndex The input whose signature is to be verified
     * @param amount The input amount needs to be known for signature verification
     * @param verificationSettings
     * @param verificationSettings.signatureIndex The index of the signature to verify (only iterates over non-empty signatures)
     * @param verificationSettings.publicKey The hex of the public key to verify (will verify all signatures)
     * @returns {boolean}
     */
    Rmg.prototype.verifySignature = function (transaction, inputIndex, amount, verificationSettings) {
        if (verificationSettings === void 0) { verificationSettings = {}; }
        if (!(transaction instanceof prova.Transaction)) {
            throw new Error('transaction has to be an instance of prova.Transaction');
        }
        var currentInput = transaction.ins[inputIndex];
        var signatureScript = currentInput.script;
        var decompiledSigScript = prova.script.decompile(signatureScript);
        // the public keys are all the even-indexed entries
        var publicKeys = _.filter(decompiledSigScript, function (item, index) { return index % 2 === 0; });
        // convert the keys to their hex representations
        var publicKeyHexes = _.map(publicKeys, function (k) { return k.toString('hex'); });
        // the signatures are all the odd-indexed ones
        var signatures = _.filter(decompiledSigScript, function (item, index) { return index % 2 === 1; });
        // we map them to each other
        var signaturesByKeys = _.zipObject(publicKeyHexes, signatures);
        var publicKeysToVerify = publicKeyHexes;
        var publicKeyHex = verificationSettings.publicKey;
        if (!_.isUndefined(verificationSettings.signatureIndex)) {
            publicKeysToVerify = [publicKeyHexes[verificationSettings.signatureIndex]];
        }
        var areAllSignaturesValid = true;
        for (var _i = 0, publicKeysToVerify_1 = publicKeysToVerify; _i < publicKeysToVerify_1.length; _i++) {
            var currentPublicKeyHex = publicKeysToVerify_1[_i];
            if (!_.isUndefined(publicKeyHex) && publicKeyHex !== currentPublicKeyHex) {
                areAllSignaturesValid = false;
                continue;
            }
            if (_.isEmpty(currentPublicKeyHex)) {
                areAllSignaturesValid = false;
                continue;
            }
            var isSignatureValid = false;
            var publicKeyBuffer = Buffer.from(currentPublicKeyHex, 'hex');
            var signatureBuffer = signaturesByKeys[currentPublicKeyHex];
            if (Buffer.isBuffer(publicKeyBuffer) && publicKeyBuffer.length > 0 && Buffer.isBuffer(signatureBuffer) && signatureBuffer.length > 0) {
                var publicKey = prova.ECPair.fromPublicKeyBuffer(publicKeyBuffer);
                var signatureHash = transaction.hashForWitnessV0(inputIndex, null, amount, prova.Transaction.SIGHASH_ALL);
                isSignatureValid = publicKey.verify(signatureHash, signatureBuffer);
            }
            if (!_.isUndefined(publicKeyHex) && isSignatureValid) {
                // We were trying to see if any of the signatures was valid for the given public key. Evidently yes.
                return true;
            }
            areAllSignaturesValid = isSignatureValid && areAllSignaturesValid;
        }
        return areAllSignaturesValid;
    };
    /**
     * Explain/parse transaction
     * @param params
     * @param callback
     */
    Rmg.prototype.explainTransaction = function (params, callback) {
        return co(function () {
            var self, transaction, id, changeAddresses, spendAmount, changeAmount, explanation;
            return __generator(this, function (_a) {
                self = this;
                transaction = prova.Transaction.fromHex(params.txHex);
                id = transaction.getId();
                changeAddresses = [];
                spendAmount = 0;
                changeAmount = 0;
                if (params.txInfo && params.txInfo.changeAddresses) {
                    changeAddresses = params.txInfo.changeAddresses;
                }
                explanation = {
                    displayOrder: ['id', 'outputAmount', 'changeAmount', 'outputs', 'changeOutputs'],
                    id: id,
                    outputs: [],
                    changeOutputs: []
                };
                transaction.outs.forEach(function (currentOutput) {
                    var currentAddress = prova.Address.fromScript(currentOutput.script, self.network).toString();
                    var currentAmount = currentOutput.value;
                    if (changeAddresses.indexOf(currentAddress) !== -1) {
                        // this is change
                        changeAmount += currentAmount;
                        explanation.changeOutputs.push({
                            address: currentAddress,
                            amount: currentAmount
                        });
                        return;
                    }
                    spendAmount += currentAmount;
                    explanation.outputs.push({
                        address: currentAddress,
                        amount: currentAmount
                    });
                });
                explanation.outputAmount = spendAmount;
                explanation.changeAmount = changeAmount;
                // add fee info if available
                if (params.feeInfo) {
                    explanation.displayOrder.push('fee');
                    explanation.fee = params.feeInfo;
                }
                return [2 /*return*/, explanation];
            });
        }).call(this).asCallback(callback);
    };
    Rmg.prototype.getAddressInfoFromExplorer = function (address) {
        throw new errors_1.MethodNotImplementedError();
    };
    Rmg.prototype.getUnspentInfoFromExplorer = function (address) {
        throw new errors_1.MethodNotImplementedError();
    };
    return Rmg;
}(abstractUtxoCoin_1.AbstractUtxoCoin));
exports.Rmg = Rmg;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm1nLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3YyL2NvaW5zL3JtZy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSx5Q0FBdUM7QUFFdkMsdUNBQXlEO0FBRXpELHVEQU00QjtBQUU1QiwwQkFBNEI7QUFDNUIsbUNBQXFDO0FBQ3JDLElBQU0sRUFBRSxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUM7QUFDOUIsSUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBRXJDO0lBQXlCLHVCQUFnQjtJQUN2QyxhQUFZLEtBQVksRUFBRSxPQUFRO1FBQWxDLGlCQUlDO1FBSEMseUNBQXlDO1FBQ3pDLEtBQUssQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxLQUFLLENBQUM7UUFDaEMsUUFBQSxrQkFBTSxLQUFLLEVBQUUsT0FBTyxJQUFJLEtBQUssQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLFNBQUM7O0lBQzlDLENBQUM7SUFFTSxrQkFBYyxHQUFyQixVQUFzQixLQUFZO1FBQ2hDLE9BQU8sSUFBSSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDeEIsQ0FBQztJQUVEOzs7T0FHRztJQUNILDJCQUFhLEdBQWI7UUFDRSxPQUFPLEdBQUcsQ0FBQztJQUNiLENBQUM7SUFFRCxzQkFBUSxHQUFSO1FBQ0UsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQsdUJBQVMsR0FBVDtRQUNFLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVELHlCQUFXLEdBQVg7UUFDRSxPQUFPLGlCQUFpQixDQUFDO0lBQzNCLENBQUM7SUFFRCw0QkFBYyxHQUFkLFVBQWUsT0FBZTtRQUM1QixPQUFPLEtBQUssQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7SUFD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QVcsSUFBSSxhQUFhLENBQUM7b0JBQzdCLFdBQVcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO3dCQUN2QixPQUFPLEVBQUUsY0FBYzt3QkFDdkIsTUFBTSxFQUFFLGFBQWE7cUJBQ3RCLENBQUMsQ0FBQztnQkFDTCxDQUFDLENBQUMsQ0FBQztnQkFDSCxXQUFXLENBQUMsWUFBWSxHQUFHLFdBQVcsQ0FBQztnQkFDdkMsV0FBVyxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7Z0JBRXhDLDRCQUE0QjtnQkFDNUIsSUFBSSxNQUFNLENBQUMsT0FBTyxFQUFFO29CQUNsQixXQUFXLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDckMsV0FBVyxDQUFDLEdBQUcsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDO2lCQUNsQztnQkFDRCxzQkFBTyxXQUFXLEVBQUM7O1NBQ3BCLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFUyx3Q0FBMEIsR0FBcEMsVUFBcUMsT0FBZTtRQUNsRCxNQUFNLElBQUksa0NBQXlCLEVBQUUsQ0FBQztJQUN4QyxDQUFDO0lBRVMsd0NBQTBCLEdBQXBDLFVBQXFDLE9BQWU7UUFDbEQsTUFBTSxJQUFJLGtDQUF5QixFQUFFLENBQUM7SUFDeEMsQ0FBQztJQUNILFVBQUM7QUFBRCxDQUFDLEFBdlZELENBQXlCLG1DQUFnQixHQXVWeEM7QUF2Vlksa0JBQUciLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoZFBhdGggfSBmcm9tICcuLi8uLi9iaXRjb2luJztcbmltcG9ydCB7IEJpdEdvIH0gZnJvbSAnLi4vLi4vYml0Z28nO1xuaW1wb3J0IHsgTWV0aG9kTm90SW1wbGVtZW50ZWRFcnJvciB9IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBCYXNlQ29pbiwgU2lnbmVkVHJhbnNhY3Rpb24gfSBmcm9tICcuLi9iYXNlQ29pbic7XG5pbXBvcnQge1xuICBBYnN0cmFjdFV0eG9Db2luLCBBZGRyZXNzSW5mbyxcbiAgRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiwgVW5zcGVudEluZm8sXG4gIEdlbmVyYXRlQWRkcmVzc09wdGlvbnMsIEFkZHJlc3NEZXRhaWxzLFxuICBTaWduVHJhbnNhY3Rpb25PcHRpb25zLCBWZXJpZnlBZGRyZXNzT3B0aW9ucyxcbn0gZnJvbSAnLi9hYnN0cmFjdFV0eG9Db2luJztcbmltcG9ydCB7IE5vZGVDYWxsYmFjayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCAqIGFzIEJsdWViaXJkIGZyb20gJ2JsdWViaXJkJztcbmNvbnN0IGNvID0gQmx1ZWJpcmQuY29yb3V0aW5lO1xuY29uc3QgcHJvdmEgPSByZXF1aXJlKCcuLi8uLi9wcm92YScpO1xuXG5leHBvcnQgY2xhc3MgUm1nIGV4dGVuZHMgQWJzdHJhY3RVdHhvQ29pbiB7XG4gIGNvbnN0cnVjdG9yKGJpdGdvOiBCaXRHbywgbmV0d29yaz8pIHtcbiAgICAvLyBUT0RPOiBtb3ZlIHRvIGJpdGdvLXV0eG8tbGliIChCRy02ODIxKVxuICAgIHByb3ZhLm5ldHdvcmtzLnJtZy5jb2luID0gJ3JtZyc7XG4gICAgc3VwZXIoYml0Z28sIG5ldHdvcmsgfHwgcHJvdmEubmV0d29ya3Mucm1nKTtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVJbnN0YW5jZShiaXRnbzogQml0R28pOiBCYXNlQ29pbiB7XG4gICAgcmV0dXJuIG5ldyBSbWcoYml0Z28pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZhY3RvciBiZXR3ZWVuIHRoZSBiYXNlIHVuaXQgYW5kIGl0cyBzbWFsbGVzdCBzdWJkaXZpc29uXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldEJhc2VGYWN0b3IoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gMWU2O1xuICB9XG5cbiAgZ2V0Q2hhaW4oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ3JtZyc7XG4gIH1cblxuICBnZXRGYW1pbHkoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ3JtZyc7XG4gIH1cblxuICBnZXRGdWxsTmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnUm95YWwgTWludCBHb2xkJztcbiAgfVxuXG4gIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm92YS5BZGRyZXNzLnZhbGlkYXRlQmFzZTU4KGFkZHJlc3MsIHRoaXMubmV0d29yayk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBzdXJlIGFuIGFkZHJlc3MgaXMgdmFsaWQgYW5kIHRocm93IGFuIGVycm9yIGlmIGl0J3Mgbm90LlxuICAgKiBAcGFyYW0gYWRkcmVzcyBUaGUgYWRkcmVzcyBzdHJpbmcgb24gdGhlIG5ldHdvcmtcbiAgICogQHBhcmFtIGtleWNoYWlucyBLZXljaGFpbiBvYmplY3RzIHdpdGggeHB1YnNcbiAgICogQHBhcmFtIGNoYWluIERlcml2YXRpb24gY2hhaW5cbiAgICogQHBhcmFtIGluZGV4IERlcml2YXRpb24gaW5kZXhcbiAgICovXG4gIHZlcmlmeUFkZHJlc3MocGFyYW1zOiBWZXJpZnlBZGRyZXNzT3B0aW9ucykge1xuICAgIGlmICghcGFyYW1zLmtleWNoYWlucykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHBhcmFtIGtleWNoYWlucycpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc1ZhbGlkQWRkcmVzcyhwYXJhbXMuYWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBhZGRyZXNzOiAke3BhcmFtcy5hZGRyZXNzfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGV4cGVjdGVkQWRkcmVzczogYW55ID0gdGhpcy5nZW5lcmF0ZUFkZHJlc3Moe1xuICAgICAga2V5Y2hhaW5zOiBwYXJhbXMua2V5Y2hhaW5zLFxuICAgICAgdGhyZXNob2xkOiAyLFxuICAgICAgY2hhaW46IHBhcmFtcy5jaGFpbixcbiAgICAgIGluZGV4OiBwYXJhbXMuaW5kZXgsXG4gICAgfSk7XG5cbiAgICBpZiAoZXhwZWN0ZWRBZGRyZXNzLmFkZHJlc3MgIT09IHBhcmFtcy5hZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGFkZHJlc3MgdmFsaWRhdGlvbiBmYWlsdXJlOiBleHBlY3RlZCAke2V4cGVjdGVkQWRkcmVzcy5hZGRyZXNzfSBidXQgZ290ICR7cGFyYW1zLmFkZHJlc3N9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYW4gYWRkcmVzcyBmb3IgYSB3YWxsZXQgYmFzZWQgb24gYSBzZXQgb2YgY29uZmlndXJhdGlvbnNcbiAgICogQHBhcmFtIGtleWNoYWlucyBBcnJheSBvZiBvYmplY3RzIHdpdGggeHB1YnNcbiAgICogQHBhcmFtIHRocmVzaG9sZCBNaW5pbXVtIG51bWJlciBvZiBzaWduYXR1cmVzXG4gICAqIEBwYXJhbSBjaGFpbiBEZXJpdmF0aW9uIGNoYWluXG4gICAqIEBwYXJhbSBpbmRleCBEZXJpdmF0aW9uIGluZGV4XG4gICAqIEByZXR1cm5zIHt7Y2hhaW46IG51bWJlciwgaW5kZXg6IG51bWJlciwgY29pbjogbnVtYmVyLCBjb2luU3BlY2lmaWM6IHtvdXRwdXRTY3JpcHR9fX1cbiAgICovXG4gIGdlbmVyYXRlQWRkcmVzcyhwYXJhbXM6IEdlbmVyYXRlQWRkcmVzc09wdGlvbnMpOiBBZGRyZXNzRGV0YWlscyB7XG4gICAgbGV0IHNpZ25hdHVyZVRocmVzaG9sZCA9IDI7XG4gICAgaWYgKF8uaXNJbnRlZ2VyKHBhcmFtcy50aHJlc2hvbGQpKSB7XG4gICAgICBzaWduYXR1cmVUaHJlc2hvbGQgPSBwYXJhbXMudGhyZXNob2xkO1xuICAgICAgaWYgKHNpZ25hdHVyZVRocmVzaG9sZCA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndGhyZXNob2xkIGhhcyB0byBiZSBwb3NpdGl2ZScpO1xuICAgICAgfVxuICAgICAgaWYgKHNpZ25hdHVyZVRocmVzaG9sZCA+IHBhcmFtcy5rZXljaGFpbnMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndGhyZXNob2xkIGNhbm5vdCBleGNlZWQgbnVtYmVyIG9mIGtleXMnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgZGVyaXZhdGlvbkNoYWluID0gMDtcbiAgICBpZiAoXy5pc051bWJlcihwYXJhbXMuY2hhaW4pICYmIF8uaXNJbnRlZ2VyKHBhcmFtcy5jaGFpbikgJiYgcGFyYW1zLmNoYWluID4gMCkge1xuICAgICAgZGVyaXZhdGlvbkNoYWluID0gcGFyYW1zLmNoYWluO1xuICAgIH1cblxuICAgIGxldCBkZXJpdmF0aW9uSW5kZXggPSAwO1xuICAgIGlmIChfLmlzSW50ZWdlcihwYXJhbXMuaW5kZXgpICYmIHBhcmFtcy5pbmRleCA+IDApIHtcbiAgICAgIGRlcml2YXRpb25JbmRleCA9IHBhcmFtcy5pbmRleDtcbiAgICB9XG5cbiAgICBjb25zdCBwYXRoID0gJ20vMC8wLycgKyBkZXJpdmF0aW9uQ2hhaW4gKyAnLycgKyBkZXJpdmF0aW9uSW5kZXg7XG4gICAgLy8gZG8gbm90IG1vZGlmeSB0aGUgb3JpZ2luYWwgYXJndW1lbnRcbiAgICBjb25zdCBrZXljaGFpbkNvcHkgPSBfLmNsb25lRGVlcChwYXJhbXMua2V5Y2hhaW5zKTtcbiAgICBjb25zdCB1c2VyS2V5ID0ga2V5Y2hhaW5Db3B5LnNoaWZ0KCk7XG5cbiAgICBpZiAoIXVzZXJLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCByZXF1aXJlZCBwYXJhbSBrZXljaGFpbnMgLSBtaXNzaW5nIHVzZXIga2V5Jyk7XG4gICAgfVxuICAgIGNvbnN0IGFzcEtleUlkcyA9IGtleWNoYWluQ29weS5tYXAoKGtleSkgPT4ga2V5LmFzcEtleUlkKTtcbiAgICBjb25zdCB1c2VyS2V5Tm9kZSA9IHByb3ZhLkhETm9kZS5mcm9tQmFzZTU4KHVzZXJLZXkucHViKTtcbiAgICBjb25zdCBkZXJpdmVkVXNlcktleSA9IGhkUGF0aCh1c2VyS2V5Tm9kZSkuZGVyaXZlS2V5KHBhdGgpLmdldFB1YmxpY0tleUJ1ZmZlcigpO1xuXG4gICAgY29uc3QgcHJvdmFBZGRyZXNzID0gbmV3IHByb3ZhLkFkZHJlc3MoZGVyaXZlZFVzZXJLZXksIGFzcEtleUlkcywgdGhpcy5uZXR3b3JrKTtcbiAgICBwcm92YUFkZHJlc3Muc2lnbmF0dXJlQ291bnQgPSBzaWduYXR1cmVUaHJlc2hvbGQ7XG5cbiAgICBjb25zdCBhZGRyZXNzRGV0YWlsczogYW55ID0ge1xuICAgICAgY2hhaW46IGRlcml2YXRpb25DaGFpbixcbiAgICAgIGluZGV4OiBkZXJpdmF0aW9uSW5kZXgsXG4gICAgICBjb2luOiB0aGlzLmdldENoYWluKCksXG4gICAgICBjb2luU3BlY2lmaWM6IHtcbiAgICAgICAgb3V0cHV0U2NyaXB0OiBwcm92YUFkZHJlc3MudG9TY3JpcHQoKS50b1N0cmluZygnaGV4JylcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICBhZGRyZXNzRGV0YWlscy5hZGRyZXNzID0gcHJvdmFBZGRyZXNzLnRvU3RyaW5nKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gbm9uLShuLTEpL24gc2lnbmF0dXJlIGNvdW50XG4gICAgICBhZGRyZXNzRGV0YWlscy5hZGRyZXNzID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYWRkcmVzc0RldGFpbHM7XG4gIH1cblxuICAvKipcbiAgICogQXNzZW1ibGUga2V5Y2hhaW4gYW5kIGhhbGYtc2lnbiBwcmVidWlsdCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIC0gdHhQcmVidWlsZFxuICAgKiAtIHBydlxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge0JsdWViaXJkPFNpZ25lZFRyYW5zYWN0aW9uPn1cbiAgICovXG4gIHNpZ25UcmFuc2FjdGlvbihwYXJhbXM6IFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFNpZ25lZFRyYW5zYWN0aW9uPik6IEJsdWViaXJkPFNpZ25lZFRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPFNpZ25lZFRyYW5zYWN0aW9uPihmdW5jdGlvbiAqKCkge1xuICAgICAgY29uc3QgdHhQcmVidWlsZCA9IHBhcmFtcy50eFByZWJ1aWxkO1xuICAgICAgY29uc3QgdXNlclBydiA9IHBhcmFtcy5wcnY7XG5cbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHR4UHJlYnVpbGQpIHx8ICFfLmlzT2JqZWN0KHR4UHJlYnVpbGQpKSB7XG4gICAgICAgIGlmICghXy5pc1VuZGVmaW5lZCh0eFByZWJ1aWxkKSAmJiAhXy5pc09iamVjdCh0eFByZWJ1aWxkKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdHhQcmVidWlsZCBtdXN0IGJlIGFuIG9iamVjdCwgZ290IHR5cGUgJHt0eXBlb2YgdHhQcmVidWlsZH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgdHhQcmVidWlsZCBwYXJhbWV0ZXInKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHRyYW5zYWN0aW9uID0gcHJvdmEuVHJhbnNhY3Rpb24uZnJvbUhleCh0eFByZWJ1aWxkLnR4SGV4KTtcblxuICAgICAgaWYgKHRyYW5zYWN0aW9uLmlucy5sZW5ndGggIT09IHR4UHJlYnVpbGQudHhJbmZvLnVuc3BlbnRzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlbmd0aCBvZiB1bnNwZW50cyBhcnJheSBzaG91bGQgZXF1YWwgdG8gdGhlIG51bWJlciBvZiB0cmFuc2FjdGlvbiBpbnB1dHMnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQodXNlclBydikgfHwgIV8uaXNTdHJpbmcodXNlclBydikpIHtcbiAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHVzZXJQcnYpICYmICFfLmlzU3RyaW5nKHVzZXJQcnYpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcnYgbXVzdCBiZSBhIHN0cmluZywgZ290IHR5cGUgJHt0eXBlb2YgdXNlclBydn1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcHJ2IHBhcmFtZXRlciB0byBzaWduIHRyYW5zYWN0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGtleWNoYWluID0gcHJvdmEuSEROb2RlLmZyb21CYXNlNTgodXNlclBydiwgc2VsZi5uZXR3b3JrKTtcblxuICAgICAgY29uc3Qgc2lnbmF0dXJlSXNzdWVzOiBhbnlbXSA9IFtdO1xuICAgICAgY29uc3Qga2V5Y2hhaW5IZFBhdGggPSBoZFBhdGgoa2V5Y2hhaW4pO1xuXG4gICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdHJhbnNhY3Rpb24uaW5zLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICBjb25zdCBjdXJyZW50VW5zcGVudCA9IHR4UHJlYnVpbGQudHhJbmZvLnVuc3BlbnRzW2luZGV4XTtcbiAgICAgICAgY29uc3QgcGF0aCA9ICdtLzAvMC8nICsgY3VycmVudFVuc3BlbnQuY2hhaW4gKyAnLycgKyBjdXJyZW50VW5zcGVudC5pbmRleDtcbiAgICAgICAgY29uc3QgcHJpdktleSA9IGtleWNoYWluSGRQYXRoLmRlcml2ZUtleShwYXRoKTtcblxuICAgICAgICBjb25zdCBjdXJyZW50U2lnbmF0dXJlSXNzdWU6IGFueSA9IHtcbiAgICAgICAgICBpbnB1dEluZGV4OiBpbmRleCxcbiAgICAgICAgICB1bnNwZW50OiBjdXJyZW50VW5zcGVudCxcbiAgICAgICAgICBwYXRoOiBwYXRoXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgdW5zcGVudEFkZHJlc3MgPSBwcm92YS5BZGRyZXNzLmZyb21CYXNlNTgoY3VycmVudFVuc3BlbnQuYWRkcmVzcyk7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdCA9IHVuc3BlbnRBZGRyZXNzLnRvU2NyaXB0KCk7XG4gICAgICAgIGNvbnN0IHR4YiA9IHByb3ZhLlRyYW5zYWN0aW9uQnVpbGRlci5mcm9tVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIHNlbGYubmV0d29yayk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdHhiLnNpZ24oaW5kZXgsIHByaXZLZXksIHN1YnNjcmlwdCwgY3VycmVudFVuc3BlbnQudmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY3VycmVudFNpZ25hdHVyZUlzc3VlLmVycm9yID0gZTtcbiAgICAgICAgICBzaWduYXR1cmVJc3N1ZXMucHVzaChjdXJyZW50U2lnbmF0dXJlSXNzdWUpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhbnNhY3Rpb24gPSB0eGIuYnVpbGRJbmNvbXBsZXRlKCk7XG4gICAgICAgIGNvbnN0IGlzVmFsaWRTaWduYXR1cmUgPSBzZWxmLnZlcmlmeVNpZ25hdHVyZSh0cmFuc2FjdGlvbiwgaW5kZXgsIGN1cnJlbnRVbnNwZW50LnZhbHVlKTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkU2lnbmF0dXJlKSB7XG4gICAgICAgICAgY3VycmVudFNpZ25hdHVyZUlzc3VlLmVycm9yID0gbmV3IEVycm9yKCdpbnZhbGlkIHNpZ25hdHVyZScpO1xuICAgICAgICAgIHNpZ25hdHVyZUlzc3Vlcy5wdXNoKGN1cnJlbnRTaWduYXR1cmVJc3N1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNpZ25hdHVyZUlzc3Vlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGZhaWxlZEluZGljZXMgPSBzaWduYXR1cmVJc3N1ZXMubWFwKGN1cnJlbnRJc3N1ZSA9PiBjdXJyZW50SXNzdWUuaW5wdXRJbmRleCk7XG4gICAgICAgIGNvbnN0IGVycm9yOiBhbnkgPSBuZXcgRXJyb3IoYEZhaWxlZCB0byBzaWduIGlucHV0cyBhdCBpbmRpY2VzICR7ZmFpbGVkSW5kaWNlcy5qb2luKCcsICcpfWApO1xuICAgICAgICBlcnJvci5jb2RlID0gJ2lucHV0X3NpZ25hdHVyZV9mYWlsdXJlJztcbiAgICAgICAgZXJyb3Iuc2lnbmluZ0Vycm9ycyA9IHNpZ25hdHVyZUlzc3VlcztcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR4SGV4OiB0cmFuc2FjdGlvbi50b0hleCgpXG4gICAgICB9O1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSB0aGUgc2lnbmF0dXJlKHMpIG9uIGEgKGhhbGYtc2lnbmVkKSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gcHJvdmFqcy1saWIgdHggb2JqZWN0XG4gICAqIEBwYXJhbSBpbnB1dEluZGV4IFRoZSBpbnB1dCB3aG9zZSBzaWduYXR1cmUgaXMgdG8gYmUgdmVyaWZpZWRcbiAgICogQHBhcmFtIGFtb3VudCBUaGUgaW5wdXQgYW1vdW50IG5lZWRzIHRvIGJlIGtub3duIGZvciBzaWduYXR1cmUgdmVyaWZpY2F0aW9uXG4gICAqIEBwYXJhbSB2ZXJpZmljYXRpb25TZXR0aW5nc1xuICAgKiBAcGFyYW0gdmVyaWZpY2F0aW9uU2V0dGluZ3Muc2lnbmF0dXJlSW5kZXggVGhlIGluZGV4IG9mIHRoZSBzaWduYXR1cmUgdG8gdmVyaWZ5IChvbmx5IGl0ZXJhdGVzIG92ZXIgbm9uLWVtcHR5IHNpZ25hdHVyZXMpXG4gICAqIEBwYXJhbSB2ZXJpZmljYXRpb25TZXR0aW5ncy5wdWJsaWNLZXkgVGhlIGhleCBvZiB0aGUgcHVibGljIGtleSB0byB2ZXJpZnkgKHdpbGwgdmVyaWZ5IGFsbCBzaWduYXR1cmVzKVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHZlcmlmeVNpZ25hdHVyZSh0cmFuc2FjdGlvbjogYW55LCBpbnB1dEluZGV4OiBudW1iZXIsIGFtb3VudD86IG51bWJlciwgdmVyaWZpY2F0aW9uU2V0dGluZ3M6IHsgc2lnbmF0dXJlSW5kZXg/OiBudW1iZXI7IHB1YmxpY0tleT86IHN0cmluZzsgfSA9IHt9KTogYm9vbGVhbiB7XG4gICAgaWYgKCEodHJhbnNhY3Rpb24gaW5zdGFuY2VvZiBwcm92YS5UcmFuc2FjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNhY3Rpb24gaGFzIHRvIGJlIGFuIGluc3RhbmNlIG9mIHByb3ZhLlRyYW5zYWN0aW9uJyk7XG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudElucHV0ID0gdHJhbnNhY3Rpb24uaW5zW2lucHV0SW5kZXhdO1xuICAgIGNvbnN0IHNpZ25hdHVyZVNjcmlwdCA9IGN1cnJlbnRJbnB1dC5zY3JpcHQ7XG4gICAgY29uc3QgZGVjb21waWxlZFNpZ1NjcmlwdCA9IHByb3ZhLnNjcmlwdC5kZWNvbXBpbGUoc2lnbmF0dXJlU2NyaXB0KTtcbiAgICAvLyB0aGUgcHVibGljIGtleXMgYXJlIGFsbCB0aGUgZXZlbi1pbmRleGVkIGVudHJpZXNcbiAgICBjb25zdCBwdWJsaWNLZXlzID0gXy5maWx0ZXIoZGVjb21waWxlZFNpZ1NjcmlwdCwgKGl0ZW0sIGluZGV4OiBudW1iZXIpID0+IGluZGV4ICUgMiA9PT0gMCk7XG4gICAgLy8gY29udmVydCB0aGUga2V5cyB0byB0aGVpciBoZXggcmVwcmVzZW50YXRpb25zXG4gICAgY29uc3QgcHVibGljS2V5SGV4ZXMgPSBfLm1hcChwdWJsaWNLZXlzLCBrID0+IChrIGFzIGFueSkudG9TdHJpbmcoJ2hleCcpKTtcbiAgICAvLyB0aGUgc2lnbmF0dXJlcyBhcmUgYWxsIHRoZSBvZGQtaW5kZXhlZCBvbmVzXG4gICAgY29uc3Qgc2lnbmF0dXJlcyA9IF8uZmlsdGVyKGRlY29tcGlsZWRTaWdTY3JpcHQsIChpdGVtLCBpbmRleDogbnVtYmVyKSA9PiBpbmRleCAlIDIgPT09IDEpO1xuICAgIC8vIHdlIG1hcCB0aGVtIHRvIGVhY2ggb3RoZXJcbiAgICBjb25zdCBzaWduYXR1cmVzQnlLZXlzID0gXy56aXBPYmplY3QocHVibGljS2V5SGV4ZXMsIHNpZ25hdHVyZXMpO1xuXG4gICAgbGV0IHB1YmxpY0tleXNUb1ZlcmlmeSA9IHB1YmxpY0tleUhleGVzO1xuICAgIGNvbnN0IHB1YmxpY0tleUhleCA9IHZlcmlmaWNhdGlvblNldHRpbmdzLnB1YmxpY0tleTtcblxuICAgIGlmICghXy5pc1VuZGVmaW5lZCh2ZXJpZmljYXRpb25TZXR0aW5ncy5zaWduYXR1cmVJbmRleCkpIHtcbiAgICAgIHB1YmxpY0tleXNUb1ZlcmlmeSA9IFtwdWJsaWNLZXlIZXhlc1t2ZXJpZmljYXRpb25TZXR0aW5ncy5zaWduYXR1cmVJbmRleF1dO1xuICAgIH1cblxuICAgIGxldCBhcmVBbGxTaWduYXR1cmVzVmFsaWQgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgY3VycmVudFB1YmxpY0tleUhleCBvZiBwdWJsaWNLZXlzVG9WZXJpZnkpIHtcblxuICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHB1YmxpY0tleUhleCkgJiYgcHVibGljS2V5SGV4ICE9PSBjdXJyZW50UHVibGljS2V5SGV4KSB7XG4gICAgICAgIGFyZUFsbFNpZ25hdHVyZXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNFbXB0eShjdXJyZW50UHVibGljS2V5SGV4KSkge1xuICAgICAgICBhcmVBbGxTaWduYXR1cmVzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGxldCBpc1NpZ25hdHVyZVZhbGlkID0gZmFsc2U7XG4gICAgICBjb25zdCBwdWJsaWNLZXlCdWZmZXIgPSBCdWZmZXIuZnJvbShjdXJyZW50UHVibGljS2V5SGV4LCAnaGV4Jyk7XG4gICAgICBjb25zdCBzaWduYXR1cmVCdWZmZXIgPSBzaWduYXR1cmVzQnlLZXlzW2N1cnJlbnRQdWJsaWNLZXlIZXhdO1xuXG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHB1YmxpY0tleUJ1ZmZlcikgJiYgcHVibGljS2V5QnVmZmVyLmxlbmd0aCA+IDAgJiYgQnVmZmVyLmlzQnVmZmVyKHNpZ25hdHVyZUJ1ZmZlcikgJiYgc2lnbmF0dXJlQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gcHJvdmEuRUNQYWlyLmZyb21QdWJsaWNLZXlCdWZmZXIocHVibGljS2V5QnVmZmVyKTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlSGFzaCA9IHRyYW5zYWN0aW9uLmhhc2hGb3JXaXRuZXNzVjAoaW5wdXRJbmRleCwgbnVsbCwgYW1vdW50LCBwcm92YS5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTCk7XG4gICAgICAgIGlzU2lnbmF0dXJlVmFsaWQgPSBwdWJsaWNLZXkudmVyaWZ5KHNpZ25hdHVyZUhhc2gsIHNpZ25hdHVyZUJ1ZmZlcik7XG4gICAgICB9XG5cbiAgICAgIGlmICghXy5pc1VuZGVmaW5lZChwdWJsaWNLZXlIZXgpICYmIGlzU2lnbmF0dXJlVmFsaWQpIHtcbiAgICAgICAgLy8gV2Ugd2VyZSB0cnlpbmcgdG8gc2VlIGlmIGFueSBvZiB0aGUgc2lnbmF0dXJlcyB3YXMgdmFsaWQgZm9yIHRoZSBnaXZlbiBwdWJsaWMga2V5LiBFdmlkZW50bHkgeWVzLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgYXJlQWxsU2lnbmF0dXJlc1ZhbGlkID0gaXNTaWduYXR1cmVWYWxpZCAmJiBhcmVBbGxTaWduYXR1cmVzVmFsaWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyZUFsbFNpZ25hdHVyZXNWYWxpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBsYWluL3BhcnNlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBleHBsYWluVHJhbnNhY3Rpb24ocGFyYW1zOiBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxUcmFuc2FjdGlvbkV4cGxhbmF0aW9uPik6IEJsdWViaXJkPFRyYW5zYWN0aW9uRXhwbGFuYXRpb24+IHtcbiAgICByZXR1cm4gY288VHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4oZnVuY3Rpb24gKigpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBwcm92YS5UcmFuc2FjdGlvbi5mcm9tSGV4KHBhcmFtcy50eEhleCk7XG4gICAgICBjb25zdCBpZCA9IHRyYW5zYWN0aW9uLmdldElkKCk7XG4gICAgICBsZXQgY2hhbmdlQWRkcmVzc2VzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgbGV0IHNwZW5kQW1vdW50ID0gMDtcbiAgICAgIGxldCBjaGFuZ2VBbW91bnQgPSAwO1xuICAgICAgaWYgKHBhcmFtcy50eEluZm8gJiYgcGFyYW1zLnR4SW5mby5jaGFuZ2VBZGRyZXNzZXMpIHtcbiAgICAgICAgY2hhbmdlQWRkcmVzc2VzID0gcGFyYW1zLnR4SW5mby5jaGFuZ2VBZGRyZXNzZXM7XG4gICAgICB9XG4gICAgICBjb25zdCBleHBsYW5hdGlvbjogYW55ID0ge1xuICAgICAgICBkaXNwbGF5T3JkZXI6IFsnaWQnLCAnb3V0cHV0QW1vdW50JywgJ2NoYW5nZUFtb3VudCcsICdvdXRwdXRzJywgJ2NoYW5nZU91dHB1dHMnXSxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgY2hhbmdlT3V0cHV0czogW11cbiAgICAgIH07XG4gICAgICB0cmFuc2FjdGlvbi5vdXRzLmZvckVhY2goZnVuY3Rpb24oY3VycmVudE91dHB1dCkge1xuICAgICAgICBjb25zdCBjdXJyZW50QWRkcmVzcyA9IHByb3ZhLkFkZHJlc3MuZnJvbVNjcmlwdChjdXJyZW50T3V0cHV0LnNjcmlwdCwgc2VsZi5uZXR3b3JrKS50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBjdXJyZW50QW1vdW50ID0gY3VycmVudE91dHB1dC52YWx1ZTtcblxuICAgICAgICBpZiAoY2hhbmdlQWRkcmVzc2VzLmluZGV4T2YoY3VycmVudEFkZHJlc3MpICE9PSAtMSkge1xuICAgICAgICAgIC8vIHRoaXMgaXMgY2hhbmdlXG4gICAgICAgICAgY2hhbmdlQW1vdW50ICs9IGN1cnJlbnRBbW91bnQ7XG4gICAgICAgICAgZXhwbGFuYXRpb24uY2hhbmdlT3V0cHV0cy5wdXNoKHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGN1cnJlbnRBZGRyZXNzLFxuICAgICAgICAgICAgYW1vdW50OiBjdXJyZW50QW1vdW50XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3BlbmRBbW91bnQgKz0gY3VycmVudEFtb3VudDtcbiAgICAgICAgZXhwbGFuYXRpb24ub3V0cHV0cy5wdXNoKHtcbiAgICAgICAgICBhZGRyZXNzOiBjdXJyZW50QWRkcmVzcyxcbiAgICAgICAgICBhbW91bnQ6IGN1cnJlbnRBbW91bnRcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGV4cGxhbmF0aW9uLm91dHB1dEFtb3VudCA9IHNwZW5kQW1vdW50O1xuICAgICAgZXhwbGFuYXRpb24uY2hhbmdlQW1vdW50ID0gY2hhbmdlQW1vdW50O1xuXG4gICAgICAvLyBhZGQgZmVlIGluZm8gaWYgYXZhaWxhYmxlXG4gICAgICBpZiAocGFyYW1zLmZlZUluZm8pIHtcbiAgICAgICAgZXhwbGFuYXRpb24uZGlzcGxheU9yZGVyLnB1c2goJ2ZlZScpO1xuICAgICAgICBleHBsYW5hdGlvbi5mZWUgPSBwYXJhbXMuZmVlSW5mbztcbiAgICAgIH1cbiAgICAgIHJldHVybiBleHBsYW5hdGlvbjtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldEFkZHJlc3NJbmZvRnJvbUV4cGxvcmVyKGFkZHJlc3M6IHN0cmluZyk6IEJsdWViaXJkPEFkZHJlc3NJbmZvPiB7XG4gICAgdGhyb3cgbmV3IE1ldGhvZE5vdEltcGxlbWVudGVkRXJyb3IoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRVbnNwZW50SW5mb0Zyb21FeHBsb3JlcihhZGRyZXNzOiBzdHJpbmcpOiBCbHVlYmlyZDxVbnNwZW50SW5mb1tdPiB7XG4gICAgdGhyb3cgbmV3IE1ldGhvZE5vdEltcGxlbWVudGVkRXJyb3IoKTtcbiAgfVxufVxuIl19