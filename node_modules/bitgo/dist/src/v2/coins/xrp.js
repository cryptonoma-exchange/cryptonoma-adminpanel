"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var bignumber_js_1 = require("bignumber.js");
var bitgo_utxo_lib_1 = require("bitgo-utxo-lib");
var Bluebird = require("bluebird");
var crypto = require("crypto");
var _ = require("lodash");
var url = require("url");
var querystring = require("querystring");
var rippleAddressCodec = require("ripple-address-codec");
var rippleBinaryCodec = require("ripple-binary-codec");
var hashes_1 = require("ripple-lib/dist/npm/common/hashes");
var rippleKeypairs = require("ripple-keypairs");
var baseCoin_1 = require("../baseCoin");
var config = require("../../config");
var errors_1 = require("../../errors");
var ripple = require('../../ripple');
var sjcl = require('../../vendor/sjcl.min.js');
var co = Bluebird.coroutine;
var Xrp = /** @class */ (function (_super) {
    __extends(Xrp, _super);
    function Xrp(bitgo) {
        return _super.call(this, bitgo) || this;
    }
    Xrp.createInstance = function (bitgo) {
        return new Xrp(bitgo);
    };
    /**
     * Factor between the coin's base unit and its smallest subdivison
     */
    Xrp.prototype.getBaseFactor = function () {
        return 1e6;
    };
    /**
     * Identifier for the blockchain which supports this coin
     */
    Xrp.prototype.getChain = function () {
        return 'xrp';
    };
    /**
     * Identifier for the coin family
     */
    Xrp.prototype.getFamily = function () {
        return 'xrp';
    };
    /**
     * Complete human-readable name of this coin
     */
    Xrp.prototype.getFullName = function () {
        return 'Ripple';
    };
    /**
     * Parse an address string into address and destination tag
     */
    Xrp.prototype.getAddressDetails = function (address) {
        var destinationDetails = url.parse(address);
        var destinationAddress = destinationDetails.pathname;
        if (!destinationAddress || !rippleAddressCodec.isValidClassicAddress(destinationAddress)) {
            throw new errors_1.InvalidAddressError("destination address \"" + destinationAddress + "\" is not valid");
        }
        // there are no other properties like destination tags
        if (destinationDetails.pathname === address) {
            return {
                address: address,
                destinationTag: undefined,
            };
        }
        if (!destinationDetails.query) {
            throw new errors_1.InvalidAddressError('no query params present');
        }
        var queryDetails = querystring.parse(destinationDetails.query);
        if (!queryDetails.dt) {
            // if there are more properties, the query details need to contain the destination tag property.
            throw new errors_1.InvalidAddressError('destination tag missing');
        }
        if (Array.isArray(queryDetails.dt)) {
            // if queryDetails.dt is an array, that means dt was given multiple times, which is not valid
            throw new errors_1.InvalidAddressError("destination tag can appear at most once, but " + queryDetails.dt.length + " destination tags were found");
        }
        var parsedTag = parseInt(queryDetails.dt, 10);
        if (!Number.isSafeInteger(parsedTag)) {
            throw new errors_1.InvalidAddressError('invalid destination tag');
        }
        if (parsedTag > 0xFFFFFFFF || parsedTag < 0) {
            throw new errors_1.InvalidAddressError('destination tag out of range');
        }
        return {
            address: destinationAddress,
            destinationTag: parsedTag,
        };
    };
    /**
     * Construct a full, normalized address from an address and destination tag
     */
    Xrp.prototype.normalizeAddress = function (_a) {
        var address = _a.address, destinationTag = _a.destinationTag;
        if (!_.isString(address)) {
            throw new errors_1.InvalidAddressError('invalid address details');
        }
        if (_.isInteger(destinationTag)) {
            return address + "?dt=" + destinationTag;
        }
        return address;
    };
    /**
     * Evaluates whether an address string is valid for this coin
     * @param address
     */
    Xrp.prototype.isValidAddress = function (address) {
        try {
            var addressDetails = this.getAddressDetails(address);
            return address === this.normalizeAddress(addressDetails);
        }
        catch (e) {
            return false;
        }
    };
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    Xrp.prototype.isValidPub = function (pub) {
        try {
            bitgo_utxo_lib_1.HDNode.fromBase58(pub);
            return true;
        }
        catch (e) {
            return false;
        }
    };
    /**
     * Get fee info from server
     */
    Xrp.prototype.getFeeInfo = function (_, callback) {
        return this.bitgo.get(this.url('/public/feeinfo'))
            .result()
            .nodeify(callback);
    };
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * - txPrebuild
     * - prv
     * @param callback
     * @returns Bluebird<HalfSignedTransaction>
     */
    Xrp.prototype.signTransaction = function (_a, callback) {
        var txPrebuild = _a.txPrebuild, prv = _a.prv;
        return co(function () {
            var userKey, userPrivateKey, userAddress, rippleLib, halfSigned;
            return __generator(this, function (_a) {
                if (_.isUndefined(txPrebuild) || !_.isObject(txPrebuild)) {
                    if (!_.isUndefined(txPrebuild) && !_.isObject(txPrebuild)) {
                        throw new Error("txPrebuild must be an object, got type " + typeof txPrebuild);
                    }
                    throw new Error('missing txPrebuild parameter');
                }
                if (_.isUndefined(prv) || !_.isString(prv)) {
                    if (!_.isUndefined(prv) && !_.isString(prv)) {
                        throw new Error("prv must be a string, got type " + typeof prv);
                    }
                    throw new Error('missing prv parameter to sign transaction');
                }
                userKey = bitgo_utxo_lib_1.HDNode.fromBase58(prv).getKey();
                userPrivateKey = userKey.getPrivateKeyBuffer();
                userAddress = rippleKeypairs.deriveAddress(userKey.getPublicKeyBuffer().toString('hex'));
                rippleLib = ripple();
                halfSigned = rippleLib.signWithPrivateKey(txPrebuild.txHex, userPrivateKey.toString('hex'), { signAs: userAddress });
                return [2 /*return*/, { halfSigned: { txHex: halfSigned.signedTransaction } }];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Ripple requires additional parameters for wallet generation to be sent to the server. The additional parameters are
     * the root public key, which is the basis of the root address, two signed, and one half-signed initialization txs
     * @param walletParams
     * - rootPrivateKey: optional hex-encoded Ripple private key
     * @param keychains
     */
    Xrp.prototype.supplementGenerateWallet = function (walletParams, keychains) {
        return co(function () {
            var userKeychain, backupKeychain, bitgoKeychain, userKey, userAddress, backupKey, backupAddress, bitgoKey, bitgoAddress, keyPair, rootPrivateKey, privateKey, publicKey, rootAddress, self, rippleLib, feeInfo, openLedgerFee, medianFee, fee, multisigAssignmentTx, signedMultisigAssignmentTx, destinationTagTx, signedDestinationTagTx, masterDeactivationTx, signedMasterDeactivationTx;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userKeychain = keychains.userKeychain, backupKeychain = keychains.backupKeychain, bitgoKeychain = keychains.bitgoKeychain;
                        userKey = bitgo_utxo_lib_1.HDNode.fromBase58(userKeychain.pub).getKey();
                        userAddress = rippleKeypairs.deriveAddress(userKey.getPublicKeyBuffer().toString('hex'));
                        backupKey = bitgo_utxo_lib_1.HDNode.fromBase58(backupKeychain.pub).getKey();
                        backupAddress = rippleKeypairs.deriveAddress(backupKey.getPublicKeyBuffer().toString('hex'));
                        bitgoKey = bitgo_utxo_lib_1.HDNode.fromBase58(bitgoKeychain.pub).getKey();
                        bitgoAddress = rippleKeypairs.deriveAddress(bitgoKey.getPublicKeyBuffer().toString('hex'));
                        keyPair = bitgo_utxo_lib_1.ECPair.makeRandom();
                        if (walletParams.rootPrivateKey) {
                            rootPrivateKey = walletParams.rootPrivateKey;
                            if (typeof rootPrivateKey !== 'string' || rootPrivateKey.length !== 64) {
                                throw new Error('rootPrivateKey needs to be a hexadecimal private key string');
                            }
                            keyPair = bitgo_utxo_lib_1.ECPair.fromPrivateKeyBuffer(Buffer.from(walletParams.rootPrivateKey, 'hex'));
                        }
                        privateKey = keyPair.getPrivateKeyBuffer();
                        publicKey = keyPair.getPublicKeyBuffer();
                        rootAddress = rippleKeypairs.deriveAddress(publicKey.toString('hex'));
                        self = this;
                        rippleLib = ripple();
                        return [4 /*yield*/, self.getFeeInfo()];
                    case 1:
                        feeInfo = _a.sent();
                        openLedgerFee = new bignumber_js_1.BigNumber(feeInfo.xrpOpenLedgerFee);
                        medianFee = new bignumber_js_1.BigNumber(feeInfo.xrpMedianFee);
                        fee = bignumber_js_1.BigNumber.max(openLedgerFee, medianFee).times(1.5).toFixed(0);
                        multisigAssignmentTx = {
                            TransactionType: 'SignerListSet',
                            Account: rootAddress,
                            SignerQuorum: 2,
                            SignerEntries: [
                                {
                                    SignerEntry: {
                                        Account: userAddress,
                                        SignerWeight: 1
                                    }
                                },
                                {
                                    SignerEntry: {
                                        Account: backupAddress,
                                        SignerWeight: 1
                                    }
                                },
                                {
                                    SignerEntry: {
                                        Account: bitgoAddress,
                                        SignerWeight: 1
                                    }
                                }
                            ],
                            Flags: 2147483648,
                            // LastLedgerSequence: ledgerVersion + 10,
                            Fee: fee,
                            Sequence: 1
                        };
                        signedMultisigAssignmentTx = rippleLib.signWithPrivateKey(JSON.stringify(multisigAssignmentTx), privateKey.toString('hex'));
                        destinationTagTx = {
                            TransactionType: 'AccountSet',
                            Account: rootAddress,
                            SetFlag: 1,
                            Flags: 2147483648,
                            // LastLedgerSequence: ledgerVersion + 10,
                            Fee: fee,
                            Sequence: 2
                        };
                        signedDestinationTagTx = rippleLib.signWithPrivateKey(JSON.stringify(destinationTagTx), privateKey.toString('hex'));
                        masterDeactivationTx = {
                            TransactionType: 'AccountSet',
                            Account: rootAddress,
                            SetFlag: 4,
                            Flags: 2147483648,
                            // LastLedgerSequence: ledgerVersion + 10,
                            Fee: fee,
                            Sequence: 3
                        };
                        signedMasterDeactivationTx = rippleLib.signWithPrivateKey(JSON.stringify(masterDeactivationTx), privateKey.toString('hex'));
                        // extend the wallet initialization params
                        walletParams.rootPub = publicKey.toString('hex');
                        walletParams.initializationTxs = {
                            setMultisig: signedMultisigAssignmentTx.signedTransaction,
                            disableMasterKey: signedMasterDeactivationTx.signedTransaction,
                            forceDestinationTag: signedDestinationTagTx.signedTransaction
                        };
                        return [2 /*return*/, walletParams];
                }
            });
        }).call(this);
    };
    /**
     * Explain/parse transaction
     * @param params
     * @param callback
     */
    Xrp.prototype.explainTransaction = function (params, callback) {
        if (params === void 0) { params = {}; }
        return co(function () {
            var transaction, txHex, id, address;
            return __generator(this, function (_a) {
                if (!params.txHex) {
                    throw new Error('missing required param txHex');
                }
                try {
                    transaction = rippleBinaryCodec.decode(params.txHex);
                    txHex = params.txHex;
                }
                catch (e) {
                    try {
                        transaction = JSON.parse(params.txHex);
                        txHex = rippleBinaryCodec.encode(transaction);
                    }
                    catch (e) {
                        throw new Error('txHex needs to be either hex or JSON string for XRP');
                    }
                }
                id = hashes_1.computeBinaryTransactionHash(txHex);
                address = transaction.Destination + ((transaction.DestinationTag >= 0) ? '?dt=' + transaction.DestinationTag : '');
                return [2 /*return*/, {
                        displayOrder: ['id', 'outputAmount', 'changeAmount', 'outputs', 'changeOutputs', 'fee'],
                        id: id,
                        changeOutputs: [],
                        outputAmount: transaction.Amount,
                        changeAmount: 0,
                        outputs: [
                            {
                                address: address,
                                amount: transaction.Amount
                            }
                        ],
                        fee: {
                            fee: transaction.Fee,
                            feeRate: null,
                            size: txHex.length / 2
                        }
                    }];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Verify that a transaction prebuild complies with the original intention
     * @param txParams params object passed to send
     * @param txPrebuild prebuild object returned by server
     * @param wallet
     * @param callback
     * @returns {boolean}
     */
    Xrp.prototype.verifyTransaction = function (_a, callback) {
        var txParams = _a.txParams, txPrebuild = _a.txPrebuild;
        var self = this;
        return co(function () {
            var explanation, output, expectedOutput, comparator;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, self.explainTransaction({
                            txHex: txPrebuild.txHex
                        })];
                    case 1:
                        explanation = _a.sent();
                        output = explanation.outputs.concat(explanation.changeOutputs)[0];
                        expectedOutput = txParams.recipients && txParams.recipients[0];
                        comparator = function (recipient1, recipient2) {
                            if (recipient1.address !== recipient2.address) {
                                return false;
                            }
                            var amount1 = new bignumber_js_1.BigNumber(recipient1.amount);
                            var amount2 = new bignumber_js_1.BigNumber(recipient2.amount);
                            return amount1.toFixed() === amount2.toFixed();
                        };
                        if (!comparator(output, expectedOutput)) {
                            throw new Error('transaction prebuild does not match expected output');
                        }
                        return [2 /*return*/, true];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Check if address is a valid XRP address, and then make sure the root addresses match.
     * This prevents attacks where an attack may switch out the new address for one of their own
     * @param address {String} the address to verify
     * @param rootAddress {String} the wallet's root address
     */
    Xrp.prototype.verifyAddress = function (_a) {
        var address = _a.address, rootAddress = _a.rootAddress;
        if (!this.isValidAddress(address)) {
            throw new errors_1.InvalidAddressError("address verification failure: address \"" + address + "\" is not valid");
        }
        var addressDetails = this.getAddressDetails(address);
        var rootAddressDetails = this.getAddressDetails(rootAddress);
        if (addressDetails.address !== rootAddressDetails.address) {
            throw new errors_1.UnexpectedAddressError("address validation failure: " + addressDetails.address + " vs. " + rootAddressDetails.address);
        }
        return true;
    };
    /**
     * URL of a well-known, public facing (non-bitgo) rippled instance which can be used for recovery
     */
    Xrp.prototype.getRippledUrl = function () {
        return 'https://s1.ripple.com:51234';
    };
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * - rootAddress: root XRP wallet address to recover funds from
     * - userKey: [encrypted] xprv
     * - backupKey: [encrypted] xprv, or xpub if the xprv is held by a KRS provider
     * - walletPassphrase: necessary if one of the xprvs is encrypted
     * - bitgoKey: xpub
     * - krsProvider: necessary if backup key is held by KRS
     * - recoveryDestination: target address to send recovered funds to
     * @param callback
     */
    Xrp.prototype.recover = function (params, callback) {
        var self = this;
        return co(function explainTransaction() {
            var rippledUrl, isKrsRecovery, isUnsignedSweep, accountInfoParams, _a, keys, addressDetails, feeDetails, serverDetails, openLedgerFee, baseReserve, reserveDelta, currentLedger, sequenceId, balance, signerLists, accountFlags, userAddress, backupAddress, signerList, foundAddresses, signerEntries, _i, signerEntries_1, SignerEntry, weight, address, USER_KEY_SETTING_FLAG, MASTER_KEY_DEACTIVATION_FLAG, REQUIRE_DESTINATION_TAG_FLAG, reserve, recoverableBalance, rawDestination, destinationDetails, destinationAddress, destinationTag, queryDetails, parsedTag, transaction, txJSON, rippleLib, userKey, userSignature, signedTransaction, backupKey, backupSignature, transactionExplanation;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        rippledUrl = self.getRippledUrl();
                        isKrsRecovery = params.backupKey.startsWith('xpub') && !params.userKey.startsWith('xpub');
                        isUnsignedSweep = params.backupKey.startsWith('xpub') && params.userKey.startsWith('xpub');
                        accountInfoParams = {
                            method: 'account_info',
                            params: [{
                                    account: params.rootAddress,
                                    strict: true,
                                    ledger_index: 'current',
                                    queue: true,
                                    signer_lists: true,
                                }],
                        };
                        return [4 /*yield*/, Bluebird.props({
                                keys: self.initiateRecovery(params),
                                addressDetails: self.bitgo.post(rippledUrl).send(accountInfoParams),
                                feeDetails: self.bitgo.post(rippledUrl).send({ method: 'fee' }),
                                serverDetails: self.bitgo.post(rippledUrl).send({ method: 'server_info' }),
                            })];
                    case 1:
                        _a = _b.sent(), keys = _a.keys, addressDetails = _a.addressDetails, feeDetails = _a.feeDetails, serverDetails = _a.serverDetails;
                        openLedgerFee = new bignumber_js_1.BigNumber(feeDetails.body.result.drops.open_ledger_fee);
                        baseReserve = new bignumber_js_1.BigNumber(serverDetails.body.result.info.validated_ledger.reserve_base_xrp).times(self.getBaseFactor());
                        reserveDelta = new bignumber_js_1.BigNumber(serverDetails.body.result.info.validated_ledger.reserve_inc_xrp).times(self.getBaseFactor());
                        currentLedger = serverDetails.body.result.info.validated_ledger.seq;
                        sequenceId = addressDetails.body.result.account_data.Sequence;
                        balance = new bignumber_js_1.BigNumber(addressDetails.body.result.account_data.Balance);
                        signerLists = addressDetails.body.result.account_data.signer_lists;
                        accountFlags = addressDetails.body.result.account_data.Flags;
                        // make sure there is only one signer list set
                        if (signerLists.length !== 1) {
                            throw new Error('unexpected set of signer lists');
                        }
                        userAddress = rippleKeypairs.deriveAddress(keys[0].getPublicKeyBuffer().toString('hex'));
                        backupAddress = rippleKeypairs.deriveAddress(keys[1].getPublicKeyBuffer().toString('hex'));
                        signerList = signerLists[0];
                        if (signerList.SignerQuorum !== 2) {
                            throw new Error('invalid minimum signature count');
                        }
                        foundAddresses = {};
                        signerEntries = signerList.SignerEntries;
                        if (signerEntries.length !== 3) {
                            throw new Error('invalid signer list length');
                        }
                        for (_i = 0, signerEntries_1 = signerEntries; _i < signerEntries_1.length; _i++) {
                            SignerEntry = signerEntries_1[_i].SignerEntry;
                            weight = SignerEntry.SignerWeight;
                            address = SignerEntry.Account;
                            if (weight !== 1) {
                                throw new Error('invalid signer weight');
                            }
                            // if it's a dupe of an address we already know, block
                            if (foundAddresses[address] >= 1) {
                                throw new Error('duplicate signer address');
                            }
                            foundAddresses[address] = (foundAddresses[address] || 0) + 1;
                        }
                        if (foundAddresses[userAddress] !== 1) {
                            throw new Error('unexpected incidence frequency of user signer address');
                        }
                        if (foundAddresses[backupAddress] !== 1) {
                            throw new Error('unexpected incidence frequency of user signer address');
                        }
                        USER_KEY_SETTING_FLAG = 65536;
                        MASTER_KEY_DEACTIVATION_FLAG = 1048576;
                        REQUIRE_DESTINATION_TAG_FLAG = 131072;
                        if ((accountFlags & USER_KEY_SETTING_FLAG) !== 0) {
                            throw new Error('a custom user key has been set');
                        }
                        if ((accountFlags & MASTER_KEY_DEACTIVATION_FLAG) !== MASTER_KEY_DEACTIVATION_FLAG) {
                            throw new Error('the master key has not been deactivated');
                        }
                        if ((accountFlags & REQUIRE_DESTINATION_TAG_FLAG) !== REQUIRE_DESTINATION_TAG_FLAG) {
                            throw new Error('the destination flag requirement has not been activated');
                        }
                        reserve = baseReserve.plus(reserveDelta.times(5));
                        recoverableBalance = balance.minus(reserve);
                        rawDestination = params.recoveryDestination;
                        destinationDetails = url.parse(rawDestination);
                        destinationAddress = destinationDetails.pathname;
                        if (destinationDetails.query) {
                            queryDetails = querystring.parse(destinationDetails.query);
                            if (Array.isArray(queryDetails.dt)) {
                                // if queryDetails.dt is an array, that means dt was given multiple times, which is not valid
                                throw new errors_1.InvalidAddressError("destination tag can appear at most once, but " + queryDetails.dt.length + " destination tags were found");
                            }
                            parsedTag = parseInt(queryDetails.dt, 10);
                            if (Number.isInteger(parsedTag)) {
                                destinationTag = parsedTag;
                            }
                        }
                        transaction = {
                            TransactionType: 'Payment',
                            Account: params.rootAddress,
                            Destination: destinationAddress,
                            DestinationTag: destinationTag,
                            Amount: recoverableBalance.toFixed(0),
                            Flags: 2147483648,
                            LastLedgerSequence: currentLedger + 1000000,
                            Fee: openLedgerFee.times(3).toFixed(0),
                            Sequence: sequenceId,
                        };
                        txJSON = JSON.stringify(transaction);
                        if (isUnsignedSweep) {
                            return [2 /*return*/, txJSON];
                        }
                        rippleLib = ripple();
                        userKey = keys[0].getKey().getPrivateKeyBuffer().toString('hex');
                        userSignature = rippleLib.signWithPrivateKey(txJSON, userKey, { signAs: userAddress });
                        if (isKrsRecovery) {
                            signedTransaction = userSignature;
                        }
                        else {
                            backupKey = keys[1].getKey().getPrivateKeyBuffer().toString('hex');
                            backupSignature = rippleLib.signWithPrivateKey(txJSON, backupKey, { signAs: backupAddress });
                            signedTransaction = rippleLib.combine([userSignature.signedTransaction, backupSignature.signedTransaction]);
                        }
                        return [4 /*yield*/, self.explainTransaction({
                                txHex: signedTransaction.signedTransaction,
                            })];
                    case 2:
                        transactionExplanation = _b.sent();
                        transactionExplanation.txHex = signedTransaction.signedTransaction;
                        if (isKrsRecovery) {
                            transactionExplanation.backupKey = params.backupKey;
                            transactionExplanation.coin = self.getChain();
                        }
                        return [2 /*return*/, transactionExplanation];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Prepare and validate all keychains from the keycard for recovery
     */
    Xrp.prototype.initiateRecovery = function (params) {
        var self = this;
        return co(function initiateRecovery() {
            var keys, userKey, backupKey, bitgoXpub, destinationAddress, passphrase, isKrsRecovery, isUnsignedSweep, validatePassphraseKey, key, backupHDNode, bitgoHDNode;
            return __generator(this, function (_a) {
                keys = [];
                userKey = params.userKey;
                backupKey = params.backupKey;
                bitgoXpub = params.bitgoKey;
                destinationAddress = params.recoveryDestination;
                passphrase = params.walletPassphrase;
                isKrsRecovery = backupKey.startsWith('xpub') && !userKey.startsWith('xpub');
                isUnsignedSweep = backupKey.startsWith('xpub') && userKey.startsWith('xpub');
                if (isKrsRecovery && params.krsProvider && _.isUndefined(config.krsProviders[params.krsProvider])) {
                    throw new Error('unknown key recovery service provider');
                }
                validatePassphraseKey = function (userKey, passphrase) {
                    try {
                        if (!userKey.startsWith('xprv') && !isUnsignedSweep) {
                            userKey = sjcl.decrypt(passphrase, userKey);
                        }
                        return bitgo_utxo_lib_1.HDNode.fromBase58(userKey);
                    }
                    catch (e) {
                        throw new Error('Failed to decrypt user key with passcode - try again!');
                    }
                };
                key = validatePassphraseKey(userKey, passphrase);
                keys.push(key);
                // Validate the backup key
                try {
                    if (!backupKey.startsWith('xprv') && !isKrsRecovery && !isUnsignedSweep) {
                        backupKey = sjcl.decrypt(passphrase, backupKey);
                    }
                    backupHDNode = bitgo_utxo_lib_1.HDNode.fromBase58(backupKey);
                    keys.push(backupHDNode);
                }
                catch (e) {
                    throw new Error('Failed to decrypt backup key with passcode - try again!');
                }
                try {
                    bitgoHDNode = bitgo_utxo_lib_1.HDNode.fromBase58(bitgoXpub);
                    keys.push(bitgoHDNode);
                }
                catch (e) {
                    if (self.getFamily() !== 'xrp') {
                        // in XRP recoveries, the BitGo xpub is optional
                        throw new Error('Failed to parse bitgo xpub!');
                    }
                }
                // Validate the destination address
                if (!self.isValidAddress(destinationAddress)) {
                    throw new Error('Invalid destination address!');
                }
                return [2 /*return*/, keys];
            });
        }).call(this);
    };
    /**
     * Generate a new keypair for this coin.
     * @param seed Seed from which the new keypair should be generated, otherwise a random seed is used
     */
    Xrp.prototype.generateKeyPair = function (seed) {
        if (!seed) {
            // An extended private key has both a normal 256 bit private key and a 256
            // bit chain code, both of which must be random. 512 bits is therefore the
            // maximum entropy and gives us maximum security against cracking.
            seed = crypto.randomBytes(512 / 8);
        }
        var extendedKey = bitgo_utxo_lib_1.HDNode.fromSeedBuffer(seed);
        var xpub = extendedKey.neutered().toBase58();
        return {
            pub: xpub,
            prv: extendedKey.toBase58(),
        };
    };
    Xrp.prototype.parseTransaction = function (params, callback) {
        return Bluebird.resolve({}).asCallback(callback);
    };
    return Xrp;
}(baseCoin_1.BaseCoin));
exports.Xrp = Xrp;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieHJwLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3YyL2NvaW5zL3hycC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSw2Q0FBeUM7QUFDekMsaURBQWdEO0FBQ2hELG1DQUFxQztBQUNyQywrQkFBaUM7QUFDakMsMEJBQTRCO0FBQzVCLHlCQUEyQjtBQUMzQix5Q0FBMkM7QUFHM0MseURBQTJEO0FBQzNELHVEQUF5RDtBQUN6RCw0REFBaUY7QUFDakYsZ0RBQWtEO0FBRWxELHdDQVVxQjtBQUNyQixxQ0FBdUM7QUFFdkMsdUNBQTJFO0FBRTNFLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUN2QyxJQUFNLElBQUksR0FBRyxPQUFPLENBQUMsMEJBQTBCLENBQUMsQ0FBQztBQUVqRCxJQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDO0FBcUQ5QjtJQUF5Qix1QkFBUTtJQUMvQixhQUFzQixLQUFZO2VBQ2hDLGtCQUFNLEtBQUssQ0FBQztJQUNkLENBQUM7SUFFTSxrQkFBYyxHQUFyQixVQUFzQixLQUFZO1FBQ2hDLE9BQU8sSUFBSSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDeEIsQ0FBQztJQUVEOztPQUVHO0lBQ0ksMkJBQWEsR0FBcEI7UUFDRSxPQUFPLEdBQUcsQ0FBQztJQUNiLENBQUM7SUFFRDs7T0FFRztJQUNJLHNCQUFRLEdBQWY7UUFDRSxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRDs7T0FFRztJQUNJLHVCQUFTLEdBQWhCO1FBQ0UsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7O09BRUc7SUFDSSx5QkFBVyxHQUFsQjtRQUNFLE9BQU8sUUFBUSxDQUFDO0lBQ2xCLENBQUM7SUFFRDs7T0FFRztJQUNJLCtCQUFpQixHQUF4QixVQUF5QixPQUFlO1FBQ3RDLElB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dEIsVUFBdUIsSUFBYTtRQUNsQyxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ1QsMEVBQTBFO1lBQzFFLDBFQUEwRTtZQUMxRSxrRUFBa0U7WUFDbEUsSUFBSSxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQ3BDO1FBQ0QsSUFBTSxXQUFXLEdBQUcsdUJBQU0sQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDaEQsSUFBTSxJQUFJLEdBQUcsV0FBVyxDQUFDLFFBQVEsRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQy9DLE9BQU87WUFDTCxHQUFHLEVBQUUsSUFBSTtZQUNULEdBQUcsRUFBRSxXQUFXLENBQUMsUUFBUSxFQUFFO1NBQzVCLENBQUM7SUFDSixDQUFDO0lBRUQsOEJBQWdCLEdBQWhCLFVBQWlCLE1BQStCLEVBQUUsUUFBMEM7UUFDMUYsT0FBTyxRQUFRLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBQ0gsVUFBQztBQUFELENBQUMsQUE5bkJELENBQXlCLG1CQUFRLEdBOG5CaEM7QUE5bkJZLGtCQUFHIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7IEhETm9kZSwgRUNQYWlyIH0gZnJvbSAnYml0Z28tdXR4by1saWInO1xuaW1wb3J0ICogYXMgQmx1ZWJpcmQgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0ICogYXMgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgKiBhcyB1cmwgZnJvbSAndXJsJztcbmltcG9ydCAqIGFzIHF1ZXJ5c3RyaW5nIGZyb20gJ3F1ZXJ5c3RyaW5nJztcbmltcG9ydCB7IEJpdEdvIH0gZnJvbSAnLi4vLi4vYml0Z28nO1xuXG5pbXBvcnQgKiBhcyByaXBwbGVBZGRyZXNzQ29kZWMgZnJvbSAncmlwcGxlLWFkZHJlc3MtY29kZWMnO1xuaW1wb3J0ICogYXMgcmlwcGxlQmluYXJ5Q29kZWMgZnJvbSAncmlwcGxlLWJpbmFyeS1jb2RlYyc7XG5pbXBvcnQgeyBjb21wdXRlQmluYXJ5VHJhbnNhY3Rpb25IYXNoIH0gZnJvbSAncmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vaGFzaGVzJztcbmltcG9ydCAqIGFzIHJpcHBsZUtleXBhaXJzIGZyb20gJ3JpcHBsZS1rZXlwYWlycyc7XG5cbmltcG9ydCB7XG4gIEJhc2VDb2luLFxuICBUcmFuc2FjdGlvbkV4cGxhbmF0aW9uLFxuICBLZXlQYWlyLFxuICBWZXJpZnlBZGRyZXNzT3B0aW9ucyBhcyBCYXNlVmVyaWZ5QWRkcmVzc09wdGlvbnMsXG4gIFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zLFxuICBQYXJzZWRUcmFuc2FjdGlvbixcbiAgVHJhbnNhY3Rpb25QcmVidWlsZCxcbiAgVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLFxuICBJbml0aWF0ZVJlY292ZXJ5T3B0aW9ucyBhcyBCYXNlSW5pdGlhdGVSZWNvdmVyeU9wdGlvbnMsXG59IGZyb20gJy4uL2Jhc2VDb2luJztcbmltcG9ydCAqIGFzIGNvbmZpZyBmcm9tICcuLi8uLi9jb25maWcnO1xuaW1wb3J0IHsgTm9kZUNhbGxiYWNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgSW52YWxpZEFkZHJlc3NFcnJvciwgVW5leHBlY3RlZEFkZHJlc3NFcnJvciB9IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5cbmNvbnN0IHJpcHBsZSA9IHJlcXVpcmUoJy4uLy4uL3JpcHBsZScpO1xuY29uc3Qgc2pjbCA9IHJlcXVpcmUoJy4uLy4uL3ZlbmRvci9zamNsLm1pbi5qcycpO1xuXG5jb25zdCBjbyA9IEJsdWViaXJkLmNvcm91dGluZTtcblxuaW50ZXJmYWNlIEFkZHJlc3Mge1xuICBhZGRyZXNzOiBzdHJpbmc7XG4gIGRlc3RpbmF0aW9uVGFnPzogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgRmVlSW5mbyB7XG4gIGRhdGU6IHN0cmluZztcbiAgaGVpZ2h0OiBudW1iZXI7XG4gIGJhc2VSZXNlcnZlOiBzdHJpbmc7XG4gIGJhc2VGZWU6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eFByZWJ1aWxkOiBUcmFuc2FjdGlvblByZWJ1aWxkO1xuICBwcnY6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEV4cGxhaW5UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eEhleD86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFZlcmlmeUFkZHJlc3NPcHRpb25zIGV4dGVuZHMgQmFzZVZlcmlmeUFkZHJlc3NPcHRpb25zIHtcbiAgcm9vdEFkZHJlc3M6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFJlY292ZXJ5SW5mbyBleHRlbmRzIFRyYW5zYWN0aW9uRXhwbGFuYXRpb24ge1xuICB0eEhleDogc3RyaW5nO1xuICBiYWNrdXBLZXk/OiBzdHJpbmc7XG4gIGNvaW4/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5pdGlhdGVSZWNvdmVyeU9wdGlvbnMgZXh0ZW5kcyBCYXNlSW5pdGlhdGVSZWNvdmVyeU9wdGlvbnMge1xuICBrcnNQcm92aWRlcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWNvdmVyeU9wdGlvbnMge1xuICBiYWNrdXBLZXk6IHN0cmluZztcbiAgdXNlcktleTogc3RyaW5nO1xuICByb290QWRkcmVzczogc3RyaW5nO1xuICByZWNvdmVyeURlc3RpbmF0aW9uOiBzdHJpbmc7XG4gIGJpdGdvS2V5Pzogc3RyaW5nO1xuICB3YWxsZXRQYXNzcGhyYXNlOiBzdHJpbmc7XG4gIGtyc1Byb3ZpZGVyPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgSGFsZlNpZ25lZFRyYW5zYWN0aW9uIHtcbiAgaGFsZlNpZ25lZDoge1xuICAgIHR4SGV4OiBzdHJpbmdcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgWHJwIGV4dGVuZHMgQmFzZUNvaW4ge1xuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoYml0Z286IEJpdEdvKSB7XG4gICAgc3VwZXIoYml0Z28pO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZUluc3RhbmNlKGJpdGdvOiBCaXRHbyk6IEJhc2VDb2luIHtcbiAgICByZXR1cm4gbmV3IFhycChiaXRnbyk7XG4gIH1cblxuICAvKipcbiAgICogRmFjdG9yIGJldHdlZW4gdGhlIGNvaW4ncyBiYXNlIHVuaXQgYW5kIGl0cyBzbWFsbGVzdCBzdWJkaXZpc29uXG4gICAqL1xuICBwdWJsaWMgZ2V0QmFzZUZhY3RvcigpOiBudW1iZXIge1xuICAgIHJldHVybiAxZTY7XG4gIH1cblxuICAvKipcbiAgICogSWRlbnRpZmllciBmb3IgdGhlIGJsb2NrY2hhaW4gd2hpY2ggc3VwcG9ydHMgdGhpcyBjb2luXG4gICAqL1xuICBwdWJsaWMgZ2V0Q2hhaW4oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ3hycCc7XG4gIH1cblxuICAvKipcbiAgICogSWRlbnRpZmllciBmb3IgdGhlIGNvaW4gZmFtaWx5XG4gICAqL1xuICBwdWJsaWMgZ2V0RmFtaWx5KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICd4cnAnO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhpcyBjb2luXG4gICAqL1xuICBwdWJsaWMgZ2V0RnVsbE5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ1JpcHBsZSc7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYW4gYWRkcmVzcyBzdHJpbmcgaW50byBhZGRyZXNzIGFuZCBkZXN0aW5hdGlvbiB0YWdcbiAgICovXG4gIHB1YmxpYyBnZXRBZGRyZXNzRGV0YWlscyhhZGRyZXNzOiBzdHJpbmcpOiBBZGRyZXNzIHtcbiAgICBjb25zdCBkZXN0aW5hdGlvbkRldGFpbHMgPSB1cmwucGFyc2UoYWRkcmVzcyk7XG4gICAgY29uc3QgZGVzdGluYXRpb25BZGRyZXNzID0gZGVzdGluYXRpb25EZXRhaWxzLnBhdGhuYW1lO1xuICAgIGlmICghZGVzdGluYXRpb25BZGRyZXNzIHx8ICFyaXBwbGVBZGRyZXNzQ29kZWMuaXNWYWxpZENsYXNzaWNBZGRyZXNzKGRlc3RpbmF0aW9uQWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKGBkZXN0aW5hdGlvbiBhZGRyZXNzIFwiJHtkZXN0aW5hdGlvbkFkZHJlc3N9XCIgaXMgbm90IHZhbGlkYCk7XG4gICAgfVxuICAgIC8vIHRoZXJlIGFyZSBubyBvdGhlciBwcm9wZXJ0aWVzIGxpa2UgZGVzdGluYXRpb24gdGFnc1xuICAgIGlmIChkZXN0aW5hdGlvbkRldGFpbHMucGF0aG5hbWUgPT09IGFkZHJlc3MpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgIGRlc3RpbmF0aW9uVGFnOiB1bmRlZmluZWQsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghZGVzdGluYXRpb25EZXRhaWxzLnF1ZXJ5KSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcignbm8gcXVlcnkgcGFyYW1zIHByZXNlbnQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBxdWVyeURldGFpbHMgPSBxdWVyeXN0cmluZy5wYXJzZShkZXN0aW5hdGlvbkRldGFpbHMucXVlcnkpO1xuICAgIGlmICghcXVlcnlEZXRhaWxzLmR0KSB7XG4gICAgICAvLyBpZiB0aGVyZSBhcmUgbW9yZSBwcm9wZXJ0aWVzLCB0aGUgcXVlcnkgZGV0YWlscyBuZWVkIHRvIGNvbnRhaW4gdGhlIGRlc3RpbmF0aW9uIHRhZyBwcm9wZXJ0eS5cbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKCdkZXN0aW5hdGlvbiB0YWcgbWlzc2luZycpO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHF1ZXJ5RGV0YWlscy5kdCkpIHtcbiAgICAgIC8vIGlmIHF1ZXJ5RGV0YWlscy5kdCBpcyBhbiBhcnJheSwgdGhhdCBtZWFucyBkdCB3YXMgZ2l2ZW4gbXVsdGlwbGUgdGltZXMsIHdoaWNoIGlzIG5vdCB2YWxpZFxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoYGRlc3RpbmF0aW9uIHRhZyBjYW4gYXBwZWFyIGF0IG1vc3Qgb25jZSwgYnV0ICR7cXVlcnlEZXRhaWxzLmR0Lmxlbmd0aH0gZGVzdGluYXRpb24gdGFncyB3ZXJlIGZvdW5kYCk7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyc2VkVGFnID0gcGFyc2VJbnQocXVlcnlEZXRhaWxzLmR0LCAxMCk7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihwYXJzZWRUYWcpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcignaW52YWxpZCBkZXN0aW5hdGlvbiB0YWcnKTtcbiAgICB9XG5cbiAgICBpZiAocGFyc2VkVGFnID4gMHhGRkZGRkZGRiB8fCBwYXJzZWRUYWcgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcignZGVzdGluYXRpb24gdGFnIG91dCBvZiByYW5nZScpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhZGRyZXNzOiBkZXN0aW5hdGlvbkFkZHJlc3MsXG4gICAgICBkZXN0aW5hdGlvblRhZzogcGFyc2VkVGFnLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgZnVsbCwgbm9ybWFsaXplZCBhZGRyZXNzIGZyb20gYW4gYWRkcmVzcyBhbmQgZGVzdGluYXRpb24gdGFnXG4gICAqL1xuICBwdWJsaWMgbm9ybWFsaXplQWRkcmVzcyh7IGFkZHJlc3MsIGRlc3RpbmF0aW9uVGFnIH06IEFkZHJlc3MpOiBzdHJpbmcge1xuICAgIGlmICghXy5pc1N0cmluZyhhZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoJ2ludmFsaWQgYWRkcmVzcyBkZXRhaWxzJyk7XG4gICAgfVxuICAgIGlmIChfLmlzSW50ZWdlcihkZXN0aW5hdGlvblRhZykpIHtcbiAgICAgIHJldHVybiBgJHthZGRyZXNzfT9kdD0ke2Rlc3RpbmF0aW9uVGFnfWA7XG4gICAgfVxuICAgIHJldHVybiBhZGRyZXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlcyB3aGV0aGVyIGFuIGFkZHJlc3Mgc3RyaW5nIGlzIHZhbGlkIGZvciB0aGlzIGNvaW5cbiAgICogQHBhcmFtIGFkZHJlc3NcbiAgICovXG4gIHB1YmxpYyBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYWRkcmVzc0RldGFpbHMgPSB0aGlzLmdldEFkZHJlc3NEZXRhaWxzKGFkZHJlc3MpO1xuICAgICAgcmV0dXJuIGFkZHJlc3MgPT09IHRoaXMubm9ybWFsaXplQWRkcmVzcyhhZGRyZXNzRGV0YWlscyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaW5wdXQgaXMgdmFsaWQgcHVibGljIGtleSBmb3IgdGhlIGNvaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwdWIgdGhlIHB1YiB0byBiZSBjaGVja2VkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBpcyBpdCB2YWxpZD9cbiAgICovXG4gIHB1YmxpYyBpc1ZhbGlkUHViKHB1Yjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIEhETm9kZS5mcm9tQmFzZTU4KHB1Yik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBmZWUgaW5mbyBmcm9tIHNlcnZlclxuICAgKi9cbiAgcHVibGljIGdldEZlZUluZm8oXz8sIGNhbGxiYWNrPyk6IFByb21pc2U8RmVlSW5mbz4ge1xuICAgIHJldHVybiB0aGlzLmJpdGdvLmdldCh0aGlzLnVybCgnL3B1YmxpYy9mZWVpbmZvJykpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlbWJsZSBrZXljaGFpbiBhbmQgaGFsZi1zaWduIHByZWJ1aWx0IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogLSB0eFByZWJ1aWxkXG4gICAqIC0gcHJ2XG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyBCbHVlYmlyZDxIYWxmU2lnbmVkVHJhbnNhY3Rpb24+XG4gICAqL1xuICBwdWJsaWMgc2lnblRyYW5zYWN0aW9uKHsgdHhQcmVidWlsZCwgcHJ2IH06IFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPEhhbGZTaWduZWRUcmFuc2FjdGlvbj4pOiBCbHVlYmlyZDxIYWxmU2lnbmVkVHJhbnNhY3Rpb24+IHtcbiAgICByZXR1cm4gY288SGFsZlNpZ25lZFRyYW5zYWN0aW9uPihmdW5jdGlvbiAqKCkge1xuICAgICAgaWYgKF8uaXNVbmRlZmluZWQodHhQcmVidWlsZCkgfHwgIV8uaXNPYmplY3QodHhQcmVidWlsZCkpIHtcbiAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHR4UHJlYnVpbGQpICYmICFfLmlzT2JqZWN0KHR4UHJlYnVpbGQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB0eFByZWJ1aWxkIG11c3QgYmUgYW4gb2JqZWN0LCBnb3QgdHlwZSAke3R5cGVvZiB0eFByZWJ1aWxkfWApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyB0eFByZWJ1aWxkIHBhcmFtZXRlcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChwcnYpIHx8ICFfLmlzU3RyaW5nKHBydikpIHtcbiAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBydikgJiYgIV8uaXNTdHJpbmcocHJ2KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcHJ2IG11c3QgYmUgYSBzdHJpbmcsIGdvdCB0eXBlICR7dHlwZW9mIHBydn1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcHJ2IHBhcmFtZXRlciB0byBzaWduIHRyYW5zYWN0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVzZXJLZXkgPSBIRE5vZGUuZnJvbUJhc2U1OChwcnYpLmdldEtleSgpO1xuICAgICAgY29uc3QgdXNlclByaXZhdGVLZXk6IEJ1ZmZlciA9IHVzZXJLZXkuZ2V0UHJpdmF0ZUtleUJ1ZmZlcigpO1xuICAgICAgY29uc3QgdXNlckFkZHJlc3MgPSByaXBwbGVLZXlwYWlycy5kZXJpdmVBZGRyZXNzKHVzZXJLZXkuZ2V0UHVibGljS2V5QnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpKTtcblxuICAgICAgY29uc3QgcmlwcGxlTGliID0gcmlwcGxlKCk7XG4gICAgICBjb25zdCBoYWxmU2lnbmVkID0gcmlwcGxlTGliLnNpZ25XaXRoUHJpdmF0ZUtleSh0eFByZWJ1aWxkLnR4SGV4LCB1c2VyUHJpdmF0ZUtleS50b1N0cmluZygnaGV4JyksIHsgc2lnbkFzOiB1c2VyQWRkcmVzcyB9KTtcbiAgICAgIHJldHVybiB7IGhhbGZTaWduZWQ6IHsgdHhIZXg6IGhhbGZTaWduZWQuc2lnbmVkVHJhbnNhY3Rpb24gfSB9O1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFJpcHBsZSByZXF1aXJlcyBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHdhbGxldCBnZW5lcmF0aW9uIHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlci4gVGhlIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBhcmVcbiAgICogdGhlIHJvb3QgcHVibGljIGtleSwgd2hpY2ggaXMgdGhlIGJhc2lzIG9mIHRoZSByb290IGFkZHJlc3MsIHR3byBzaWduZWQsIGFuZCBvbmUgaGFsZi1zaWduZWQgaW5pdGlhbGl6YXRpb24gdHhzXG4gICAqIEBwYXJhbSB3YWxsZXRQYXJhbXNcbiAgICogLSByb290UHJpdmF0ZUtleTogb3B0aW9uYWwgaGV4LWVuY29kZWQgUmlwcGxlIHByaXZhdGUga2V5XG4gICAqIEBwYXJhbSBrZXljaGFpbnNcbiAgICovXG4gIHN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldCh3YWxsZXRQYXJhbXMsIGtleWNoYWlucyk6IEJsdWViaXJkPGFueT4ge1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqKCkge1xuICAgICAgY29uc3QgeyB1c2VyS2V5Y2hhaW4sIGJhY2t1cEtleWNoYWluLCBiaXRnb0tleWNoYWluIH0gPSBrZXljaGFpbnM7XG5cbiAgICAgIGNvbnN0IHVzZXJLZXkgPSBIRE5vZGUuZnJvbUJhc2U1OCh1c2VyS2V5Y2hhaW4ucHViKS5nZXRLZXkoKTtcbiAgICAgIGNvbnN0IHVzZXJBZGRyZXNzID0gcmlwcGxlS2V5cGFpcnMuZGVyaXZlQWRkcmVzcyh1c2VyS2V5LmdldFB1YmxpY0tleUJ1ZmZlcigpLnRvU3RyaW5nKCdoZXgnKSk7XG5cbiAgICAgIGNvbnN0IGJhY2t1cEtleSA9IEhETm9kZS5mcm9tQmFzZTU4KGJhY2t1cEtleWNoYWluLnB1YikuZ2V0S2V5KCk7XG4gICAgICBjb25zdCBiYWNrdXBBZGRyZXNzID0gcmlwcGxlS2V5cGFpcnMuZGVyaXZlQWRkcmVzcyhiYWNrdXBLZXkuZ2V0UHVibGljS2V5QnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpKTtcblxuICAgICAgY29uc3QgYml0Z29LZXkgPSBIRE5vZGUuZnJvbUJhc2U1OChiaXRnb0tleWNoYWluLnB1YikuZ2V0S2V5KCk7XG4gICAgICBjb25zdCBiaXRnb0FkZHJlc3MgPSByaXBwbGVLZXlwYWlycy5kZXJpdmVBZGRyZXNzKGJpdGdvS2V5LmdldFB1YmxpY0tleUJ1ZmZlcigpLnRvU3RyaW5nKCdoZXgnKSk7XG5cbiAgICAgIC8vIGluaXRpYWxseSwgd2UgbmVlZCB0byBnZW5lcmF0ZSBhIHJhbmRvbSByb290IGFkZHJlc3Mgd2hpY2ggaGFzIHRvIGJlIGRpc3RpbmN0IGZyb20gYWxsIHRocmVlIGtleWNoYWluc1xuICAgICAgbGV0IGtleVBhaXIgPSBFQ1BhaXIubWFrZVJhbmRvbSgpO1xuICAgICAgaWYgKHdhbGxldFBhcmFtcy5yb290UHJpdmF0ZUtleSkge1xuICAgICAgICBjb25zdCByb290UHJpdmF0ZUtleSA9IHdhbGxldFBhcmFtcy5yb290UHJpdmF0ZUtleTtcbiAgICAgICAgaWYgKHR5cGVvZiByb290UHJpdmF0ZUtleSAhPT0gJ3N0cmluZycgfHwgcm9vdFByaXZhdGVLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncm9vdFByaXZhdGVLZXkgbmVlZHMgdG8gYmUgYSBoZXhhZGVjaW1hbCBwcml2YXRlIGtleSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBrZXlQYWlyID0gRUNQYWlyLmZyb21Qcml2YXRlS2V5QnVmZmVyKEJ1ZmZlci5mcm9tKHdhbGxldFBhcmFtcy5yb290UHJpdmF0ZUtleSwgJ2hleCcpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByaXZhdGVLZXk6IEJ1ZmZlciA9IGtleVBhaXIuZ2V0UHJpdmF0ZUtleUJ1ZmZlcigpO1xuICAgICAgY29uc3QgcHVibGljS2V5OiBCdWZmZXIgPSBrZXlQYWlyLmdldFB1YmxpY0tleUJ1ZmZlcigpO1xuICAgICAgY29uc3Qgcm9vdEFkZHJlc3MgPSByaXBwbGVLZXlwYWlycy5kZXJpdmVBZGRyZXNzKHB1YmxpY0tleS50b1N0cmluZygnaGV4JykpO1xuXG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIGNvbnN0IHJpcHBsZUxpYiA9IHJpcHBsZSgpO1xuXG4gICAgICBjb25zdCBmZWVJbmZvID0geWllbGQgc2VsZi5nZXRGZWVJbmZvKCk7XG4gICAgICBjb25zdCBvcGVuTGVkZ2VyRmVlID0gbmV3IEJpZ051bWJlcihmZWVJbmZvLnhycE9wZW5MZWRnZXJGZWUpO1xuICAgICAgY29uc3QgbWVkaWFuRmVlID0gbmV3IEJpZ051bWJlcihmZWVJbmZvLnhycE1lZGlhbkZlZSk7XG4gICAgICBjb25zdCBmZWUgPSBCaWdOdW1iZXIubWF4KG9wZW5MZWRnZXJGZWUsIG1lZGlhbkZlZSkudGltZXMoMS41KS50b0ZpeGVkKDApO1xuXG4gICAgICAvLyBjb25maWd1cmUgbXVsdGlzaWduZXJzXG4gICAgICBjb25zdCBtdWx0aXNpZ0Fzc2lnbm1lbnRUeCA9IHtcbiAgICAgICAgVHJhbnNhY3Rpb25UeXBlOiAnU2lnbmVyTGlzdFNldCcsXG4gICAgICAgIEFjY291bnQ6IHJvb3RBZGRyZXNzLFxuICAgICAgICBTaWduZXJRdW9ydW06IDIsXG4gICAgICAgIFNpZ25lckVudHJpZXM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBTaWduZXJFbnRyeToge1xuICAgICAgICAgICAgICBBY2NvdW50OiB1c2VyQWRkcmVzcyxcbiAgICAgICAgICAgICAgU2lnbmVyV2VpZ2h0OiAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBTaWduZXJFbnRyeToge1xuICAgICAgICAgICAgICBBY2NvdW50OiBiYWNrdXBBZGRyZXNzLFxuICAgICAgICAgICAgICBTaWduZXJXZWlnaHQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIFNpZ25lckVudHJ5OiB7XG4gICAgICAgICAgICAgIEFjY291bnQ6IGJpdGdvQWRkcmVzcyxcbiAgICAgICAgICAgICAgU2lnbmVyV2VpZ2h0OiAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBGbGFnczogMjE0NzQ4MzY0OCxcbiAgICAgICAgLy8gTGFzdExlZGdlclNlcXVlbmNlOiBsZWRnZXJWZXJzaW9uICsgMTAsXG4gICAgICAgIEZlZTogZmVlLFxuICAgICAgICBTZXF1ZW5jZTogMVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNpZ25lZE11bHRpc2lnQXNzaWdubWVudFR4ID0gcmlwcGxlTGliLnNpZ25XaXRoUHJpdmF0ZUtleShKU09OLnN0cmluZ2lmeShtdWx0aXNpZ0Fzc2lnbm1lbnRUeCksIHByaXZhdGVLZXkudG9TdHJpbmcoJ2hleCcpKTtcblxuICAgICAgLy8gZW5mb3JjZSBkZXN0aW5hdGlvbiB0YWdzXG4gICAgICBjb25zdCBkZXN0aW5hdGlvblRhZ1R4ID0ge1xuICAgICAgICBUcmFuc2FjdGlvblR5cGU6ICdBY2NvdW50U2V0JyxcbiAgICAgICAgQWNjb3VudDogcm9vdEFkZHJlc3MsXG4gICAgICAgIFNldEZsYWc6IDEsXG4gICAgICAgIEZsYWdzOiAyMTQ3NDgzNjQ4LFxuICAgICAgICAvLyBMYXN0TGVkZ2VyU2VxdWVuY2U6IGxlZGdlclZlcnNpb24gKyAxMCxcbiAgICAgICAgRmVlOiBmZWUsXG4gICAgICAgIFNlcXVlbmNlOiAyXG4gICAgICB9O1xuICAgICAgY29uc3Qgc2lnbmVkRGVzdGluYXRpb25UYWdUeCA9IHJpcHBsZUxpYi5zaWduV2l0aFByaXZhdGVLZXkoSlNPTi5zdHJpbmdpZnkoZGVzdGluYXRpb25UYWdUeCksIHByaXZhdGVLZXkudG9TdHJpbmcoJ2hleCcpKTtcblxuICAgICAgLy8gZGlzYWJsZSBtYXN0ZXIga2V5XG4gICAgICBjb25zdCBtYXN0ZXJEZWFjdGl2YXRpb25UeCA9IHtcbiAgICAgICAgVHJhbnNhY3Rpb25UeXBlOiAnQWNjb3VudFNldCcsXG4gICAgICAgIEFjY291bnQ6IHJvb3RBZGRyZXNzLFxuICAgICAgICBTZXRGbGFnOiA0LFxuICAgICAgICBGbGFnczogMjE0NzQ4MzY0OCxcbiAgICAgICAgLy8gTGFzdExlZGdlclNlcXVlbmNlOiBsZWRnZXJWZXJzaW9uICsgMTAsXG4gICAgICAgIEZlZTogZmVlLFxuICAgICAgICBTZXF1ZW5jZTogM1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNpZ25lZE1hc3RlckRlYWN0aXZhdGlvblR4ID0gcmlwcGxlTGliLnNpZ25XaXRoUHJpdmF0ZUtleShKU09OLnN0cmluZ2lmeShtYXN0ZXJEZWFjdGl2YXRpb25UeCksIHByaXZhdGVLZXkudG9TdHJpbmcoJ2hleCcpKTtcblxuICAgICAgLy8gZXh0ZW5kIHRoZSB3YWxsZXQgaW5pdGlhbGl6YXRpb24gcGFyYW1zXG4gICAgICB3YWxsZXRQYXJhbXMucm9vdFB1YiA9IHB1YmxpY0tleS50b1N0cmluZygnaGV4Jyk7XG4gICAgICB3YWxsZXRQYXJhbXMuaW5pdGlhbGl6YXRpb25UeHMgPSB7XG4gICAgICAgIHNldE11bHRpc2lnOiBzaWduZWRNdWx0aXNpZ0Fzc2lnbm1lbnRUeC5zaWduZWRUcmFuc2FjdGlvbixcbiAgICAgICAgZGlzYWJsZU1hc3RlcktleTogc2lnbmVkTWFzdGVyRGVhY3RpdmF0aW9uVHguc2lnbmVkVHJhbnNhY3Rpb24sXG4gICAgICAgIGZvcmNlRGVzdGluYXRpb25UYWc6IHNpZ25lZERlc3RpbmF0aW9uVGFnVHguc2lnbmVkVHJhbnNhY3Rpb25cbiAgICAgIH07XG4gICAgICByZXR1cm4gd2FsbGV0UGFyYW1zO1xuICAgIH0pLmNhbGwodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogRXhwbGFpbi9wYXJzZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgZXhwbGFpblRyYW5zYWN0aW9uKHBhcmFtczogRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxUcmFuc2FjdGlvbkV4cGxhbmF0aW9uPik6IEJsdWViaXJkPFRyYW5zYWN0aW9uRXhwbGFuYXRpb24+IHtcbiAgICByZXR1cm4gY288VHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4oZnVuY3Rpb24gKigpIHtcbiAgICAgIGlmICghcGFyYW1zLnR4SGV4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBwYXJhbSB0eEhleCcpO1xuICAgICAgfVxuICAgICAgbGV0IHRyYW5zYWN0aW9uO1xuICAgICAgbGV0IHR4SGV4O1xuICAgICAgdHJ5IHtcbiAgICAgICAgdHJhbnNhY3Rpb24gPSByaXBwbGVCaW5hcnlDb2RlYy5kZWNvZGUocGFyYW1zLnR4SGV4KTtcbiAgICAgICAgdHhIZXggPSBwYXJhbXMudHhIZXg7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24gPSBKU09OLnBhcnNlKHBhcmFtcy50eEhleCk7XG4gICAgICAgICAgdHhIZXggPSByaXBwbGVCaW5hcnlDb2RlYy5lbmNvZGUodHJhbnNhY3Rpb24pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eEhleCBuZWVkcyB0byBiZSBlaXRoZXIgaGV4IG9yIEpTT04gc3RyaW5nIGZvciBYUlAnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgaWQgPSBjb21wdXRlQmluYXJ5VHJhbnNhY3Rpb25IYXNoKHR4SGV4KTtcbiAgICAgIGNvbnN0IGFkZHJlc3MgPSB0cmFuc2FjdGlvbi5EZXN0aW5hdGlvbiArICgodHJhbnNhY3Rpb24uRGVzdGluYXRpb25UYWcgPj0gMCkgPyAnP2R0PScgKyB0cmFuc2FjdGlvbi5EZXN0aW5hdGlvblRhZyA6ICcnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpc3BsYXlPcmRlcjogWydpZCcsICdvdXRwdXRBbW91bnQnLCAnY2hhbmdlQW1vdW50JywgJ291dHB1dHMnLCAnY2hhbmdlT3V0cHV0cycsICdmZWUnXSxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBjaGFuZ2VPdXRwdXRzOiBbXSxcbiAgICAgICAgb3V0cHV0QW1vdW50OiB0cmFuc2FjdGlvbi5BbW91bnQsXG4gICAgICAgIGNoYW5nZUFtb3VudDogMCxcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICBhbW91bnQ6IHRyYW5zYWN0aW9uLkFtb3VudFxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgZmVlOiB7XG4gICAgICAgICAgZmVlOiB0cmFuc2FjdGlvbi5GZWUsXG4gICAgICAgICAgZmVlUmF0ZTogbnVsbCxcbiAgICAgICAgICBzaXplOiB0eEhleC5sZW5ndGggLyAyXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgdGhhdCBhIHRyYW5zYWN0aW9uIHByZWJ1aWxkIGNvbXBsaWVzIHdpdGggdGhlIG9yaWdpbmFsIGludGVudGlvblxuICAgKiBAcGFyYW0gdHhQYXJhbXMgcGFyYW1zIG9iamVjdCBwYXNzZWQgdG8gc2VuZFxuICAgKiBAcGFyYW0gdHhQcmVidWlsZCBwcmVidWlsZCBvYmplY3QgcmV0dXJuZWQgYnkgc2VydmVyXG4gICAqIEBwYXJhbSB3YWxsZXRcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgcHVibGljIHZlcmlmeVRyYW5zYWN0aW9uKHsgdHhQYXJhbXMsIHR4UHJlYnVpbGQgfTogVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLCBjYWxsYmFjayk6IEJsdWViaXJkPGJvb2xlYW4+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288Ym9vbGVhbj4oZnVuY3Rpb24gKigpIHtcbiAgICAgIGNvbnN0IGV4cGxhbmF0aW9uID0geWllbGQgc2VsZi5leHBsYWluVHJhbnNhY3Rpb24oe1xuICAgICAgICB0eEhleDogdHhQcmVidWlsZC50eEhleFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG91dHB1dCA9IFsuLi5leHBsYW5hdGlvbi5vdXRwdXRzLCAuLi5leHBsYW5hdGlvbi5jaGFuZ2VPdXRwdXRzXVswXTtcbiAgICAgIGNvbnN0IGV4cGVjdGVkT3V0cHV0ID0gdHhQYXJhbXMucmVjaXBpZW50cyAmJiB0eFBhcmFtcy5yZWNpcGllbnRzWzBdO1xuXG4gICAgICBjb25zdCBjb21wYXJhdG9yID0gKHJlY2lwaWVudDEsIHJlY2lwaWVudDIpID0+IHtcbiAgICAgICAgaWYgKHJlY2lwaWVudDEuYWRkcmVzcyAhPT0gcmVjaXBpZW50Mi5hZGRyZXNzKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFtb3VudDEgPSBuZXcgQmlnTnVtYmVyKHJlY2lwaWVudDEuYW1vdW50KTtcbiAgICAgICAgY29uc3QgYW1vdW50MiA9IG5ldyBCaWdOdW1iZXIocmVjaXBpZW50Mi5hbW91bnQpO1xuICAgICAgICByZXR1cm4gYW1vdW50MS50b0ZpeGVkKCkgPT09IGFtb3VudDIudG9GaXhlZCgpO1xuICAgICAgfTtcblxuICAgICAgaWYgKCFjb21wYXJhdG9yKG91dHB1dCwgZXhwZWN0ZWRPdXRwdXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNhY3Rpb24gcHJlYnVpbGQgZG9lcyBub3QgbWF0Y2ggZXhwZWN0ZWQgb3V0cHV0Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYWRkcmVzcyBpcyBhIHZhbGlkIFhSUCBhZGRyZXNzLCBhbmQgdGhlbiBtYWtlIHN1cmUgdGhlIHJvb3QgYWRkcmVzc2VzIG1hdGNoLlxuICAgKiBUaGlzIHByZXZlbnRzIGF0dGFja3Mgd2hlcmUgYW4gYXR0YWNrIG1heSBzd2l0Y2ggb3V0IHRoZSBuZXcgYWRkcmVzcyBmb3Igb25lIG9mIHRoZWlyIG93blxuICAgKiBAcGFyYW0gYWRkcmVzcyB7U3RyaW5nfSB0aGUgYWRkcmVzcyB0byB2ZXJpZnlcbiAgICogQHBhcmFtIHJvb3RBZGRyZXNzIHtTdHJpbmd9IHRoZSB3YWxsZXQncyByb290IGFkZHJlc3NcbiAgICovXG4gIHB1YmxpYyB2ZXJpZnlBZGRyZXNzKHsgYWRkcmVzcywgcm9vdEFkZHJlc3MgfTogVmVyaWZ5QWRkcmVzc09wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKGBhZGRyZXNzIHZlcmlmaWNhdGlvbiBmYWlsdXJlOiBhZGRyZXNzIFwiJHthZGRyZXNzfVwiIGlzIG5vdCB2YWxpZGApO1xuICAgIH1cblxuICAgIGNvbnN0IGFkZHJlc3NEZXRhaWxzID0gdGhpcy5nZXRBZGRyZXNzRGV0YWlscyhhZGRyZXNzKTtcbiAgICBjb25zdCByb290QWRkcmVzc0RldGFpbHMgPSB0aGlzLmdldEFkZHJlc3NEZXRhaWxzKHJvb3RBZGRyZXNzKTtcblxuICAgIGlmIChhZGRyZXNzRGV0YWlscy5hZGRyZXNzICE9PSByb290QWRkcmVzc0RldGFpbHMuYWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRBZGRyZXNzRXJyb3IoYGFkZHJlc3MgdmFsaWRhdGlvbiBmYWlsdXJlOiAke2FkZHJlc3NEZXRhaWxzLmFkZHJlc3N9IHZzLiAke3Jvb3RBZGRyZXNzRGV0YWlscy5hZGRyZXNzfWApO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVSTCBvZiBhIHdlbGwta25vd24sIHB1YmxpYyBmYWNpbmcgKG5vbi1iaXRnbykgcmlwcGxlZCBpbnN0YW5jZSB3aGljaCBjYW4gYmUgdXNlZCBmb3IgcmVjb3ZlcnlcbiAgICovXG4gIHB1YmxpYyBnZXRSaXBwbGVkVXJsKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdodHRwczovL3MxLnJpcHBsZS5jb206NTEyMzQnO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhIGZ1bmRzIHJlY292ZXJ5IHRyYW5zYWN0aW9uIHdpdGhvdXQgQml0R29cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiAtIHJvb3RBZGRyZXNzOiByb290IFhSUCB3YWxsZXQgYWRkcmVzcyB0byByZWNvdmVyIGZ1bmRzIGZyb21cbiAgICogLSB1c2VyS2V5OiBbZW5jcnlwdGVkXSB4cHJ2XG4gICAqIC0gYmFja3VwS2V5OiBbZW5jcnlwdGVkXSB4cHJ2LCBvciB4cHViIGlmIHRoZSB4cHJ2IGlzIGhlbGQgYnkgYSBLUlMgcHJvdmlkZXJcbiAgICogLSB3YWxsZXRQYXNzcGhyYXNlOiBuZWNlc3NhcnkgaWYgb25lIG9mIHRoZSB4cHJ2cyBpcyBlbmNyeXB0ZWRcbiAgICogLSBiaXRnb0tleTogeHB1YlxuICAgKiAtIGtyc1Byb3ZpZGVyOiBuZWNlc3NhcnkgaWYgYmFja3VwIGtleSBpcyBoZWxkIGJ5IEtSU1xuICAgKiAtIHJlY292ZXJ5RGVzdGluYXRpb246IHRhcmdldCBhZGRyZXNzIHRvIHNlbmQgcmVjb3ZlcmVkIGZ1bmRzIHRvXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgcHVibGljIHJlY292ZXIocGFyYW1zOiBSZWNvdmVyeU9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFJlY292ZXJ5SW5mbyB8IHN0cmluZz4pOiBCbHVlYmlyZDxSZWNvdmVyeUluZm8gfCBzdHJpbmc+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288UmVjb3ZlcnlJbmZvIHwgc3RyaW5nPihmdW5jdGlvbiAqZXhwbGFpblRyYW5zYWN0aW9uKCkge1xuICAgICAgY29uc3QgcmlwcGxlZFVybCA9IHNlbGYuZ2V0UmlwcGxlZFVybCgpO1xuICAgICAgY29uc3QgaXNLcnNSZWNvdmVyeSA9IHBhcmFtcy5iYWNrdXBLZXkuc3RhcnRzV2l0aCgneHB1YicpICYmICFwYXJhbXMudXNlcktleS5zdGFydHNXaXRoKCd4cHViJyk7XG4gICAgICBjb25zdCBpc1Vuc2lnbmVkU3dlZXAgPSBwYXJhbXMuYmFja3VwS2V5LnN0YXJ0c1dpdGgoJ3hwdWInKSAmJiBwYXJhbXMudXNlcktleS5zdGFydHNXaXRoKCd4cHViJyk7XG5cbiAgICAgIGNvbnN0IGFjY291bnRJbmZvUGFyYW1zID0ge1xuICAgICAgICBtZXRob2Q6ICdhY2NvdW50X2luZm8nLFxuICAgICAgICBwYXJhbXM6IFt7XG4gICAgICAgICAgYWNjb3VudDogcGFyYW1zLnJvb3RBZGRyZXNzLFxuICAgICAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgICAgICBsZWRnZXJfaW5kZXg6ICdjdXJyZW50JyxcbiAgICAgICAgICBxdWV1ZTogdHJ1ZSxcbiAgICAgICAgICBzaWduZXJfbGlzdHM6IHRydWUsXG4gICAgICAgIH1dLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgeyBrZXlzLCBhZGRyZXNzRGV0YWlscywgZmVlRGV0YWlscywgc2VydmVyRGV0YWlscyB9ID0geWllbGQgQmx1ZWJpcmQucHJvcHMoe1xuICAgICAgICBrZXlzOiBzZWxmLmluaXRpYXRlUmVjb3ZlcnkocGFyYW1zKSxcbiAgICAgICAgYWRkcmVzc0RldGFpbHM6IHNlbGYuYml0Z28ucG9zdChyaXBwbGVkVXJsKS5zZW5kKGFjY291bnRJbmZvUGFyYW1zKSxcbiAgICAgICAgZmVlRGV0YWlsczogc2VsZi5iaXRnby5wb3N0KHJpcHBsZWRVcmwpLnNlbmQoeyBtZXRob2Q6ICdmZWUnIH0pLFxuICAgICAgICBzZXJ2ZXJEZXRhaWxzOiBzZWxmLmJpdGdvLnBvc3QocmlwcGxlZFVybCkuc2VuZCh7IG1ldGhvZDogJ3NlcnZlcl9pbmZvJyB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBvcGVuTGVkZ2VyRmVlID0gbmV3IEJpZ051bWJlcihmZWVEZXRhaWxzLmJvZHkucmVzdWx0LmRyb3BzLm9wZW5fbGVkZ2VyX2ZlZSk7XG4gICAgICBjb25zdCBiYXNlUmVzZXJ2ZSA9IG5ldyBCaWdOdW1iZXIoc2VydmVyRGV0YWlscy5ib2R5LnJlc3VsdC5pbmZvLnZhbGlkYXRlZF9sZWRnZXIucmVzZXJ2ZV9iYXNlX3hycCkudGltZXMoc2VsZi5nZXRCYXNlRmFjdG9yKCkpO1xuICAgICAgY29uc3QgcmVzZXJ2ZURlbHRhID0gbmV3IEJpZ051bWJlcihzZXJ2ZXJEZXRhaWxzLmJvZHkucmVzdWx0LmluZm8udmFsaWRhdGVkX2xlZGdlci5yZXNlcnZlX2luY194cnApLnRpbWVzKHNlbGYuZ2V0QmFzZUZhY3RvcigpKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRMZWRnZXIgPSBzZXJ2ZXJEZXRhaWxzLmJvZHkucmVzdWx0LmluZm8udmFsaWRhdGVkX2xlZGdlci5zZXE7XG4gICAgICBjb25zdCBzZXF1ZW5jZUlkID0gYWRkcmVzc0RldGFpbHMuYm9keS5yZXN1bHQuYWNjb3VudF9kYXRhLlNlcXVlbmNlO1xuICAgICAgY29uc3QgYmFsYW5jZSA9IG5ldyBCaWdOdW1iZXIoYWRkcmVzc0RldGFpbHMuYm9keS5yZXN1bHQuYWNjb3VudF9kYXRhLkJhbGFuY2UpO1xuICAgICAgY29uc3Qgc2lnbmVyTGlzdHMgPSBhZGRyZXNzRGV0YWlscy5ib2R5LnJlc3VsdC5hY2NvdW50X2RhdGEuc2lnbmVyX2xpc3RzO1xuICAgICAgY29uc3QgYWNjb3VudEZsYWdzID0gYWRkcmVzc0RldGFpbHMuYm9keS5yZXN1bHQuYWNjb3VudF9kYXRhLkZsYWdzO1xuXG4gICAgICAvLyBtYWtlIHN1cmUgdGhlcmUgaXMgb25seSBvbmUgc2lnbmVyIGxpc3Qgc2V0XG4gICAgICBpZiAoc2lnbmVyTGlzdHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBzZXQgb2Ygc2lnbmVyIGxpc3RzJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgc2lnbmVycyBhcmUgdXNlciwgYmFja3VwLCBiaXRnb1xuICAgICAgY29uc3QgdXNlckFkZHJlc3MgPSByaXBwbGVLZXlwYWlycy5kZXJpdmVBZGRyZXNzKGtleXNbMF0uZ2V0UHVibGljS2V5QnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpKTtcbiAgICAgIGNvbnN0IGJhY2t1cEFkZHJlc3MgPSByaXBwbGVLZXlwYWlycy5kZXJpdmVBZGRyZXNzKGtleXNbMV0uZ2V0UHVibGljS2V5QnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpKTtcblxuICAgICAgY29uc3Qgc2lnbmVyTGlzdCA9IHNpZ25lckxpc3RzWzBdO1xuICAgICAgaWYgKHNpZ25lckxpc3QuU2lnbmVyUXVvcnVtICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBtaW5pbXVtIHNpZ25hdHVyZSBjb3VudCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgZm91bmRBZGRyZXNzZXMgPSB7fTtcblxuICAgICAgY29uc3Qgc2lnbmVyRW50cmllcyA9IHNpZ25lckxpc3QuU2lnbmVyRW50cmllcztcbiAgICAgIGlmIChzaWduZXJFbnRyaWVzLmxlbmd0aCAhPT0gMykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2lnbmVyIGxpc3QgbGVuZ3RoJyk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHsgU2lnbmVyRW50cnkgfSBvZiBzaWduZXJFbnRyaWVzKSB7XG4gICAgICAgIGNvbnN0IHdlaWdodCA9IFNpZ25lckVudHJ5LlNpZ25lcldlaWdodDtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IFNpZ25lckVudHJ5LkFjY291bnQ7XG4gICAgICAgIGlmICh3ZWlnaHQgIT09IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2lnbmVyIHdlaWdodCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgaXQncyBhIGR1cGUgb2YgYW4gYWRkcmVzcyB3ZSBhbHJlYWR5IGtub3csIGJsb2NrXG4gICAgICAgIGlmIChmb3VuZEFkZHJlc3Nlc1thZGRyZXNzXSA+PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkdXBsaWNhdGUgc2lnbmVyIGFkZHJlc3MnKTtcbiAgICAgICAgfVxuICAgICAgICBmb3VuZEFkZHJlc3Nlc1thZGRyZXNzXSA9IChmb3VuZEFkZHJlc3Nlc1thZGRyZXNzXSB8fCAwKSArIDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3VuZEFkZHJlc3Nlc1t1c2VyQWRkcmVzc10gIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIGluY2lkZW5jZSBmcmVxdWVuY3kgb2YgdXNlciBzaWduZXIgYWRkcmVzcycpO1xuICAgICAgfVxuICAgICAgaWYgKGZvdW5kQWRkcmVzc2VzW2JhY2t1cEFkZHJlc3NdICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBpbmNpZGVuY2UgZnJlcXVlbmN5IG9mIHVzZXIgc2lnbmVyIGFkZHJlc3MnKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWFrZSBzdXJlIHRoZSBmbGFncyBkaXNhYmxlIHRoZSBtYXN0ZXIga2V5IGFuZCBlbmZvcmNlIGRlc3RpbmF0aW9uIHRhZ3NcbiAgICAgIGNvbnN0IFVTRVJfS0VZX1NFVFRJTkdfRkxBRyA9IDY1NTM2O1xuICAgICAgY29uc3QgTUFTVEVSX0tFWV9ERUFDVElWQVRJT05fRkxBRyA9IDEwNDg1NzY7XG4gICAgICBjb25zdCBSRVFVSVJFX0RFU1RJTkFUSU9OX1RBR19GTEFHID0gMTMxMDcyO1xuICAgICAgaWYgKChhY2NvdW50RmxhZ3MgJiBVU0VSX0tFWV9TRVRUSU5HX0ZMQUcpICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYSBjdXN0b20gdXNlciBrZXkgaGFzIGJlZW4gc2V0Jyk7XG4gICAgICB9XG4gICAgICBpZiAoKGFjY291bnRGbGFncyAmIE1BU1RFUl9LRVlfREVBQ1RJVkFUSU9OX0ZMQUcpICE9PSBNQVNURVJfS0VZX0RFQUNUSVZBVElPTl9GTEFHKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndGhlIG1hc3RlciBrZXkgaGFzIG5vdCBiZWVuIGRlYWN0aXZhdGVkJyk7XG4gICAgICB9XG4gICAgICBpZiAoKGFjY291bnRGbGFncyAmIFJFUVVJUkVfREVTVElOQVRJT05fVEFHX0ZMQUcpICE9PSBSRVFVSVJFX0RFU1RJTkFUSU9OX1RBR19GTEFHKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndGhlIGRlc3RpbmF0aW9uIGZsYWcgcmVxdWlyZW1lbnQgaGFzIG5vdCBiZWVuIGFjdGl2YXRlZCcpO1xuICAgICAgfVxuXG4gICAgICAvLyByZWNvdmVyIHRoZSBmdW5kc1xuICAgICAgY29uc3QgcmVzZXJ2ZSA9IGJhc2VSZXNlcnZlLnBsdXMocmVzZXJ2ZURlbHRhLnRpbWVzKDUpKTtcbiAgICAgIGNvbnN0IHJlY292ZXJhYmxlQmFsYW5jZSA9IGJhbGFuY2UubWludXMocmVzZXJ2ZSk7XG5cbiAgICAgIGNvbnN0IHJhd0Rlc3RpbmF0aW9uID0gcGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb247XG4gICAgICBjb25zdCBkZXN0aW5hdGlvbkRldGFpbHMgPSB1cmwucGFyc2UocmF3RGVzdGluYXRpb24pO1xuICAgICAgY29uc3QgZGVzdGluYXRpb25BZGRyZXNzID0gZGVzdGluYXRpb25EZXRhaWxzLnBhdGhuYW1lO1xuXG4gICAgICAvLyBwYXJzZSBkZXN0aW5hdGlvbiB0YWcgZnJvbSBxdWVyeVxuICAgICAgbGV0IGRlc3RpbmF0aW9uVGFnOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgICBpZiAoZGVzdGluYXRpb25EZXRhaWxzLnF1ZXJ5KSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5RGV0YWlscyA9IHF1ZXJ5c3RyaW5nLnBhcnNlKGRlc3RpbmF0aW9uRGV0YWlscy5xdWVyeSk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHF1ZXJ5RGV0YWlscy5kdCkpIHtcbiAgICAgICAgICAvLyBpZiBxdWVyeURldGFpbHMuZHQgaXMgYW4gYXJyYXksIHRoYXQgbWVhbnMgZHQgd2FzIGdpdmVuIG11bHRpcGxlIHRpbWVzLCB3aGljaCBpcyBub3QgdmFsaWRcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihgZGVzdGluYXRpb24gdGFnIGNhbiBhcHBlYXIgYXQgbW9zdCBvbmNlLCBidXQgJHtxdWVyeURldGFpbHMuZHQubGVuZ3RofSBkZXN0aW5hdGlvbiB0YWdzIHdlcmUgZm91bmRgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBhcnNlZFRhZyA9IHBhcnNlSW50KHF1ZXJ5RGV0YWlscy5kdCwgMTApO1xuICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihwYXJzZWRUYWcpKSB7XG4gICAgICAgICAgZGVzdGluYXRpb25UYWcgPSBwYXJzZWRUYWc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB7XG4gICAgICAgIFRyYW5zYWN0aW9uVHlwZTogJ1BheW1lbnQnLFxuICAgICAgICBBY2NvdW50OiBwYXJhbXMucm9vdEFkZHJlc3MsIC8vIHNvdXJjZSBhZGRyZXNzXG4gICAgICAgIERlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbkFkZHJlc3MsXG4gICAgICAgIERlc3RpbmF0aW9uVGFnOiBkZXN0aW5hdGlvblRhZyxcbiAgICAgICAgQW1vdW50OiByZWNvdmVyYWJsZUJhbGFuY2UudG9GaXhlZCgwKSxcbiAgICAgICAgRmxhZ3M6IDIxNDc0ODM2NDgsXG4gICAgICAgIExhc3RMZWRnZXJTZXF1ZW5jZTogY3VycmVudExlZGdlciArIDEwMDAwMDAsIC8vIGdpdmUgaXQgMSBtaWxsaW9uIGxlZGdlcnMnIHRpbWUgKH4xIG1vbnRoLCBzdWl0YWJsZSBmb3IgS1JTKVxuICAgICAgICBGZWU6IG9wZW5MZWRnZXJGZWUudGltZXMoMykudG9GaXhlZCgwKSwgLy8gdGhlIGZhY3RvciB0aHJlZSBpcyBmb3IgdGhlIG11bHRpc2lnbmluZ1xuICAgICAgICBTZXF1ZW5jZTogc2VxdWVuY2VJZCxcbiAgICAgIH07XG4gICAgICBjb25zdCB0eEpTT046IHN0cmluZyA9IEpTT04uc3RyaW5naWZ5KHRyYW5zYWN0aW9uKTtcblxuICAgICAgaWYgKGlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgICByZXR1cm4gdHhKU09OO1xuICAgICAgfVxuICAgICAgY29uc3QgcmlwcGxlTGliID0gcmlwcGxlKCk7XG4gICAgICBjb25zdCB1c2VyS2V5ID0ga2V5c1swXS5nZXRLZXkoKS5nZXRQcml2YXRlS2V5QnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgY29uc3QgdXNlclNpZ25hdHVyZSA9IHJpcHBsZUxpYi5zaWduV2l0aFByaXZhdGVLZXkodHhKU09OLCB1c2VyS2V5LCB7IHNpZ25BczogdXNlckFkZHJlc3MgfSk7XG5cbiAgICAgIGxldCBzaWduZWRUcmFuc2FjdGlvbjtcblxuICAgICAgaWYgKGlzS3JzUmVjb3ZlcnkpIHtcbiAgICAgICAgc2lnbmVkVHJhbnNhY3Rpb24gPSB1c2VyU2lnbmF0dXJlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYmFja3VwS2V5ID0ga2V5c1sxXS5nZXRLZXkoKS5nZXRQcml2YXRlS2V5QnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICBjb25zdCBiYWNrdXBTaWduYXR1cmUgPSByaXBwbGVMaWIuc2lnbldpdGhQcml2YXRlS2V5KHR4SlNPTiwgYmFja3VwS2V5LCB7IHNpZ25BczogYmFja3VwQWRkcmVzcyB9KTtcbiAgICAgICAgc2lnbmVkVHJhbnNhY3Rpb24gPSByaXBwbGVMaWIuY29tYmluZShbdXNlclNpZ25hdHVyZS5zaWduZWRUcmFuc2FjdGlvbiwgYmFja3VwU2lnbmF0dXJlLnNpZ25lZFRyYW5zYWN0aW9uXSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uRXhwbGFuYXRpb246IFJlY292ZXJ5SW5mbyA9IHlpZWxkIHNlbGYuZXhwbGFpblRyYW5zYWN0aW9uKHtcbiAgICAgICAgdHhIZXg6IHNpZ25lZFRyYW5zYWN0aW9uLnNpZ25lZFRyYW5zYWN0aW9uLFxuICAgICAgfSk7XG4gICAgICB0cmFuc2FjdGlvbkV4cGxhbmF0aW9uLnR4SGV4ID0gc2lnbmVkVHJhbnNhY3Rpb24uc2lnbmVkVHJhbnNhY3Rpb247XG5cbiAgICAgIGlmIChpc0tyc1JlY292ZXJ5KSB7XG4gICAgICAgIHRyYW5zYWN0aW9uRXhwbGFuYXRpb24uYmFja3VwS2V5ID0gcGFyYW1zLmJhY2t1cEtleTtcbiAgICAgICAgdHJhbnNhY3Rpb25FeHBsYW5hdGlvbi5jb2luID0gc2VsZi5nZXRDaGFpbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uRXhwbGFuYXRpb247XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwYXJlIGFuZCB2YWxpZGF0ZSBhbGwga2V5Y2hhaW5zIGZyb20gdGhlIGtleWNhcmQgZm9yIHJlY292ZXJ5XG4gICAqL1xuICBpbml0aWF0ZVJlY292ZXJ5KHBhcmFtczogSW5pdGlhdGVSZWNvdmVyeU9wdGlvbnMpOiBCbHVlYmlyZDxIRE5vZGVbXT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxIRE5vZGVbXT4oZnVuY3Rpb24gKmluaXRpYXRlUmVjb3ZlcnkoKSB7XG4gICAgICBjb25zdCBrZXlzOiBIRE5vZGVbXSA9IFtdO1xuICAgICAgY29uc3QgdXNlcktleSA9IHBhcmFtcy51c2VyS2V5OyAvLyBCb3ggQVxuICAgICAgbGV0IGJhY2t1cEtleSA9IHBhcmFtcy5iYWNrdXBLZXk7IC8vIEJveCBCXG4gICAgICBjb25zdCBiaXRnb1hwdWIgPSBwYXJhbXMuYml0Z29LZXk7IC8vIEJveCBDXG4gICAgICBjb25zdCBkZXN0aW5hdGlvbkFkZHJlc3MgPSBwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbjtcbiAgICAgIGNvbnN0IHBhc3NwaHJhc2UgPSBwYXJhbXMud2FsbGV0UGFzc3BocmFzZTtcblxuICAgICAgY29uc3QgaXNLcnNSZWNvdmVyeSA9IGJhY2t1cEtleS5zdGFydHNXaXRoKCd4cHViJykgJiYgIXVzZXJLZXkuc3RhcnRzV2l0aCgneHB1YicpO1xuICAgICAgY29uc3QgaXNVbnNpZ25lZFN3ZWVwID0gYmFja3VwS2V5LnN0YXJ0c1dpdGgoJ3hwdWInKSAmJiB1c2VyS2V5LnN0YXJ0c1dpdGgoJ3hwdWInKTtcblxuICAgICAgaWYgKGlzS3JzUmVjb3ZlcnkgJiYgcGFyYW1zLmtyc1Byb3ZpZGVyICYmIF8uaXNVbmRlZmluZWQoY29uZmlnLmtyc1Byb3ZpZGVyc1twYXJhbXMua3JzUHJvdmlkZXJdKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24ga2V5IHJlY292ZXJ5IHNlcnZpY2UgcHJvdmlkZXInKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdmFsaWRhdGVQYXNzcGhyYXNlS2V5ID0gZnVuY3Rpb24odXNlcktleSwgcGFzc3BocmFzZSk6IEhETm9kZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCF1c2VyS2V5LnN0YXJ0c1dpdGgoJ3hwcnYnKSAmJiAhaXNVbnNpZ25lZFN3ZWVwKSB7XG4gICAgICAgICAgICB1c2VyS2V5ID0gc2pjbC5kZWNyeXB0KHBhc3NwaHJhc2UsIHVzZXJLZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gSEROb2RlLmZyb21CYXNlNTgodXNlcktleSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkZWNyeXB0IHVzZXIga2V5IHdpdGggcGFzc2NvZGUgLSB0cnkgYWdhaW4hJyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGtleSA9IHZhbGlkYXRlUGFzc3BocmFzZUtleSh1c2VyS2V5LCBwYXNzcGhyYXNlKTtcblxuICAgICAga2V5cy5wdXNoKGtleSk7XG5cbiAgICAgIC8vIFZhbGlkYXRlIHRoZSBiYWNrdXAga2V5XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWJhY2t1cEtleS5zdGFydHNXaXRoKCd4cHJ2JykgJiYgIWlzS3JzUmVjb3ZlcnkgJiYgIWlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgICAgIGJhY2t1cEtleSA9IHNqY2wuZGVjcnlwdChwYXNzcGhyYXNlLCBiYWNrdXBLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhY2t1cEhETm9kZSA9IEhETm9kZS5mcm9tQmFzZTU4KGJhY2t1cEtleSk7XG4gICAgICAgIGtleXMucHVzaChiYWNrdXBIRE5vZGUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkZWNyeXB0IGJhY2t1cCBrZXkgd2l0aCBwYXNzY29kZSAtIHRyeSBhZ2FpbiEnKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGJpdGdvSEROb2RlID0gSEROb2RlLmZyb21CYXNlNTgoYml0Z29YcHViKTtcbiAgICAgICAga2V5cy5wdXNoKGJpdGdvSEROb2RlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHNlbGYuZ2V0RmFtaWx5KCkgIT09ICd4cnAnKSB7XG4gICAgICAgICAgLy8gaW4gWFJQIHJlY292ZXJpZXMsIHRoZSBCaXRHbyB4cHViIGlzIG9wdGlvbmFsXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2UgYml0Z28geHB1YiEnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gVmFsaWRhdGUgdGhlIGRlc3RpbmF0aW9uIGFkZHJlc3NcbiAgICAgIGlmICghc2VsZi5pc1ZhbGlkQWRkcmVzcyhkZXN0aW5hdGlvbkFkZHJlc3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkZXN0aW5hdGlvbiBhZGRyZXNzIScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ga2V5cztcbiAgICB9KS5jYWxsKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgbmV3IGtleXBhaXIgZm9yIHRoaXMgY29pbi5cbiAgICogQHBhcmFtIHNlZWQgU2VlZCBmcm9tIHdoaWNoIHRoZSBuZXcga2V5cGFpciBzaG91bGQgYmUgZ2VuZXJhdGVkLCBvdGhlcndpc2UgYSByYW5kb20gc2VlZCBpcyB1c2VkXG4gICAqL1xuICBwdWJsaWMgZ2VuZXJhdGVLZXlQYWlyKHNlZWQ/OiBCdWZmZXIpOiBLZXlQYWlyIHtcbiAgICBpZiAoIXNlZWQpIHtcbiAgICAgIC8vIEFuIGV4dGVuZGVkIHByaXZhdGUga2V5IGhhcyBib3RoIGEgbm9ybWFsIDI1NiBiaXQgcHJpdmF0ZSBrZXkgYW5kIGEgMjU2XG4gICAgICAvLyBiaXQgY2hhaW4gY29kZSwgYm90aCBvZiB3aGljaCBtdXN0IGJlIHJhbmRvbS4gNTEyIGJpdHMgaXMgdGhlcmVmb3JlIHRoZVxuICAgICAgLy8gbWF4aW11bSBlbnRyb3B5IGFuZCBnaXZlcyB1cyBtYXhpbXVtIHNlY3VyaXR5IGFnYWluc3QgY3JhY2tpbmcuXG4gICAgICBzZWVkID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDUxMiAvIDgpO1xuICAgIH1cbiAgICBjb25zdCBleHRlbmRlZEtleSA9IEhETm9kZS5mcm9tU2VlZEJ1ZmZlcihzZWVkKTtcbiAgICBjb25zdCB4cHViID0gZXh0ZW5kZWRLZXkubmV1dGVyZWQoKS50b0Jhc2U1OCgpO1xuICAgIHJldHVybiB7XG4gICAgICBwdWI6IHhwdWIsXG4gICAgICBwcnY6IGV4dGVuZGVkS2V5LnRvQmFzZTU4KCksXG4gICAgfTtcbiAgfVxuXG4gIHBhcnNlVHJhbnNhY3Rpb24ocGFyYW1zOiBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8UGFyc2VkVHJhbnNhY3Rpb24+KTogQmx1ZWJpcmQ8UGFyc2VkVHJhbnNhY3Rpb24+IHtcbiAgICByZXR1cm4gQmx1ZWJpcmQucmVzb2x2ZSh7fSkuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cbn1cbiJdfQ==