"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("lodash");
var bitcoin = require("bitgo-utxo-lib");
var querystring = require("querystring");
var url = require("url");
var Bluebird = require("bluebird");
var request = require("superagent");
var stellar = require("stellar-sdk");
var bignumber_js_1 = require("bignumber.js");
var keychains_1 = require("../keychains");
var keyDeriver_1 = require("../internal/keyDeriver");
var config = require("../../config");
var common = require("../../common");
var errors_1 = require("../../errors");
var baseCoin_1 = require("../baseCoin");
var co = Bluebird.coroutine;
var Xlm = /** @class */ (function (_super) {
    __extends(Xlm, _super);
    function Xlm(bitgo) {
        var _this = _super.call(this, bitgo) || this;
        _this.homeDomain = 'bitgo.com'; // used for reverse federation lookup
        stellar.Network.use(new stellar.Network(stellar.Networks.PUBLIC));
        return _this;
    }
    Xlm.createInstance = function (bitgo) {
        return new Xlm(bitgo);
    };
    /**
     * Factor between the base unit and its smallest subdivison
     */
    Xlm.prototype.getBaseFactor = function () {
        return 1e7;
    };
    /**
     * Identifier for the blockchain which supports this coin
     */
    Xlm.prototype.getChain = function () {
        return 'xlm';
    };
    /**
     * Identifier for the coin family
     */
    Xlm.prototype.getFamily = function () {
        return 'xlm';
    };
    /**
     * Complete human-readable name of this coin
     */
    Xlm.prototype.getFullName = function () {
        return 'Stellar';
    };
    /**
     * Url at which the stellar federation server can be reached
     */
    Xlm.prototype.getFederationServerUrl = function () {
        return common.Environments[this.bitgo.getEnv()].stellarFederationServerUrl;
    };
    /**
     * Url at which horizon can be reached
     */
    Xlm.prototype.getHorizonUrl = function () {
        return 'https://horizon.stellar.org';
    };
    /**
     * Generate a new key pair on the ed25519 curve
     * @param seed
     * @returns generated pub and prv
     */
    Xlm.prototype.generateKeyPair = function (seed) {
        var pair = seed ? stellar.Keypair.fromRawEd25519Seed(seed) : stellar.Keypair.random();
        return {
            pub: pair.publicKey(),
            prv: pair.secret(),
        };
    };
    /**
     * Get decoded ed25519 public key from raw data
     *
     * @param pub Raw public key
     * @returns Encoded public key
     */
    Xlm.prototype.getPubFromRaw = function (pub) {
        return stellar.StrKey.encodeEd25519PublicKey(Buffer.from(pub, 'hex'));
    };
    /**
     * Get decoded ed25519 private key from raw data
     *
     * @param prv Raw private key
     * @returns Encoded private key
     */
    Xlm.prototype.getPrvFromRaw = function (prv) {
        return stellar.StrKey.encodeEd25519SecretSeed(Buffer.from(prv, 'hex'));
    };
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param pub the pub to be checked
     * @returns is it valid?
     */
    Xlm.prototype.isValidPub = function (pub) {
        return stellar.StrKey.isValidEd25519PublicKey(pub);
    };
    /**
     * Return boolean indicating whether input is valid private key for the coin
     *
     * @param prv the prv to be checked
     * @returns is it valid?
     */
    Xlm.prototype.isValidPrv = function (prv) {
        return stellar.StrKey.isValidEd25519SecretSeed(prv);
    };
    /**
     * Return boolean indicating whether a memo id is valid
     *
     * @param memoId memo id
     * @returns true if memo id is valid
     */
    Xlm.prototype.isValidMemoId = function (memoId) {
        var memoIdNumber;
        try {
            stellar.Memo.id(memoId); // throws if the value is not valid memo id
            memoIdNumber = new bignumber_js_1.BigNumber(memoId);
        }
        catch (e) {
            return false;
        }
        return (memoIdNumber.gte(0) && memoIdNumber.lt(Xlm.maxMemoId));
    };
    /**
     * Evaluates whether a memo is valid
     *
     * @param value value of the memo
     * @param type type of the memo
     * @returns true if value and type are a valid
     */
    Xlm.prototype.isValidMemo = function (_a) {
        var value = _a.value, type = _a.type;
        if (!value || !type) {
            return false;
        }
        try {
            // throws if the value is not valid for the type
            // valid types are: 'id', 'text', 'hash', 'return'
            // See https://www.stellar.org/developers/guides/concepts/transactions.html#memo
            stellar.Memo[type](value);
        }
        catch (e) {
            return false;
        }
        return true;
    };
    /**
     * Minimum balance of a 2-of-3 multisig wallet
     * @returns minimum balance in stroops
     */
    Xlm.prototype.getMinimumReserve = function () {
        var self = this;
        return co(function () {
            var server, horizonLedgerInfo, baseReserve;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        server = new stellar.Server(self.getHorizonUrl());
                        return [4 /*yield*/, server
                                .ledgers()
                                .order('desc')
                                .limit(1)
                                .call()];
                    case 1:
                        horizonLedgerInfo = _a.sent();
                        if (!horizonLedgerInfo) {
                            throw new Error('unable to connect to Horizon for reserve requirement data');
                        }
                        baseReserve = horizonLedgerInfo.records[0].base_reserve_in_stroops;
                        // 2-of-3 wallets have a minimum reserve of 5x the base reserve
                        return [2 /*return*/, 5 * baseReserve];
                }
            });
        }).call(this);
    };
    /**
     * Transaction fee for each operation
     * @returns transaction fee in stroops
     */
    Xlm.prototype.getBaseTransactionFee = function () {
        var self = this;
        return co(function () {
            var server, horizonLedgerInfo;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        server = new stellar.Server(self.getHorizonUrl());
                        return [4 /*yield*/, server
                                .ledgers()
                                .order('desc')
                                .limit(1)
                                .call()];
                    case 1:
                        horizonLedgerInfo = _a.sent();
                        if (!horizonLedgerInfo) {
                            throw new Error('unable to connect to Horizon for reserve requirement data');
                        }
                        return [2 /*return*/, horizonLedgerInfo.records[0].base_fee_in_stroops];
                }
            });
        }).call(this);
    };
    /**
     * Process address into address and memo id
     *
     * @param address the address
     * @returns object containing address and memo id
     */
    Xlm.prototype.getAddressDetails = function (address) {
        var destinationDetails = url.parse(address);
        var destinationAddress = destinationDetails.pathname;
        if (!destinationAddress || !stellar.StrKey.isValidEd25519PublicKey(destinationAddress)) {
            throw new Error("invalid address: " + address);
        }
        // address doesn't have a memo id
        if (destinationDetails.pathname === address) {
            return {
                address: address,
                memoId: undefined,
            };
        }
        if (!destinationDetails.query) {
            throw new errors_1.InvalidAddressError("invalid address: " + address);
        }
        var queryDetails = querystring.parse(destinationDetails.query);
        if (!queryDetails.memoId) {
            // if there are more properties, the query details need to contain the memo id property
            throw new errors_1.InvalidAddressError("invalid address: " + address);
        }
        if (Array.isArray(queryDetails.memoId)) {
            throw new errors_1.InvalidAddressError("memoId may only be given at most once, but found " + queryDetails.memoId.length + " instances in address " + address);
        }
        if (Array.isArray(queryDetails.memoId) && queryDetails.memoId.length !== 1) {
            // valid addresses can only contain one memo id
            throw new errors_1.InvalidAddressError("invalid address '" + address + "', must contain exactly one memoId");
        }
        var memoId = _.castArray(queryDetails.memoId)[0];
        if (!this.isValidMemoId(memoId)) {
            throw new errors_1.InvalidMemoIdError("invalid address: '" + address + "', memoId is not valid");
        }
        return {
            address: destinationAddress,
            memoId: memoId,
        };
    };
    /**
     * Validate and return address with appended memo id
     *
     * @param address address
     * @param memoId memo id
     * @returns address with memo id
     */
    Xlm.prototype.normalizeAddress = function (_a) {
        var address = _a.address, memoId = _a.memoId;
        if (!stellar.StrKey.isValidEd25519PublicKey(address)) {
            throw new Error("invalid address details: " + address);
        }
        if (memoId && this.isValidMemoId(memoId)) {
            return address + "?memoId=" + memoId;
        }
        return address;
    };
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param address the pub to be checked
     * @returns is it valid?
     */
    Xlm.prototype.isValidAddress = function (address) {
        try {
            var addressDetails = this.getAddressDetails(address);
            return address === this.normalizeAddress(addressDetails);
        }
        catch (e) {
            return false;
        }
    };
    /**
     * Return a Stellar Asset in coin:token form (i.e. (t)xlm:<code>-<issuer>)
     * If the asset is XLM, return the chain
     * @param {stellar.Asset} asset - instance of Stellar Asset
     */
    Xlm.prototype.getTokenNameFromStellarAsset = function (asset) {
        var code = asset.getCode();
        var issuer = asset.getIssuer();
        if (asset.isNative()) {
            return this.getChain();
        }
        return "" + this.getChain() + baseCoin_1.BaseCoin.coinTokenPatternSeparator + code + Xlm.tokenPatternSeparator + issuer;
    };
    /**
     * Evaluate whether a stellar username has valid format
     * This method is used by the client when a stellar address is being added to a wallet
     * Example of a common stellar username: foo@bar.baz
     * The above example would result in the Stellar address: foo@bar.baz*bitgo.com
     *
     * @param username - stellar username
     * @return true if stellar username is valid
     */
    Xlm.prototype.isValidStellarUsername = function (username) {
        return /^[a-z0-9\-_.+@]+$/.test(username);
    };
    /**
     * Get an instance of FederationServer for BitGo lookups
     *
     * @returns instance of BitGo Federation Server
     */
    Xlm.prototype.getBitGoFederationServer = function () {
        // Identify the URI scheme in case we need to allow connecting to HTTP server.
        var isNonSecureEnv = !_.startsWith(common.Environments[this.bitgo.env].uri, 'https');
        var federationServerOptions = { allowHttp: isNonSecureEnv };
        return new stellar.FederationServer(this.getFederationServerUrl(), 'bitgo.com', federationServerOptions);
    };
    /**
     * Perform federation lookups
     * Our federation server handles lookups for bitgo as well as for other federation domains
     *
     * @param {String} [address] - address to look up
     * @param {String} [accountId] - account id to look up
     */
    Xlm.prototype.federationLookup = function (_a) {
        var address = _a.address, accountId = _a.accountId;
        var self = this;
        return co(function () {
            var federationServer, e_1, error;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 6, , 7]);
                        federationServer = self.getBitGoFederationServer();
                        if (!address) return [3 /*break*/, 2];
                        return [4 /*yield*/, federationServer.resolveAddress(address)];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2:
                        if (!accountId) return [3 /*break*/, 4];
                        return [4 /*yield*/, federationServer.resolveAccountId(accountId)];
                    case 3: return [2 /*return*/, _a.sent()];
                    case 4: throw new Error('invalid argument - must provide Stellar address or account id');
                    case 5: return [3 /*break*/, 7];
                    case 6:
                        e_1 = _a.sent();
                        error = _.get(e_1, 'response.data.detail');
                        if (error) {
                            throw new errors_1.StellarFederationUserNotFoundError(error);
                        }
                        else {
                            throw e_1;
                        }
                        return [3 /*break*/, 7];
                    case 7: return [2 /*return*/];
                }
            });
        }).call(this);
    };
    /**
     * Attempt to resolve a stellar address into a stellar account
     *
     * @param {String} address - stellar address to look for
     */
    Xlm.prototype.federationLookupByName = function (address) {
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                if (!address) {
                    throw new Error('invalid Stellar address');
                }
                return [2 /*return*/, self.federationLookup({ address: address })];
            });
        }).call(this);
    };
    /**
     * Attempt to resolve an account id into a stellar account
     * Only works for accounts that can be resolved by our federation server
     *
     * @param {String} accountId - stellar account id
     */
    Xlm.prototype.federationLookupByAccountId = function (accountId) {
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                if (!accountId) {
                    throw new Error('invalid Stellar account');
                }
                return [2 /*return*/, self.federationLookup({ accountId: accountId })];
            });
        }).call(this);
    };
    /**
     * Check if address is a valid XLM address, and then make sure it matches the root address.
     *
     * @param address {String} the address to verify
     * @param rootAddress {String} the wallet's root address
     */
    Xlm.prototype.verifyAddress = function (_a) {
        var address = _a.address, rootAddress = _a.rootAddress;
        if (!this.isValidAddress(address)) {
            throw new errors_1.InvalidAddressError("invalid address: " + address);
        }
        var addressDetails = this.getAddressDetails(address);
        var rootAddressDetails = this.getAddressDetails(rootAddress);
        if (addressDetails.address !== rootAddressDetails.address) {
            throw new errors_1.UnexpectedAddressError("address validation failure: " + addressDetails.address + " vs " + rootAddressDetails.address);
        }
        return true;
    };
    /**
     * Get extra parameters for prebuilding a tx
     * Set empty recipients array in trustline txs
     */
    Xlm.prototype.getExtraPrebuildParams = function (buildParams, callback) {
        var params = {};
        if (buildParams.type === 'trustline') {
            params.recipients = [];
        }
        return Bluebird.resolve(params).asCallback(callback);
    };
    /**
     * Generates Stellar keypairs from the user key and backup key
     * @param params
     */
    Xlm.prototype.initiateRecovery = function (params) {
        var self = this;
        return co(function () {
            var keys, userKey, backupKey, isKrsRecovery, isUnsignedSweep, userKeyPair;
            return __generator(this, function (_a) {
                keys = [];
                userKey = params.userKey;
                backupKey = params.backupKey;
                isKrsRecovery = backupKey.startsWith('G') && !userKey.startsWith('G');
                isUnsignedSweep = backupKey.startsWith('G') && userKey.startsWith('G');
                if (isKrsRecovery && params.krsProvider && _.isUndefined(config.krsProviders[params.krsProvider])) {
                    throw new errors_1.KeyRecoveryServiceError("Unknown key recovery service provider - " + params.krsProvider);
                }
                if (isKrsRecovery && params.krsProvider && !config.krsProviders[params.krsProvider].supportedCoins.includes(self.getFamily())) {
                    throw new errors_1.KeyRecoveryServiceError("Specified key recovery service does not support recoveries for " + self.getChain());
                }
                if (!self.isValidAddress(params.recoveryDestination)) {
                    throw new errors_1.InvalidAddressError('Invalid destination address!');
                }
                try {
                    if (!userKey.startsWith('S') && !userKey.startsWith('G')) {
                        userKey = self.bitgo.decrypt({
                            input: userKey,
                            password: params.walletPassphrase,
                        });
                    }
                    userKeyPair = isUnsignedSweep ?
                        stellar.Keypair.fromPublicKey(userKey) :
                        stellar.Keypair.fromSecret(userKey);
                    keys.push(userKeyPair);
                }
                catch (e) {
                    throw new Error('Failed to decrypt user key with passcode - try again!');
                }
                try {
                    if (!backupKey.startsWith('S') && !isKrsRecovery && !isUnsignedSweep) {
                        backupKey = this.bitgo.decrypt({
                            input: backupKey,
                            password: params.walletPassphrase,
                        });
                    }
                    if (isKrsRecovery || isUnsignedSweep) {
                        keys.push(stellar.Keypair.fromPublicKey(backupKey));
                    }
                    else {
                        keys.push(stellar.Keypair.fromSecret(backupKey));
                    }
                }
                catch (e) {
                    throw new Error('Failed to decrypt backup key with passcode - try again!');
                }
                return [2 /*return*/, keys];
            });
        }).call(this);
    };
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * - userKey: [encrypted] Stellar private key
     * - backupKey: [encrypted] Stellar private key, or public key if the private key is held by a KRS provider
     * - walletPassphrase: necessary if one of the private keys is encrypted
     * - rootAddress: base address of the wallet to recover funds from
     * - krsProvider: necessary if backup key is held by KRS
     * - recoveryDestination: target address to send recovered funds to
     * @param callback
     */
    Xlm.prototype.recover = function (params, callback) {
        var self = this;
        return co(function () {
            var _a, userKey, backupKey, isKrsRecovery, isUnsignedSweep, accountDataUrl, destinationUrl, accountData, e_2, unfundedDestination, e_3, account, nativeBalanceInfo, walletBalance, minimumReserve, baseTxFee, recoveryAmount, formattedRecoveryAmount, txBuilder, operation, tx, transaction;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, self.initiateRecovery(params)];
                    case 1:
                        _a = _b.sent(), userKey = _a[0], backupKey = _a[1];
                        isKrsRecovery = params.backupKey.startsWith('G') && !params.userKey.startsWith('G');
                        isUnsignedSweep = params.backupKey.startsWith('G') && params.userKey.startsWith('G');
                        if (!params.rootAddress || !stellar.StrKey.isValidEd25519PublicKey(params.rootAddress)) {
                            throw new Error("Invalid wallet address: " + params.rootAddress);
                        }
                        accountDataUrl = self.getHorizonUrl() + "/accounts/" + params.rootAddress;
                        destinationUrl = self.getHorizonUrl() + "/accounts/" + params.recoveryDestination;
                        _b.label = 2;
                    case 2:
                        _b.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, request.get(accountDataUrl).result()];
                    case 3:
                        accountData = _b.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        e_2 = _b.sent();
                        throw new Error('Unable to reach the Stellar network via Horizon.');
                    case 5:
                        unfundedDestination = false;
                        _b.label = 6;
                    case 6:
                        _b.trys.push([6, 8, , 9]);
                        return [4 /*yield*/, request.get(destinationUrl)];
                    case 7:
                        _b.sent();
                        return [3 /*break*/, 9];
                    case 8:
                        e_3 = _b.sent();
                        if (e_3.status === 404) {
                            // If the destination account does not yet exist, horizon responds with 404
                            unfundedDestination = true;
                        }
                        return [3 /*break*/, 9];
                    case 9:
                        if (!accountData.sequence || !accountData.balances) {
                            throw new Error('Horizon server error - unable to retrieve sequence ID or account balance');
                        }
                        account = new stellar.Account(params.rootAddress, accountData.sequence);
                        nativeBalanceInfo = accountData.balances.find(function (assetBalance) { return assetBalance['asset_type'] === 'native'; });
                        if (!nativeBalanceInfo) {
                            throw new Error('Provided wallet has a balance of 0 XLM, recovery aborted');
                        }
                        walletBalance = Number(self.bigUnitsToBaseUnits(nativeBalanceInfo.balance));
                        return [4 /*yield*/, self.getMinimumReserve()];
                    case 10:
                        minimumReserve = _b.sent();
                        return [4 /*yield*/, self.getBaseTransactionFee()];
                    case 11:
                        baseTxFee = _b.sent();
                        recoveryAmount = walletBalance - minimumReserve - baseTxFee;
                        formattedRecoveryAmount = self.baseUnitsToBigUnits(recoveryAmount).toString();
                        txBuilder = new stellar.TransactionBuilder(account);
                        operation = unfundedDestination ?
                            // In this case, we need to create the account
                            stellar.Operation.createAccount({
                                destination: params.recoveryDestination,
                                startingBalance: formattedRecoveryAmount,
                            }) :
                            // Otherwise if the account already exists, we do a normal send
                            stellar.Operation.payment({
                                destination: params.recoveryDestination,
                                asset: stellar.Asset.native(),
                                amount: formattedRecoveryAmount,
                            });
                        tx = txBuilder.addOperation(operation).build();
                        if (!isUnsignedSweep) {
                            tx.sign(userKey);
                        }
                        if (!isKrsRecovery && !isUnsignedSweep) {
                            tx.sign(backupKey);
                        }
                        transaction = {
                            tx: Xlm.txToString(tx),
                            recoveryAmount: recoveryAmount,
                        };
                        if (isKrsRecovery) {
                            transaction.backupKey = params.backupKey;
                            transaction.coin = self.getChain();
                        }
                        return [2 /*return*/, transaction];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {Object} prebuild object returned by platform
     * @param params.prv {String} user prv
     * @param callback
     * @returns {Bluebird<HalfSignedTransaction>}
     */
    Xlm.prototype.signTransaction = function (params, callback) {
        return co(function () {
            var txPrebuild, prv, keyPair, tx;
            return __generator(this, function (_a) {
                txPrebuild = params.txPrebuild, prv = params.prv;
                if (_.isUndefined(txPrebuild)) {
                    throw new Error('missing txPrebuild parameter');
                }
                if (!_.isObject(txPrebuild)) {
                    throw new Error("txPrebuild must be an object, got type " + typeof txPrebuild);
                }
                if (_.isUndefined(prv)) {
                    throw new Error('missing prv parameter to sign transaction');
                }
                if (!_.isString(prv)) {
                    throw new Error("prv must be a string, got type " + typeof prv);
                }
                keyPair = stellar.Keypair.fromSecret(prv);
                tx = new stellar.Transaction(txPrebuild.txBase64);
                tx.sign(keyPair);
                return [2 /*return*/, {
                        halfSigned: {
                            txBase64: Xlm.txToString(tx),
                        },
                    }];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Extend walletParams with extra params required for generating an XLM wallet
     *
     * Stellar wallets have three keychains on them. Two are generated by the platform, and the last is generated by the user.
     * Initially, we need a root prv to generate the account, which must be distinct from all three keychains on the wallet.
     * If a root prv is not provided, a random one is generated.
     */
    Xlm.prototype.supplementGenerateWallet = function (walletParams) {
        var self = this;
        return co(function () {
            var seed, rootPrv, keyPair;
            return __generator(this, function (_a) {
                rootPrv = walletParams.rootPrivateKey;
                if (rootPrv) {
                    if (!self.isValidPrv(rootPrv)) {
                        throw new Error('rootPrivateKey needs to be valid ed25519 secret seed');
                    }
                    seed = stellar.StrKey.decodeEd25519SecretSeed(rootPrv);
                }
                keyPair = self.generateKeyPair(seed);
                // extend the wallet initialization params
                walletParams.rootPrivateKey = keyPair.prv;
                return [2 /*return*/, walletParams];
            });
        }).call(this);
    };
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     * @param callback
     */
    Xlm.prototype.signMessage = function (key, message, callback) {
        var self = this;
        return co(function cosignMessage() {
            var keypair;
            return __generator(this, function (_a) {
                if (!self.isValidPrv(key.prv)) {
                    throw new Error("invalid prv: " + key.prv);
                }
                if (!Buffer.isBuffer(message)) {
                    message = Buffer.from(message);
                }
                keypair = stellar.Keypair.fromSecret(key.prv);
                return [2 /*return*/, keypair.sign(message)];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Verifies if signature for message is valid.
     *
     * @param pub public key
     * @param message signed message
     * @param signature signature to verify
     * @returns true if signature is valid.
     */
    Xlm.prototype.verifySignature = function (pub, message, signature) {
        if (!this.isValidPub(pub)) {
            throw new Error("invalid pub: " + pub);
        }
        if (!Buffer.isBuffer(message)) {
            message = Buffer.from(message);
        }
        var keyPair = stellar.Keypair.fromPublicKey(pub);
        return keyPair.verify(message, signature);
    };
    /**
     * Explain/parse transaction
     * @param params
     * @param callback
     */
    Xlm.prototype.explainTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            var txBase64, tx, id, memo, spendAmount, spendAmounts, outputs, operations, outputAmount, outputAmounts, fee;
            return __generator(this, function (_a) {
                txBase64 = params.txBase64;
                try {
                    tx = new stellar.Transaction(txBase64);
                }
                catch (e) {
                    throw new Error('txBase64 needs to be a valid tx encoded as base64 string');
                }
                id = tx.hash().toString('hex');
                memo = _.result(tx, '_memo.value') && _.result(tx, '_memo.arm') ?
                    {
                        value: _.result(tx, '_memo.value').toString(),
                        type: _.result(tx, '_memo.arm'),
                    } : {};
                spendAmount = new bignumber_js_1.BigNumber(0);
                spendAmounts = {};
                if (_.isEmpty(tx.operations)) {
                    throw new Error('missing operations');
                }
                outputs = [];
                operations = [];
                _.forEach(tx.operations, function (op) {
                    if (op.type === 'createAccount' || op.type === 'payment') {
                        // TODO Remove memoId from address
                        // Get memo to attach to address, if type is 'id'
                        var memoId = _.get(memo, 'type') === 'id' && !_.get(memo, 'value') ?
                            "?memoId=" + memo.value :
                            '';
                        var asset = op.type === 'payment' ? op.asset : stellar.Asset.native();
                        var coin = self.getTokenNameFromStellarAsset(asset); // coin or token id
                        var output = {
                            amount: self.bigUnitsToBaseUnits(op.startingBalance || op.amount),
                            address: op.destination + memoId,
                            coin: coin,
                        };
                        if (!_.isUndefined(spendAmounts[coin])) {
                            spendAmounts[coin] = spendAmounts[coin].plus(output.amount);
                        }
                        else {
                            spendAmounts[coin] = new bignumber_js_1.BigNumber(output.amount);
                        }
                        if (asset.isNative()) {
                            spendAmount = spendAmount.plus(output.amount);
                        }
                        outputs.push(output);
                    }
                    else if (op.type === 'changeTrust') {
                        operations.push({
                            type: op.type,
                            coin: self.getTokenNameFromStellarAsset(op.line),
                            asset: op.line,
                            limit: self.bigUnitsToBaseUnits(op.limit),
                        });
                    }
                });
                outputAmount = spendAmount.toFixed(0);
                outputAmounts = _.mapValues(spendAmounts, function (amount) { return amount.toFixed(0); });
                fee = {
                    fee: tx.fee.toFixed(0),
                    feeRate: null,
                    size: null,
                };
                return [2 /*return*/, {
                        displayOrder: ['id', 'outputAmount', 'outputAmounts', 'changeAmount', 'outputs', 'changeOutputs', 'fee', 'memo', 'operations'],
                        id: id,
                        outputs: outputs,
                        outputAmount: outputAmount,
                        outputAmounts: outputAmounts,
                        changeOutputs: [],
                        changeAmount: '0',
                        memo: memo,
                        fee: fee,
                        operations: operations,
                    }];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Verify that a tx prebuild's operations comply with the original intention
     * @param {stellar.Operation} operations - tx operations
     * @param {TransactionParams} txParams - params used to build the tx
     */
    Xlm.prototype.verifyTrustlineTxOperations = function (operations, txParams) {
        var _this = this;
        var trustlineOperations = _.filter(operations, ['type', 'changeTrust']);
        if (trustlineOperations.length !== _.get(txParams, 'trustlines', []).length) {
            throw new Error('transaction prebuild does not match expected trustline operations');
        }
        _.forEach(trustlineOperations, function (op) {
            var opToken = _this.getTokenNameFromStellarAsset(op.line);
            var tokenTrustline = _.find(txParams.trustlines, function (trustline) {
                // trustline params use limits in base units
                var opLimitBaseUnits = _this.bigUnitsToBaseUnits(op.limit);
                // Prepare the conditions to check for
                // Limit will always be set in the operation, even if it was omitted from txParams in the following cases:
                // 1. Action is 'add' - limit is set to Xlm.maxTrustlineLimit by default
                // 2. Action is 'remove' - limit is set to '0'
                var noLimit = _.isUndefined(trustline.limit);
                var addTrustlineWithDefaultLimit = (trustline.action === 'add' && opLimitBaseUnits === Xlm.maxTrustlineLimit);
                var removeTrustline = (trustline.action === 'remove' && opLimitBaseUnits === '0');
                return (trustline.token === opToken &&
                    (trustline.limit === opLimitBaseUnits || (noLimit && (addTrustlineWithDefaultLimit || removeTrustline))));
            });
            if (!tokenTrustline) {
                throw new Error('transaction prebuild does not match expected trustline tokens');
            }
        });
    };
    /**
     * Verify that a transaction prebuild complies with the original intention
     *
     * @param options
     * @param options.txPrebuild prebuild object returned by platform
     * @param options.txPrebuild.txBase64 prebuilt transaction encoded as base64 string
     * @param options.wallet wallet object to obtain keys to verify against
     * @param options.verification specifying some verification parameters
     * @param options.verification.disableNetworking Disallow fetching any data from the internet for verification purposes
     * @param options.verification.keychains Pass keychains manually rather than fetching them by id
     * @param callback
     */
    Xlm.prototype.verifyTransaction = function (options, callback) {
        // TODO BG-5600 Add parseTransaction / improve verification
        var self = this;
        return co(function () {
            var txParams, txPrebuild, wallet, _a, verification, disableNetworking, tx, outputOperations, userSignature, keychains;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        txParams = options.txParams, txPrebuild = options.txPrebuild, wallet = options.wallet, _a = options.verification, verification = _a === void 0 ? {} : _a;
                        disableNetworking = !!verification.disableNetworking;
                        if (!txPrebuild.txBase64) {
                            throw new Error('missing required tx prebuild property txBase64');
                        }
                        tx = new stellar.Transaction(txPrebuild.txBase64);
                        if (txParams.recipients && txParams.recipients.length > 1) {
                            throw new Error('cannot specify more than 1 recipient');
                        }
                        outputOperations = _.filter(tx.operations, function (operation) {
                            return operation.type === 'createAccount' || operation.type === 'payment';
                        });
                        if (txParams.type === 'trustline') {
                            this.verifyTrustlineTxOperations(tx.operations, txParams);
                        }
                        else {
                            if (_.isEmpty(outputOperations)) {
                                throw new Error('transaction prebuild does not have any operations');
                            }
                            _.forEach(txParams.recipients, function (expectedOutput, index) {
                                var expectedOutputAddress = self.getAddressDetails(expectedOutput.address);
                                var output = outputOperations[index];
                                if (output.destination !== expectedOutputAddress.address) {
                                    throw new Error('transaction prebuild does not match expected recipient');
                                }
                                var expectedOutputAmount = new bignumber_js_1.BigNumber(expectedOutput.amount);
                                // The output amount is expressed as startingBalance in createAccount operations and as amount in payment operations.
                                var outputAmountString = (output.type === 'createAccount') ? output.startingBalance : output.amount;
                                var outputAmount = new bignumber_js_1.BigNumber(self.bigUnitsToBaseUnits(outputAmountString));
                                if (!outputAmount.eq(expectedOutputAmount)) {
                                    throw new Error('transaction prebuild does not match expected amount');
                                }
                            });
                        }
                        if (!!_.isEmpty(tx.signatures)) return [3 /*break*/, 4];
                        userSignature = tx.signatures[0].signature();
                        keychains = verification.keychains;
                        if (!(!keychains && disableNetworking)) return [3 /*break*/, 1];
                        throw new Error('cannot fetch keychains without networking');
                    case 1:
                        if (!!keychains) return [3 /*break*/, 3];
                        return [4 /*yield*/, Bluebird.props({
                                user: self.keychains().get({ id: wallet.keyIds()[keychains_1.KeyIndices.USER] }),
                                backup: self.keychains().get({ id: wallet.keyIds()[keychains_1.KeyIndices.BACKUP] }),
                            })];
                    case 2:
                        keychains = _b.sent();
                        _b.label = 3;
                    case 3:
                        if (!keychains || !keychains.backup || !keychains.user) {
                            throw new Error('keychains are required, but could not be fetched');
                        }
                        if (self.verifySignature(keychains.backup.pub, tx.hash(), userSignature)) {
                            throw new Error('transaction signed with wrong key');
                        }
                        if (!self.verifySignature(keychains.user.pub, tx.hash(), userSignature)) {
                            throw new Error('transaction signature invalid');
                        }
                        _b.label = 4;
                    case 4: return [2 /*return*/, true];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Derive a hardened child public key from a master key seed using an additional seed for randomness.
     *
     * Due to technical differences between keypairs on the ed25519 curve and the secp256k1 curve,
     * only hardened private key derivation is supported.
     *
     * @param key seed for the master key. Note: Not the public key or encoded private key. This is the raw seed.
     * @param entropySeed random seed which is hashed to generate the derivation path
     */
    Xlm.prototype.deriveKeyWithSeed = function (_a) {
        var key = _a.key, seed = _a.seed;
        var derivationPathInput = bitcoin.crypto.hash256("" + seed).toString('hex');
        var derivationPathParts = [
            999999,
            parseInt(derivationPathInput.slice(0, 7), 16),
            parseInt(derivationPathInput.slice(7, 14), 16),
        ];
        var derivationPath = 'm/' + derivationPathParts
            .map(function (part) { return part + "'"; })
            .join('/');
        var derivedKey = keyDeriver_1.Ed25519KeyDeriver.derivePath(derivationPath, key).key;
        var keypair = stellar.Keypair.fromRawEd25519Seed(derivedKey);
        return {
            key: keypair.publicKey(),
            derivationPath: derivationPath,
        };
    };
    Xlm.prototype.parseTransaction = function (params, callback) {
        return Bluebird.resolve({}).asCallback(callback);
    };
    Xlm.tokenPatternSeparator = '-'; // separator for token code and issuer
    Xlm.maxMemoId = '0xFFFFFFFFFFFFFFFF'; // max unsigned 64-bit number = 18446744073709551615
    // max int64 number supported by the network (2^63)-1
    // See: https://www.stellar.org/developers/guides/concepts/assets.html#amount-precision-and-representation
    Xlm.maxTrustlineLimit = '9223372036854775807';
    /**
     * stellar-sdk has two overloads for toXDR, and typescript can't seem to figure out the
     * correct one to use, so we have to be very explicit as to which one we want.
     * @param tx transaction to convert
     */
    Xlm.txToString = function (tx) { return tx.toEnvelope().toXDR('base64'); };
    return Xlm;
}(baseCoin_1.BaseCoin));
exports.Xlm = Xlm;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieGxtLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3YyL2NvaW5zL3hsbS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwwQkFBNEI7QUFDNUIsd0NBQTBDO0FBQzFDLHlDQUEyQztBQUMzQyx5QkFBMkI7QUFDM0IsbUNBQXFDO0FBQ3JDLG9DQUFzQztBQUN0QyxxQ0FBdUM7QUFDdkMsNkNBQXlDO0FBRXpDLDBDQUEwQztBQUUxQyxxREFBMkQ7QUFDM0QscUNBQXVDO0FBQ3ZDLHFDQUF1QztBQUN2Qyx1Q0FNc0I7QUFDdEIsd0NBWXFCO0FBSXJCLElBQU0sRUFBRSxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUM7QUFtRzlCO0lBQXlCLHVCQUFRO0lBUS9CLGFBQVksS0FBWTtRQUF4QixZQUNFLGtCQUFNLEtBQUssQ0FBQyxTQUdiO1FBRkMsS0FBSSxDQUFDLFVBQVUsR0FBRyxXQUFXLENBQUMsQ0FBQyxxQ0FBcUM7UUFDcEUsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxPQUFPLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQzs7SUFDcEUsQ0FBQztJQUVNLGtCQUFjLEdBQXJCLFVBQXNCLEtBQVk7UUFDaEMsT0FBTyxJQUFJLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN4QixDQUFDO0lBRUQ7O09BRUc7SUFDSCwyQkFBYSxHQUFiO1FBQ0UsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0lBRUQ7O09BRUc7SUFDSCxzQkFBUSxHQUFSO1FBQ0UsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7O09BRUc7SUFDSCx1QkFBUyxHQUFUO1FBQ0UsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7O09BRUc7SUFDSCx5QkFBVyxHQUFYO1FBQ0UsT0FBTyxTQUFTLENB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QUFHLENBQUMsQ0FBQyxHQUFHLENBQUM7UUFDekUsSUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUMvRCxPQUFPO1lBQ0wsR0FBRyxFQUFFLE9BQU8sQ0FBQyxTQUFTLEVBQUU7WUFDeEIsY0FBYyxnQkFBQTtTQUNmLENBQUM7SUFDSixDQUFDO0lBU0QsOEJBQWdCLEdBQWhCLFVBQWlCLE1BQStCLEVBQUUsUUFBMEM7UUFDMUYsT0FBTyxRQUFRLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBbjdCc0IseUJBQXFCLEdBQUcsR0FBRyxDQUFDLENBQUMsc0NBQXNDO0lBQzFFLGFBQVMsR0FBVyxvQkFBb0IsQ0FBQyxDQUFDLG9EQUFvRDtJQUM5RyxxREFBcUQ7SUFDckQsMEdBQTBHO0lBQzFGLHFCQUFpQixHQUFXLHFCQUFxQixDQUFDO0lBczZCbEU7Ozs7T0FJRztJQUNjLGNBQVUsR0FBRyxVQUFDLEVBQXVCLElBQWEsT0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLENBQUMsS0FBaUMsQ0FBQyxRQUFRLENBQUMsRUFBNUQsQ0FBNEQsQ0FBQztJQUtsSSxVQUFDO0NBQUEsQUF0N0JELENBQXlCLG1CQUFRLEdBczdCaEM7QUF0N0JZLGtCQUFHIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0ICogYXMgYml0Y29pbiBmcm9tICdiaXRnby11dHhvLWxpYic7XG5pbXBvcnQgKiBhcyBxdWVyeXN0cmluZyBmcm9tICdxdWVyeXN0cmluZyc7XG5pbXBvcnQgKiBhcyB1cmwgZnJvbSAndXJsJztcbmltcG9ydCAqIGFzIEJsdWViaXJkIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCAqIGFzIHJlcXVlc3QgZnJvbSAnc3VwZXJhZ2VudCc7XG5pbXBvcnQgKiBhcyBzdGVsbGFyIGZyb20gJ3N0ZWxsYXItc2RrJztcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgeyBCaXRHbyB9IGZyb20gJy4uLy4uL2JpdGdvJztcbmltcG9ydCB7IEtleUluZGljZXMgfSBmcm9tICcuLi9rZXljaGFpbnMnO1xuXG5pbXBvcnQgeyBFZDI1NTE5S2V5RGVyaXZlciB9IGZyb20gJy4uL2ludGVybmFsL2tleURlcml2ZXInO1xuaW1wb3J0ICogYXMgY29uZmlnIGZyb20gJy4uLy4uL2NvbmZpZyc7XG5pbXBvcnQgKiBhcyBjb21tb24gZnJvbSAnLi4vLi4vY29tbW9uJztcbmltcG9ydCB7XG4gIEludmFsaWRBZGRyZXNzRXJyb3IsXG4gIEludmFsaWRNZW1vSWRFcnJvcixcbiAgS2V5UmVjb3ZlcnlTZXJ2aWNlRXJyb3IsXG4gIFVuZXhwZWN0ZWRBZGRyZXNzRXJyb3IsXG4gIFN0ZWxsYXJGZWRlcmF0aW9uVXNlck5vdEZvdW5kRXJyb3IsXG59IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5pbXBvcnQge1xuICBCYXNlQ29pbixcbiAgVHJhbnNhY3Rpb25SZWNpcGllbnQgYXMgQmFzZVRyYW5zYWN0aW9uT3V0cHV0LFxuICBUcmFuc2FjdGlvbkV4cGxhbmF0aW9uIGFzIEJhc2VUcmFuc2FjdGlvbkV4cGxhbmF0aW9uLFxuICBLZXlQYWlyLFxuICBWZXJpZnlBZGRyZXNzT3B0aW9ucyBhcyBCYXNlVmVyaWZ5QWRkcmVzc09wdGlvbnMsXG4gIFRyYW5zYWN0aW9uUHJlYnVpbGQgYXMgQmFzZVRyYW5zYWN0aW9uUHJlYnVpbGQsXG4gIFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zLFxuICBQYXJzZWRUcmFuc2FjdGlvbixcbiAgVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zIGFzIEJhc2VWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgYXMgQmFzZVNpZ25UcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFRyYW5zYWN0aW9uUGFyYW1zIGFzIEJhc2VUcmFuc2FjdGlvblBhcmFtcywgRXh0cmFQcmVidWlsZFBhcmFtc09wdGlvbnMsXG59IGZyb20gJy4uL2Jhc2VDb2luJztcbmltcG9ydCB7IE5vZGVDYWxsYmFjayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IFdhbGxldCB9IGZyb20gJy4uL3dhbGxldCc7XG5cbmNvbnN0IGNvID0gQmx1ZWJpcmQuY29yb3V0aW5lO1xuXG5pbnRlcmZhY2UgQWRkcmVzc0RldGFpbHMge1xuICBhZGRyZXNzOiBzdHJpbmc7XG4gIG1lbW9JZD86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIE1lbW8ge1xuICB0eXBlOiBzdGVsbGFyLk1lbW9UeXBlO1xuICB2YWx1ZTogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgSW5pdGlhdGVSZWNvdmVyeU9wdGlvbnMge1xuICB1c2VyS2V5OiBzdHJpbmc7XG4gIGJhY2t1cEtleTogc3RyaW5nO1xuICByZWNvdmVyeURlc3RpbmF0aW9uOiBzdHJpbmc7XG4gIGtyc1Byb3ZpZGVyPzogc3RyaW5nO1xuICB3YWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgUmVjb3ZlcnlPcHRpb25zIGV4dGVuZHMgSW5pdGlhdGVSZWNvdmVyeU9wdGlvbnMge1xuICByb290QWRkcmVzcz86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFJlY292ZXJ5VHJhbnNhY3Rpb24ge1xuICB0eDogc3RyaW5nO1xuICByZWNvdmVyeUFtb3VudDogbnVtYmVyO1xuICBiYWNrdXBLZXk/OiBzdHJpbmc7XG4gIGNvaW4/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBCdWlsZE9wdGlvbnMge1xuICB3YWxsZXQ/OiBXYWxsZXQ7XG4gIHJlY2lwaWVudHM/OiBvYmplY3RbXTtcbiAgdHlwZT86IHN0cmluZztcbiAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFRyYW5zYWN0aW9uUHJlYnVpbGQgZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25QcmVidWlsZCB7XG4gIHR4QmFzZTY0OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBTaWduVHJhbnNhY3Rpb25PcHRpb25zIGV4dGVuZHMgQmFzZVNpZ25UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eFByZWJ1aWxkOiBUcmFuc2FjdGlvblByZWJ1aWxkO1xuICBwcnY6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEhhbGZTaWduZWRUcmFuc2FjdGlvbiB7XG4gIGhhbGZTaWduZWQ6IHtcbiAgICB0eEJhc2U2NDogc3RyaW5nO1xuICB9XG59XG5cbmludGVyZmFjZSBTdXBwbGVtZW50R2VuZXJhdGVXYWxsZXRPcHRpb25zIHtcbiAgcm9vdFByaXZhdGVLZXk/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhCYXNlNjQ6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFRyYW5zYWN0aW9uTWVtbyB7XG4gIHZhbHVlPzogc3RyaW5nO1xuICB0eXBlPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgVHJhbnNhY3Rpb25PcGVyYXRpb24ge1xuICB0eXBlOiBzdHJpbmc7XG4gIGNvaW46IHN0cmluZztcbiAgbGltaXQ/OiBzdHJpbmc7XG4gIGFzc2V0Pzogc3RlbGxhci5Bc3NldDtcbn1cblxuaW50ZXJmYWNlIFRyYW5zYWN0aW9uT3V0cHV0IGV4dGVuZHMgQmFzZVRyYW5zYWN0aW9uT3V0cHV0IHtcbiAgY29pbjogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiBleHRlbmRzIEJhc2VUcmFuc2FjdGlvbkV4cGxhbmF0aW9uIHtcbiAgbWVtbzogVHJhbnNhY3Rpb25NZW1vO1xufVxuXG5pbnRlcmZhY2UgVmVyaWZ5QWRkcmVzc09wdGlvbnMgZXh0ZW5kcyBCYXNlVmVyaWZ5QWRkcmVzc09wdGlvbnMge1xuICByb290QWRkcmVzczogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgVHJ1c3RsaW5lT3B0aW9ucyB7XG4gIHRva2VuOiBzdHJpbmc7XG4gIGFjdGlvbjogc3RyaW5nO1xuICBsaW1pdD86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFRyYW5zYWN0aW9uUGFyYW1zIGV4dGVuZHMgQmFzZVRyYW5zYWN0aW9uUGFyYW1zIHtcbiAgdHJ1c3RsaW5lcz86IFRydXN0bGluZU9wdGlvbnNbXTtcbn1cblxuaW50ZXJmYWNlIFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyBleHRlbmRzIEJhc2VWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eFBhcmFtczogVHJhbnNhY3Rpb25QYXJhbXM7XG59XG5cbmV4cG9ydCBjbGFzcyBYbG0gZXh0ZW5kcyBCYXNlQ29pbiB7XG4gIHB1YmxpYyByZWFkb25seSBob21lRG9tYWluOiBzdHJpbmc7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgdG9rZW5QYXR0ZXJuU2VwYXJhdG9yID0gJy0nOyAvLyBzZXBhcmF0b3IgZm9yIHRva2VuIGNvZGUgYW5kIGlzc3VlclxuICBzdGF0aWMgcmVhZG9ubHkgbWF4TWVtb0lkOiBzdHJpbmcgPSAnMHhGRkZGRkZGRkZGRkZGRkZGJzsgLy8gbWF4IHVuc2lnbmVkIDY0LWJpdCBudW1iZXIgPSAxODQ0Njc0NDA3MzcwOTU1MTYxNVxuICAvLyBtYXggaW50NjQgbnVtYmVyIHN1cHBvcnRlZCBieSB0aGUgbmV0d29yayAoMl42MyktMVxuICAvLyBTZWU6IGh0dHBzOi8vd3d3LnN0ZWxsYXIub3JnL2RldmVsb3BlcnMvZ3VpZGVzL2NvbmNlcHRzL2Fzc2V0cy5odG1sI2Ftb3VudC1wcmVjaXNpb24tYW5kLXJlcHJlc2VudGF0aW9uXG4gIHN0YXRpYyByZWFkb25seSBtYXhUcnVzdGxpbmVMaW1pdDogc3RyaW5nID0gJzkyMjMzNzIwMzY4NTQ3NzU4MDcnO1xuXG4gIGNvbnN0cnVjdG9yKGJpdGdvOiBCaXRHbykge1xuICAgIHN1cGVyKGJpdGdvKTtcbiAgICB0aGlzLmhvbWVEb21haW4gPSAnYml0Z28uY29tJzsgLy8gdXNlZCBmb3IgcmV2ZXJzZSBmZWRlcmF0aW9uIGxvb2t1cFxuICAgIHN0ZWxsYXIuTmV0d29yay51c2UobmV3IHN0ZWxsYXIuTmV0d29yayhzdGVsbGFyLk5ldHdvcmtzLlBVQkxJQykpO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZUluc3RhbmNlKGJpdGdvOiBCaXRHbyk6IEJhc2VDb2luIHtcbiAgICByZXR1cm4gbmV3IFhsbShiaXRnbyk7XG4gIH1cblxuICAvKipcbiAgICogRmFjdG9yIGJldHdlZW4gdGhlIGJhc2UgdW5pdCBhbmQgaXRzIHNtYWxsZXN0IHN1YmRpdmlzb25cbiAgICovXG4gIGdldEJhc2VGYWN0b3IoKSB7XG4gICAgcmV0dXJuIDFlNztcbiAgfVxuXG4gIC8qKlxuICAgKiBJZGVudGlmaWVyIGZvciB0aGUgYmxvY2tjaGFpbiB3aGljaCBzdXBwb3J0cyB0aGlzIGNvaW5cbiAgICovXG4gIGdldENoYWluKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICd4bG0nO1xuICB9XG5cbiAgLyoqXG4gICAqIElkZW50aWZpZXIgZm9yIHRoZSBjb2luIGZhbWlseVxuICAgKi9cbiAgZ2V0RmFtaWx5KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICd4bG0nO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhpcyBjb2luXG4gICAqL1xuICBnZXRGdWxsTmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnU3RlbGxhcic7XG4gIH1cblxuICAvKipcbiAgICogVXJsIGF0IHdoaWNoIHRoZSBzdGVsbGFyIGZlZGVyYXRpb24gc2VydmVyIGNhbiBiZSByZWFjaGVkXG4gICAqL1xuICBnZXRGZWRlcmF0aW9uU2VydmVyVXJsKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGNvbW1vbi5FbnZpcm9ubWVudHNbdGhpcy5iaXRnby5nZXRFbnYoKV0uc3RlbGxhckZlZGVyYXRpb25TZXJ2ZXJVcmw7XG4gIH1cblxuICAvKipcbiAgICogVXJsIGF0IHdoaWNoIGhvcml6b24gY2FuIGJlIHJlYWNoZWRcbiAgICovXG4gIGdldEhvcml6b25VcmwoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ2h0dHBzOi8vaG9yaXpvbi5zdGVsbGFyLm9yZyc7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBuZXcga2V5IHBhaXIgb24gdGhlIGVkMjU1MTkgY3VydmVcbiAgICogQHBhcmFtIHNlZWRcbiAgICogQHJldHVybnMgZ2VuZXJhdGVkIHB1YiBhbmQgcHJ2XG4gICAqL1xuICBnZW5lcmF0ZUtleVBhaXIoc2VlZDogQnVmZmVyKTogS2V5UGFpciB7XG4gICAgY29uc3QgcGFpciA9IHNlZWQgPyBzdGVsbGFyLktleXBhaXIuZnJvbVJhd0VkMjU1MTlTZWVkKHNlZWQpIDogc3RlbGxhci5LZXlwYWlyLnJhbmRvbSgpO1xuICAgIHJldHVybiB7XG4gICAgICBwdWI6IHBhaXIucHVibGljS2V5KCksXG4gICAgICBwcnY6IHBhaXIuc2VjcmV0KCksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZGVjb2RlZCBlZDI1NTE5IHB1YmxpYyBrZXkgZnJvbSByYXcgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0gcHViIFJhdyBwdWJsaWMga2V5XG4gICAqIEByZXR1cm5zIEVuY29kZWQgcHVibGljIGtleVxuICAgKi9cbiAgZ2V0UHViRnJvbVJhdyhwdWI6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHN0ZWxsYXIuU3RyS2V5LmVuY29kZUVkMjU1MTlQdWJsaWNLZXkoQnVmZmVyLmZyb20ocHViLCAnaGV4JykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBkZWNvZGVkIGVkMjU1MTkgcHJpdmF0ZSBrZXkgZnJvbSByYXcgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0gcHJ2IFJhdyBwcml2YXRlIGtleVxuICAgKiBAcmV0dXJucyBFbmNvZGVkIHByaXZhdGUga2V5XG4gICAqL1xuICBnZXRQcnZGcm9tUmF3KHBydjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gc3RlbGxhci5TdHJLZXkuZW5jb2RlRWQyNTUxOVNlY3JldFNlZWQoQnVmZmVyLmZyb20ocHJ2LCAnaGV4JykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBwdWJsaWMga2V5IGZvciB0aGUgY29pbi5cbiAgICpcbiAgICogQHBhcmFtIHB1YiB0aGUgcHViIHRvIGJlIGNoZWNrZWRcbiAgICogQHJldHVybnMgaXMgaXQgdmFsaWQ/XG4gICAqL1xuICBpc1ZhbGlkUHViKHB1Yjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHN0ZWxsYXIuU3RyS2V5LmlzVmFsaWRFZDI1NTE5UHVibGljS2V5KHB1Yik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGlucHV0IGlzIHZhbGlkIHByaXZhdGUga2V5IGZvciB0aGUgY29pblxuICAgKlxuICAgKiBAcGFyYW0gcHJ2IHRoZSBwcnYgdG8gYmUgY2hlY2tlZFxuICAgKiBAcmV0dXJucyBpcyBpdCB2YWxpZD9cbiAgICovXG4gIGlzVmFsaWRQcnYocHJ2OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gc3RlbGxhci5TdHJLZXkuaXNWYWxpZEVkMjU1MTlTZWNyZXRTZWVkKHBydik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGEgbWVtbyBpZCBpcyB2YWxpZFxuICAgKlxuICAgKiBAcGFyYW0gbWVtb0lkIG1lbW8gaWRcbiAgICogQHJldHVybnMgdHJ1ZSBpZiBtZW1vIGlkIGlzIHZhbGlkXG4gICAqL1xuICBpc1ZhbGlkTWVtb0lkKG1lbW9JZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgbGV0IG1lbW9JZE51bWJlcjtcbiAgICB0cnkge1xuICAgICAgc3RlbGxhci5NZW1vLmlkKG1lbW9JZCk7IC8vIHRocm93cyBpZiB0aGUgdmFsdWUgaXMgbm90IHZhbGlkIG1lbW8gaWRcbiAgICAgIG1lbW9JZE51bWJlciA9IG5ldyBCaWdOdW1iZXIobWVtb0lkKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIChtZW1vSWROdW1iZXIuZ3RlKDApICYmIG1lbW9JZE51bWJlci5sdChYbG0ubWF4TWVtb0lkKSk7XG4gIH1cblxuICAvKipcbiAgICogRXZhbHVhdGVzIHdoZXRoZXIgYSBtZW1vIGlzIHZhbGlkXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSBvZiB0aGUgbWVtb1xuICAgKiBAcGFyYW0gdHlwZSB0eXBlIG9mIHRoZSBtZW1vXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdmFsdWUgYW5kIHR5cGUgYXJlIGEgdmFsaWRcbiAgICovXG4gIGlzVmFsaWRNZW1vKHsgdmFsdWUsIHR5cGUgfTogTWVtbyk6IGJvb2xlYW4ge1xuICAgIGlmICghdmFsdWUgfHwgIXR5cGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIHRocm93cyBpZiB0aGUgdmFsdWUgaXMgbm90IHZhbGlkIGZvciB0aGUgdHlwZVxuICAgICAgLy8gdmFsaWQgdHlwZXMgYXJlOiAnaWQnLCAndGV4dCcsICdoYXNoJywgJ3JldHVybidcbiAgICAgIC8vIFNlZSBodHRwczovL3d3dy5zdGVsbGFyLm9yZy9kZXZlbG9wZXJzL2d1aWRlcy9jb25jZXB0cy90cmFuc2FjdGlvbnMuaHRtbCNtZW1vXG4gICAgICBzdGVsbGFyLk1lbW9bdHlwZV0odmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogTWluaW11bSBiYWxhbmNlIG9mIGEgMi1vZi0zIG11bHRpc2lnIHdhbGxldFxuICAgKiBAcmV0dXJucyBtaW5pbXVtIGJhbGFuY2UgaW4gc3Ryb29wc1xuICAgKi9cbiAgZ2V0TWluaW11bVJlc2VydmUoKTogQmx1ZWJpcmQ8bnVtYmVyPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPG51bWJlcj4oZnVuY3Rpb24gKigpIHtcbiAgICAgIGNvbnN0IHNlcnZlciA9IG5ldyBzdGVsbGFyLlNlcnZlcihzZWxmLmdldEhvcml6b25VcmwoKSk7XG5cbiAgICAgIGNvbnN0IGhvcml6b25MZWRnZXJJbmZvID0geWllbGQgc2VydmVyXG4gICAgICAgIC5sZWRnZXJzKClcbiAgICAgICAgLm9yZGVyKCdkZXNjJylcbiAgICAgICAgLmxpbWl0KDEpXG4gICAgICAgIC5jYWxsKCk7XG5cbiAgICAgIGlmICghaG9yaXpvbkxlZGdlckluZm8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gY29ubmVjdCB0byBIb3Jpem9uIGZvciByZXNlcnZlIHJlcXVpcmVtZW50IGRhdGEnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYmFzZVJlc2VydmU6IG51bWJlciA9IGhvcml6b25MZWRnZXJJbmZvLnJlY29yZHNbMF0uYmFzZV9yZXNlcnZlX2luX3N0cm9vcHM7XG5cbiAgICAgIC8vIDItb2YtMyB3YWxsZXRzIGhhdmUgYSBtaW5pbXVtIHJlc2VydmUgb2YgNXggdGhlIGJhc2UgcmVzZXJ2ZVxuICAgICAgcmV0dXJuIDUgKiBiYXNlUmVzZXJ2ZTtcbiAgICB9KS5jYWxsKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zYWN0aW9uIGZlZSBmb3IgZWFjaCBvcGVyYXRpb25cbiAgICogQHJldHVybnMgdHJhbnNhY3Rpb24gZmVlIGluIHN0cm9vcHNcbiAgICovXG4gIGdldEJhc2VUcmFuc2FjdGlvbkZlZSgpOiBCbHVlYmlyZDxudW1iZXI+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288bnVtYmVyPihmdW5jdGlvbiAqKCkge1xuICAgICAgY29uc3Qgc2VydmVyID0gbmV3IHN0ZWxsYXIuU2VydmVyKHNlbGYuZ2V0SG9yaXpvblVybCgpKTtcblxuICAgICAgY29uc3QgaG9yaXpvbkxlZGdlckluZm8gPSB5aWVsZCBzZXJ2ZXJcbiAgICAgICAgLmxlZGdlcnMoKVxuICAgICAgICAub3JkZXIoJ2Rlc2MnKVxuICAgICAgICAubGltaXQoMSlcbiAgICAgICAgLmNhbGwoKTtcblxuICAgICAgaWYgKCFob3Jpem9uTGVkZ2VySW5mbykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBjb25uZWN0IHRvIEhvcml6b24gZm9yIHJlc2VydmUgcmVxdWlyZW1lbnQgZGF0YScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaG9yaXpvbkxlZGdlckluZm8ucmVjb3Jkc1swXS5iYXNlX2ZlZV9pbl9zdHJvb3BzO1xuICAgIH0pLmNhbGwodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyBhZGRyZXNzIGludG8gYWRkcmVzcyBhbmQgbWVtbyBpZFxuICAgKlxuICAgKiBAcGFyYW0gYWRkcmVzcyB0aGUgYWRkcmVzc1xuICAgKiBAcmV0dXJucyBvYmplY3QgY29udGFpbmluZyBhZGRyZXNzIGFuZCBtZW1vIGlkXG4gICAqL1xuICBnZXRBZGRyZXNzRGV0YWlscyhhZGRyZXNzOiBzdHJpbmcpOiBBZGRyZXNzRGV0YWlscyB7XG4gICAgY29uc3QgZGVzdGluYXRpb25EZXRhaWxzID0gdXJsLnBhcnNlKGFkZHJlc3MpO1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uQWRkcmVzcyA9IGRlc3RpbmF0aW9uRGV0YWlscy5wYXRobmFtZTtcbiAgICBpZiAoIWRlc3RpbmF0aW9uQWRkcmVzcyB8fCAhc3RlbGxhci5TdHJLZXkuaXNWYWxpZEVkMjU1MTlQdWJsaWNLZXkoZGVzdGluYXRpb25BZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGFkZHJlc3M6ICR7YWRkcmVzc31gKTtcbiAgICB9XG4gICAgLy8gYWRkcmVzcyBkb2Vzbid0IGhhdmUgYSBtZW1vIGlkXG4gICAgaWYgKGRlc3RpbmF0aW9uRGV0YWlscy5wYXRobmFtZSA9PT0gYWRkcmVzcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgbWVtb0lkOiB1bmRlZmluZWQsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghZGVzdGluYXRpb25EZXRhaWxzLnF1ZXJ5KSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihgaW52YWxpZCBhZGRyZXNzOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgcXVlcnlEZXRhaWxzID0gcXVlcnlzdHJpbmcucGFyc2UoZGVzdGluYXRpb25EZXRhaWxzLnF1ZXJ5KTtcbiAgICBpZiAoIXF1ZXJ5RGV0YWlscy5tZW1vSWQpIHtcbiAgICAgIC8vIGlmIHRoZXJlIGFyZSBtb3JlIHByb3BlcnRpZXMsIHRoZSBxdWVyeSBkZXRhaWxzIG5lZWQgdG8gY29udGFpbiB0aGUgbWVtbyBpZCBwcm9wZXJ0eVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoYGludmFsaWQgYWRkcmVzczogJHthZGRyZXNzfWApO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHF1ZXJ5RGV0YWlscy5tZW1vSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihcbiAgICAgICAgYG1lbW9JZCBtYXkgb25seSBiZSBnaXZlbiBhdCBtb3N0IG9uY2UsIGJ1dCBmb3VuZCAke3F1ZXJ5RGV0YWlscy5tZW1vSWQubGVuZ3RofSBpbnN0YW5jZXMgaW4gYWRkcmVzcyAke2FkZHJlc3N9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShxdWVyeURldGFpbHMubWVtb0lkKSAmJiBxdWVyeURldGFpbHMubWVtb0lkLmxlbmd0aCAhPT0gMSkge1xuICAgICAgLy8gdmFsaWQgYWRkcmVzc2VzIGNhbiBvbmx5IGNvbnRhaW4gb25lIG1lbW8gaWRcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKGBpbnZhbGlkIGFkZHJlc3MgJyR7YWRkcmVzc30nLCBtdXN0IGNvbnRhaW4gZXhhY3RseSBvbmUgbWVtb0lkYCk7XG4gICAgfVxuXG4gICAgY29uc3QgW21lbW9JZF0gPSBfLmNhc3RBcnJheShxdWVyeURldGFpbHMubWVtb0lkKTtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZE1lbW9JZChtZW1vSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZE1lbW9JZEVycm9yKGBpbnZhbGlkIGFkZHJlc3M6ICcke2FkZHJlc3N9JywgbWVtb0lkIGlzIG5vdCB2YWxpZGApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhZGRyZXNzOiBkZXN0aW5hdGlvbkFkZHJlc3MsXG4gICAgICBtZW1vSWQsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBhbmQgcmV0dXJuIGFkZHJlc3Mgd2l0aCBhcHBlbmRlZCBtZW1vIGlkXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyZXNzIGFkZHJlc3NcbiAgICogQHBhcmFtIG1lbW9JZCBtZW1vIGlkXG4gICAqIEByZXR1cm5zIGFkZHJlc3Mgd2l0aCBtZW1vIGlkXG4gICAqL1xuICBub3JtYWxpemVBZGRyZXNzKHsgYWRkcmVzcywgbWVtb0lkIH06IEFkZHJlc3NEZXRhaWxzKTogc3RyaW5nIHtcbiAgICBpZiAoIXN0ZWxsYXIuU3RyS2V5LmlzVmFsaWRFZDI1NTE5UHVibGljS2V5KGFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgYWRkcmVzcyBkZXRhaWxzOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuICAgIGlmIChtZW1vSWQgJiYgdGhpcy5pc1ZhbGlkTWVtb0lkKG1lbW9JZCkpIHtcbiAgICAgIHJldHVybiBgJHthZGRyZXNzfT9tZW1vSWQ9JHttZW1vSWR9YDtcbiAgICB9XG4gICAgcmV0dXJuIGFkZHJlc3M7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGlucHV0IGlzIHZhbGlkIHB1YmxpYyBrZXkgZm9yIHRoZSBjb2luXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyZXNzIHRoZSBwdWIgdG8gYmUgY2hlY2tlZFxuICAgKiBAcmV0dXJucyBpcyBpdCB2YWxpZD9cbiAgICovXG4gIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhZGRyZXNzRGV0YWlscyA9IHRoaXMuZ2V0QWRkcmVzc0RldGFpbHMoYWRkcmVzcyk7XG4gICAgICByZXR1cm4gYWRkcmVzcyA9PT0gdGhpcy5ub3JtYWxpemVBZGRyZXNzKGFkZHJlc3NEZXRhaWxzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIFN0ZWxsYXIgQXNzZXQgaW4gY29pbjp0b2tlbiBmb3JtIChpLmUuICh0KXhsbTo8Y29kZT4tPGlzc3Vlcj4pXG4gICAqIElmIHRoZSBhc3NldCBpcyBYTE0sIHJldHVybiB0aGUgY2hhaW5cbiAgICogQHBhcmFtIHtzdGVsbGFyLkFzc2V0fSBhc3NldCAtIGluc3RhbmNlIG9mIFN0ZWxsYXIgQXNzZXRcbiAgICovXG4gIGdldFRva2VuTmFtZUZyb21TdGVsbGFyQXNzZXQoYXNzZXQ6IHN0ZWxsYXIuQXNzZXQpIHtcbiAgICBjb25zdCBjb2RlID0gYXNzZXQuZ2V0Q29kZSgpO1xuICAgIGNvbnN0IGlzc3VlciA9IGFzc2V0LmdldElzc3VlcigpO1xuICAgIGlmIChhc3NldC5pc05hdGl2ZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRDaGFpbigpO1xuICAgIH1cbiAgICByZXR1cm4gYCR7dGhpcy5nZXRDaGFpbigpfSR7QmFzZUNvaW4uY29pblRva2VuUGF0dGVyblNlcGFyYXRvcn0ke2NvZGV9JHtYbG0udG9rZW5QYXR0ZXJuU2VwYXJhdG9yfSR7aXNzdWVyfWA7XG4gIH1cblxuICAvKipcbiAgICogRXZhbHVhdGUgd2hldGhlciBhIHN0ZWxsYXIgdXNlcm5hbWUgaGFzIHZhbGlkIGZvcm1hdFxuICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGJ5IHRoZSBjbGllbnQgd2hlbiBhIHN0ZWxsYXIgYWRkcmVzcyBpcyBiZWluZyBhZGRlZCB0byBhIHdhbGxldFxuICAgKiBFeGFtcGxlIG9mIGEgY29tbW9uIHN0ZWxsYXIgdXNlcm5hbWU6IGZvb0BiYXIuYmF6XG4gICAqIFRoZSBhYm92ZSBleGFtcGxlIHdvdWxkIHJlc3VsdCBpbiB0aGUgU3RlbGxhciBhZGRyZXNzOiBmb29AYmFyLmJheipiaXRnby5jb21cbiAgICpcbiAgICogQHBhcmFtIHVzZXJuYW1lIC0gc3RlbGxhciB1c2VybmFtZVxuICAgKiBAcmV0dXJuIHRydWUgaWYgc3RlbGxhciB1c2VybmFtZSBpcyB2YWxpZFxuICAgKi9cbiAgaXNWYWxpZFN0ZWxsYXJVc2VybmFtZSh1c2VybmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIC9eW2EtejAtOVxcLV8uK0BdKyQvLnRlc3QodXNlcm5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBpbnN0YW5jZSBvZiBGZWRlcmF0aW9uU2VydmVyIGZvciBCaXRHbyBsb29rdXBzXG4gICAqXG4gICAqIEByZXR1cm5zIGluc3RhbmNlIG9mIEJpdEdvIEZlZGVyYXRpb24gU2VydmVyXG4gICAqL1xuICBnZXRCaXRHb0ZlZGVyYXRpb25TZXJ2ZXIoKTogc3RlbGxhci5GZWRlcmF0aW9uU2VydmVyIHtcbiAgICAvLyBJZGVudGlmeSB0aGUgVVJJIHNjaGVtZSBpbiBjYXNlIHdlIG5lZWQgdG8gYWxsb3cgY29ubmVjdGluZyB0byBIVFRQIHNlcnZlci5cbiAgICBjb25zdCBpc05vblNlY3VyZUVudiA9ICFfLnN0YXJ0c1dpdGgoY29tbW9uLkVudmlyb25tZW50c1t0aGlzLmJpdGdvLmVudl0udXJpLCAnaHR0cHMnKTtcbiAgICBjb25zdCBmZWRlcmF0aW9uU2VydmVyT3B0aW9ucyA9IHsgYWxsb3dIdHRwOiBpc05vblNlY3VyZUVudiB9O1xuICAgIHJldHVybiBuZXcgc3RlbGxhci5GZWRlcmF0aW9uU2VydmVyKHRoaXMuZ2V0RmVkZXJhdGlvblNlcnZlclVybCgpLCAnYml0Z28uY29tJywgZmVkZXJhdGlvblNlcnZlck9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gZmVkZXJhdGlvbiBsb29rdXBzXG4gICAqIE91ciBmZWRlcmF0aW9uIHNlcnZlciBoYW5kbGVzIGxvb2t1cHMgZm9yIGJpdGdvIGFzIHdlbGwgYXMgZm9yIG90aGVyIGZlZGVyYXRpb24gZG9tYWluc1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2FkZHJlc3NdIC0gYWRkcmVzcyB0byBsb29rIHVwXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbYWNjb3VudElkXSAtIGFjY291bnQgaWQgdG8gbG9vayB1cFxuICAgKi9cbiAgcHJpdmF0ZSBmZWRlcmF0aW9uTG9va3VwKHsgYWRkcmVzcywgYWNjb3VudElkIH06IHsgYWRkcmVzcz86IHN0cmluZywgYWNjb3VudElkPzogc3RyaW5nIH0pOiBCbHVlYmlyZDxzdGVsbGFyLkZlZGVyYXRpb25TZXJ2ZXIuUmVjb3JkPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPHN0ZWxsYXIuRmVkZXJhdGlvblNlcnZlci5SZWNvcmQ+KGZ1bmN0aW9uICooKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBmZWRlcmF0aW9uU2VydmVyID0gc2VsZi5nZXRCaXRHb0ZlZGVyYXRpb25TZXJ2ZXIoKTtcbiAgICAgICAgaWYgKGFkZHJlc3MpIHtcbiAgICAgICAgICByZXR1cm4geWllbGQgZmVkZXJhdGlvblNlcnZlci5yZXNvbHZlQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgfSBlbHNlIGlmIChhY2NvdW50SWQpIHtcbiAgICAgICAgICByZXR1cm4geWllbGQgZmVkZXJhdGlvblNlcnZlci5yZXNvbHZlQWNjb3VudElkKGFjY291bnRJZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IC0gbXVzdCBwcm92aWRlIFN0ZWxsYXIgYWRkcmVzcyBvciBhY2NvdW50IGlkJyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBfLmdldChlLCAncmVzcG9uc2UuZGF0YS5kZXRhaWwnKTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN0ZWxsYXJGZWRlcmF0aW9uVXNlck5vdEZvdW5kRXJyb3IoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KS5jYWxsKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHQgdG8gcmVzb2x2ZSBhIHN0ZWxsYXIgYWRkcmVzcyBpbnRvIGEgc3RlbGxhciBhY2NvdW50XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIC0gc3RlbGxhciBhZGRyZXNzIHRvIGxvb2sgZm9yXG4gICAqL1xuICBmZWRlcmF0aW9uTG9va3VwQnlOYW1lKGFkZHJlc3M6IHN0cmluZyk6IEJsdWViaXJkPHN0ZWxsYXIuRmVkZXJhdGlvblNlcnZlci5SZWNvcmQ+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288c3RlbGxhci5GZWRlcmF0aW9uU2VydmVyLlJlY29yZD4oZnVuY3Rpb24gKigpIHtcbiAgICAgIGlmICghYWRkcmVzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgU3RlbGxhciBhZGRyZXNzJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLmZlZGVyYXRpb25Mb29rdXAoeyBhZGRyZXNzIH0pO1xuICAgIH0pLmNhbGwodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdCB0byByZXNvbHZlIGFuIGFjY291bnQgaWQgaW50byBhIHN0ZWxsYXIgYWNjb3VudFxuICAgKiBPbmx5IHdvcmtzIGZvciBhY2NvdW50cyB0aGF0IGNhbiBiZSByZXNvbHZlZCBieSBvdXIgZmVkZXJhdGlvbiBzZXJ2ZXJcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCAtIHN0ZWxsYXIgYWNjb3VudCBpZFxuICAgKi9cbiAgZmVkZXJhdGlvbkxvb2t1cEJ5QWNjb3VudElkKGFjY291bnRJZDogc3RyaW5nKTogQmx1ZWJpcmQ8c3RlbGxhci5GZWRlcmF0aW9uU2VydmVyLlJlY29yZD4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxzdGVsbGFyLkZlZGVyYXRpb25TZXJ2ZXIuUmVjb3JkPihmdW5jdGlvbiAqKCkge1xuICAgICAgaWYgKCFhY2NvdW50SWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFN0ZWxsYXIgYWNjb3VudCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGYuZmVkZXJhdGlvbkxvb2t1cCh7IGFjY291bnRJZCB9KTtcbiAgICB9KS5jYWxsKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFkZHJlc3MgaXMgYSB2YWxpZCBYTE0gYWRkcmVzcywgYW5kIHRoZW4gbWFrZSBzdXJlIGl0IG1hdGNoZXMgdGhlIHJvb3QgYWRkcmVzcy5cbiAgICpcbiAgICogQHBhcmFtIGFkZHJlc3Mge1N0cmluZ30gdGhlIGFkZHJlc3MgdG8gdmVyaWZ5XG4gICAqIEBwYXJhbSByb290QWRkcmVzcyB7U3RyaW5nfSB0aGUgd2FsbGV0J3Mgcm9vdCBhZGRyZXNzXG4gICAqL1xuICB2ZXJpZnlBZGRyZXNzKHsgYWRkcmVzcywgcm9vdEFkZHJlc3MgfTogVmVyaWZ5QWRkcmVzc09wdGlvbnMpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKGBpbnZhbGlkIGFkZHJlc3M6ICR7YWRkcmVzc31gKTtcbiAgICB9XG5cbiAgICBjb25zdCBhZGRyZXNzRGV0YWlscyA9IHRoaXMuZ2V0QWRkcmVzc0RldGFpbHMoYWRkcmVzcyk7XG4gICAgY29uc3Qgcm9vdEFkZHJlc3NEZXRhaWxzID0gdGhpcy5nZXRBZGRyZXNzRGV0YWlscyhyb290QWRkcmVzcyk7XG5cbiAgICBpZiAoYWRkcmVzc0RldGFpbHMuYWRkcmVzcyAhPT0gcm9vdEFkZHJlc3NEZXRhaWxzLmFkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQWRkcmVzc0Vycm9yKGBhZGRyZXNzIHZhbGlkYXRpb24gZmFpbHVyZTogJHthZGRyZXNzRGV0YWlscy5hZGRyZXNzfSB2cyAke3Jvb3RBZGRyZXNzRGV0YWlscy5hZGRyZXNzfWApO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBleHRyYSBwYXJhbWV0ZXJzIGZvciBwcmVidWlsZGluZyBhIHR4XG4gICAqIFNldCBlbXB0eSByZWNpcGllbnRzIGFycmF5IGluIHRydXN0bGluZSB0eHNcbiAgICovXG4gIGdldEV4dHJhUHJlYnVpbGRQYXJhbXMoYnVpbGRQYXJhbXM6IEV4dHJhUHJlYnVpbGRQYXJhbXNPcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxCdWlsZE9wdGlvbnM+KTogQmx1ZWJpcmQ8QnVpbGRPcHRpb25zPiB7XG4gICAgY29uc3QgcGFyYW1zOiB7IHJlY2lwaWVudHM/OiBvYmplY3RbXSB9ID0ge307XG4gICAgaWYgKGJ1aWxkUGFyYW1zLnR5cGUgPT09ICd0cnVzdGxpbmUnKSB7XG4gICAgICBwYXJhbXMucmVjaXBpZW50cyA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gQmx1ZWJpcmQucmVzb2x2ZShwYXJhbXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBTdGVsbGFyIGtleXBhaXJzIGZyb20gdGhlIHVzZXIga2V5IGFuZCBiYWNrdXAga2V5XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIGluaXRpYXRlUmVjb3ZlcnkocGFyYW1zOiBSZWNvdmVyeU9wdGlvbnMpOiBCbHVlYmlyZDxzdGVsbGFyLktleXBhaXJbXT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxzdGVsbGFyLktleXBhaXJbXT4oZnVuY3Rpb24gKigpIHtcbiAgICAgIGNvbnN0IGtleXM6IHN0ZWxsYXIuS2V5cGFpcltdID0gW107XG4gICAgICBsZXQgdXNlcktleSA9IHBhcmFtcy51c2VyS2V5O1xuICAgICAgbGV0IGJhY2t1cEtleSA9IHBhcmFtcy5iYWNrdXBLZXk7XG5cbiAgICAgIC8vIFN0ZWxsYXIncyBFZDI1NTE5IHB1YmxpYyBrZXlzIHN0YXJ0IHdpdGggYSBHLCB3aGlsZSBwcml2YXRlIGtleXMgc3RhcnQgd2l0aCBhbiBTXG4gICAgICBjb25zdCBpc0tyc1JlY292ZXJ5ID0gYmFja3VwS2V5LnN0YXJ0c1dpdGgoJ0cnKSAmJiAhdXNlcktleS5zdGFydHNXaXRoKCdHJyk7XG4gICAgICBjb25zdCBpc1Vuc2lnbmVkU3dlZXAgPSBiYWNrdXBLZXkuc3RhcnRzV2l0aCgnRycpICYmIHVzZXJLZXkuc3RhcnRzV2l0aCgnRycpO1xuXG5cbiAgICAgIGlmIChpc0tyc1JlY292ZXJ5ICYmIHBhcmFtcy5rcnNQcm92aWRlciAmJiBfLmlzVW5kZWZpbmVkKGNvbmZpZy5rcnNQcm92aWRlcnNbcGFyYW1zLmtyc1Byb3ZpZGVyXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEtleVJlY292ZXJ5U2VydmljZUVycm9yKGBVbmtub3duIGtleSByZWNvdmVyeSBzZXJ2aWNlIHByb3ZpZGVyIC0gJHtwYXJhbXMua3JzUHJvdmlkZXJ9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0tyc1JlY292ZXJ5ICYmIHBhcmFtcy5rcnNQcm92aWRlciAmJiAhY29uZmlnLmtyc1Byb3ZpZGVyc1twYXJhbXMua3JzUHJvdmlkZXJdLnN1cHBvcnRlZENvaW5zLmluY2x1ZGVzKHNlbGYuZ2V0RmFtaWx5KCkpKSB7XG4gICAgICAgIHRocm93IG5ldyBLZXlSZWNvdmVyeVNlcnZpY2VFcnJvcihgU3BlY2lmaWVkIGtleSByZWNvdmVyeSBzZXJ2aWNlIGRvZXMgbm90IHN1cHBvcnQgcmVjb3ZlcmllcyBmb3IgJHtzZWxmLmdldENoYWluKCl9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghc2VsZi5pc1ZhbGlkQWRkcmVzcyhwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoJ0ludmFsaWQgZGVzdGluYXRpb24gYWRkcmVzcyEnKTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCF1c2VyS2V5LnN0YXJ0c1dpdGgoJ1MnKSAmJiAhdXNlcktleS5zdGFydHNXaXRoKCdHJykpIHtcbiAgICAgICAgICB1c2VyS2V5ID0gc2VsZi5iaXRnby5kZWNyeXB0KHtcbiAgICAgICAgICAgIGlucHV0OiB1c2VyS2V5LFxuICAgICAgICAgICAgcGFzc3dvcmQ6IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdXNlcktleVBhaXIgPSBpc1Vuc2lnbmVkU3dlZXAgP1xuICAgICAgICAgIHN0ZWxsYXIuS2V5cGFpci5mcm9tUHVibGljS2V5KHVzZXJLZXkpIDpcbiAgICAgICAgICBzdGVsbGFyLktleXBhaXIuZnJvbVNlY3JldCh1c2VyS2V5KTtcbiAgICAgICAga2V5cy5wdXNoKHVzZXJLZXlQYWlyKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZGVjcnlwdCB1c2VyIGtleSB3aXRoIHBhc3Njb2RlIC0gdHJ5IGFnYWluIScpO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWJhY2t1cEtleS5zdGFydHNXaXRoKCdTJykgJiYgIWlzS3JzUmVjb3ZlcnkgJiYgIWlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgICAgIGJhY2t1cEtleSA9IHRoaXMuYml0Z28uZGVjcnlwdCh7XG4gICAgICAgICAgICBpbnB1dDogYmFja3VwS2V5LFxuICAgICAgICAgICAgcGFzc3dvcmQ6IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzS3JzUmVjb3ZlcnkgfHwgaXNVbnNpZ25lZFN3ZWVwKSB7XG4gICAgICAgICAga2V5cy5wdXNoKHN0ZWxsYXIuS2V5cGFpci5mcm9tUHVibGljS2V5KGJhY2t1cEtleSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtleXMucHVzaChzdGVsbGFyLktleXBhaXIuZnJvbVNlY3JldChiYWNrdXBLZXkpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkZWNyeXB0IGJhY2t1cCBrZXkgd2l0aCBwYXNzY29kZSAtIHRyeSBhZ2FpbiEnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGtleXM7XG4gICAgfSkuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBmdW5kcyByZWNvdmVyeSB0cmFuc2FjdGlvbiB3aXRob3V0IEJpdEdvXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogLSB1c2VyS2V5OiBbZW5jcnlwdGVkXSBTdGVsbGFyIHByaXZhdGUga2V5XG4gICAqIC0gYmFja3VwS2V5OiBbZW5jcnlwdGVkXSBTdGVsbGFyIHByaXZhdGUga2V5LCBvciBwdWJsaWMga2V5IGlmIHRoZSBwcml2YXRlIGtleSBpcyBoZWxkIGJ5IGEgS1JTIHByb3ZpZGVyXG4gICAqIC0gd2FsbGV0UGFzc3BocmFzZTogbmVjZXNzYXJ5IGlmIG9uZSBvZiB0aGUgcHJpdmF0ZSBrZXlzIGlzIGVuY3J5cHRlZFxuICAgKiAtIHJvb3RBZGRyZXNzOiBiYXNlIGFkZHJlc3Mgb2YgdGhlIHdhbGxldCB0byByZWNvdmVyIGZ1bmRzIGZyb21cbiAgICogLSBrcnNQcm92aWRlcjogbmVjZXNzYXJ5IGlmIGJhY2t1cCBrZXkgaXMgaGVsZCBieSBLUlNcbiAgICogLSByZWNvdmVyeURlc3RpbmF0aW9uOiB0YXJnZXQgYWRkcmVzcyB0byBzZW5kIHJlY292ZXJlZCBmdW5kcyB0b1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHJlY292ZXIocGFyYW1zOiBSZWNvdmVyeU9wdGlvbnMsIGNhbGxiYWNrOiBOb2RlQ2FsbGJhY2s8UmVjb3ZlcnlUcmFuc2FjdGlvbj4pOiBCbHVlYmlyZDxSZWNvdmVyeVRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPFJlY292ZXJ5VHJhbnNhY3Rpb24+KGZ1bmN0aW9uICooKSB7XG4gICAgICBjb25zdCBbdXNlcktleSwgYmFja3VwS2V5XSA9IHlpZWxkIHNlbGYuaW5pdGlhdGVSZWNvdmVyeShwYXJhbXMpO1xuICAgICAgY29uc3QgaXNLcnNSZWNvdmVyeSA9IHBhcmFtcy5iYWNrdXBLZXkuc3RhcnRzV2l0aCgnRycpICYmICFwYXJhbXMudXNlcktleS5zdGFydHNXaXRoKCdHJyk7XG4gICAgICBjb25zdCBpc1Vuc2lnbmVkU3dlZXAgPSBwYXJhbXMuYmFja3VwS2V5LnN0YXJ0c1dpdGgoJ0cnKSAmJiBwYXJhbXMudXNlcktleS5zdGFydHNXaXRoKCdHJyk7XG5cbiAgICAgIGlmICghcGFyYW1zLnJvb3RBZGRyZXNzIHx8ICFzdGVsbGFyLlN0cktleS5pc1ZhbGlkRWQyNTUxOVB1YmxpY0tleShwYXJhbXMucm9vdEFkZHJlc3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB3YWxsZXQgYWRkcmVzczogJHtwYXJhbXMucm9vdEFkZHJlc3N9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFjY291bnREYXRhVXJsID0gYCR7c2VsZi5nZXRIb3Jpem9uVXJsKCl9L2FjY291bnRzLyR7cGFyYW1zLnJvb3RBZGRyZXNzfWA7XG4gICAgICBjb25zdCBkZXN0aW5hdGlvblVybCA9IGAke3NlbGYuZ2V0SG9yaXpvblVybCgpfS9hY2NvdW50cy8ke3BhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9ufWA7XG5cbiAgICAgIGxldCBhY2NvdW50RGF0YTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGFjY291bnREYXRhID0geWllbGQgcmVxdWVzdC5nZXQoYWNjb3VudERhdGFVcmwpLnJlc3VsdCgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byByZWFjaCB0aGUgU3RlbGxhciBuZXR3b3JrIHZpYSBIb3Jpem9uLicpO1xuICAgICAgfVxuXG4gICAgICAvLyBOb3cgY2hlY2sgaWYgdGhlIGRlc3RpbmF0aW9uIGFjY291bnQgaXMgZW1wdHkgb3Igbm90XG4gICAgICBsZXQgdW5mdW5kZWREZXN0aW5hdGlvbiA9IGZhbHNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgeWllbGQgcmVxdWVzdC5nZXQoZGVzdGluYXRpb25VcmwpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkZXN0aW5hdGlvbiBhY2NvdW50IGRvZXMgbm90IHlldCBleGlzdCwgaG9yaXpvbiByZXNwb25kcyB3aXRoIDQwNFxuICAgICAgICAgIHVuZnVuZGVkRGVzdGluYXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghYWNjb3VudERhdGEuc2VxdWVuY2UgfHwgIWFjY291bnREYXRhLmJhbGFuY2VzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSG9yaXpvbiBzZXJ2ZXIgZXJyb3IgLSB1bmFibGUgdG8gcmV0cmlldmUgc2VxdWVuY2UgSUQgb3IgYWNjb3VudCBiYWxhbmNlJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFjY291bnQgPSBuZXcgc3RlbGxhci5BY2NvdW50KHBhcmFtcy5yb290QWRkcmVzcywgYWNjb3VudERhdGEuc2VxdWVuY2UpO1xuXG4gICAgICAvLyBTdGVsbGFyIHN1cHBvcnRzIG11bHRpcGxlIGFzc2V0cyBvbiBjaGFpbiwgd2UncmUgb25seSBpbnRlcmVzdGVkIGluIHRoZSBiYWxhbmNlcyBlbnRyeSB3aG9zZSB0eXBlIGlzIFwibmF0aXZlXCIgKFhMTSlcbiAgICAgIGNvbnN0IG5hdGl2ZUJhbGFuY2VJbmZvID0gYWNjb3VudERhdGEuYmFsYW5jZXMuZmluZChhc3NldEJhbGFuY2UgPT4gYXNzZXRCYWxhbmNlWydhc3NldF90eXBlJ10gPT09ICduYXRpdmUnKTtcblxuICAgICAgaWYgKCFuYXRpdmVCYWxhbmNlSW5mbykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGVkIHdhbGxldCBoYXMgYSBiYWxhbmNlIG9mIDAgWExNLCByZWNvdmVyeSBhYm9ydGVkJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHdhbGxldEJhbGFuY2UgPSBOdW1iZXIoc2VsZi5iaWdVbml0c1RvQmFzZVVuaXRzKG5hdGl2ZUJhbGFuY2VJbmZvLmJhbGFuY2UpKTtcbiAgICAgIGNvbnN0IG1pbmltdW1SZXNlcnZlOiBudW1iZXIgPSB5aWVsZCBzZWxmLmdldE1pbmltdW1SZXNlcnZlKCk7XG4gICAgICBjb25zdCBiYXNlVHhGZWU6IG51bWJlciA9IHlpZWxkIHNlbGYuZ2V0QmFzZVRyYW5zYWN0aW9uRmVlKCk7XG4gICAgICBjb25zdCByZWNvdmVyeUFtb3VudCA9IHdhbGxldEJhbGFuY2UgLSBtaW5pbXVtUmVzZXJ2ZSAtIGJhc2VUeEZlZTtcbiAgICAgIGNvbnN0IGZvcm1hdHRlZFJlY292ZXJ5QW1vdW50ID0gc2VsZi5iYXNlVW5pdHNUb0JpZ1VuaXRzKHJlY292ZXJ5QW1vdW50KS50b1N0cmluZygpO1xuXG4gICAgICBjb25zdCB0eEJ1aWxkZXIgPSBuZXcgc3RlbGxhci5UcmFuc2FjdGlvbkJ1aWxkZXIoYWNjb3VudCk7XG4gICAgICBjb25zdCBvcGVyYXRpb24gPSB1bmZ1bmRlZERlc3RpbmF0aW9uID9cbiAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgYWNjb3VudFxuICAgICAgICBzdGVsbGFyLk9wZXJhdGlvbi5jcmVhdGVBY2NvdW50KHtcbiAgICAgICAgICBkZXN0aW5hdGlvbjogcGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24sXG4gICAgICAgICAgc3RhcnRpbmdCYWxhbmNlOiBmb3JtYXR0ZWRSZWNvdmVyeUFtb3VudCxcbiAgICAgICAgfSkgOlxuICAgICAgICAvLyBPdGhlcndpc2UgaWYgdGhlIGFjY291bnQgYWxyZWFkeSBleGlzdHMsIHdlIGRvIGEgbm9ybWFsIHNlbmRcbiAgICAgICAgc3RlbGxhci5PcGVyYXRpb24ucGF5bWVudCh7XG4gICAgICAgICAgZGVzdGluYXRpb246IHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uLFxuICAgICAgICAgIGFzc2V0OiBzdGVsbGFyLkFzc2V0Lm5hdGl2ZSgpLFxuICAgICAgICAgIGFtb3VudDogZm9ybWF0dGVkUmVjb3ZlcnlBbW91bnQsXG4gICAgICAgIH0pO1xuICAgICAgY29uc3QgdHggPSB0eEJ1aWxkZXIuYWRkT3BlcmF0aW9uKG9wZXJhdGlvbikuYnVpbGQoKTtcblxuICAgICAgaWYgKCFpc1Vuc2lnbmVkU3dlZXApIHtcbiAgICAgICAgdHguc2lnbih1c2VyS2V5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0tyc1JlY292ZXJ5ICYmICFpc1Vuc2lnbmVkU3dlZXApIHtcbiAgICAgICAgdHguc2lnbihiYWNrdXBLZXkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbjogUmVjb3ZlcnlUcmFuc2FjdGlvbiA9IHtcbiAgICAgICAgdHg6IFhsbS50eFRvU3RyaW5nKHR4KSxcbiAgICAgICAgcmVjb3ZlcnlBbW91bnQsXG4gICAgICB9O1xuXG4gICAgICBpZiAoaXNLcnNSZWNvdmVyeSkge1xuICAgICAgICB0cmFuc2FjdGlvbi5iYWNrdXBLZXkgPSBwYXJhbXMuYmFja3VwS2V5O1xuICAgICAgICB0cmFuc2FjdGlvbi5jb2luID0gc2VsZi5nZXRDaGFpbigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJhbnNhY3Rpb247XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlbWJsZSBrZXljaGFpbiBhbmQgaGFsZi1zaWduIHByZWJ1aWx0IHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy50eFByZWJ1aWxkIHtPYmplY3R9IHByZWJ1aWxkIG9iamVjdCByZXR1cm5lZCBieSBwbGF0Zm9ybVxuICAgKiBAcGFyYW0gcGFyYW1zLnBydiB7U3RyaW5nfSB1c2VyIHBydlxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge0JsdWViaXJkPEhhbGZTaWduZWRUcmFuc2FjdGlvbj59XG4gICAqL1xuICBzaWduVHJhbnNhY3Rpb24ocGFyYW1zOiBTaWduVHJhbnNhY3Rpb25PcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxIYWxmU2lnbmVkVHJhbnNhY3Rpb24+KTogQmx1ZWJpcmQ8SGFsZlNpZ25lZFRyYW5zYWN0aW9uPiB7XG4gICAgcmV0dXJuIGNvPEhhbGZTaWduZWRUcmFuc2FjdGlvbj4oZnVuY3Rpb24gKigpIHtcbiAgICAgIGNvbnN0IHsgdHhQcmVidWlsZCwgcHJ2IH0gPSBwYXJhbXM7XG5cbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHR4UHJlYnVpbGQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyB0eFByZWJ1aWxkIHBhcmFtZXRlcicpO1xuICAgICAgfVxuICAgICAgaWYgKCFfLmlzT2JqZWN0KHR4UHJlYnVpbGQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdHhQcmVidWlsZCBtdXN0IGJlIGFuIG9iamVjdCwgZ290IHR5cGUgJHt0eXBlb2YgdHhQcmVidWlsZH1gKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocHJ2KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcHJ2IHBhcmFtZXRlciB0byBzaWduIHRyYW5zYWN0aW9uJyk7XG4gICAgICB9XG4gICAgICBpZiAoIV8uaXNTdHJpbmcocHJ2KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBydiBtdXN0IGJlIGEgc3RyaW5nLCBnb3QgdHlwZSAke3R5cGVvZiBwcnZ9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGtleVBhaXIgPSBzdGVsbGFyLktleXBhaXIuZnJvbVNlY3JldChwcnYpO1xuICAgICAgY29uc3QgdHggPSBuZXcgc3RlbGxhci5UcmFuc2FjdGlvbih0eFByZWJ1aWxkLnR4QmFzZTY0KTtcbiAgICAgIHR4LnNpZ24oa2V5UGFpcik7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhhbGZTaWduZWQ6IHtcbiAgICAgICAgICB0eEJhc2U2NDogWGxtLnR4VG9TdHJpbmcodHgpLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRlbmQgd2FsbGV0UGFyYW1zIHdpdGggZXh0cmEgcGFyYW1zIHJlcXVpcmVkIGZvciBnZW5lcmF0aW5nIGFuIFhMTSB3YWxsZXRcbiAgICpcbiAgICogU3RlbGxhciB3YWxsZXRzIGhhdmUgdGhyZWUga2V5Y2hhaW5zIG9uIHRoZW0uIFR3byBhcmUgZ2VuZXJhdGVkIGJ5IHRoZSBwbGF0Zm9ybSwgYW5kIHRoZSBsYXN0IGlzIGdlbmVyYXRlZCBieSB0aGUgdXNlci5cbiAgICogSW5pdGlhbGx5LCB3ZSBuZWVkIGEgcm9vdCBwcnYgdG8gZ2VuZXJhdGUgdGhlIGFjY291bnQsIHdoaWNoIG11c3QgYmUgZGlzdGluY3QgZnJvbSBhbGwgdGhyZWUga2V5Y2hhaW5zIG9uIHRoZSB3YWxsZXQuXG4gICAqIElmIGEgcm9vdCBwcnYgaXMgbm90IHByb3ZpZGVkLCBhIHJhbmRvbSBvbmUgaXMgZ2VuZXJhdGVkLlxuICAgKi9cbiAgc3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0KHdhbGxldFBhcmFtczogU3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0T3B0aW9ucyk6IEJsdWViaXJkPFN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldE9wdGlvbnM+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288U3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0T3B0aW9ucz4oZnVuY3Rpb24gKigpIHtcbiAgICAgIGxldCBzZWVkO1xuICAgICAgY29uc3Qgcm9vdFBydiA9IHdhbGxldFBhcmFtcy5yb290UHJpdmF0ZUtleTtcbiAgICAgIGlmIChyb290UHJ2KSB7XG4gICAgICAgIGlmICghc2VsZi5pc1ZhbGlkUHJ2KHJvb3RQcnYpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyb290UHJpdmF0ZUtleSBuZWVkcyB0byBiZSB2YWxpZCBlZDI1NTE5IHNlY3JldCBzZWVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgc2VlZCA9IHN0ZWxsYXIuU3RyS2V5LmRlY29kZUVkMjU1MTlTZWNyZXRTZWVkKHJvb3RQcnYpO1xuICAgICAgfVxuICAgICAgY29uc3Qga2V5UGFpciA9IHNlbGYuZ2VuZXJhdGVLZXlQYWlyKHNlZWQpO1xuICAgICAgLy8gZXh0ZW5kIHRoZSB3YWxsZXQgaW5pdGlhbGl6YXRpb24gcGFyYW1zXG4gICAgICB3YWxsZXRQYXJhbXMucm9vdFByaXZhdGVLZXkgPSBrZXlQYWlyLnBydjtcbiAgICAgIHJldHVybiB3YWxsZXRQYXJhbXM7XG4gICAgfSkuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWduIG1lc3NhZ2Ugd2l0aCBwcml2YXRlIGtleVxuICAgKlxuICAgKiBAcGFyYW0ga2V5XG4gICAqIEBwYXJhbSBtZXNzYWdlXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgc2lnbk1lc3NhZ2Uoa2V5OiBLZXlQYWlyLCBtZXNzYWdlOiBzdHJpbmcgfCBCdWZmZXIsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPEJ1ZmZlcj4pOiBCbHVlYmlyZDxCdWZmZXI+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288QnVmZmVyPihmdW5jdGlvbiogY29zaWduTWVzc2FnZSgpIHtcbiAgICAgIGlmICghc2VsZi5pc1ZhbGlkUHJ2KGtleS5wcnYpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBwcnY6ICR7a2V5LnBydn1gKTtcbiAgICAgIH1cbiAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKG1lc3NhZ2UpKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBCdWZmZXIuZnJvbShtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGtleXBhaXIgPSBzdGVsbGFyLktleXBhaXIuZnJvbVNlY3JldChrZXkucHJ2KTtcbiAgICAgIHJldHVybiBrZXlwYWlyLnNpZ24obWVzc2FnZSk7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZpZXMgaWYgc2lnbmF0dXJlIGZvciBtZXNzYWdlIGlzIHZhbGlkLlxuICAgKlxuICAgKiBAcGFyYW0gcHViIHB1YmxpYyBrZXlcbiAgICogQHBhcmFtIG1lc3NhZ2Ugc2lnbmVkIG1lc3NhZ2VcbiAgICogQHBhcmFtIHNpZ25hdHVyZSBzaWduYXR1cmUgdG8gdmVyaWZ5XG4gICAqIEByZXR1cm5zIHRydWUgaWYgc2lnbmF0dXJlIGlzIHZhbGlkLlxuICAgKi9cbiAgdmVyaWZ5U2lnbmF0dXJlKHB1Yjogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcgfCBCdWZmZXIsIHNpZ25hdHVyZTogQnVmZmVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWRQdWIocHViKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHB1YjogJHtwdWJ9YCk7XG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKG1lc3NhZ2UpKSB7XG4gICAgICBtZXNzYWdlID0gQnVmZmVyLmZyb20obWVzc2FnZSk7XG4gICAgfVxuICAgIGNvbnN0IGtleVBhaXIgPSBzdGVsbGFyLktleXBhaXIuZnJvbVB1YmxpY0tleShwdWIpO1xuICAgIHJldHVybiBrZXlQYWlyLnZlcmlmeShtZXNzYWdlLCBzaWduYXR1cmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cGxhaW4vcGFyc2UgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGV4cGxhaW5UcmFuc2FjdGlvbihwYXJhbXM6IEV4cGxhaW5UcmFuc2FjdGlvbk9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFRyYW5zYWN0aW9uRXhwbGFuYXRpb24+KTogQmx1ZWJpcmQ8VHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxUcmFuc2FjdGlvbkV4cGxhbmF0aW9uPihmdW5jdGlvbiAqKCkge1xuICAgICAgY29uc3QgeyB0eEJhc2U2NCB9ID0gcGFyYW1zO1xuICAgICAgbGV0IHR4OiBzdGVsbGFyLlRyYW5zYWN0aW9uO1xuXG4gICAgICB0cnkge1xuICAgICAgICB0eCA9IG5ldyBzdGVsbGFyLlRyYW5zYWN0aW9uKHR4QmFzZTY0KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eEJhc2U2NCBuZWVkcyB0byBiZSBhIHZhbGlkIHR4IGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZycpO1xuICAgICAgfVxuICAgICAgY29uc3QgaWQgPSB0eC5oYXNoKCkudG9TdHJpbmcoJ2hleCcpO1xuXG4gICAgICAvLyBJbiBhIFN0ZWxsYXIgdHgsIHRoZSBfbWVtbyBwcm9wZXJ0eSBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgbWV0aG9kczpcbiAgICAgIC8vIHZhbHVlKCkgYW5kIGFybSgpIHRoYXQgcHJvdmlkZSBtZW1vIHZhbHVlIGFuZCB0eXBlLCByZXNwZWN0aXZlbHkuXG4gICAgICBjb25zdCBtZW1vOiBUcmFuc2FjdGlvbk1lbW8gPSBfLnJlc3VsdCh0eCwgJ19tZW1vLnZhbHVlJykgJiYgXy5yZXN1bHQodHgsICdfbWVtby5hcm0nKSA/XG4gICAgICAgIHtcbiAgICAgICAgICB2YWx1ZTogKF8ucmVzdWx0KHR4LCAnX21lbW8udmFsdWUnKSBhcyBhbnkpLnRvU3RyaW5nKCksXG4gICAgICAgICAgdHlwZTogXy5yZXN1bHQodHgsICdfbWVtby5hcm0nKSxcbiAgICAgICAgfSA6IHt9O1xuXG4gICAgICBsZXQgc3BlbmRBbW91bnQgPSBuZXcgQmlnTnVtYmVyKDApOyAvLyBhbW91bnQgb2YgWExNIHVzZWQgaW4gWExNLW9ubHkgdHhzXG4gICAgICBjb25zdCBzcGVuZEFtb3VudHMgPSB7fTsgLy8gdHJhY2sgYm90aCB4bG0gYW5kIHRva2VuIGFtb3VudHNcbiAgICAgIGlmIChfLmlzRW1wdHkodHgub3BlcmF0aW9ucykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIG9wZXJhdGlvbnMnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3V0cHV0czogVHJhbnNhY3Rpb25PdXRwdXRbXSA9IFtdO1xuICAgICAgY29uc3Qgb3BlcmF0aW9uczogVHJhbnNhY3Rpb25PcGVyYXRpb25bXSA9IFtdOyAvLyBub24tcGF5bWVudCBvcGVyYXRpb25zXG5cbiAgICAgIF8uZm9yRWFjaCh0eC5vcGVyYXRpb25zLCBvcCA9PiB7XG4gICAgICAgIGlmIChvcC50eXBlID09PSAnY3JlYXRlQWNjb3VudCcgfHwgb3AudHlwZSA9PT0gJ3BheW1lbnQnKSB7XG4gICAgICAgICAgLy8gVE9ETyBSZW1vdmUgbWVtb0lkIGZyb20gYWRkcmVzc1xuICAgICAgICAgIC8vIEdldCBtZW1vIHRvIGF0dGFjaCB0byBhZGRyZXNzLCBpZiB0eXBlIGlzICdpZCdcbiAgICAgICAgICBjb25zdCBtZW1vSWQgPSBfLmdldChtZW1vLCAndHlwZScpID09PSAnaWQnICYmICEgXy5nZXQobWVtbywgJ3ZhbHVlJykgP1xuICAgICAgICAgICAgYD9tZW1vSWQ9JHttZW1vLnZhbHVlfWAgOlxuICAgICAgICAgICAgJyc7XG4gICAgICAgICAgY29uc3QgYXNzZXQgPSBvcC50eXBlID09PSAncGF5bWVudCcgPyBvcC5hc3NldCA6IHN0ZWxsYXIuQXNzZXQubmF0aXZlKCk7XG4gICAgICAgICAgY29uc3QgY29pbiA9IHNlbGYuZ2V0VG9rZW5OYW1lRnJvbVN0ZWxsYXJBc3NldChhc3NldCk7IC8vIGNvaW4gb3IgdG9rZW4gaWRcbiAgICAgICAgICBjb25zdCBvdXRwdXQ6IFRyYW5zYWN0aW9uT3V0cHV0ID0ge1xuICAgICAgICAgICAgYW1vdW50OiBzZWxmLmJpZ1VuaXRzVG9CYXNlVW5pdHMoXG4gICAgICAgICAgICAgIChvcCBhcyBzdGVsbGFyLk9wZXJhdGlvbi5DcmVhdGVBY2NvdW50KS5zdGFydGluZ0JhbGFuY2UgfHwgKG9wIGFzIHN0ZWxsYXIuT3BlcmF0aW9uLlBheW1lbnQpLmFtb3VudFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGFkZHJlc3M6IG9wLmRlc3RpbmF0aW9uICsgbWVtb0lkLFxuICAgICAgICAgICAgY29pbixcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHNwZW5kQW1vdW50c1tjb2luXSkpIHtcbiAgICAgICAgICAgIHNwZW5kQW1vdW50c1tjb2luXSA9IHNwZW5kQW1vdW50c1tjb2luXS5wbHVzKG91dHB1dC5hbW91bnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzcGVuZEFtb3VudHNbY29pbl0gPSBuZXcgQmlnTnVtYmVyKG91dHB1dC5hbW91bnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXNzZXQuaXNOYXRpdmUoKSkge1xuICAgICAgICAgICAgc3BlbmRBbW91bnQgPSBzcGVuZEFtb3VudC5wbHVzKG91dHB1dC5hbW91bnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXRzLnB1c2gob3V0cHV0KTtcbiAgICAgICAgfSBlbHNlIGlmIChvcC50eXBlID09PSAnY2hhbmdlVHJ1c3QnKSB7XG4gICAgICAgICAgb3BlcmF0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IG9wLnR5cGUsXG4gICAgICAgICAgICBjb2luOiBzZWxmLmdldFRva2VuTmFtZUZyb21TdGVsbGFyQXNzZXQob3AubGluZSksXG4gICAgICAgICAgICBhc3NldDogb3AubGluZSxcbiAgICAgICAgICAgIGxpbWl0OiBzZWxmLmJpZ1VuaXRzVG9CYXNlVW5pdHMob3AubGltaXQpLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgb3V0cHV0QW1vdW50ID0gc3BlbmRBbW91bnQudG9GaXhlZCgwKTtcbiAgICAgIGNvbnN0IG91dHB1dEFtb3VudHMgPSBfLm1hcFZhbHVlcyhzcGVuZEFtb3VudHMsIChhbW91bnQ6IEJpZ051bWJlcikgPT4gYW1vdW50LnRvRml4ZWQoMCkpO1xuICAgICAgY29uc3QgZmVlID0ge1xuICAgICAgICBmZWU6IHR4LmZlZS50b0ZpeGVkKDApLFxuICAgICAgICBmZWVSYXRlOiBudWxsLFxuICAgICAgICBzaXplOiBudWxsLFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzcGxheU9yZGVyOiBbJ2lkJywgJ291dHB1dEFtb3VudCcsICdvdXRwdXRBbW91bnRzJywgJ2NoYW5nZUFtb3VudCcsICdvdXRwdXRzJywgJ2NoYW5nZU91dHB1dHMnLCAnZmVlJywgJ21lbW8nLCAnb3BlcmF0aW9ucyddLFxuICAgICAgICBpZCxcbiAgICAgICAgb3V0cHV0cyxcbiAgICAgICAgb3V0cHV0QW1vdW50LFxuICAgICAgICBvdXRwdXRBbW91bnRzLFxuICAgICAgICBjaGFuZ2VPdXRwdXRzOiBbXSxcbiAgICAgICAgY2hhbmdlQW1vdW50OiAnMCcsXG4gICAgICAgIG1lbW8sXG4gICAgICAgIGZlZSxcbiAgICAgICAgb3BlcmF0aW9ucyxcbiAgICAgIH07XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgdGhhdCBhIHR4IHByZWJ1aWxkJ3Mgb3BlcmF0aW9ucyBjb21wbHkgd2l0aCB0aGUgb3JpZ2luYWwgaW50ZW50aW9uXG4gICAqIEBwYXJhbSB7c3RlbGxhci5PcGVyYXRpb259IG9wZXJhdGlvbnMgLSB0eCBvcGVyYXRpb25zXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25QYXJhbXN9IHR4UGFyYW1zIC0gcGFyYW1zIHVzZWQgdG8gYnVpbGQgdGhlIHR4XG4gICAqL1xuICB2ZXJpZnlUcnVzdGxpbmVUeE9wZXJhdGlvbnMob3BlcmF0aW9uczogc3RlbGxhci5PcGVyYXRpb25bXSwgdHhQYXJhbXM6IFRyYW5zYWN0aW9uUGFyYW1zKTogdm9pZCB7XG4gICAgY29uc3QgdHJ1c3RsaW5lT3BlcmF0aW9ucyA9IF8uZmlsdGVyKG9wZXJhdGlvbnMsIFsndHlwZScsICdjaGFuZ2VUcnVzdCddKSBhcyBzdGVsbGFyLk9wZXJhdGlvbi5DaGFuZ2VUcnVzdFtdO1xuICAgIGlmICh0cnVzdGxpbmVPcGVyYXRpb25zLmxlbmd0aCAhPT0gXy5nZXQodHhQYXJhbXMsICd0cnVzdGxpbmVzJywgW10pLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFuc2FjdGlvbiBwcmVidWlsZCBkb2VzIG5vdCBtYXRjaCBleHBlY3RlZCB0cnVzdGxpbmUgb3BlcmF0aW9ucycpO1xuICAgIH1cbiAgICBfLmZvckVhY2godHJ1c3RsaW5lT3BlcmF0aW9ucywgb3AgPT4ge1xuICAgICAgY29uc3Qgb3BUb2tlbiA9IHRoaXMuZ2V0VG9rZW5OYW1lRnJvbVN0ZWxsYXJBc3NldChvcC5saW5lKTtcbiAgICAgIGNvbnN0IHRva2VuVHJ1c3RsaW5lID0gXy5maW5kKHR4UGFyYW1zLnRydXN0bGluZXMsIHRydXN0bGluZSA9PiB7XG4gICAgICAgIC8vIHRydXN0bGluZSBwYXJhbXMgdXNlIGxpbWl0cyBpbiBiYXNlIHVuaXRzXG4gICAgICAgIGNvbnN0IG9wTGltaXRCYXNlVW5pdHMgPSB0aGlzLmJpZ1VuaXRzVG9CYXNlVW5pdHMob3AubGltaXQpO1xuICAgICAgICAvLyBQcmVwYXJlIHRoZSBjb25kaXRpb25zIHRvIGNoZWNrIGZvclxuICAgICAgICAvLyBMaW1pdCB3aWxsIGFsd2F5cyBiZSBzZXQgaW4gdGhlIG9wZXJhdGlvbiwgZXZlbiBpZiBpdCB3YXMgb21pdHRlZCBmcm9tIHR4UGFyYW1zIGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gICAgICAgIC8vIDEuIEFjdGlvbiBpcyAnYWRkJyAtIGxpbWl0IGlzIHNldCB0byBYbG0ubWF4VHJ1c3RsaW5lTGltaXQgYnkgZGVmYXVsdFxuICAgICAgICAvLyAyLiBBY3Rpb24gaXMgJ3JlbW92ZScgLSBsaW1pdCBpcyBzZXQgdG8gJzAnXG4gICAgICAgIGNvbnN0IG5vTGltaXQgPSBfLmlzVW5kZWZpbmVkKHRydXN0bGluZS5saW1pdCk7XG4gICAgICAgIGNvbnN0IGFkZFRydXN0bGluZVdpdGhEZWZhdWx0TGltaXQgPSAodHJ1c3RsaW5lLmFjdGlvbiA9PT0gJ2FkZCcgJiYgb3BMaW1pdEJhc2VVbml0cyA9PT0gWGxtLm1heFRydXN0bGluZUxpbWl0KTtcbiAgICAgICAgY29uc3QgcmVtb3ZlVHJ1c3RsaW5lID0gKHRydXN0bGluZS5hY3Rpb24gPT09ICdyZW1vdmUnICYmIG9wTGltaXRCYXNlVW5pdHMgPT09ICcwJyk7XG4gICAgICAgIHJldHVybiAodHJ1c3RsaW5lLnRva2VuID09PSBvcFRva2VuICYmXG4gICAgICAgICAgKHRydXN0bGluZS5saW1pdCA9PT0gb3BMaW1pdEJhc2VVbml0cyB8fCAobm9MaW1pdCAmJiAoYWRkVHJ1c3RsaW5lV2l0aERlZmF1bHRMaW1pdCB8fCByZW1vdmVUcnVzdGxpbmUpKSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCF0b2tlblRydXN0bGluZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zYWN0aW9uIHByZWJ1aWxkIGRvZXMgbm90IG1hdGNoIGV4cGVjdGVkIHRydXN0bGluZSB0b2tlbnMnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgdGhhdCBhIHRyYW5zYWN0aW9uIHByZWJ1aWxkIGNvbXBsaWVzIHdpdGggdGhlIG9yaWdpbmFsIGludGVudGlvblxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKiBAcGFyYW0gb3B0aW9ucy50eFByZWJ1aWxkIHByZWJ1aWxkIG9iamVjdCByZXR1cm5lZCBieSBwbGF0Zm9ybVxuICAgKiBAcGFyYW0gb3B0aW9ucy50eFByZWJ1aWxkLnR4QmFzZTY0IHByZWJ1aWx0IHRyYW5zYWN0aW9uIGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZ1xuICAgKiBAcGFyYW0gb3B0aW9ucy53YWxsZXQgd2FsbGV0IG9iamVjdCB0byBvYnRhaW4ga2V5cyB0byB2ZXJpZnkgYWdhaW5zdFxuICAgKiBAcGFyYW0gb3B0aW9ucy52ZXJpZmljYXRpb24gc3BlY2lmeWluZyBzb21lIHZlcmlmaWNhdGlvbiBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSBvcHRpb25zLnZlcmlmaWNhdGlvbi5kaXNhYmxlTmV0d29ya2luZyBEaXNhbGxvdyBmZXRjaGluZyBhbnkgZGF0YSBmcm9tIHRoZSBpbnRlcm5ldCBmb3IgdmVyaWZpY2F0aW9uIHB1cnBvc2VzXG4gICAqIEBwYXJhbSBvcHRpb25zLnZlcmlmaWNhdGlvbi5rZXljaGFpbnMgUGFzcyBrZXljaGFpbnMgbWFudWFsbHkgcmF0aGVyIHRoYW4gZmV0Y2hpbmcgdGhlbSBieSBpZFxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHZlcmlmeVRyYW5zYWN0aW9uKG9wdGlvbnM6IFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8Ym9vbGVhbj4pOiBCbHVlYmlyZDxib29sZWFuPiB7XG4gICAgLy8gVE9ETyBCRy01NjAwIEFkZCBwYXJzZVRyYW5zYWN0aW9uIC8gaW1wcm92ZSB2ZXJpZmljYXRpb25cbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288Ym9vbGVhbj4oZnVuY3Rpb24gKigpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHhQYXJhbXMsXG4gICAgICAgIHR4UHJlYnVpbGQsXG4gICAgICAgIHdhbGxldCxcbiAgICAgICAgdmVyaWZpY2F0aW9uID0ge30sXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIGNvbnN0IGRpc2FibGVOZXR3b3JraW5nID0gISF2ZXJpZmljYXRpb24uZGlzYWJsZU5ldHdvcmtpbmc7XG5cbiAgICAgIGlmICghdHhQcmVidWlsZC50eEJhc2U2NCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgdHggcHJlYnVpbGQgcHJvcGVydHkgdHhCYXNlNjQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdHggPSBuZXcgc3RlbGxhci5UcmFuc2FjdGlvbih0eFByZWJ1aWxkLnR4QmFzZTY0KTtcblxuICAgICAgaWYgKHR4UGFyYW1zLnJlY2lwaWVudHMgJiYgdHhQYXJhbXMucmVjaXBpZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNwZWNpZnkgbW9yZSB0aGFuIDEgcmVjaXBpZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0ZWxsYXIgdHhzIGFyZSBtYWRlIHVwIG9mIG9wZXJhdGlvbnMuIFdlIG9ubHkgY2FyZSBhYm91dCBDcmVhdGUgQWNjb3VudCBhbmQgUGF5bWVudCBmb3Igc2VuZGluZyBmdW5kcy5cbiAgICAgIGNvbnN0IG91dHB1dE9wZXJhdGlvbnMgPSBfLmZpbHRlcih0eC5vcGVyYXRpb25zLCBvcGVyYXRpb24gPT5cbiAgICAgICAgb3BlcmF0aW9uLnR5cGUgPT09ICdjcmVhdGVBY2NvdW50JyB8fCBvcGVyYXRpb24udHlwZSA9PT0gJ3BheW1lbnQnXG4gICAgICApO1xuXG4gICAgICBpZiAodHhQYXJhbXMudHlwZSA9PT0gJ3RydXN0bGluZScpIHtcbiAgICAgICAgdGhpcy52ZXJpZnlUcnVzdGxpbmVUeE9wZXJhdGlvbnModHgub3BlcmF0aW9ucywgdHhQYXJhbXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKF8uaXNFbXB0eShvdXRwdXRPcGVyYXRpb25zKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNhY3Rpb24gcHJlYnVpbGQgZG9lcyBub3QgaGF2ZSBhbnkgb3BlcmF0aW9ucycpO1xuICAgICAgICB9XG5cbiAgICAgICAgXy5mb3JFYWNoKHR4UGFyYW1zLnJlY2lwaWVudHMsIChleHBlY3RlZE91dHB1dCwgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb25zdCBleHBlY3RlZE91dHB1dEFkZHJlc3MgPSBzZWxmLmdldEFkZHJlc3NEZXRhaWxzKGV4cGVjdGVkT3V0cHV0LmFkZHJlc3MpO1xuICAgICAgICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dE9wZXJhdGlvbnNbaW5kZXhdIGFzIChzdGVsbGFyLk9wZXJhdGlvbi5QYXltZW50IHwgc3RlbGxhci5PcGVyYXRpb24uQ3JlYXRlQWNjb3VudCk7XG4gICAgICAgICAgaWYgKG91dHB1dC5kZXN0aW5hdGlvbiAhPT0gZXhwZWN0ZWRPdXRwdXRBZGRyZXNzLmFkZHJlc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNhY3Rpb24gcHJlYnVpbGQgZG9lcyBub3QgbWF0Y2ggZXhwZWN0ZWQgcmVjaXBpZW50Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZXhwZWN0ZWRPdXRwdXRBbW91bnQgPSBuZXcgQmlnTnVtYmVyKGV4cGVjdGVkT3V0cHV0LmFtb3VudCk7XG4gICAgICAgICAgLy8gVGhlIG91dHB1dCBhbW91bnQgaXMgZXhwcmVzc2VkIGFzIHN0YXJ0aW5nQmFsYW5jZSBpbiBjcmVhdGVBY2NvdW50IG9wZXJhdGlvbnMgYW5kIGFzIGFtb3VudCBpbiBwYXltZW50IG9wZXJhdGlvbnMuXG4gICAgICAgICAgY29uc3Qgb3V0cHV0QW1vdW50U3RyaW5nID0gKG91dHB1dC50eXBlID09PSAnY3JlYXRlQWNjb3VudCcpID8gb3V0cHV0LnN0YXJ0aW5nQmFsYW5jZSA6IG91dHB1dC5hbW91bnQ7XG4gICAgICAgICAgY29uc3Qgb3V0cHV0QW1vdW50ID0gbmV3IEJpZ051bWJlcihzZWxmLmJpZ1VuaXRzVG9CYXNlVW5pdHMob3V0cHV0QW1vdW50U3RyaW5nKSk7XG5cbiAgICAgICAgICBpZiAoIW91dHB1dEFtb3VudC5lcShleHBlY3RlZE91dHB1dEFtb3VudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNhY3Rpb24gcHJlYnVpbGQgZG9lcyBub3QgbWF0Y2ggZXhwZWN0ZWQgYW1vdW50Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gVmVyaWZ5IHRoZSB1c2VyIHNpZ25hdHVyZSwgaWYgdGhlIHR4IGlzIGhhbGYtc2lnbmVkXG4gICAgICBpZiAoIV8uaXNFbXB0eSh0eC5zaWduYXR1cmVzKSkge1xuICAgICAgICBjb25zdCB1c2VyU2lnbmF0dXJlID0gdHguc2lnbmF0dXJlc1swXS5zaWduYXR1cmUoKTtcblxuICAgICAgICAvLyBvYnRhaW4gdGhlIGtleWNoYWlucyBhbmQga2V5IHNpZ25hdHVyZXNcbiAgICAgICAgbGV0IGtleWNoYWlucyA9IHZlcmlmaWNhdGlvbi5rZXljaGFpbnM7XG4gICAgICAgIGlmICgha2V5Y2hhaW5zICYmIGRpc2FibGVOZXR3b3JraW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgZmV0Y2gga2V5Y2hhaW5zIHdpdGhvdXQgbmV0d29ya2luZycpO1xuICAgICAgICB9IGVsc2UgaWYgKCFrZXljaGFpbnMpIHtcbiAgICAgICAgICBrZXljaGFpbnMgPSB5aWVsZCBCbHVlYmlyZC5wcm9wcyh7XG4gICAgICAgICAgICB1c2VyOiBzZWxmLmtleWNoYWlucygpLmdldCh7IGlkOiB3YWxsZXQua2V5SWRzKClbS2V5SW5kaWNlcy5VU0VSXSB9KSxcbiAgICAgICAgICAgIGJhY2t1cDogc2VsZi5rZXljaGFpbnMoKS5nZXQoeyBpZDogd2FsbGV0LmtleUlkcygpW0tleUluZGljZXMuQkFDS1VQXSB9KSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgha2V5Y2hhaW5zIHx8ICFrZXljaGFpbnMuYmFja3VwIHx8ICFrZXljaGFpbnMudXNlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigna2V5Y2hhaW5zIGFyZSByZXF1aXJlZCwgYnV0IGNvdWxkIG5vdCBiZSBmZXRjaGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi52ZXJpZnlTaWduYXR1cmUoa2V5Y2hhaW5zLmJhY2t1cC5wdWIsIHR4Lmhhc2goKSwgdXNlclNpZ25hdHVyZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zYWN0aW9uIHNpZ25lZCB3aXRoIHdyb25nIGtleScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2VsZi52ZXJpZnlTaWduYXR1cmUoa2V5Y2hhaW5zLnVzZXIucHViLCB0eC5oYXNoKCksIHVzZXJTaWduYXR1cmUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFuc2FjdGlvbiBzaWduYXR1cmUgaW52YWxpZCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogRGVyaXZlIGEgaGFyZGVuZWQgY2hpbGQgcHVibGljIGtleSBmcm9tIGEgbWFzdGVyIGtleSBzZWVkIHVzaW5nIGFuIGFkZGl0aW9uYWwgc2VlZCBmb3IgcmFuZG9tbmVzcy5cbiAgICpcbiAgICogRHVlIHRvIHRlY2huaWNhbCBkaWZmZXJlbmNlcyBiZXR3ZWVuIGtleXBhaXJzIG9uIHRoZSBlZDI1NTE5IGN1cnZlIGFuZCB0aGUgc2VjcDI1NmsxIGN1cnZlLFxuICAgKiBvbmx5IGhhcmRlbmVkIHByaXZhdGUga2V5IGRlcml2YXRpb24gaXMgc3VwcG9ydGVkLlxuICAgKlxuICAgKiBAcGFyYW0ga2V5IHNlZWQgZm9yIHRoZSBtYXN0ZXIga2V5LiBOb3RlOiBOb3QgdGhlIHB1YmxpYyBrZXkgb3IgZW5jb2RlZCBwcml2YXRlIGtleS4gVGhpcyBpcyB0aGUgcmF3IHNlZWQuXG4gICAqIEBwYXJhbSBlbnRyb3B5U2VlZCByYW5kb20gc2VlZCB3aGljaCBpcyBoYXNoZWQgdG8gZ2VuZXJhdGUgdGhlIGRlcml2YXRpb24gcGF0aFxuICAgKi9cbiAgZGVyaXZlS2V5V2l0aFNlZWQoeyBrZXksIHNlZWQgfTogeyBrZXk6IHN0cmluZzsgc2VlZDogc3RyaW5nIH0pOiB7IGRlcml2YXRpb25QYXRoOiBzdHJpbmc7IGtleTogc3RyaW5nIH0ge1xuICAgIGNvbnN0IGRlcml2YXRpb25QYXRoSW5wdXQgPSBiaXRjb2luLmNyeXB0by5oYXNoMjU2KGAke3NlZWR9YCkudG9TdHJpbmcoJ2hleCcpO1xuICAgIGNvbnN0IGRlcml2YXRpb25QYXRoUGFydHMgPSBbXG4gICAgICA5OTk5OTksXG4gICAgICBwYXJzZUludChkZXJpdmF0aW9uUGF0aElucHV0LnNsaWNlKDAsIDcpLCAxNiksXG4gICAgICBwYXJzZUludChkZXJpdmF0aW9uUGF0aElucHV0LnNsaWNlKDcsIDE0KSwgMTYpLFxuICAgIF07XG4gICAgY29uc3QgZGVyaXZhdGlvblBhdGggPSAnbS8nICsgZGVyaXZhdGlvblBhdGhQYXJ0c1xuICAgICAgLm1hcCgocGFydCkgPT4gYCR7cGFydH0nYClcbiAgICAgIC5qb2luKCcvJyk7XG4gICAgY29uc3QgZGVyaXZlZEtleSA9IEVkMjU1MTlLZXlEZXJpdmVyLmRlcml2ZVBhdGgoZGVyaXZhdGlvblBhdGgsIGtleSkua2V5O1xuICAgIGNvbnN0IGtleXBhaXIgPSBzdGVsbGFyLktleXBhaXIuZnJvbVJhd0VkMjU1MTlTZWVkKGRlcml2ZWRLZXkpO1xuICAgIHJldHVybiB7XG4gICAgICBrZXk6IGtleXBhaXIucHVibGljS2V5KCksXG4gICAgICBkZXJpdmF0aW9uUGF0aCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIHN0ZWxsYXItc2RrIGhhcyB0d28gb3ZlcmxvYWRzIGZvciB0b1hEUiwgYW5kIHR5cGVzY3JpcHQgY2FuJ3Qgc2VlbSB0byBmaWd1cmUgb3V0IHRoZVxuICAgKiBjb3JyZWN0IG9uZSB0byB1c2UsIHNvIHdlIGhhdmUgdG8gYmUgdmVyeSBleHBsaWNpdCBhcyB0byB3aGljaCBvbmUgd2Ugd2FudC5cbiAgICogQHBhcmFtIHR4IHRyYW5zYWN0aW9uIHRvIGNvbnZlcnRcbiAgICovXG4gIHByb3RlY3RlZCBzdGF0aWMgdHhUb1N0cmluZyA9ICh0eDogc3RlbGxhci5UcmFuc2FjdGlvbik6IHN0cmluZyA9PiAodHgudG9FbnZlbG9wZSgpLnRvWERSIGFzICgoXzogc3RyaW5nKSA9PiBzdHJpbmcpKSgnYmFzZTY0Jyk7XG5cbiAgcGFyc2VUcmFuc2FjdGlvbihwYXJhbXM6IFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxQYXJzZWRUcmFuc2FjdGlvbj4pOiBCbHVlYmlyZDxQYXJzZWRUcmFuc2FjdGlvbj4ge1xuICAgIHJldHVybiBCbHVlYmlyZC5yZXNvbHZlKHt9KS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxufVxuIl19