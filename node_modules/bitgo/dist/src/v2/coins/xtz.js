"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @prettier
 */
var Bluebird = require("bluebird");
var co = Bluebird.coroutine;
var bitgoAccountLib = require("@bitgo/account-lib");
var baseCoin_1 = require("../baseCoin");
var bignumber_js_1 = require("bignumber.js");
var errors_1 = require("../../errors");
var Xtz = /** @class */ (function (_super) {
    __extends(Xtz, _super);
    function Xtz(bitgo, staticsCoin) {
        var _this = _super.call(this, bitgo) || this;
        if (!staticsCoin) {
            throw new Error('missing required constructor parameter staticsCoin');
        }
        _this._staticsCoin = staticsCoin;
        return _this;
    }
    Xtz.prototype.getChain = function () {
        return this._staticsCoin.name;
    };
    Xtz.prototype.getFamily = function () {
        return this._staticsCoin.family;
    };
    Xtz.prototype.getFullName = function () {
        return this._staticsCoin.fullName;
    };
    Xtz.prototype.getBaseFactor = function () {
        return Math.pow(10, this._staticsCoin.decimalPlaces);
    };
    Xtz.createInstance = function (bitgo, staticsCoin) {
        return new Xtz(bitgo, staticsCoin);
    };
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    Xtz.prototype.valuelessTransferAllowed = function () {
        return true;
    };
    /**
     * Checks if this is a valid base58 or hex address
     * @param address
     */
    Xtz.prototype.isValidAddress = function (address) {
        if (!address) {
            return false;
        }
        return bitgoAccountLib.Xtz.Utils.isValidAddress(address);
    };
    /**
     * Generate Tezos key pair
     *
     * @param seed
     * @returns {Object} object with generated pub, prv
     */
    Xtz.prototype.generateKeyPair = function (seed) {
        var keyPair = seed ? new bitgoAccountLib.Xtz.KeyPair({ seed: seed }) : new bitgoAccountLib.Xtz.KeyPair();
        var keys = keyPair.getKeys();
        return {
            pub: keys.pub,
            prv: keys.prv,
        };
    };
    Xtz.prototype.parseTransaction = function (params, callback) {
        return Bluebird.resolve({}).asCallback(callback);
    };
    Xtz.prototype.verifyAddress = function (params) {
        return true;
    };
    Xtz.prototype.verifyTransaction = function (params, callback) {
        return Bluebird.resolve(true).asCallback(callback);
    };
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {Object} prebuild object returned by platform
     * @param params.prv {String} user prv
     * @param params.wallet.addressVersion {String} this is the version of the Algorand multisig address generation format
     * @param callback
     * @returns Bluebird<SignedTransaction>
     */
    Xtz.prototype.signTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            var txBuilder, transaction, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        txBuilder = bitgoAccountLib.getBuilder(self.getChain());
                        txBuilder.from(params.txPrebuild.txHex);
                        txBuilder.source(params.txPrebuild.source);
                        if (params.txPrebuild.dataToSign) {
                            txBuilder.overrideDataToSign({ dataToSign: params.txPrebuild.dataToSign });
                        }
                        txBuilder.sign({ key: params.prv });
                        return [4 /*yield*/, txBuilder.build()];
                    case 1:
                        transaction = _a.sent();
                        if (!transaction) {
                            throw new Error('Invalid messaged passed to signMessage');
                        }
                        response = {
                            txHex: transaction.toBroadcastFormat(),
                        };
                        return [2 /*return*/, transaction.signature.length >= 2 ? response : { halfSigned: response }];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    Xtz.prototype.signMessage = function (key, message, callback) {
        return co(function cosignMessage() {
            var keyPair, messageHex, signatureData;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keyPair = new bitgoAccountLib.Xtz.KeyPair({ prv: key.prv });
                        messageHex = message instanceof Buffer ? message.toString('hex') : new Buffer(message).toString('hex');
                        return [4 /*yield*/, bitgoAccountLib.Xtz.Utils.sign(keyPair, messageHex)];
                    case 1:
                        signatureData = _a.sent();
                        return [2 /*return*/, signatureData.sig];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Builds a funds recovery transaction without BitGo.
     * We need to do three queries during this:
     * 1) Node query - how much money is in the account
     * 2) Build transaction - build our transaction for the amount
     * 3) Send signed build - send our signed build to a public node
     * @param params
     * @param callback
     */
    Xtz.prototype.recover = function (params, callback) {
        throw new errors_1.MethodNotImplementedError();
    };
    /**
     * Explain a Tezos transaction from txHex
     * @param params
     * @param callback
     */
    Xtz.prototype.explainTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            var txHex, txBuilder, tx, displayOrder;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        txHex = params.txHex || (params.halfSigned && params.halfSigned.txHex);
                        if (!txHex || !params.feeInfo) {
                            throw new Error('missing explain tx parameters');
                        }
                        txBuilder = bitgoAccountLib.getBuilder(self.getChain());
                        txBuilder.from(txHex);
                        return [4 /*yield*/, txBuilder.build()];
                    case 1:
                        tx = _a.sent();
                        displayOrder = ['id', 'outputAmount', 'changeAmount', 'outputs', 'changeOutputs', 'fee'];
                        return [2 /*return*/, {
                                displayOrder: displayOrder,
                                id: tx.id,
                                outputs: tx.outputs,
                                outputAmount: tx.outputs
                                    .reduce(function (accumulator, output) { return accumulator.plus(output.value); }, new bignumber_js_1.default('0'))
                                    .toFixed(0),
                                changeOutputs: [],
                                changeAmount: '0',
                                fee: params.feeInfo,
                            }];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    Xtz.prototype.isValidPub = function (pub) {
        return bitgoAccountLib.Xtz.Utils.isValidPublicKey(pub);
    };
    return Xtz;
}(baseCoin_1.BaseCoin));
exports.Xtz = Xtz;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieHR6LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3YyL2NvaW5zL3h0ei50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7R0FFRztBQUNILG1DQUFxQztBQUVyQyxJQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDO0FBQzlCLG9EQUFzRDtBQUV0RCx3Q0FhcUI7QUFJckIsNkNBQXFDO0FBQ3JDLHVDQUF5RDtBQW1DekQ7SUFBeUIsdUJBQVE7SUFHL0IsYUFBWSxLQUFZLEVBQUUsV0FBdUM7UUFBakUsWUFDRSxrQkFBTSxLQUFLLENBQUMsU0FPYjtRQUxDLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDaEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxvREFBb0QsQ0FBQyxDQUFDO1NBQ3ZFO1FBRUQsS0FBSSxDQUFDLFlBQVksR0FBRyxXQUFXLENBQUM7O0lBQ2xDLENBQUM7SUFFRCxzQkFBUSxHQUFSO1FBQ0UsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQztJQUNoQyxDQUFDO0lBRUQsdUJBQVMsR0FBVDtRQUNFLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUM7SUFDbEMsQ0FBQztJQUVELHlCQUFXLEdBQVg7UUFDRSxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDO0lBQ3BDLENBQUM7SUFFRCwyQkFBYSxHQUFiO1FBQ0UsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFFTSxrQkFBYyxHQUFyQixVQUFzQixLQUFZLEVBQUUsV0FBdUM7UUFDekUsT0FBTyxJQUFJLEdBQUcsQ0FBQyxLQUFLLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVEOzs7T0FHRztJQUNILHNDQUF3QixH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ICogQHByZXR0aWVyXG4gKi9cbmltcG9ydCAqIGFzIEJsdWViaXJkIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCB7IENvaW5GYW1pbHksIEJhc2VDb2luIGFzIFN0YXRpY3NCYXNlQ29pbiB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmNvbnN0IGNvID0gQmx1ZWJpcmQuY29yb3V0aW5lO1xuaW1wb3J0ICogYXMgYml0Z29BY2NvdW50TGliIGZyb20gJ0BiaXRnby9hY2NvdW50LWxpYic7XG5cbmltcG9ydCB7XG4gIEJhc2VDb2luLFxuICBLZXlQYWlyLFxuICBQYXJzZWRUcmFuc2FjdGlvbixcbiAgUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFNpZ25lZFRyYW5zYWN0aW9uLFxuICBTaWduVHJhbnNhY3Rpb25PcHRpb25zLFxuICBWZXJpZnlBZGRyZXNzT3B0aW9ucyxcbiAgVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLFxuICBUcmFuc2FjdGlvbkZlZSxcbiAgVHJhbnNhY3Rpb25SZWNpcGllbnQgYXMgUmVjaXBpZW50LFxuICBUcmFuc2FjdGlvblByZWJ1aWxkIGFzIEJhc2VUcmFuc2FjdGlvblByZWJ1aWxkLFxuICBUcmFuc2FjdGlvbkV4cGxhbmF0aW9uLFxufSBmcm9tICcuLi9iYXNlQ29pbic7XG5cbmltcG9ydCB7IEJpdEdvIH0gZnJvbSAnLi4vLi4vYml0Z28nO1xuaW1wb3J0IHsgTm9kZUNhbGxiYWNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IHsgTWV0aG9kTm90SW1wbGVtZW50ZWRFcnJvciB9IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgWHR6U2lnblRyYW5zYWN0aW9uT3B0aW9ucyBleHRlbmRzIFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eFByZWJ1aWxkOiBUcmFuc2FjdGlvblByZWJ1aWxkO1xuICBwcnY6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUeEluZm8ge1xuICByZWNpcGllbnRzOiBSZWNpcGllbnRbXTtcbiAgZnJvbTogc3RyaW5nO1xuICB0eGlkOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25QcmVidWlsZCBleHRlbmRzIEJhc2VUcmFuc2FjdGlvblByZWJ1aWxkIHtcbiAgdHhIZXg6IHN0cmluZztcbiAgdHhJbmZvOiBUeEluZm87XG4gIGZlZUluZm86IFh0elRyYW5zYWN0aW9uRmVlO1xuICBzb3VyY2U6IHN0cmluZztcbiAgZGF0YVRvU2lnbjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFh0elRyYW5zYWN0aW9uRmVlIHtcbiAgZmVlOiBzdHJpbmc7XG4gIGdhc0xpbWl0Pzogc3RyaW5nO1xuICBzdG9yYWdlTGltaXQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4SGV4Pzogc3RyaW5nO1xuICBoYWxmU2lnbmVkPzoge1xuICAgIHR4SGV4OiBzdHJpbmc7XG4gIH07XG4gIGZlZUluZm86IFRyYW5zYWN0aW9uRmVlO1xufVxuXG5leHBvcnQgY2xhc3MgWHR6IGV4dGVuZHMgQmFzZUNvaW4ge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX3N0YXRpY3NDb2luOiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+O1xuXG4gIGNvbnN0cnVjdG9yKGJpdGdvOiBCaXRHbywgc3RhdGljc0NvaW4/OiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+KSB7XG4gICAgc3VwZXIoYml0Z28pO1xuXG4gICAgaWYgKCFzdGF0aWNzQ29pbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIGNvbnN0cnVjdG9yIHBhcmFtZXRlciBzdGF0aWNzQ29pbicpO1xuICAgIH1cblxuICAgIHRoaXMuX3N0YXRpY3NDb2luID0gc3RhdGljc0NvaW47XG4gIH1cblxuICBnZXRDaGFpbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4ubmFtZTtcbiAgfVxuXG4gIGdldEZhbWlseSgpOiBDb2luRmFtaWx5IHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4uZmFtaWx5O1xuICB9XG5cbiAgZ2V0RnVsbE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRpY3NDb2luLmZ1bGxOYW1lO1xuICB9XG5cbiAgZ2V0QmFzZUZhY3RvcigpIHtcbiAgICByZXR1cm4gTWF0aC5wb3coMTAsIHRoaXMuX3N0YXRpY3NDb2luLmRlY2ltYWxQbGFjZXMpO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZUluc3RhbmNlKGJpdGdvOiBCaXRHbywgc3RhdGljc0NvaW4/OiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+KTogQmFzZUNvaW4ge1xuICAgIHJldHVybiBuZXcgWHR6KGJpdGdvLCBzdGF0aWNzQ29pbik7XG4gIH1cblxuICAvKipcbiAgICogRmxhZyBmb3Igc2VuZGluZyB2YWx1ZSBvZiAwXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIG9rYXkgdG8gc2VuZCAwIHZhbHVlLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIHZhbHVlbGVzc1RyYW5zZmVyQWxsb3dlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBpcyBhIHZhbGlkIGJhc2U1OCBvciBoZXggYWRkcmVzc1xuICAgKiBAcGFyYW0gYWRkcmVzc1xuICAgKi9cbiAgaXNWYWxpZEFkZHJlc3MoYWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgaWYgKCFhZGRyZXNzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBiaXRnb0FjY291bnRMaWIuWHR6LlV0aWxzLmlzVmFsaWRBZGRyZXNzKGFkZHJlc3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIFRlem9zIGtleSBwYWlyXG4gICAqXG4gICAqIEBwYXJhbSBzZWVkXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdCB3aXRoIGdlbmVyYXRlZCBwdWIsIHBydlxuICAgKi9cbiAgZ2VuZXJhdGVLZXlQYWlyKHNlZWQ/OiBCdWZmZXIpOiBLZXlQYWlyIHtcbiAgICBjb25zdCBrZXlQYWlyID0gc2VlZCA/IG5ldyBiaXRnb0FjY291bnRMaWIuWHR6LktleVBhaXIoeyBzZWVkIH0pIDogbmV3IGJpdGdvQWNjb3VudExpYi5YdHouS2V5UGFpcigpO1xuICAgIGNvbnN0IGtleXMgPSBrZXlQYWlyLmdldEtleXMoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcHViOiBrZXlzLnB1YixcbiAgICAgIHBydjoga2V5cy5wcnYhLFxuICAgIH07XG4gIH1cblxuICBwYXJzZVRyYW5zYWN0aW9uKFxuICAgIHBhcmFtczogUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMsXG4gICAgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8UGFyc2VkVHJhbnNhY3Rpb24+XG4gICk6IEJsdWViaXJkPFBhcnNlZFRyYW5zYWN0aW9uPiB7XG4gICAgcmV0dXJuIEJsdWViaXJkLnJlc29sdmUoe30pLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgdmVyaWZ5QWRkcmVzcyhwYXJhbXM6IFZlcmlmeUFkZHJlc3NPcHRpb25zKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2ZXJpZnlUcmFuc2FjdGlvbihwYXJhbXM6IFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8Ym9vbGVhbj4pOiBCbHVlYmlyZDxib29sZWFuPiB7XG4gICAgcmV0dXJuIEJsdWViaXJkLnJlc29sdmUodHJ1ZSkuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQXNzZW1ibGUga2V5Y2hhaW4gYW5kIGhhbGYtc2lnbiBwcmVidWlsdCB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMudHhQcmVidWlsZCB7T2JqZWN0fSBwcmVidWlsZCBvYmplY3QgcmV0dXJuZWQgYnkgcGxhdGZvcm1cbiAgICogQHBhcmFtIHBhcmFtcy5wcnYge1N0cmluZ30gdXNlciBwcnZcbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXQuYWRkcmVzc1ZlcnNpb24ge1N0cmluZ30gdGhpcyBpcyB0aGUgdmVyc2lvbiBvZiB0aGUgQWxnb3JhbmQgbXVsdGlzaWcgYWRkcmVzcyBnZW5lcmF0aW9uIGZvcm1hdFxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMgQmx1ZWJpcmQ8U2lnbmVkVHJhbnNhY3Rpb24+XG4gICAqL1xuICBzaWduVHJhbnNhY3Rpb24oXG4gICAgcGFyYW1zOiBYdHpTaWduVHJhbnNhY3Rpb25PcHRpb25zLFxuICAgIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFNpZ25lZFRyYW5zYWN0aW9uPlxuICApOiBCbHVlYmlyZDxTaWduZWRUcmFuc2FjdGlvbj4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxTaWduZWRUcmFuc2FjdGlvbj4oZnVuY3Rpb24qKCkge1xuICAgICAgY29uc3QgdHhCdWlsZGVyOiBhbnkgPSBiaXRnb0FjY291bnRMaWIuZ2V0QnVpbGRlcihzZWxmLmdldENoYWluKCkpO1xuICAgICAgdHhCdWlsZGVyLmZyb20ocGFyYW1zLnR4UHJlYnVpbGQudHhIZXgpO1xuICAgICAgdHhCdWlsZGVyLnNvdXJjZShwYXJhbXMudHhQcmVidWlsZC5zb3VyY2UpO1xuICAgICAgaWYgKHBhcmFtcy50eFByZWJ1aWxkLmRhdGFUb1NpZ24pIHtcbiAgICAgICAgdHhCdWlsZGVyLm92ZXJyaWRlRGF0YVRvU2lnbih7IGRhdGFUb1NpZ246IHBhcmFtcy50eFByZWJ1aWxkLmRhdGFUb1NpZ24gfSk7XG4gICAgICB9XG4gICAgICB0eEJ1aWxkZXIuc2lnbih7IGtleTogcGFyYW1zLnBydiB9KTtcblxuICAgICAgY29uc3QgdHJhbnNhY3Rpb246IGFueSA9IHlpZWxkIHR4QnVpbGRlci5idWlsZCgpO1xuICAgICAgaWYgKCF0cmFuc2FjdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWVzc2FnZWQgcGFzc2VkIHRvIHNpZ25NZXNzYWdlJyk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgICAgdHhIZXg6IHRyYW5zYWN0aW9uLnRvQnJvYWRjYXN0Rm9ybWF0KCksXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uLnNpZ25hdHVyZS5sZW5ndGggPj0gMiA/IHJlc3BvbnNlIDogeyBoYWxmU2lnbmVkOiByZXNwb25zZSB9O1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gbWVzc2FnZSB3aXRoIHByaXZhdGUga2V5XG4gICAqXG4gICAqIEBwYXJhbSBrZXlcbiAgICogQHBhcmFtIG1lc3NhZ2VcbiAgICovXG4gIHNpZ25NZXNzYWdlKGtleTogS2V5UGFpciwgbWVzc2FnZTogc3RyaW5nIHwgQnVmZmVyLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxCdWZmZXI+KTogQmx1ZWJpcmQ8QnVmZmVyPiB7XG4gICAgcmV0dXJuIGNvPEJ1ZmZlcj4oZnVuY3Rpb24qIGNvc2lnbk1lc3NhZ2UoKSB7XG4gICAgICBjb25zdCBrZXlQYWlyID0gbmV3IGJpdGdvQWNjb3VudExpYi5YdHouS2V5UGFpcih7IHBydjoga2V5LnBydiB9KTtcbiAgICAgIGNvbnN0IG1lc3NhZ2VIZXggPSBtZXNzYWdlIGluc3RhbmNlb2YgQnVmZmVyID8gbWVzc2FnZS50b1N0cmluZygnaGV4JykgOiBuZXcgQnVmZmVyKG1lc3NhZ2UpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZURhdGEgPSB5aWVsZCBiaXRnb0FjY291bnRMaWIuWHR6LlV0aWxzLnNpZ24oa2V5UGFpciwgbWVzc2FnZUhleCk7XG4gICAgICByZXR1cm4gc2lnbmF0dXJlRGF0YS5zaWc7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGEgZnVuZHMgcmVjb3ZlcnkgdHJhbnNhY3Rpb24gd2l0aG91dCBCaXRHby5cbiAgICogV2UgbmVlZCB0byBkbyB0aHJlZSBxdWVyaWVzIGR1cmluZyB0aGlzOlxuICAgKiAxKSBOb2RlIHF1ZXJ5IC0gaG93IG11Y2ggbW9uZXkgaXMgaW4gdGhlIGFjY291bnRcbiAgICogMikgQnVpbGQgdHJhbnNhY3Rpb24gLSBidWlsZCBvdXIgdHJhbnNhY3Rpb24gZm9yIHRoZSBhbW91bnRcbiAgICogMykgU2VuZCBzaWduZWQgYnVpbGQgLSBzZW5kIG91ciBzaWduZWQgYnVpbGQgdG8gYSBwdWJsaWMgbm9kZVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgcmVjb3ZlcihwYXJhbXM6IGFueSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIHRocm93IG5ldyBNZXRob2ROb3RJbXBsZW1lbnRlZEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogRXhwbGFpbiBhIFRlem9zIHRyYW5zYWN0aW9uIGZyb20gdHhIZXhcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGV4cGxhaW5UcmFuc2FjdGlvbihcbiAgICBwYXJhbXM6IEV4cGxhaW5UcmFuc2FjdGlvbk9wdGlvbnMsXG4gICAgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8VHJhbnNhY3Rpb25FeHBsYW5hdGlvbj5cbiAgKTogQmx1ZWJpcmQ8VHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxUcmFuc2FjdGlvbkV4cGxhbmF0aW9uPihmdW5jdGlvbiooKSB7XG4gICAgICBjb25zdCB0eEhleCA9IHBhcmFtcy50eEhleCB8fCAocGFyYW1zLmhhbGZTaWduZWQgJiYgcGFyYW1zLmhhbGZTaWduZWQudHhIZXgpO1xuICAgICAgaWYgKCF0eEhleCB8fCAhcGFyYW1zLmZlZUluZm8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGV4cGxhaW4gdHggcGFyYW1ldGVycycpO1xuICAgICAgfVxuICAgICAgY29uc3QgdHhCdWlsZGVyID0gYml0Z29BY2NvdW50TGliLmdldEJ1aWxkZXIoc2VsZi5nZXRDaGFpbigpKTtcbiAgICAgIHR4QnVpbGRlci5mcm9tKHR4SGV4KTtcbiAgICAgIGNvbnN0IHR4OiBhbnkgPSB5aWVsZCB0eEJ1aWxkZXIuYnVpbGQoKTtcblxuICAgICAgY29uc3QgZGlzcGxheU9yZGVyID0gWydpZCcsICdvdXRwdXRBbW91bnQnLCAnY2hhbmdlQW1vdW50JywgJ291dHB1dHMnLCAnY2hhbmdlT3V0cHV0cycsICdmZWUnXTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzcGxheU9yZGVyLFxuICAgICAgICBpZDogdHguaWQsXG4gICAgICAgIG91dHB1dHM6IHR4Lm91dHB1dHMsXG4gICAgICAgIG91dHB1dEFtb3VudDogdHgub3V0cHV0c1xuICAgICAgICAgIC5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBvdXRwdXQpID0+IGFjY3VtdWxhdG9yLnBsdXMob3V0cHV0LnZhbHVlKSwgbmV3IEJpZ051bWJlcignMCcpKVxuICAgICAgICAgIC50b0ZpeGVkKDApLFxuICAgICAgICBjaGFuZ2VPdXRwdXRzOiBbXSwgLy8gYWNjb3VudCBiYXNlZCBkb2VzIG5vdCB1c2UgY2hhbmdlIG91dHB1dHNcbiAgICAgICAgY2hhbmdlQW1vdW50OiAnMCcsIC8vIGFjY291bnQgYmFzZSBkb2VzIG5vdCBtYWtlIGNoYW5nZVxuICAgICAgICBmZWU6IHBhcmFtcy5mZWVJbmZvLFxuICAgICAgfTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlzVmFsaWRQdWIocHViOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gYml0Z29BY2NvdW50TGliLlh0ei5VdGlscy5pc1ZhbGlkUHVibGljS2V5KHB1Yik7XG4gIH1cbn1cbiJdfQ==