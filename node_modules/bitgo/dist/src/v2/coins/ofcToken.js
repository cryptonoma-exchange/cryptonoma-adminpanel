"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var ofc_1 = require("./ofc");
var lodash_1 = require("lodash");
var Bluebird = require("bluebird");
var co = Bluebird.coroutine;
var publicIdRegex = /^[a-f\d]{32}$/i;
var OfcToken = /** @class */ (function (_super) {
    __extends(OfcToken, _super);
    function OfcToken(bitgo, tokenConfig) {
        var _this = _super.call(this, bitgo) || this;
        _this.tokenConfig = tokenConfig;
        return _this;
    }
    Object.defineProperty(OfcToken.prototype, "coin", {
        get: function () {
            return this.tokenConfig.coin;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OfcToken.prototype, "decimalPlaces", {
        get: function () {
            return this.tokenConfig.decimalPlaces;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OfcToken.prototype, "name", {
        get: function () {
            return this.tokenConfig.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OfcToken.prototype, "backingCoin", {
        get: function () {
            return this.tokenConfig.backingCoin;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OfcToken.prototype, "isFiat", {
        get: function () {
            return this.tokenConfig.isFiat;
        },
        enumerable: true,
        configurable: true
    });
    OfcToken.prototype.getChain = function () {
        return this.type;
    };
    OfcToken.prototype.getFullName = function () {
        return this.name;
    };
    OfcToken.prototype.getBaseFactor = function () {
        return String(Math.pow(10, this.decimalPlaces));
    };
    Object.defineProperty(OfcToken.prototype, "type", {
        get: function () {
            return this.tokenConfig.type;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    OfcToken.prototype.valuelessTransferAllowed = function () {
        return false;
    };
    OfcToken.createTokenConstructor = function (config) {
        return function (bitgo) { return new OfcToken(bitgo, config); };
    };
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * @param callback
     * @returns {Bluebird<SignedTransaction>}
     */
    OfcToken.prototype.signTransaction = function (params, callback) {
        return co(function () {
            var txPrebuild, payload, signatureBuffer, signature;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        txPrebuild = params.txPrebuild;
                        payload = txPrebuild.payload;
                        return [4 /*yield*/, this.signMessage(params, payload)];
                    case 1:
                        signatureBuffer = _a.sent();
                        signature = signatureBuffer.toString('hex');
                        return [2 /*return*/, { halfSigned: { payload: payload, signature: signature } }];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Check if an address is valid for this ofc token.
     *
     * These addresses are either bg-<publicid>, where public id is the internal address to send to,
     * or are an address which is valid on the backing coin of this ofc token.
     * @param address address to check for validity
     */
    OfcToken.prototype.isValidAddress = function (address) {
        if (!lodash_1.isString(address)) {
            return false;
        }
        if (address.startsWith('bg-')) {
            var parts = address.split('-');
            var accountId = parts[1];
            return parts.length === 2 && publicIdRegex.test(accountId);
        }
        else {
            var backingCoin = this.bitgo.coin(this.backingCoin);
            return backingCoin.isValidAddress(address);
        }
    };
    return OfcToken;
}(ofc_1.Ofc));
exports.OfcToken = OfcToken;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2ZjVG9rZW4uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvdjIvY29pbnMvb2ZjVG9rZW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS0EsNkJBQTRCO0FBQzVCLGlDQUFrQztBQUlsQyxtQ0FBcUM7QUFDckMsSUFBTSxFQUFFLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQztBQWtCOUIsSUFBTSxhQUFhLEdBQUcsZ0JBQWdCLENBQUM7QUFDdkM7SUFBOEIsNEJBQUc7SUFHL0Isa0JBQVksS0FBWSxFQUFFLFdBQTJCO1FBQXJELFlBQ0Usa0JBQU0sS0FBSyxDQUFDLFNBRWI7UUFEQyxLQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQzs7SUFDakMsQ0FBQztJQUVELHNCQUFJLDBCQUFJO2FBQVI7WUFDRSxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDO1FBQy9CLENBQUM7OztPQUFBO0lBRUQsc0JBQUksbUNBQWE7YUFBakI7WUFDRSxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDO1FBQ3hDLENBQUM7OztPQUFBO0lBRUQsc0JBQUksMEJBQUk7YUFBUjtZQUNFLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUM7UUFDL0IsQ0FBQzs7O09BQUE7SUFFRCxzQkFBSSxpQ0FBVzthQUFmO1lBQ0UsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQztRQUN0QyxDQUFDOzs7T0FBQTtJQUVELHNCQUFJLDRCQUFNO2FBQVY7WUFDRSxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDO1FBQ2pDLENBQUM7OztPQUFBO0lBRUQsMkJBQVEsR0FBUjtRQUNFLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQztJQUNuQixDQUFDO0lBRUQsOEJBQVcsR0FBWDtRQUNFLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQztJQUNuQixDQUFDO0lBRUQsZ0NBQWEsR0FBYjtRQUNFLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO0lBQ2xELENBQUM7SUFFRCxzQkFBVywwQkFBSTthQUFmO1lBQ0UsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQztRQUMvQixDQUFDOzs7T0FBQTtJQUVEOzs7T0FHRztJQUNILDJDQUF3QixHQUF4QjtRQUNFLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVNLCtCQUFzQixHQUE3QixVQUE4QixNQUFzQjtRQUNsRCxPQUFPLFVBQUMsS0FBWSxJQUFLLE9BQUEsSUFBSSxRQUFRLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxFQUEzQixDQUEyQixDQUFDO0lBQ3ZELENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILGtDQUFlLEdBQWYsVUFDRSxNQUE4QixFQUM5QixRQUEwQztRQUUxQyxPQUFPLEVBQUUsQ0FBb0I7Ozs7O3dCQUNyQixVQUFVLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQzt3QkFDL0IsT0FBTyxHQUFHLFVBQVUsQ0FBQyxPQUFPLENBQUM7d0JBQ1gscUJBQU0sSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUUsT0FBTyxDQUFDLEVBQUE7O3dCQUF6RCxlQUFlLEdBQUcsU0FBdUM7d0JBQ3pELFNBQVMsR0FBVyxlQUFlLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO3dCQUMxRCxzQkFBTyxFQUFFLFVBQVUsRUFBRSxFQUFFLE9BQU8sU0FBQSxFQUFFLFNBQVMsV0FBQSxFQUFFLEVBQUUsRUFBQzs7O1NBQy9DLENBQUM7YUFDQyxJQUFJLENBQUMsSUFBSSxDQUFDO2FBQ1YsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxpQ0FBYyxHQUFkLFVBQWUsT0FBZ0I7UUFDN0IsSUFBSSxDQUFDLGlCQUFRLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDdEIsT0FBTyxLQUFLLENBQUM7U0FDZDtRQUNELElBQUksT0FBTyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUM3QixJQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ2pDLElBQU0sU0FBUyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMzQixPQUFPLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxJQUFJLGFBQWEsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDNUQ7YUFBTTtZQUNMLElBQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUN0RCxPQUFPLFdBQVcsQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDNUM7SUFDSCxDQUFDO0lBQ0gsZUFBQztBQUFELENBQUMsQUFqR0QsQ0FBOEIsU0FBRyxHQWlHaEM7QUFqR1ksNEJBQVEiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5pbXBvcnQgeyBCaXRHbyB9IGZyb20gJy4uLy4uL2JpdGdvJztcbmltcG9ydCB7IENvaW5Db25zdHJ1Y3RvciB9IGZyb20gJy4uL2NvaW5GYWN0b3J5JztcbmltcG9ydCB7IE9mYyB9IGZyb20gJy4vb2ZjJztcbmltcG9ydCB7IGlzU3RyaW5nIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgYXMgQmFzZVNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgfSBmcm9tICcuLi9iYXNlQ29pbic7XG5pbXBvcnQgeyBOb2RlQ2FsbGJhY2sgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBTaWduZWRUcmFuc2FjdGlvbiB9IGZyb20gJy4vZXRoJztcbmltcG9ydCAqIGFzIEJsdWViaXJkIGZyb20gJ2JsdWViaXJkJztcbmNvbnN0IGNvID0gQmx1ZWJpcmQuY29yb3V0aW5lO1xuXG5leHBvcnQgaW50ZXJmYWNlIE9mY1Rva2VuQ29uZmlnIHtcbiAgdHlwZTogc3RyaW5nO1xuICBjb2luOiBzdHJpbmc7XG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcjtcbiAgbmFtZTogc3RyaW5nO1xuICBiYWNraW5nQ29pbjogc3RyaW5nO1xuICBpc0ZpYXQ6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyBleHRlbmRzIEJhc2VTaWduVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhQcmVidWlsZDoge1xuICAgIHBheWxvYWQ6IHN0cmluZztcbiAgfTtcbiAgcHJ2OiBzdHJpbmc7XG59XG5cbmNvbnN0IHB1YmxpY0lkUmVnZXggPSAvXlthLWZcXGRdezMyfSQvaTtcbmV4cG9ydCBjbGFzcyBPZmNUb2tlbiBleHRlbmRzIE9mYyB7XG4gIHB1YmxpYyByZWFkb25seSB0b2tlbkNvbmZpZzogT2ZjVG9rZW5Db25maWc7XG5cbiAgY29uc3RydWN0b3IoYml0Z286IEJpdEdvLCB0b2tlbkNvbmZpZzogT2ZjVG9rZW5Db25maWcpIHtcbiAgICBzdXBlcihiaXRnbyk7XG4gICAgdGhpcy50b2tlbkNvbmZpZyA9IHRva2VuQ29uZmlnO1xuICB9XG5cbiAgZ2V0IGNvaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5Db25maWcuY29pbjtcbiAgfVxuXG4gIGdldCBkZWNpbWFsUGxhY2VzKCkge1xuICAgIHJldHVybiB0aGlzLnRva2VuQ29uZmlnLmRlY2ltYWxQbGFjZXM7XG4gIH1cblxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy50b2tlbkNvbmZpZy5uYW1lO1xuICB9XG5cbiAgZ2V0IGJhY2tpbmdDb2luKCkge1xuICAgIHJldHVybiB0aGlzLnRva2VuQ29uZmlnLmJhY2tpbmdDb2luO1xuICB9XG5cbiAgZ2V0IGlzRmlhdCgpIHtcbiAgICByZXR1cm4gdGhpcy50b2tlbkNvbmZpZy5pc0ZpYXQ7XG4gIH1cblxuICBnZXRDaGFpbigpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlO1xuICB9XG5cbiAgZ2V0RnVsbE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuXG4gIGdldEJhc2VGYWN0b3IoKSB7XG4gICAgcmV0dXJuIFN0cmluZyhNYXRoLnBvdygxMCwgdGhpcy5kZWNpbWFsUGxhY2VzKSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5Db25maWcudHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGFnIGZvciBzZW5kaW5nIHZhbHVlIG9mIDBcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgb2theSB0byBzZW5kIDAgdmFsdWUsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgdmFsdWVsZXNzVHJhbnNmZXJBbGxvd2VkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVUb2tlbkNvbnN0cnVjdG9yKGNvbmZpZzogT2ZjVG9rZW5Db25maWcpOiBDb2luQ29uc3RydWN0b3Ige1xuICAgIHJldHVybiAoYml0Z286IEJpdEdvKSA9PiBuZXcgT2ZjVG9rZW4oYml0Z28sIGNvbmZpZyk7XG4gIH1cblxuICAvKipcbiAgICogQXNzZW1ibGUga2V5Y2hhaW4gYW5kIGhhbGYtc2lnbiBwcmVidWlsdCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Qmx1ZWJpcmQ8U2lnbmVkVHJhbnNhY3Rpb24+fVxuICAgKi9cbiAgc2lnblRyYW5zYWN0aW9uKFxuICAgIHBhcmFtczogU2lnblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgICBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxTaWduZWRUcmFuc2FjdGlvbj5cbiAgKTogQmx1ZWJpcmQ8U2lnbmVkVHJhbnNhY3Rpb24+IHtcbiAgICByZXR1cm4gY288U2lnbmVkVHJhbnNhY3Rpb24+KGZ1bmN0aW9uKigpIHtcbiAgICAgIGNvbnN0IHR4UHJlYnVpbGQgPSBwYXJhbXMudHhQcmVidWlsZDtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB0eFByZWJ1aWxkLnBheWxvYWQ7XG4gICAgICBjb25zdCBzaWduYXR1cmVCdWZmZXIgPSB5aWVsZCB0aGlzLnNpZ25NZXNzYWdlKHBhcmFtcywgcGF5bG9hZCk7XG4gICAgICBjb25zdCBzaWduYXR1cmU6IHN0cmluZyA9IHNpZ25hdHVyZUJ1ZmZlci50b1N0cmluZygnaGV4Jyk7XG4gICAgICByZXR1cm4geyBoYWxmU2lnbmVkOiB7IHBheWxvYWQsIHNpZ25hdHVyZSB9IH07XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYWRkcmVzcyBpcyB2YWxpZCBmb3IgdGhpcyBvZmMgdG9rZW4uXG4gICAqXG4gICAqIFRoZXNlIGFkZHJlc3NlcyBhcmUgZWl0aGVyIGJnLTxwdWJsaWNpZD4sIHdoZXJlIHB1YmxpYyBpZCBpcyB0aGUgaW50ZXJuYWwgYWRkcmVzcyB0byBzZW5kIHRvLFxuICAgKiBvciBhcmUgYW4gYWRkcmVzcyB3aGljaCBpcyB2YWxpZCBvbiB0aGUgYmFja2luZyBjb2luIG9mIHRoaXMgb2ZjIHRva2VuLlxuICAgKiBAcGFyYW0gYWRkcmVzcyBhZGRyZXNzIHRvIGNoZWNrIGZvciB2YWxpZGl0eVxuICAgKi9cbiAgaXNWYWxpZEFkZHJlc3MoYWRkcmVzcz86IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmICghaXNTdHJpbmcoYWRkcmVzcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGFkZHJlc3Muc3RhcnRzV2l0aCgnYmctJykpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gYWRkcmVzcy5zcGxpdCgnLScpO1xuICAgICAgY29uc3QgYWNjb3VudElkID0gcGFydHNbMV07XG4gICAgICByZXR1cm4gcGFydHMubGVuZ3RoID09PSAyICYmIHB1YmxpY0lkUmVnZXgudGVzdChhY2NvdW50SWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBiYWNraW5nQ29pbiA9IHRoaXMuYml0Z28uY29pbih0aGlzLmJhY2tpbmdDb2luKTtcbiAgICAgIHJldHVybiBiYWNraW5nQ29pbi5pc1ZhbGlkQWRkcmVzcyhhZGRyZXNzKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==