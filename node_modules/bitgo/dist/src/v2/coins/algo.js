"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @prettier
 */
var Bluebird = require("bluebird");
var _ = require("lodash");
var stellar = require("stellar-sdk");
var algosdk_1 = require("algosdk");
var baseCoin_1 = require("../baseCoin");
var keychains_1 = require("../keychains");
var co = Bluebird.coroutine;
var Algo = /** @class */ (function (_super) {
    __extends(Algo, _super);
    function Algo(bitgo) {
        return _super.call(this, bitgo) || this;
    }
    Algo.createInstance = function (bitgo) {
        return new Algo(bitgo);
    };
    Algo.prototype.getChain = function () {
        return 'algo';
    };
    Algo.prototype.getFamily = function () {
        return 'algo';
    };
    Algo.prototype.getFullName = function () {
        return 'Algorand';
    };
    Algo.prototype.getBaseFactor = function () {
        return 1e6;
    };
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    Algo.prototype.valuelessTransferAllowed = function () {
        // TODO: this sounds like its true with the staking txes - confirm before launch
        return false;
    };
    /**
     * Algorand supports account consolidations. These are transfers from the receive addresses
     * to the main address.
     */
    Algo.prototype.allowsAccountConsolidations = function () {
        return true;
    };
    /**
     * Generate ed25519 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub, prv
     */
    Algo.prototype.generateKeyPair = function (seed) {
        var pair = seed ? algosdk_1.generateAccountFromSeed(seed) : algosdk_1.generateAccount();
        return {
            pub: pair.addr,
            prv: algosdk_1.Seed.encode(pair.sk),
        };
    };
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    Algo.prototype.isValidPub = function (pub) {
        return algosdk_1.isValidAddress(pub);
    };
    /**
     * Return boolean indicating whether input is valid seed for the coin
     * In Algorand, when the private key is encoded as base32 string only the first 32 bytes are taken,
     * so the encoded value is actually the seed
     *
     * @param {String} prv the prv to be checked
     * @returns {Boolean} is it valid?
     */
    Algo.prototype.isValidPrv = function (prv) {
        return algosdk_1.isValidSeed(prv);
    };
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param {String} address the pub to be checked
     * @returns {Boolean} is it valid?
     */
    Algo.prototype.isValidAddress = function (address) {
        return algosdk_1.isValidAddress(address);
    };
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    Algo.prototype.signMessage = function (key, message, callback) {
        var self = this;
        return co(function cosignMessage() {
            var seed, keyPair;
            return __generator(this, function (_a) {
                seed = key.prv;
                if (!self.isValidPrv(seed)) {
                    throw new Error("invalid seed: " + seed);
                }
                if (typeof seed === 'string') {
                    try {
                        seed = algosdk_1.Seed.decode(seed).seed;
                    }
                    catch (e) {
                        throw new Error("could not decode seed: " + seed);
                    }
                }
                keyPair = algosdk_1.generateAccountFromSeed(seed);
                if (!Buffer.isBuffer(message)) {
                    message = Buffer.from(message);
                }
                return [2 /*return*/, Buffer.from(algosdk_1.NaclWrapper.sign(message, keyPair.sk))];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Specifies what key we will need for signing` - Algorand needs the backup, bitgo pubs.
     */
    Algo.prototype.keyIdsForSigning = function () {
        return [keychains_1.KeyIndices.USER, keychains_1.KeyIndices.BACKUP, keychains_1.KeyIndices.BITGO];
    };
    /**
     * Explain/parse transaction
     * @param params
     * @param callback
     */
    Algo.prototype.explainTransaction = function (params, callback) {
        return co(function () {
            var txHex, tx, type, senderAddress, voteKeyBase64, voteLastBlock, txToHex, decodedTx, txnForDecoding, id, fee, outputAmount, outputs, memo;
            return __generator(this, function (_a) {
                txHex = params.txHex || (params.halfSigned && params.halfSigned.txHex);
                if (!txHex) {
                    throw new Error('missing required param txHex or halfSigned.txHex');
                }
                try {
                    txToHex = Buffer.from(txHex, 'base64');
                    decodedTx = algosdk_1.Encoding.decode(txToHex);
                    txnForDecoding = decodedTx.txn || decodedTx;
                    if (!!txnForDecoding.votekey) {
                        type = txnForDecoding.type;
                        senderAddress = algosdk_1.Address.encode(txnForDecoding.snd);
                        voteKeyBase64 = txnForDecoding.votekey.toString('base64');
                        voteLastBlock = txnForDecoding.votelst;
                    }
                    tx = algosdk_1.Multisig.MultiSigTransaction.from_obj_for_encoding(txnForDecoding);
                }
                catch (ex) {
                    throw new Error('txHex needs to be a valid tx encoded as base64 string');
                }
                id = tx.txID();
                fee = { fee: tx.fee };
                outputAmount = tx.amount || 0;
                outputs = [];
                if (tx.to) {
                    outputs.push({
                        amount: outputAmount,
                        address: algosdk_1.Address.encode(new Uint8Array(tx.to.publicKey)),
                    });
                }
                memo = tx.note;
                return [2 /*return*/, {
                        displayOrder: [
                            'id',
                            'outputAmount',
                            'changeAmount',
                            'outputs',
                            'changeOutputs',
                            'fee',
                            'memo',
                            'type',
                            'senderAddress',
                            'voteKeyBase64',
                            'voteLastBlock',
                        ],
                        id: id,
                        outputs: outputs,
                        outputAmount: outputAmount,
                        changeAmount: 0,
                        fee: fee,
                        changeOutputs: [],
                        memo: memo,
                        type: type,
                        senderAddress: senderAddress,
                        voteKeyBase64: voteKeyBase64,
                        voteLastBlock: voteLastBlock,
                    }];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    Algo.prototype.isStellarSeed = function (seed) {
        return stellar.StrKey.isValidEd25519SecretSeed(seed);
    };
    Algo.prototype.convertFromStellarSeed = function (seed) {
        // assume this is a trust custodial seed if its a valid ed25519 prv
        if (!this.isStellarSeed(seed)) {
            return null;
        }
        return algosdk_1.Seed.encode(stellar.StrKey.decodeEd25519SecretSeed(seed));
    };
    Algo.prototype.verifySignTransactionParams = function (params) {
        var prv = params.prv;
        var addressVersion = params.txPrebuild.addressVersion;
        var isHalfSigned = false;
        // it's possible this tx was already signed - take the halfSigned
        // txHex if it is
        var txHex = params.txPrebuild.txHex;
        if (params.txPrebuild.halfSigned) {
            isHalfSigned = true;
            txHex = params.txPrebuild.halfSigned.txHex;
        }
        if (_.isUndefined(txHex)) {
            throw new Error('missing txPrebuild parameter');
        }
        if (!_.isString(txHex)) {
            throw new Error("txPrebuild must be an object, got type " + typeof txHex);
        }
        if (_.isUndefined(prv)) {
            throw new Error('missing prv parameter to sign transaction');
        }
        if (!_.isString(prv)) {
            throw new Error("prv must be a string, got type " + typeof prv);
        }
        if (!_.has(params.txPrebuild, 'keys[0]') ||
            !_.has(params.txPrebuild, 'keys[1]') ||
            !_.has(params.txPrebuild, 'keys[2]')) {
            throw new Error('missing public keys parameter to sign transaction');
        }
        if (!_.isNumber(addressVersion)) {
            throw new Error('missing addressVersion parameter to sign transaction');
        }
        // we need to re-encode our public keys using algosdk's format
        var keys = [params.txPrebuild.keys[0], params.txPrebuild.keys[1], params.txPrebuild.keys[2]];
        // re-encode sk from our prv (this acts as a seed out of the keychain)
        var seed = algosdk_1.Seed.decode(prv).seed;
        var pair = algosdk_1.generateAccountFromSeed(seed);
        var sk = pair.sk;
        return { txHex: txHex, addressVersion: addressVersion, keys: keys, sk: sk, isHalfSigned: isHalfSigned };
    };
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {TransactionPrebuild} prebuild object returned by platform
     * @param params.prv {String} user prv
     * @param callback
     * @returns {Bluebird<SignedTransaction>}
     */
    Algo.prototype.signTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            var _a, txHex, addressVersion, keys, sk, isHalfSigned, encodedPublicKeys, transaction, txToHex, initialDecodedTx, decodedTx, signed, signedBase64;
            return __generator(this, function (_b) {
                _a = self.verifySignTransactionParams(params), txHex = _a.txHex, addressVersion = _a.addressVersion, keys = _a.keys, sk = _a.sk, isHalfSigned = _a.isHalfSigned;
                encodedPublicKeys = _.map(keys, function (k) { return algosdk_1.Address.decode(k).publicKey; });
                try {
                    txToHex = Buffer.from(txHex, 'base64');
                    initialDecodedTx = algosdk_1.Encoding.decode(txToHex);
                    decodedTx = isHalfSigned ? initialDecodedTx.txn : initialDecodedTx;
                    transaction = algosdk_1.Multisig.MultiSigTransaction.from_obj_for_encoding(decodedTx);
                }
                catch (e) {
                    throw new Error('transaction needs to be a valid tx encoded as base64 string');
                }
                signed = transaction.partialSignTxn({ version: addressVersion, threshold: 2, pks: encodedPublicKeys }, sk);
                // if we have already signed it, we'll have to merge that with our previous tx
                if (isHalfSigned) {
                    signed = algosdk_1.mergeMultisigTransactions([Buffer.from(signed), txToHex]);
                }
                signedBase64 = Buffer.from(signed).toString('base64');
                if (isHalfSigned) {
                    return [2 /*return*/, { txHex: signedBase64 }];
                }
                else {
                    return [2 /*return*/, { halfSigned: { txHex: signedBase64 } }];
                }
                return [2 /*return*/];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    Algo.prototype.parseTransaction = function (params, callback) {
        return Bluebird.resolve({}).asCallback(callback);
    };
    Algo.prototype.verifyAddress = function (params) {
        return true;
    };
    Algo.prototype.verifyTransaction = function (params, callback) {
        return Bluebird.resolve(true).asCallback(callback);
    };
    return Algo;
}(baseCoin_1.BaseCoin));
exports.Algo = Algo;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWxnby5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy92Mi9jb2lucy9hbGdvLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztHQUVHO0FBQ0gsbUNBQXFDO0FBQ3JDLDBCQUE0QjtBQUM1QixxQ0FBdUM7QUFDdkMsbUNBV2lCO0FBR2pCLHdDQVNxQjtBQUNyQiwwQ0FBMEM7QUFHMUMsSUFBTSxFQUFFLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQztBQTREOUI7SUFBMEIsd0JBQVE7SUFDaEMsY0FBWSxLQUFZO2VBQ3RCLGtCQUFNLEtBQUssQ0FBQztJQUNkLENBQUM7SUFFTSxtQkFBYyxHQUFyQixVQUFzQixLQUFZO1FBQ2hDLE9BQU8sSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDekIsQ0FBQztJQUVELHVCQUFRLEdBQVI7UUFDRSxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRUQsd0JBQVMsR0FBVDtRQUNFLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFRCwwQkFBVyxHQUFYO1FBQ0UsT0FBTyxVQUFVLENBQUM7SUFDcEIsQ0FBQztJQUVELDRCQUFhLEdBQWI7UUFDRSxPQUFPLEdBQUcsQ0FBQztJQUNiLENBQUM7SUFFRDs7O09BR0c7SUFDSCx1Q0FBd0IsR0FBeEI7UUFDRSxnRkFBZ0Y7UUFDaEYsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsMENBQTJCLEdBQTNCO1FBQ0UsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCw4QkFBZSxHQUFmLFVBQWdCLElBQWE7UUFDM0IsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxpQ0FBdUIsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMseUJBQWUsRUFBRSxDQUFDO1FBQ3RFLE9BQU87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QUFnQztRQUNsRixPQUFPLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JELENBQUM7SUFDSCxXQUFDO0FBQUQsQ0FBQyxBQXZWRCxDQUEwQixtQkFBUSxHQXVWakM7QUF2Vlksb0JBQUkiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5pbXBvcnQgKiBhcyBCbHVlYmlyZCBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgKiBhcyBzdGVsbGFyIGZyb20gJ3N0ZWxsYXItc2RrJztcbmltcG9ydCB7XG4gIE5hY2xXcmFwcGVyLFxuICBNdWx0aXNpZyxcbiAgQWRkcmVzcyxcbiAgU2VlZCxcbiAgZ2VuZXJhdGVBY2NvdW50RnJvbVNlZWQsXG4gIGdlbmVyYXRlQWNjb3VudCxcbiAgaXNWYWxpZEFkZHJlc3MsXG4gIGlzVmFsaWRTZWVkLFxuICBFbmNvZGluZyxcbiAgbWVyZ2VNdWx0aXNpZ1RyYW5zYWN0aW9ucyxcbn0gZnJvbSAnYWxnb3Nkayc7XG5pbXBvcnQgeyBCaXRHbyB9IGZyb20gJy4uLy4uL2JpdGdvJztcblxuaW1wb3J0IHtcbiAgQmFzZUNvaW4sXG4gIFRyYW5zYWN0aW9uRXhwbGFuYXRpb24gYXMgQmFzZVRyYW5zYWN0aW9uRXhwbGFuYXRpb24sXG4gIEtleVBhaXIsXG4gIFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zLFxuICBQYXJzZWRUcmFuc2FjdGlvbixcbiAgVmVyaWZ5QWRkcmVzc09wdGlvbnMsXG4gIFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgU2lnbmVkVHJhbnNhY3Rpb24sXG59IGZyb20gJy4uL2Jhc2VDb2luJztcbmltcG9ydCB7IEtleUluZGljZXMgfSBmcm9tICcuLi9rZXljaGFpbnMnO1xuaW1wb3J0IHsgTm9kZUNhbGxiYWNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5jb25zdCBjbyA9IEJsdWViaXJkLmNvcm91dGluZTtcblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2FjdGlvbkV4cGxhbmF0aW9uIGV4dGVuZHMgQmFzZVRyYW5zYWN0aW9uRXhwbGFuYXRpb24ge1xuICBtZW1vOiBzdHJpbmc7XG4gIHR5cGU/OiBzdHJpbmc7XG4gIHNlbmRlckFkZHJlc3M/OiBzdHJpbmc7XG4gIHZvdGVLZXlCYXNlNjQ/OiBzdHJpbmc7XG4gIHZvdGVMYXN0QmxvY2s/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4UHJlYnVpbGQ6IFRyYW5zYWN0aW9uUHJlYnVpbGQ7XG4gIHBydjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zYWN0aW9uUHJlYnVpbGQge1xuICB0eEhleDogc3RyaW5nO1xuICBoYWxmU2lnbmVkPzoge1xuICAgIHR4SGV4OiBzdHJpbmc7XG4gIH07XG4gIHR4SW5mbzoge1xuICAgIGZyb206IHN0cmluZztcbiAgICB0bzogc3RyaW5nO1xuICAgIGFtb3VudDogc3RyaW5nO1xuICAgIGZlZTogbnVtYmVyO1xuICAgIGZpcnN0Um91bmQ6IG51bWJlcjtcbiAgICBsYXN0Um91bmQ6IG51bWJlcjtcbiAgICBnZW5lc2lzSUQ6IHN0cmluZztcbiAgICBnZW5lc2lzSGFzaDogc3RyaW5nO1xuICAgIG5vdGU/OiBzdHJpbmc7XG4gIH07XG4gIGtleXM6IHN0cmluZ1tdO1xuICBhZGRyZXNzVmVyc2lvbjogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZ1bGx5U2lnbmVkVHJhbnNhY3Rpb24ge1xuICB0eEhleDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhhbGZTaWduZWRUcmFuc2FjdGlvbiB7XG4gIGhhbGZTaWduZWQ6IHtcbiAgICB0eEhleDogc3RyaW5nO1xuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4cGxhaW5UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eEhleD86IHN0cmluZztcbiAgaGFsZlNpZ25lZD86IHtcbiAgICB0eEhleDogc3RyaW5nO1xuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZlcmlmaWVkVHJhbnNhY3Rpb25QYXJhbWV0ZXJzIHtcbiAgdHhIZXg6IHN0cmluZztcbiAgYWRkcmVzc1ZlcnNpb246IG51bWJlcjtcbiAga2V5czogc3RyaW5nW107XG4gIHNrOiBzdHJpbmc7XG4gIGlzSGFsZlNpZ25lZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNsYXNzIEFsZ28gZXh0ZW5kcyBCYXNlQ29pbiB7XG4gIGNvbnN0cnVjdG9yKGJpdGdvOiBCaXRHbykge1xuICAgIHN1cGVyKGJpdGdvKTtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVJbnN0YW5jZShiaXRnbzogQml0R28pOiBCYXNlQ29pbiB7XG4gICAgcmV0dXJuIG5ldyBBbGdvKGJpdGdvKTtcbiAgfVxuXG4gIGdldENoYWluKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdhbGdvJztcbiAgfVxuXG4gIGdldEZhbWlseSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnYWxnbyc7XG4gIH1cblxuICBnZXRGdWxsTmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnQWxnb3JhbmQnO1xuICB9XG5cbiAgZ2V0QmFzZUZhY3RvcigpOiBhbnkge1xuICAgIHJldHVybiAxZTY7XG4gIH1cblxuICAvKipcbiAgICogRmxhZyBmb3Igc2VuZGluZyB2YWx1ZSBvZiAwXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIG9rYXkgdG8gc2VuZCAwIHZhbHVlLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIHZhbHVlbGVzc1RyYW5zZmVyQWxsb3dlZCgpOiBib29sZWFuIHtcbiAgICAvLyBUT0RPOiB0aGlzIHNvdW5kcyBsaWtlIGl0cyB0cnVlIHdpdGggdGhlIHN0YWtpbmcgdHhlcyAtIGNvbmZpcm0gYmVmb3JlIGxhdW5jaFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGdvcmFuZCBzdXBwb3J0cyBhY2NvdW50IGNvbnNvbGlkYXRpb25zLiBUaGVzZSBhcmUgdHJhbnNmZXJzIGZyb20gdGhlIHJlY2VpdmUgYWRkcmVzc2VzXG4gICAqIHRvIHRoZSBtYWluIGFkZHJlc3MuXG4gICAqL1xuICBhbGxvd3NBY2NvdW50Q29uc29saWRhdGlvbnMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgZWQyNTUxOSBrZXkgcGFpclxuICAgKlxuICAgKiBAcGFyYW0gc2VlZFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3Qgd2l0aCBnZW5lcmF0ZWQgcHViLCBwcnZcbiAgICovXG4gIGdlbmVyYXRlS2V5UGFpcihzZWVkPzogQnVmZmVyKTogS2V5UGFpciB7XG4gICAgY29uc3QgcGFpciA9IHNlZWQgPyBnZW5lcmF0ZUFjY291bnRGcm9tU2VlZChzZWVkKSA6IGdlbmVyYXRlQWNjb3VudCgpO1xuICAgIHJldHVybiB7XG4gICAgICBwdWI6IHBhaXIuYWRkciwgLy8gZW5jb2RlZCBwdWJcbiAgICAgIHBydjogU2VlZC5lbmNvZGUocGFpci5zayksIC8vIGVuY29kZWQgc2VlZFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGlucHV0IGlzIHZhbGlkIHB1YmxpYyBrZXkgZm9yIHRoZSBjb2luLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHViIHRoZSBwdWIgdG8gYmUgY2hlY2tlZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gaXMgaXQgdmFsaWQ/XG4gICAqL1xuICBpc1ZhbGlkUHViKHB1Yjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGlzVmFsaWRBZGRyZXNzKHB1Yik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGlucHV0IGlzIHZhbGlkIHNlZWQgZm9yIHRoZSBjb2luXG4gICAqIEluIEFsZ29yYW5kLCB3aGVuIHRoZSBwcml2YXRlIGtleSBpcyBlbmNvZGVkIGFzIGJhc2UzMiBzdHJpbmcgb25seSB0aGUgZmlyc3QgMzIgYnl0ZXMgYXJlIHRha2VuLFxuICAgKiBzbyB0aGUgZW5jb2RlZCB2YWx1ZSBpcyBhY3R1YWxseSB0aGUgc2VlZFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJ2IHRoZSBwcnYgdG8gYmUgY2hlY2tlZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gaXMgaXQgdmFsaWQ/XG4gICAqL1xuICBpc1ZhbGlkUHJ2KHBydjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGlzVmFsaWRTZWVkKHBydik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGlucHV0IGlzIHZhbGlkIHB1YmxpYyBrZXkgZm9yIHRoZSBjb2luXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIHRoZSBwdWIgdG8gYmUgY2hlY2tlZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gaXMgaXQgdmFsaWQ/XG4gICAqL1xuICBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNWYWxpZEFkZHJlc3MoYWRkcmVzcyk7XG4gIH1cblxuICAvKipcbiAgICogU2lnbiBtZXNzYWdlIHdpdGggcHJpdmF0ZSBrZXlcbiAgICpcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcGFyYW0gbWVzc2FnZVxuICAgKi9cbiAgc2lnbk1lc3NhZ2Uoa2V5OiBLZXlQYWlyLCBtZXNzYWdlOiBzdHJpbmcgfCBCdWZmZXIsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPEJ1ZmZlcj4pOiBCbHVlYmlyZDxCdWZmZXI+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288QnVmZmVyPihmdW5jdGlvbiogY29zaWduTWVzc2FnZSgpIHtcbiAgICAgIC8vIGtleS5wcnYgYWN0dWFsbHkgaG9sZHMgdGhlIGVuY29kZWQgc2VlZCwgYnV0IHdlIHVzZSB0aGUgcHJ2IG5hbWUgdG8gYXZvaWQgYnJlYWtpbmcgdGhlIGtleXBhaXIgc2NoZW1hLlxuICAgICAgLy8gU2VlIGpzZG9jIGNvbW1lbnQgaW4gaXNWYWxpZFBydlxuICAgICAgbGV0IHNlZWQgPSBrZXkucHJ2O1xuICAgICAgaWYgKCFzZWxmLmlzVmFsaWRQcnYoc2VlZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHNlZWQ6ICR7c2VlZH1gKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc2VlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzZWVkID0gU2VlZC5kZWNvZGUoc2VlZCkuc2VlZDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY291bGQgbm90IGRlY29kZSBzZWVkOiAke3NlZWR9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGtleVBhaXIgPSBnZW5lcmF0ZUFjY291bnRGcm9tU2VlZChzZWVkKTtcblxuICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIobWVzc2FnZSkpIHtcbiAgICAgICAgbWVzc2FnZSA9IEJ1ZmZlci5mcm9tKG1lc3NhZ2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oTmFjbFdyYXBwZXIuc2lnbihtZXNzYWdlLCBrZXlQYWlyLnNrKSk7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogU3BlY2lmaWVzIHdoYXQga2V5IHdlIHdpbGwgbmVlZCBmb3Igc2lnbmluZ2AgLSBBbGdvcmFuZCBuZWVkcyB0aGUgYmFja3VwLCBiaXRnbyBwdWJzLlxuICAgKi9cbiAga2V5SWRzRm9yU2lnbmluZygpOiBudW1iZXJbXSB7XG4gICAgcmV0dXJuIFtLZXlJbmRpY2VzLlVTRVIsIEtleUluZGljZXMuQkFDS1VQLCBLZXlJbmRpY2VzLkJJVEdPXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBsYWluL3BhcnNlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBleHBsYWluVHJhbnNhY3Rpb24oXG4gICAgcGFyYW1zOiBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zLFxuICAgIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFRyYW5zYWN0aW9uRXhwbGFuYXRpb24+XG4gICk6IEJsdWViaXJkPFRyYW5zYWN0aW9uRXhwbGFuYXRpb24+IHtcbiAgICByZXR1cm4gY288VHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4oZnVuY3Rpb24qKCkge1xuICAgICAgLy8gdGFrZSB0eEhleCBmaXJzdCBhbHdheXMsIGJ1dCBhcyBpdCBtaWdodCBhbHJlYWR5IGJlIHNpZ25lZCwgdGFrZSBoYWxmU2lnbmVkIHNlY29uZFxuICAgICAgY29uc3QgdHhIZXggPSBwYXJhbXMudHhIZXggfHwgKHBhcmFtcy5oYWxmU2lnbmVkICYmIHBhcmFtcy5oYWxmU2lnbmVkLnR4SGV4KTtcblxuICAgICAgaWYgKCF0eEhleCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgcGFyYW0gdHhIZXggb3IgaGFsZlNpZ25lZC50eEhleCcpO1xuICAgICAgfVxuICAgICAgbGV0IHR4LCB0eXBlLCBzZW5kZXJBZGRyZXNzLCB2b3RlS2V5QmFzZTY0LCB2b3RlTGFzdEJsb2NrO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdHhUb0hleCA9IEJ1ZmZlci5mcm9tKHR4SGV4LCAnYmFzZTY0Jyk7XG4gICAgICAgIGNvbnN0IGRlY29kZWRUeCA9IEVuY29kaW5nLmRlY29kZSh0eFRvSGV4KTtcblxuICAgICAgICAvLyBpZiB3ZSBhcmUgYSBzaWduZWQgbXNpZyB0eCwgdGhlIHN0cnVjdHVyZSBhY3R1YWxseSBoYXMgdGhlIHsgbXNpZywgdHhuIH0gYXMgdGhlIHJvb3Qgb2JqZWN0XG4gICAgICAgIC8vIGlmIHdlIGFyZSBub3Qgc2lnbmVkLCB0aGUgZGVjb2RlZCB0eCBpcyB0aGUgdHhuIC0gcmVmZXIgdG8gcGFydGlhbFNpZ25UeG4gYW5kIE11bHRpU2lnIGNvbnN0cnVjdG9yXG4gICAgICAgIC8vICAgaW4gYWxnb3NkayBmb3IgbW9yZSBpbmZvcm1hdGlvblxuICAgICAgICBjb25zdCB0eG5Gb3JEZWNvZGluZyA9IGRlY29kZWRUeC50eG4gfHwgZGVjb2RlZFR4O1xuICAgICAgICBpZiAoISF0eG5Gb3JEZWNvZGluZy52b3Rla2V5KSB7XG4gICAgICAgICAgdHlwZSA9IHR4bkZvckRlY29kaW5nLnR5cGU7XG4gICAgICAgICAgc2VuZGVyQWRkcmVzcyA9IEFkZHJlc3MuZW5jb2RlKHR4bkZvckRlY29kaW5nLnNuZCk7XG4gICAgICAgICAgdm90ZUtleUJhc2U2NCA9IHR4bkZvckRlY29kaW5nLnZvdGVrZXkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgICAgIHZvdGVMYXN0QmxvY2sgPSB0eG5Gb3JEZWNvZGluZy52b3RlbHN0O1xuICAgICAgICB9XG5cbiAgICAgICAgdHggPSBNdWx0aXNpZy5NdWx0aVNpZ1RyYW5zYWN0aW9uLmZyb21fb2JqX2Zvcl9lbmNvZGluZyh0eG5Gb3JEZWNvZGluZyk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R4SGV4IG5lZWRzIHRvIGJlIGEgdmFsaWQgdHggZW5jb2RlZCBhcyBiYXNlNjQgc3RyaW5nJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlkID0gdHgudHhJRCgpO1xuICAgICAgY29uc3QgZmVlID0geyBmZWU6IHR4LmZlZSB9O1xuXG4gICAgICBjb25zdCBvdXRwdXRBbW91bnQgPSB0eC5hbW91bnQgfHwgMDtcbiAgICAgIGNvbnN0IG91dHB1dHM6IHsgYW1vdW50OiBudW1iZXI7IGFkZHJlc3M6IHN0cmluZyB9W10gPSBbXTtcbiAgICAgIGlmICh0eC50bykge1xuICAgICAgICBvdXRwdXRzLnB1c2goe1xuICAgICAgICAgIGFtb3VudDogb3V0cHV0QW1vdW50LFxuICAgICAgICAgIGFkZHJlc3M6IEFkZHJlc3MuZW5jb2RlKG5ldyBVaW50OEFycmF5KHR4LnRvLnB1YmxpY0tleSkpLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETyhDVC00ODApOiBhZGQgcmVjaWV2aW5nIGFkZHJlc3MgZGlzcGxheSBoZXJlXG4gICAgICBjb25zdCBtZW1vID0gdHgubm90ZTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzcGxheU9yZGVyOiBbXG4gICAgICAgICAgJ2lkJyxcbiAgICAgICAgICAnb3V0cHV0QW1vdW50JyxcbiAgICAgICAgICAnY2hhbmdlQW1vdW50JyxcbiAgICAgICAgICAnb3V0cHV0cycsXG4gICAgICAgICAgJ2NoYW5nZU91dHB1dHMnLFxuICAgICAgICAgICdmZWUnLFxuICAgICAgICAgICdtZW1vJyxcbiAgICAgICAgICAndHlwZScsXG4gICAgICAgICAgJ3NlbmRlckFkZHJlc3MnLFxuICAgICAgICAgICd2b3RlS2V5QmFzZTY0JyxcbiAgICAgICAgICAndm90ZUxhc3RCbG9jaycsXG4gICAgICAgIF0sXG4gICAgICAgIGlkLFxuICAgICAgICBvdXRwdXRzLFxuICAgICAgICBvdXRwdXRBbW91bnQsXG4gICAgICAgIGNoYW5nZUFtb3VudDogMCxcbiAgICAgICAgZmVlLFxuICAgICAgICBjaGFuZ2VPdXRwdXRzOiBbXSxcbiAgICAgICAgbWVtbyxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgdm90ZUtleUJhc2U2NCxcbiAgICAgICAgdm90ZUxhc3RCbG9jayxcbiAgICAgIH07XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICBpc1N0ZWxsYXJTZWVkKHNlZWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBzdGVsbGFyLlN0cktleS5pc1ZhbGlkRWQyNTUxOVNlY3JldFNlZWQoc2VlZCk7XG4gIH1cblxuICBjb252ZXJ0RnJvbVN0ZWxsYXJTZWVkKHNlZWQ6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICAgIC8vIGFzc3VtZSB0aGlzIGlzIGEgdHJ1c3QgY3VzdG9kaWFsIHNlZWQgaWYgaXRzIGEgdmFsaWQgZWQyNTUxOSBwcnZcbiAgICBpZiAoIXRoaXMuaXNTdGVsbGFyU2VlZChzZWVkKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBTZWVkLmVuY29kZShzdGVsbGFyLlN0cktleS5kZWNvZGVFZDI1NTE5U2VjcmV0U2VlZChzZWVkKSk7XG4gIH1cblxuICB2ZXJpZnlTaWduVHJhbnNhY3Rpb25QYXJhbXMocGFyYW1zOiBTaWduVHJhbnNhY3Rpb25PcHRpb25zKTogVmVyaWZpZWRUcmFuc2FjdGlvblBhcmFtZXRlcnMge1xuICAgIGNvbnN0IHBydiA9IHBhcmFtcy5wcnY7XG4gICAgY29uc3QgYWRkcmVzc1ZlcnNpb24gPSBwYXJhbXMudHhQcmVidWlsZC5hZGRyZXNzVmVyc2lvbjtcbiAgICBsZXQgaXNIYWxmU2lnbmVkID0gZmFsc2U7XG5cbiAgICAvLyBpdCdzIHBvc3NpYmxlIHRoaXMgdHggd2FzIGFscmVhZHkgc2lnbmVkIC0gdGFrZSB0aGUgaGFsZlNpZ25lZFxuICAgIC8vIHR4SGV4IGlmIGl0IGlzXG4gICAgbGV0IHR4SGV4ID0gcGFyYW1zLnR4UHJlYnVpbGQudHhIZXg7XG4gICAgaWYgKHBhcmFtcy50eFByZWJ1aWxkLmhhbGZTaWduZWQpIHtcbiAgICAgIGlzSGFsZlNpZ25lZCA9IHRydWU7XG4gICAgICB0eEhleCA9IHBhcmFtcy50eFByZWJ1aWxkLmhhbGZTaWduZWQudHhIZXg7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQodHhIZXgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgdHhQcmVidWlsZCBwYXJhbWV0ZXInKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNTdHJpbmcodHhIZXgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHR4UHJlYnVpbGQgbXVzdCBiZSBhbiBvYmplY3QsIGdvdCB0eXBlICR7dHlwZW9mIHR4SGV4fWApO1xuICAgIH1cblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHBydikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBwcnYgcGFyYW1ldGVyIHRvIHNpZ24gdHJhbnNhY3Rpb24nKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNTdHJpbmcocHJ2KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcnYgbXVzdCBiZSBhIHN0cmluZywgZ290IHR5cGUgJHt0eXBlb2YgcHJ2fWApO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICFfLmhhcyhwYXJhbXMudHhQcmVidWlsZCwgJ2tleXNbMF0nKSB8fFxuICAgICAgIV8uaGFzKHBhcmFtcy50eFByZWJ1aWxkLCAna2V5c1sxXScpIHx8XG4gICAgICAhXy5oYXMocGFyYW1zLnR4UHJlYnVpbGQsICdrZXlzWzJdJylcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBwdWJsaWMga2V5cyBwYXJhbWV0ZXIgdG8gc2lnbiB0cmFuc2FjdGlvbicpO1xuICAgIH1cblxuICAgIGlmICghXy5pc051bWJlcihhZGRyZXNzVmVyc2lvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBhZGRyZXNzVmVyc2lvbiBwYXJhbWV0ZXIgdG8gc2lnbiB0cmFuc2FjdGlvbicpO1xuICAgIH1cblxuICAgIC8vIHdlIG5lZWQgdG8gcmUtZW5jb2RlIG91ciBwdWJsaWMga2V5cyB1c2luZyBhbGdvc2RrJ3MgZm9ybWF0XG4gICAgY29uc3Qga2V5cyA9IFtwYXJhbXMudHhQcmVidWlsZC5rZXlzWzBdLCBwYXJhbXMudHhQcmVidWlsZC5rZXlzWzFdLCBwYXJhbXMudHhQcmVidWlsZC5rZXlzWzJdXTtcblxuICAgIC8vIHJlLWVuY29kZSBzayBmcm9tIG91ciBwcnYgKHRoaXMgYWN0cyBhcyBhIHNlZWQgb3V0IG9mIHRoZSBrZXljaGFpbilcbiAgICBjb25zdCBzZWVkID0gU2VlZC5kZWNvZGUocHJ2KS5zZWVkO1xuICAgIGNvbnN0IHBhaXIgPSBnZW5lcmF0ZUFjY291bnRGcm9tU2VlZChzZWVkKTtcbiAgICBjb25zdCBzayA9IHBhaXIuc2s7XG5cbiAgICByZXR1cm4geyB0eEhleCwgYWRkcmVzc1ZlcnNpb24sIGtleXMsIHNrLCBpc0hhbGZTaWduZWQgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlbWJsZSBrZXljaGFpbiBhbmQgaGFsZi1zaWduIHByZWJ1aWx0IHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy50eFByZWJ1aWxkIHtUcmFuc2FjdGlvblByZWJ1aWxkfSBwcmVidWlsZCBvYmplY3QgcmV0dXJuZWQgYnkgcGxhdGZvcm1cbiAgICogQHBhcmFtIHBhcmFtcy5wcnYge1N0cmluZ30gdXNlciBwcnZcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtCbHVlYmlyZDxTaWduZWRUcmFuc2FjdGlvbj59XG4gICAqL1xuICBzaWduVHJhbnNhY3Rpb24oXG4gICAgcGFyYW1zOiBTaWduVHJhbnNhY3Rpb25PcHRpb25zLFxuICAgIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFNpZ25lZFRyYW5zYWN0aW9uPlxuICApOiBCbHVlYmlyZDxTaWduZWRUcmFuc2FjdGlvbj4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxTaWduZWRUcmFuc2FjdGlvbj4oZnVuY3Rpb24qKCkge1xuICAgICAgY29uc3QgeyB0eEhleCwgYWRkcmVzc1ZlcnNpb24sIGtleXMsIHNrLCBpc0hhbGZTaWduZWQgfSA9IHNlbGYudmVyaWZ5U2lnblRyYW5zYWN0aW9uUGFyYW1zKHBhcmFtcyk7XG4gICAgICBjb25zdCBlbmNvZGVkUHVibGljS2V5cyA9IF8ubWFwKGtleXMsIGsgPT4gQWRkcmVzcy5kZWNvZGUoaykucHVibGljS2V5KTtcblxuICAgICAgLy8gZGVjb2RlIG91ciB1bnNpZ25lZC9oYWxmLXNpZ25lZCB0eFxuICAgICAgbGV0IHRyYW5zYWN0aW9uO1xuICAgICAgbGV0IHR4VG9IZXg7XG4gICAgICB0cnkge1xuICAgICAgICB0eFRvSGV4ID0gQnVmZmVyLmZyb20odHhIZXgsICdiYXNlNjQnKTtcbiAgICAgICAgY29uc3QgaW5pdGlhbERlY29kZWRUeCA9IEVuY29kaW5nLmRlY29kZSh0eFRvSGV4KTtcblxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHNjcnViIHRoZSB0eG4gb2Ygc2lncyBmb3IgaGFsZi1zaWduZWRcbiAgICAgICAgY29uc3QgZGVjb2RlZFR4ID0gaXNIYWxmU2lnbmVkID8gaW5pdGlhbERlY29kZWRUeC50eG4gOiBpbml0aWFsRGVjb2RlZFR4O1xuXG4gICAgICAgIHRyYW5zYWN0aW9uID0gTXVsdGlzaWcuTXVsdGlTaWdUcmFuc2FjdGlvbi5mcm9tX29ial9mb3JfZW5jb2RpbmcoZGVjb2RlZFR4KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFuc2FjdGlvbiBuZWVkcyB0byBiZSBhIHZhbGlkIHR4IGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZycpO1xuICAgICAgfVxuXG4gICAgICAvLyBzaWduIG91ciB0eFxuICAgICAgbGV0IHNpZ25lZCA9IHRyYW5zYWN0aW9uLnBhcnRpYWxTaWduVHhuKHsgdmVyc2lvbjogYWRkcmVzc1ZlcnNpb24sIHRocmVzaG9sZDogMiwgcGtzOiBlbmNvZGVkUHVibGljS2V5cyB9LCBzayk7XG5cbiAgICAgIC8vIGlmIHdlIGhhdmUgYWxyZWFkeSBzaWduZWQgaXQsIHdlJ2xsIGhhdmUgdG8gbWVyZ2UgdGhhdCB3aXRoIG91ciBwcmV2aW91cyB0eFxuICAgICAgaWYgKGlzSGFsZlNpZ25lZCkge1xuICAgICAgICBzaWduZWQgPSBtZXJnZU11bHRpc2lnVHJhbnNhY3Rpb25zKFtCdWZmZXIuZnJvbShzaWduZWQpLCB0eFRvSGV4XSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNpZ25lZEJhc2U2NCA9IEJ1ZmZlci5mcm9tKHNpZ25lZCkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuXG4gICAgICBpZiAoaXNIYWxmU2lnbmVkKSB7XG4gICAgICAgIHJldHVybiB7IHR4SGV4OiBzaWduZWRCYXNlNjQgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7IGhhbGZTaWduZWQ6IHsgdHhIZXg6IHNpZ25lZEJhc2U2NCB9IH07XG4gICAgICB9XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICBwYXJzZVRyYW5zYWN0aW9uKFxuICAgIHBhcmFtczogUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMsXG4gICAgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8UGFyc2VkVHJhbnNhY3Rpb24+XG4gICk6IEJsdWViaXJkPFBhcnNlZFRyYW5zYWN0aW9uPiB7XG4gICAgcmV0dXJuIEJsdWViaXJkLnJlc29sdmUoe30pLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgdmVyaWZ5QWRkcmVzcyhwYXJhbXM6IFZlcmlmeUFkZHJlc3NPcHRpb25zKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2ZXJpZnlUcmFuc2FjdGlvbihwYXJhbXM6IFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8Ym9vbGVhbj4pOiBCbHVlYmlyZDxib29sZWFuPiB7XG4gICAgcmV0dXJuIEJsdWViaXJkLnJlc29sdmUodHJ1ZSkuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cbn1cbiJdfQ==