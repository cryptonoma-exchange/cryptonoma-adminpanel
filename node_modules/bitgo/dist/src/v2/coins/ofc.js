"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @prettier
 */
var errors_1 = require("../../errors");
var baseCoin_1 = require("../baseCoin");
var Bluebird = require("bluebird");
var crypto = require("crypto");
var bitGoUtxoLib = require("bitgo-utxo-lib");
var Ofc = /** @class */ (function (_super) {
    __extends(Ofc, _super);
    function Ofc() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Ofc.createInstance = function (bitgo) {
        return new Ofc(bitgo);
    };
    Ofc.prototype.getChain = function () {
        return 'ofc';
    };
    /**
     * Generate secp256k1 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub and prv
     */
    Ofc.prototype.generateKeyPair = function (seed) {
        if (!seed) {
            // An extended private key has both a normal 256 bit private key and a 256
            // bit chain code, both of which must be random. 512 bits is therefore the
            // maximum entropy and gives us maximum security against cracking.
            seed = crypto.randomBytes(512 / 8);
        }
        var extendedKey = bitGoUtxoLib.HDNode.fromSeedBuffer(seed);
        var xpub = extendedKey.neutered().toBase58();
        return {
            pub: xpub,
            prv: extendedKey.toBase58(),
        };
    };
    Ofc.prototype.getFamily = function () {
        return 'ofc';
    };
    Ofc.prototype.getFullName = function () {
        return 'Offchain';
    };
    /**
     * Return whether the given m of n wallet signers/ key amounts are valid for the coin
     */
    Ofc.prototype.isValidMofNSetup = function (_a) {
        var m = _a.m, n = _a.n;
        return m === 1 && n === 1;
    };
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    Ofc.prototype.isValidPub = function (pub) {
        try {
            bitGoUtxoLib.HDNode.fromBase58(pub);
            return true;
        }
        catch (e) {
            return false;
        }
    };
    Ofc.prototype.isValidAddress = function (address) {
        throw new errors_1.MethodNotImplementedError();
    };
    Ofc.prototype.getBaseFactor = function () {
        return 0;
    };
    Ofc.prototype.parseTransaction = function (params, callback) {
        return Bluebird.resolve({}).asCallback(callback);
    };
    Ofc.prototype.verifyAddress = function (params) {
        return true;
    };
    Ofc.prototype.verifyTransaction = function (params, callback) {
        return Bluebird.resolve(true).asCallback(callback);
    };
    Ofc.prototype.signTransaction = function (params, callback) {
        return Bluebird.reject(new errors_1.MethodNotImplementedError()).asCallback(callback);
    };
    return Ofc;
}(baseCoin_1.BaseCoin));
exports.Ofc = Ofc;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2ZjLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3YyL2NvaW5zL29mYy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7R0FFRztBQUNILHVDQUF5RDtBQUN6RCx3Q0FTcUI7QUFHckIsbUNBQXFDO0FBQ3JDLCtCQUFpQztBQUNqQyw2Q0FBK0M7QUFFL0M7SUFBeUIsdUJBQVE7SUFBakM7O0lBeUZBLENBQUM7SUF4RlEsa0JBQWMsR0FBckIsVUFBc0IsS0FBWTtRQUNoQyxPQUFPLElBQUksR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3hCLENBQUM7SUFFRCxzQkFBUSxHQUFSO1FBQ0UsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCw2QkFBZSxHQUFmLFVBQWdCLElBQWE7UUFDM0IsSUFBSSxDQUFDLElBQUksRUFBRTtZQUNULDBFQUEwRTtZQUMxRSwwRUFBMEU7WUFDMUUsa0VBQWtFO1lBQ2xFLElBQUksR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQztTQUNwQztRQUNELElBQU0sV0FBVyxHQUFHLFlBQVksQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzdELElBQU0sSUFBSSxHQUFHLFdBQVcsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUMvQyxPQUFPO1lBQ0wsR0FBRyxFQUFFLElBQUk7WUFDVCxHQUFHLEVBQUUsV0FBVyxDQUFDLFFBQVEsRUFBRTtTQUM1QixDQUFDO0lBQ0osQ0FBQztJQUVELHVCQUFTLEdBQVQ7UUFDRSxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRCx5QkFBVyxHQUFYO1FBQ0UsT0FBTyxVQUFVLENBQUM7SUFDcEIsQ0FBQztJQUVEOztPQUVHO0lBQ0gsOEJBQWdCLEdBQWhCLFVBQWlCLEVBQWtDO1lBQWhDLFFBQUMsRUFBRSxRQUFDO1FBQ3JCLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzVCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILHdCQUFVLEdBQVYsVUFBVyxHQUFXO1FBQ3BCLElBQUk7WUFDRixZQUFZLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNwQyxPQUFPLElBQUksQ0FBQztTQUNiO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixPQUFPLEtBQUssQ0FBQztTQUNkO0lBQ0gsQ0FBQztJQUVELDRCQUFjLEdBQWQsVUFBZSxPQUFlO1FBQzVCLE1BQU0sSUFBSSxrQ0FBeUIsRUFBRSxDQUFDO0lBQ3hDLENBQUM7SUFFRCwyQkFBYSxHQUFiO1FBQ0UsT0FBTyxDQUFDLENBQUM7SUFDWCxDQUFDO0lBRUQsOEJBQWdCLEdBQWhCLFVBQ0UsTUFBK0IsRUFDL0IsUUFBMEM7UUFFMUMsT0FBTyxRQUFRLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBRUQsMkJBQWEsR0FBYixVQUFjLE1BQTRCO1FBQ3hDLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVELCtCQUFpQixHQUFqQixVQUFrQixNQUFnQyxFQUFFLFFBQWdDO1FBQ2xGLE9BQU8sUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDckQsQ0FBQztJQUVELDZCQUFlLEdBQWYsVUFDRSxNQUE4QixFQUM5QixRQUEwQztRQUUxQyxPQUFPLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxrQ0FBeUIsRUFBRSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQy9FLENBQUM7SUFDSCxVQUFDO0FBQUQsQ0FBQyxBQXpGRCxDQUF5QixtQkFBUSxHQXlGaEM7QUF6Rlksa0JBQUciLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5pbXBvcnQgeyBNZXRob2ROb3RJbXBsZW1lbnRlZEVycm9yIH0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7XG4gIEJhc2VDb2luLFxuICBLZXlQYWlyLFxuICBQYXJzZWRUcmFuc2FjdGlvbixcbiAgUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFNpZ25lZFRyYW5zYWN0aW9uLFxuICBTaWduVHJhbnNhY3Rpb25PcHRpb25zLFxuICBWZXJpZnlBZGRyZXNzT3B0aW9ucyxcbiAgVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLFxufSBmcm9tICcuLi9iYXNlQ29pbic7XG5pbXBvcnQgeyBCaXRHbyB9IGZyb20gJy4uLy4uL2JpdGdvJztcbmltcG9ydCB7IE5vZGVDYWxsYmFjayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCAqIGFzIEJsdWViaXJkIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCAqIGFzIGNyeXB0byBmcm9tICdjcnlwdG8nO1xuaW1wb3J0ICogYXMgYml0R29VdHhvTGliIGZyb20gJ2JpdGdvLXV0eG8tbGliJztcblxuZXhwb3J0IGNsYXNzIE9mYyBleHRlbmRzIEJhc2VDb2luIHtcbiAgc3RhdGljIGNyZWF0ZUluc3RhbmNlKGJpdGdvOiBCaXRHbyk6IEJhc2VDb2luIHtcbiAgICByZXR1cm4gbmV3IE9mYyhiaXRnbyk7XG4gIH1cblxuICBnZXRDaGFpbigpIHtcbiAgICByZXR1cm4gJ29mYyc7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgc2VjcDI1NmsxIGtleSBwYWlyXG4gICAqXG4gICAqIEBwYXJhbSBzZWVkXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdCB3aXRoIGdlbmVyYXRlZCBwdWIgYW5kIHBydlxuICAgKi9cbiAgZ2VuZXJhdGVLZXlQYWlyKHNlZWQ/OiBCdWZmZXIpOiBLZXlQYWlyIHtcbiAgICBpZiAoIXNlZWQpIHtcbiAgICAgIC8vIEFuIGV4dGVuZGVkIHByaXZhdGUga2V5IGhhcyBib3RoIGEgbm9ybWFsIDI1NiBiaXQgcHJpdmF0ZSBrZXkgYW5kIGEgMjU2XG4gICAgICAvLyBiaXQgY2hhaW4gY29kZSwgYm90aCBvZiB3aGljaCBtdXN0IGJlIHJhbmRvbS4gNTEyIGJpdHMgaXMgdGhlcmVmb3JlIHRoZVxuICAgICAgLy8gbWF4aW11bSBlbnRyb3B5IGFuZCBnaXZlcyB1cyBtYXhpbXVtIHNlY3VyaXR5IGFnYWluc3QgY3JhY2tpbmcuXG4gICAgICBzZWVkID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDUxMiAvIDgpO1xuICAgIH1cbiAgICBjb25zdCBleHRlbmRlZEtleSA9IGJpdEdvVXR4b0xpYi5IRE5vZGUuZnJvbVNlZWRCdWZmZXIoc2VlZCk7XG4gICAgY29uc3QgeHB1YiA9IGV4dGVuZGVkS2V5Lm5ldXRlcmVkKCkudG9CYXNlNTgoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcHViOiB4cHViLFxuICAgICAgcHJ2OiBleHRlbmRlZEtleS50b0Jhc2U1OCgpLFxuICAgIH07XG4gIH1cblxuICBnZXRGYW1pbHkoKSB7XG4gICAgcmV0dXJuICdvZmMnO1xuICB9XG5cbiAgZ2V0RnVsbE5hbWUoKSB7XG4gICAgcmV0dXJuICdPZmZjaGFpbic7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhlIGdpdmVuIG0gb2YgbiB3YWxsZXQgc2lnbmVycy8ga2V5IGFtb3VudHMgYXJlIHZhbGlkIGZvciB0aGUgY29pblxuICAgKi9cbiAgaXNWYWxpZE1vZk5TZXR1cCh7IG0sIG4gfTogeyBtOiBudW1iZXI7IG46IG51bWJlciB9KSB7XG4gICAgcmV0dXJuIG0gPT09IDEgJiYgbiA9PT0gMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaW5wdXQgaXMgdmFsaWQgcHVibGljIGtleSBmb3IgdGhlIGNvaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwdWIgdGhlIHB1YiB0byBiZSBjaGVja2VkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBpcyBpdCB2YWxpZD9cbiAgICovXG4gIGlzVmFsaWRQdWIocHViOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgYml0R29VdHhvTGliLkhETm9kZS5mcm9tQmFzZTU4KHB1Yik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaXNWYWxpZEFkZHJlc3MoYWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdGhyb3cgbmV3IE1ldGhvZE5vdEltcGxlbWVudGVkRXJyb3IoKTtcbiAgfVxuXG4gIGdldEJhc2VGYWN0b3IoKTogbnVtYmVyIHwgc3RyaW5nIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHBhcnNlVHJhbnNhY3Rpb24oXG4gICAgcGFyYW1zOiBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgICBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxQYXJzZWRUcmFuc2FjdGlvbj5cbiAgKTogQmx1ZWJpcmQ8UGFyc2VkVHJhbnNhY3Rpb24+IHtcbiAgICByZXR1cm4gQmx1ZWJpcmQucmVzb2x2ZSh7fSkuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICB2ZXJpZnlBZGRyZXNzKHBhcmFtczogVmVyaWZ5QWRkcmVzc09wdGlvbnMpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZlcmlmeVRyYW5zYWN0aW9uKHBhcmFtczogVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxib29sZWFuPik6IEJsdWViaXJkPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gQmx1ZWJpcmQucmVzb2x2ZSh0cnVlKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIHNpZ25UcmFuc2FjdGlvbihcbiAgICBwYXJhbXM6IFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMsXG4gICAgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8U2lnbmVkVHJhbnNhY3Rpb24+XG4gICk6IEJsdWViaXJkPFNpZ25lZFRyYW5zYWN0aW9uPiB7XG4gICAgcmV0dXJuIEJsdWViaXJkLnJlamVjdChuZXcgTWV0aG9kTm90SW1wbGVtZW50ZWRFcnJvcigpKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxufVxuIl19