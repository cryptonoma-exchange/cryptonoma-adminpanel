"use strict";
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var bignumber_js_1 = require("bignumber.js");
var Bluebird = require("bluebird");
var _ = require("lodash");
var debugLib = require("debug");
var bitcoin_1 = require("../bitcoin");
var common = require("../common");
var errors_1 = require("../errors");
var internal = require("./internal/internal");
var keycard_1 = require("./internal/keycard");
var tradingAccount_1 = require("./trading/tradingAccount");
var pendingApproval_1 = require("./pendingApproval");
var util_1 = require("./internal/util");
var debug = debugLib('bitgo:v2:wallet');
var co = Bluebird.coroutine;
var Wallet = /** @class */ (function () {
    function Wallet(bitgo, baseCoin, walletData) {
        this.bitgo = bitgo;
        this.baseCoin = baseCoin;
        this._wallet = walletData;
        var userId = _.get(bitgo, '_user.id');
        if (_.isString(userId)) {
            var userDetails = _.find(walletData.users, { user: userId });
            this._permissions = _.get(userDetails, 'permissions');
        }
    }
    /**
     * Build a URL using this wallet's id which can be used for BitGo API operations
     * @param extra API specific string to append to the wallet id
     */
    Wallet.prototype.url = function (extra) {
        if (extra === void 0) { extra = ''; }
        return this.baseCoin.url('/wallet/' + this.id() + extra);
    };
    /**
     * Get this wallet's id
     */
    Wallet.prototype.id = function () {
        return this._wallet.id;
    };
    /**
     * Get the number of approvals required for spending funds from this wallet
     */
    Wallet.prototype.approvalsRequired = function () {
        return this._wallet.approvalsRequired;
    };
    /**
     * Get the current balance of this wallet
     */
    Wallet.prototype.balance = function () {
        return this._wallet.balance;
    };
    Wallet.prototype.prebuildWhitelistedParams = function () {
        return [
            'recipients', 'numBlocks', 'feeRate', 'maxFeeRate', 'minConfirms', 'enforceMinConfirmsForChange',
            'targetWalletUnspents', 'message', 'minValue', 'maxValue', 'sequenceId', 'lastLedgerSequence',
            'ledgerSequenceDelta', 'gasPrice', 'gasLimit', 'noSplitChange', 'unspents', 'changeAddress', 'instant', 'memo', 'addressType',
            'cpfpTxIds', 'cpfpFeeRate', 'maxFee', 'idfVersion', 'idfSignedTimestamp', 'idfUserId', 'strategy',
            'validFromBlock', 'validToBlock', 'type', 'trustlines', 'reservation',
        ];
    };
    /**
     * This is a strict sub-set of prebuildWhitelistedParams.
     */
    Wallet.prototype.prebuildConsolidateTransactionParams = function () {
        return [
            'feeRate', 'maxFeeRate', 'memo', 'validFromBlock', 'validToBlock',
        ];
    };
    /**
     * Get the confirmed balance of this wallet
     */
    Wallet.prototype.confirmedBalance = function () {
        return this._wallet.confirmedBalance;
    };
    /**
     * Get the spendable balance of this wallet
     */
    Wallet.prototype.spendableBalance = function () {
        return this._wallet.spendableBalance;
    };
    /**
     * Get a string representation of the balance of this wallet
     *
     * This is useful when balances have the potential to overflow standard javascript numbers
     */
    Wallet.prototype.balanceString = function () {
        return this._wallet.balanceString;
    };
    /**
     * Get a string representation of the confirmed balance of this wallet
     *
     * This is useful when balances have the potential to overflow standard javascript numbers
     */
    Wallet.prototype.confirmedBalanceString = function () {
        return this._wallet.confirmedBalanceString;
    };
    /**
     * Get a string representation of the spendable balance of this wallet
     *
     * This is useful when balances have the potential to overflow standard javascript numbers
     */
    Wallet.prototype.spendableBalanceString = function () {
        return this._wallet.spendableBalanceString;
    };
    /**
     * Get the coin identifier for the type of coin this wallet holds
     */
    Wallet.prototype.coin = function () {
        return this._wallet.coin;
    };
    /**
     * Get the label (name) for this wallet
     */
    Wallet.prototype.label = function () {
        return this._wallet.label;
    };
    /**
     * Get the public object ids for the keychains on this wallet.
     */
    Wallet.prototype.keyIds = function () {
        return this._wallet.keys;
    };
    /**
     * Get a receive address for this wallet
     */
    Wallet.prototype.receiveAddress = function () {
        return this._wallet.receiveAddress.address;
    };
    /**
     * Get the wallet id of the wallet that this wallet was migrated from.
     *
     * For example, if this is a BCH wallet that was created from a BTC wallet,
     * the BCH wallet migrated from field would have the BTC wallet id.
     */
    Wallet.prototype.migratedFrom = function () {
        return this._wallet.migratedFrom;
    };
    /**
     * Return the token flush thresholds for this wallet
     * @return {*|Object} pairs of { [tokenName]: thresholds } base units
     */
    Wallet.prototype.tokenFlushThresholds = function () {
        if (this.baseCoin.getFamily() !== 'eth') {
            throw new Error('not supported for this wallet');
        }
        return this._wallet.coinSpecific.tokenFlushThresholds;
    };
    /**
     * Get wallet properties which are specific to certain coin implementations
     */
    Wallet.prototype.coinSpecific = function () {
        return this._wallet.coinSpecific;
    };
    /**
     * Get all pending approvals on this wallet
     */
    Wallet.prototype.pendingApprovals = function () {
        var _this = this;
        return this._wallet.pendingApprovals.map(function (currentApproval) {
            return new pendingApproval_1.PendingApproval(_this.bitgo, _this.baseCoin, currentApproval, _this);
        });
    };
    /**
     * Refresh the wallet object by syncing with the back-end
     * @param params
     * @param callback
     * @returns {Wallet}
     */
    Wallet.prototype.refresh = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = self;
                        return [4 /*yield*/, self.bitgo.get(self.url()).result()];
                    case 1:
                        _a._wallet = _b.sent();
                        return [2 /*return*/, this];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * List the transactions for a given wallet
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.transactions = function (params, callback) {
        if (params === void 0) { params = {}; }
        var query = {};
        if (params.prevId) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            query.prevId = params.prevId;
        }
        if (params.limit) {
            if (!_.isNumber(params.limit)) {
                throw new Error('invalid limit argument, expecting number');
            }
            query.limit = params.limit;
        }
        return this.bitgo.get(this.baseCoin.url('/wallet/' + this._wallet.id + '/tx'))
            .query(query)
            .result()
            .nodeify(callback);
    };
    /**
     * List the transactions for a given wallet
     * @param params
     *  - txHash the transaction hash to search for
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.getTransaction = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['txHash'], [], callback);
        var query = {};
        if (!_.isUndefined(params.prevId)) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            query.prevId = params.prevId;
        }
        if (!_.isUndefined(params.limit)) {
            if (!_.isInteger(params.limit) || params.limit < 1) {
                throw new Error('invalid limit argument, expecting positive integer');
            }
            query.limit = params.limit;
        }
        return this.bitgo.get(this.url('/tx/' + params.txHash))
            .query(query)
            .result()
            .nodeify(callback);
    };
    /**
     * List the transfers for a given wallet
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.transfers = function (params, callback) {
        if (params === void 0) { params = {}; }
        var query = {};
        if (params.prevId) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            query.prevId = params.prevId;
        }
        if (params.limit) {
            if (!_.isNumber(params.limit)) {
                throw new Error('invalid limit argument, expecting number');
            }
            query.limit = params.limit;
        }
        if (params.allTokens) {
            if (!_.isBoolean(params.allTokens)) {
                throw new Error('invalid allTokens argument, expecting boolean');
            }
            query.allTokens = params.allTokens;
        }
        if (params.searchLabel) {
            if (!_.isString(params.searchLabel)) {
                throw new Error('invalid searchLabel argument, expecting string');
            }
            query.searchLabel = params.searchLabel;
        }
        if (params.address) {
            if (!_.isArray(params.address) && !_.isString(params.address)) {
                throw new Error('invalid address argument, expecting string or array');
            }
            if (_.isArray(params.address)) {
                params.address.forEach(function (address) {
                    if (!_.isString(address)) {
                        throw new Error('invalid address argument, expecting array of address strings');
                    }
                });
            }
            query.address = params.address;
        }
        if (params.dateGte) {
            if (!_.isString(params.dateGte)) {
                throw new Error('invalid dateGte argument, expecting string');
            }
            query.dateGte = params.dateGte;
        }
        if (params.dateLt) {
            if (!_.isString(params.dateLt)) {
                throw new Error('invalid dateLt argument, expecting string');
            }
            query.dateLt = params.dateLt;
        }
        if (!_.isNil(params.valueGte)) {
            if (!_.isNumber(params.valueGte)) {
                throw new Error('invalid valueGte argument, expecting number');
            }
            query.valueGte = params.valueGte;
        }
        if (!_.isNil(params.valueLt)) {
            if (!_.isNumber(params.valueLt)) {
                throw new Error('invalid valueLt argument, expecting number');
            }
            query.valueLt = params.valueLt;
        }
        if (!_.isNil(params.includeHex)) {
            if (!_.isBoolean(params.includeHex)) {
                throw new Error('invalid includeHex argument, expecting boolean');
            }
            query.includeHex = params.includeHex;
        }
        if (!_.isNil(params.state)) {
            if (!Array.isArray(params.state) && !_.isString(params.state)) {
                throw new Error('invalid state argument, expecting string or array');
            }
            if (Array.isArray(params.state)) {
                params.state.forEach(function (state) {
                    if (!_.isString(state)) {
                        throw new Error('invalid state argument, expecting array of state strings');
                    }
                });
            }
            query.state = params.state;
        }
        if (!_.isNil(params.type)) {
            if (!_.isString(params.type)) {
                throw new Error('invalid type argument, expecting string');
            }
            query.type = params.type;
        }
        return this.bitgo.get(this.url('/transfer'))
            .query(query)
            .result()
            .nodeify(callback);
    };
    /**
     * Get transfers on this wallet
     * @param params
     * @param callback
     */
    Wallet.prototype.getTransfer = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['id'], [], callback);
        return this.bitgo.get(this.url('/transfer/' + params.id))
            .result()
            .nodeify(callback);
    };
    /**
     * Get a transaction by sequence id for a given wallet
     * @param params
     * @param callback
     */
    Wallet.prototype.transferBySequenceId = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['sequenceId'], [], callback);
        return this.bitgo.get(this.url('/transfer/sequenceId/' + params.sequenceId))
            .result()
            .nodeify(callback);
    };
    /**
     * Get the maximum amount you can spend in a single transaction
     *
     * @param {Object} params - parameters object
     * @param {Number} params.limit - maximum number of selectable unspents
     * @param {Number} params.minValue - the minimum value of unspents to use in satoshis
     * @param {Number} params.maxValue - the maximum value of unspents to use in satoshis
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - Enforces minConfirms on change inputs
     * @param {Number} params.feeRate - fee rate to use in calculation of maximum spendable in satoshis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {String} params.recipientAddress - recipient addresses for a more accurate calculation of the maximum available to send
     * @param callback
     * @returns {{maximumSpendable: Number, coin: String}}
     * NOTE : feeTxConfirmTarget omitted on purpose because gauging the maximum spendable amount with dynamic fees does not make sense
     */
    Wallet.prototype.maximumSpendable = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var filteredParams;
            return __generator(this, function (_a) {
                filteredParams = _.pick(params, [
                    'minValue', 'maxValue', 'minHeight', 'target', 'plainTarget', 'limit', 'minConfirms',
                    'enforceMinConfirmsForChange', 'feeRate', 'maxFeeRate', 'recipientAddress'
                ]);
                return [2 /*return*/, self.bitgo.get(self.url('/maximumSpendable'))
                        .query(filteredParams)
                        .result()];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * List the unspents for a given wallet
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.unspents = function (params, callback) {
        if (params === void 0) { params = {}; }
        var query = _.pick(params, ['prevId', 'limit', 'minValue', 'maxValue', 'minHeight', 'minConfirms', 'target', 'segwit', 'chains']);
        return this.bitgo.get(this.url('/unspents'))
            .query(query)
            .result()
            .nodeify(callback);
    };
    /**
     * Consolidate or fanout unspents on a wallet
     *
     * @param {String} routeName - either `consolidate` or `fanout`
     *
     * @param {Object} params - parameters object
     *
     * Wallet parameters:
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     *
     * Fee parameters:
     * @param {Number} params.feeRate - The fee rate to use for the consolidation in satoshis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {Number} params.maxFeePercentage - the maximum relative portion that you're willing to spend towards fees
     * @param {Number} params.feeTxConfirmTarget - estimate the fees to aim for first confirmation with this number of blocks
     *
     * Input parameters:
     * @param {Number} params.minValue - the minimum value of unspents to use in satoshis
     * @param {Number} params.maxValue - the maximum value of unspents to use in satoshis
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - if true, minConfirms also applies to change outputs
     * @param {Number} params.limit                for routeName === 'consolidate'
     *                 params.maxNumUnspentsToUse  for routeName === 'fanout'
     *                  - maximum number of unspents you want to use in the transaction
     * Output parameters:
     * @param {Number} params.numUnspentsToMake - the number of new unspents to make
     *
     * @param callback
     */
    Wallet.prototype.manageUnspents = function (routeName, params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var reqId, filteredParams, response, keychain, transactionParams, signedTransaction, selectParams, finalTxParams;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        common.validateParams(params, [], ['walletPassphrase', 'xprv'], callback);
                        reqId = new util_1.RequestTracer();
                        filteredParams = _.pick(params, [
                            'feeRate',
                            'maxFeeRate',
                            'maxFeePercentage',
                            'feeTxConfirmTarget',
                            'minValue',
                            'maxValue',
                            'minHeight',
                            'minConfirms',
                            'enforceMinConfirmsForChange',
                            routeName === 'consolidate' ? 'limit' : 'maxNumUnspentsToUse',
                            'numUnspentsToMake',
                        ]);
                        self.bitgo.setRequestTracer(reqId);
                        return [4 /*yield*/, self.bitgo.post(self.url("/" + routeName + "Unspents"))
                                .send(filteredParams)
                                .result()];
                    case 1:
                        response = _a.sent();
                        return [4 /*yield*/, self.baseCoin.keychains().get({ id: self._wallet.keys[0], reqId: reqId })];
                    case 2:
                        keychain = _a.sent();
                        transactionParams = _.extend({}, params, { txPrebuild: response, keychain: keychain });
                        return [4 /*yield*/, self.signTransaction(transactionParams)];
                    case 3:
                        signedTransaction = _a.sent();
                        selectParams = _.pick(params, ['comment', 'otp']);
                        finalTxParams = _.extend({}, signedTransaction, selectParams);
                        self.bitgo.setRequestTracer(reqId);
                        return [2 /*return*/, self.bitgo.post(self.baseCoin.url('/wallet/' + self._wallet.id + '/tx/send'))
                                .send(finalTxParams)
                                .result()];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Consolidate unspents on a wallet
     *
     * @param {Object} params - parameters object
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     * @param {Number} params.feeRate - The fee rate to use for the consolidation in satoshis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {Number} params.maxFeePercentage - the maximum relative portion that you're willing to spend towards fees
     * @param {Number} params.feeTxConfirmTarget - estimate the fees to aim for first confirmation with this number of blocks
     * @param {Number} params.minValue - the minimum value of unspents to use in satoshis
     * @param {Number} params.maxValue - the maximum value of unspents to use in satoshis
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - if true, minConfirms also applies to change outputs
     * @param {Number} params.limit                for routeName === 'consolidate'
     *                 params.maxNumUnspentsToUse  for routeName === 'fanout'
     *                  - maximum number of unspents you want to use in the transaction
     * @param {Number} params.numUnspentsToMake - the number of new unspents to make
     * @param callback
     */
    Wallet.prototype.consolidateUnspents = function (params, callback) {
        if (params === void 0) { params = {}; }
        return this.manageUnspents('consolidate', params, callback);
    };
    /**
     * Fanout unspents on a wallet
     *
     * @param {Object} params - parameters object
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     * @param {Number} params.minValue - the minimum value of unspents to use
     * @param {Number} params.maxValue - the maximum value of unspents to use
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Number} params.maxFeePercentage - the maximum proportion of an unspent you are willing to lose to fees
     * @param {Number} params.feeTxConfirmTarget - estimate the fees to aim for first confirmation with this number of blocks
     * @param {Number} params.feeRate - The desired fee rate for the transaction in satoshis/kB
     * @param {Number} params.maxFeeRate - The max limit for a fee rate in satoshis/kB
     * @param {Number} params.maxNumInputsToUse - the number of unspents you want to use in the transaction
     * @param {Number} params.numUnspentsToMake - the number of new unspents to make
     * @param callback
     */
    Wallet.prototype.fanoutUnspents = function (params, callback) {
        if (params === void 0) { params = {}; }
        return this.manageUnspents('fanout', params, callback);
    };
    /**
     * Set the token flush thresholds for the wallet. Updates the wallet.
     * Tokens will only be flushed from forwarder contracts if the balance is greater than the threshold defined here.
     * @param thresholds {Object} - pairs of { [tokenName]: threshold } (base units)
     * @param [callback]
     */
    Wallet.prototype.updateTokenFlushThresholds = function (thresholds, callback) {
        if (thresholds === void 0) { thresholds = {}; }
        var self = this;
        return co(function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (self.baseCoin.getFamily() !== 'eth') {
                            throw new Error('not supported for this wallet');
                        }
                        _a = self;
                        return [4 /*yield*/, self.bitgo.put(self.url()).send({
                                tokenFlushThresholds: thresholds
                            }).result()];
                    case 1:
                        _a._wallet = _b.sent();
                        return [2 /*return*/];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Sweep funds for a wallet
     *
     * @param {Object} params - parameters object
     * @param {String} params.address - The address to send all the funds in the wallet to
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     * @param {String} params.otp - Two factor auth code to enable sending the transaction
     * @param {Number} params.feeTxConfirmTarget - Estimate the fees to aim for first confirmation within this number of blocks
     * @param {Number} params.feeRate - The desired fee rate for the transaction in satoshis/kB
     * @param {Number} [params.maxFeeRate] - upper limit for feeRate in satoshis/kB
     * @param {Boolean} [params.allowPartialSweep] - allows sweeping 200 unspents when the wallet has more than that
     * @param [callback]
     * @returns txHex {String} the txHex of the signed transaction
     */
    Wallet.prototype.sweep = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var value, reqId, filteredParams, response, keychain, transactionParams, signedTransaction, selectParams, finalTxParams;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = params || {};
                        common.validateParams(params, ['address'], ['walletPassphrase', 'xprv', 'otp'], callback);
                        if (['eth', 'xrp'].includes(self.baseCoin.getFamily())) {
                            if (self.confirmedBalanceString() !== self.balanceString()) {
                                throw new Error('cannot sweep when unconfirmed funds exist on the wallet, please wait until all inbound transactions confirm');
                            }
                            value = self.spendableBalanceString();
                            if (_.isUndefined(value) || value === '0') {
                                throw new Error('no funds to sweep');
                            }
                            params.recipients = [{
                                    address: params.address,
                                    amount: value,
                                }];
                            return [2 /*return*/, self.sendMany(params)];
                        }
                        reqId = new util_1.RequestTracer();
                        filteredParams = _.pick(params, ['address', 'feeRate', 'maxFeeRate', 'feeTxConfirmTarget', 'allowPartialSweep']);
                        self.bitgo.setRequestTracer(reqId);
                        return [4 /*yield*/, self.bitgo.post(self.url('/sweepWallet'))
                                .send(filteredParams)
                                .result()];
                    case 1:
                        response = _a.sent();
                        return [4 /*yield*/, self.baseCoin.keychains().get({ id: self._wallet.keys[0], reqId: reqId })];
                    case 2:
                        keychain = _a.sent();
                        transactionParams = _.extend({}, params, { txPrebuild: response, keychain: keychain, prv: params.xprv });
                        return [4 /*yield*/, self.signTransaction(transactionParams)];
                    case 3:
                        signedTransaction = _a.sent();
                        selectParams = _.pick(params, ['otp']);
                        finalTxParams = _.extend({}, signedTransaction, selectParams);
                        self.bitgo.setRequestTracer(reqId);
                        return [2 /*return*/, self.bitgo.post(self.baseCoin.url('/wallet/' + self._wallet.id + '/tx/send'))
                                .send(finalTxParams)
                                .result()];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Freeze a given wallet
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.freeze = function (params, callback) {
        if (params === void 0) { params = {}; }
        params = params || {};
        common.validateParams(params, [], [], callback);
        if (params.duration) {
            if (!_.isNumber(params.duration)) {
                throw new Error('invalid duration: should be number of seconds');
            }
        }
        return this.bitgo.post(this.url('/freeze'))
            .result()
            .nodeify(callback);
    };
    /**
     * Update comment of a transfer
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.transferComment = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['id'], ['comment'], callback);
        return this.bitgo.post(this.baseCoin.url('/wallet/' + this._wallet.id + '/transfer/' + params.id + '/comment'))
            .send(params)
            .result()
            .nodeify(callback);
    };
    /**
     * List the addresses for a given wallet
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.addresses = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, [], [], callback);
        var query = {};
        if (params.mine) {
            query.mine = !!params.mine;
        }
        if (!_.isUndefined(params.prevId)) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            query.prevId = params.prevId;
        }
        if (params.sort) {
            if (!_.isNumber(params.sort)) {
                throw new Error('invalid sort argument, expecting number');
            }
            query.sort = params.sort;
        }
        if (params.limit) {
            if (!_.isNumber(params.limit)) {
                throw new Error('invalid limit argument, expecting number');
            }
            query.limit = params.limit;
        }
        if (params.labelContains) {
            if (!_.isString(params.labelContains)) {
                throw new Error('invalid labelContains argument, expecting string');
            }
            query.labelContains = params.labelContains;
        }
        if (!_.isUndefined(params.segwit)) {
            if (!_.isBoolean(params.segwit)) {
                throw new Error('invalid segwit argument, expecting boolean');
            }
            query.segwit = params.segwit;
        }
        if (!_.isUndefined(params.chains)) {
            if (!_.isArray(params.chains)) {
                throw new Error('invalid chains argument, expecting array of numbers');
            }
            query.chains = params.chains;
        }
        return this.bitgo.get(this.baseCoin.url('/wallet/' + this._wallet.id + '/addresses'))
            .query(query)
            .result()
            .nodeify(callback);
    };
    /**
     * Get a single wallet address by its id
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.getAddress = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, [], ['address', 'id'], callback);
        var query;
        if (_.isUndefined(params.address) && _.isUndefined(params.id)) {
            throw new Error('address or id of address required');
        }
        if (params.address) {
            query = params.address;
        }
        else {
            query = params.id;
        }
        if (params.reqId) {
            this.bitgo.setRequestTracer(params.reqId);
        }
        return this.bitgo.get(this.baseCoin.url("/wallet/" + this._wallet.id + "/address/" + encodeURIComponent(query)))
            .result()
            .nodeify(callback);
    };
    /**
     * Create one or more new address(es) for use with this wallet.
     *
     * If the `count` field is defined and greater than 1, an object with a single
     * array property named `addresses` containing `count` address objects
     * will be returned. Otherwise, a single address object is returned.
     *
     * @param params
     * @param {Number} params.chain on which the new address should be created
     * @param {(Number|String)} params.gasPrice gas price for new address creation, if applicable
     * @param {String} params.label label for the new address(es)
     * @param {Number} params.count=1 number of new addresses which should be created (maximum 250)
     * @param {Boolean} params.lowPriority Ethereum-specific param to create address using low priority fee address
     * @param callback
     */
    Wallet.prototype.createAddress = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var addressParams, reqId, chain, gasPrice, label, lowPriority, _a, count, keychains, rootAddress, newAddresses, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        addressParams = {};
                        reqId = new util_1.RequestTracer();
                        chain = params.chain, gasPrice = params.gasPrice, label = params.label, lowPriority = params.lowPriority, _a = params.count, count = _a === void 0 ? 1 : _a;
                        if (!_.isUndefined(chain)) {
                            if (!_.isInteger(chain)) {
                                throw new Error('chain has to be an integer');
                            }
                            addressParams.chain = chain;
                        }
                        if (!_.isUndefined(gasPrice)) {
                            if (!_.isInteger(gasPrice) && (isNaN(Number(gasPrice)) || !_.isString(gasPrice))) {
                                throw new Error('gasPrice has to be an integer or numeric string');
                            }
                            addressParams.gasPrice = gasPrice;
                        }
                        if (!_.isUndefined(label)) {
                            if (!_.isString(label)) {
                                throw new Error('label has to be a string');
                            }
                            addressParams.label = label;
                        }
                        if (!_.isInteger(count) || count <= 0 || count > 250) {
                            throw new Error('count has to be a number between 1 and 250');
                        }
                        if (!_.isUndefined(lowPriority)) {
                            if (!_.isBoolean(lowPriority)) {
                                throw new Error('lowPriority has to be a boolean');
                            }
                            addressParams.lowPriority = lowPriority;
                        }
                        return [4 /*yield*/, Bluebird.map(self._wallet.keys, function (k) { return self.baseCoin.keychains().get({ id: k, reqId: reqId }); })];
                    case 1:
                        keychains = _c.sent();
                        rootAddress = _.get(self._wallet, 'receiveAddress.address');
                        newAddresses = _.times(count, co(function createAndVerifyAddress() {
                            var newAddress, AbstractUtxoCoin_1, verificationData;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        self.bitgo.setRequestTracer(reqId);
                                        return [4 /*yield*/, self.bitgo.post(self.baseCoin.url('/wallet/' + self._wallet.id + '/address'))
                                                .send(addressParams)
                                                .result()];
                                    case 1:
                                        newAddress = _a.sent();
                                        // infer its address type
                                        if (_.isObject(newAddress.coinSpecific)) {
                                            AbstractUtxoCoin_1 = require('./coins/abstractUtxoCoin').AbstractUtxoCoin;
                                            newAddress.addressType = AbstractUtxoCoin_1.inferAddressType(newAddress);
                                        }
                                        newAddress.keychains = keychains;
                                        verificationData = _.merge({}, newAddress, { rootAddress: rootAddress });
                                        if (verificationData.error) {
                                            throw new errors_1.AddressGenerationError(verificationData.error);
                                        }
                                        self.baseCoin.verifyAddress(verificationData);
                                        return [2 /*return*/, newAddress];
                                }
                            });
                        }).bind(this));
                        if (newAddresses.length === 1) {
                            return [2 /*return*/, newAddresses[0]];
                        }
                        _b = {};
                        return [4 /*yield*/, Promise.all(newAddresses)];
                    case 2: return [2 /*return*/, (_b.addresses = _c.sent(),
                            _b)];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Update properties on an address
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.updateAddress = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var address, putParams, url;
            return __generator(this, function (_a) {
                address = params.address;
                if (!_.isString(address)) {
                    throw new Error('missing required string parameter address');
                }
                putParams = _.pick(params, ['label']);
                url = self.url('/address/' + encodeURIComponent(address));
                return [2 /*return*/, self.bitgo.put(url).send(putParams).result()];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * List webhooks on this wallet
     * @param params
     * @param callback
     */
    Wallet.prototype.listWebhooks = function (params, callback) {
        if (params === void 0) { params = {}; }
        var query = {};
        if (params.prevId) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            query.prevId = params.prevId;
        }
        if (params.limit) {
            if (!_.isNumber(params.limit)) {
                throw new Error('invalid limit argument, expecting number');
            }
            query.limit = params.limit;
        }
        return this.bitgo.get(this.url('/webhooks'))
            .query(query)
            .result()
            .nodeify(callback);
    };
    /**
     * Simulate wallet webhook, currently for webhooks of type transfer and pending approval
     * @param params
     * - webhookId (required) id of the webhook to be simulated
     * - transferId (optional but required for transfer webhooks) id of the simulated transfer
     * - pendingApprovalId (optional but required for pending approval webhooks) id of the simulated pending approval
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.simulateWebhook = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['webhookId'], ['transferId', 'pendingApprovalId'], callback);
        var hasTransferId = !!params.transferId;
        var hasPendingApprovalId = !!params.pendingApprovalId;
        if (!hasTransferId && !hasPendingApprovalId) {
            throw new Error('must supply either transferId or pendingApprovalId');
        }
        if (hasTransferId && hasPendingApprovalId) {
            throw new Error('must supply either transferId or pendingApprovalId, but not both');
        }
        // depending on the coin type of the wallet, the txHash has to adhere to its respective format
        // but the server takes care of that
        // only take the transferId and pendingApprovalId properties
        var filteredParams = _.pick(params, ['transferId', 'pendingApprovalId']);
        var webhookId = params.webhookId;
        return this.bitgo.post(this.url('/webhooks/' + webhookId + '/simulate'))
            .send(filteredParams)
            .result()
            .nodeify(callback);
    };
    /**
     * Add a webhook to this wallet
     * @param params
     * @param callback
     */
    Wallet.prototype.addWebhook = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['url', 'type'], [], callback);
        return this.bitgo.post(this.url('/webhooks'))
            .send(params)
            .result()
            .nodeify(callback);
    };
    /**
     * Remove a webhook from this wallet
     * @param params
     * @param callback
     */
    Wallet.prototype.removeWebhook = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['url', 'type'], [], callback);
        return this.bitgo.del(this.url('/webhooks'))
            .send(params)
            .result()
            .nodeify(callback);
    };
    /**
     * Gets the user key chain for this wallet
     *
     * The user key chain is the first keychain of the wallet and usually has the encrypted prv stored on BitGo.
     * Useful when trying to get the users' keychain from the server before decrypting to sign a transaction.
     * @param params
     * @param callback
     */
    Wallet.prototype.getEncryptedUserKeychain = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        var tryKeyChain = co(function (index) {
            var params, keychain;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!self._wallet.keys || index >= self._wallet.keys.length) {
                            throw new Error('No encrypted keychains on this wallet.');
                        }
                        params = { id: self._wallet.keys[index] };
                        return [4 /*yield*/, self.baseCoin.keychains().get(params)];
                    case 1:
                        keychain = _a.sent();
                        // If we find the prv, then this is probably the user keychain we're looking for
                        if (keychain.encryptedPrv) {
                            return [2 /*return*/, keychain];
                        }
                        return [2 /*return*/, tryKeyChain(index + 1)];
                }
            });
        }).bind(this);
        return tryKeyChain(0).nodeify(callback);
    };
    /**
     * Gets the unencrypted private key for this wallet (be careful!)
     * Requires wallet passphrase
     *
     * @param params
     * @param callback
     */
    Wallet.prototype.getPrv = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var userKeychain, userEncryptedPrv, userPrv;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        common.validateParams(params, [], ['walletPassphrase', 'prv'], callback);
                        // Prepare signing key
                        if (_.isUndefined(params.prv) && _.isUndefined(params.walletPassphrase)) {
                            throw new Error('must either provide prv or wallet passphrase');
                        }
                        if (!_.isUndefined(params.prv) && !_.isString(params.prv)) {
                            throw new Error('prv must be a string');
                        }
                        if (!_.isUndefined(params.walletPassphrase) && !_.isString(params.walletPassphrase)) {
                            throw new Error('walletPassphrase must be a string');
                        }
                        if (params.prv) {
                            return [2 /*return*/, params.prv];
                        }
                        return [4 /*yield*/, self.getEncryptedUserKeychain()];
                    case 1:
                        userKeychain = _a.sent();
                        userEncryptedPrv = userKeychain.encryptedPrv;
                        try {
                            userPrv = self.bitgo.decrypt({ input: userEncryptedPrv, password: params.walletPassphrase });
                        }
                        catch (e) {
                            throw new Error('error decrypting wallet passphrase');
                        }
                        return [2 /*return*/, userPrv];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Send an encrypted wallet share to BitGo.
     * @param params
     * @param callback
     */
    Wallet.prototype.createShare = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['user', 'permissions'], [], callback);
        if (params.keychain && !_.isEmpty(params.keychain)) {
            if (!params.keychain.pub || !params.keychain.encryptedPrv || !params.keychain.fromPubKey || !params.keychain.toPubKey || !params.keychain.path) {
                throw new Error('requires keychain parameters - pub, encryptedPrv, fromPubKey, toPubKey, path');
            }
        }
        return this.bitgo.post(this.url('/share'))
            .send(params)
            .result()
            .nodeify(callback);
    };
    /**
     * Share this wallet with another BitGo user.
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.shareWallet = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var needsKeychain, sharing, sharedKeychain, keychain, eckey, secret, newEncryptedPrv, e_1, options;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        common.validateParams(params, ['email', 'permissions'], ['walletPassphrase', 'message'], callback);
                        if (params.reshare !== undefined && !_.isBoolean(params.reshare)) {
                            throw new Error('Expected reshare to be a boolean.');
                        }
                        if (params.skipKeychain !== undefined && !_.isBoolean(params.skipKeychain)) {
                            throw new Error('Expected skipKeychain to be a boolean. ');
                        }
                        needsKeychain = !params.skipKeychain && params.permissions && params.permissions.indexOf('spend') !== -1;
                        if (params.disableEmail !== undefined && !_.isBoolean(params.disableEmail)) {
                            throw new Error('Expected disableEmail to be a boolean.');
                        }
                        if (!_.isString(params.email)) {
                            throw new Error('missing required string parameter email');
                        }
                        return [4 /*yield*/, self.bitgo.getSharingKey({ email: params.email.toLowerCase() })];
                    case 1:
                        sharing = _a.sent();
                        if (!needsKeychain) return [3 /*break*/, 5];
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, self.getEncryptedUserKeychain({})];
                    case 3:
                        keychain = _a.sent();
                        // Decrypt the user key with a passphrase
                        if (keychain.encryptedPrv) {
                            if (!params.walletPassphrase) {
                                throw new Error('Missing walletPassphrase argument');
                            }
                            try {
                                keychain.prv = self.bitgo.decrypt({ password: params.walletPassphrase, input: keychain.encryptedPrv });
                            }
                            catch (e) {
                                throw new Error('Unable to decrypt user keychain');
                            }
                            eckey = bitcoin_1.makeRandomKey();
                            secret = self.bitgo.getECDHSecret({ eckey: eckey, otherPubKeyHex: sharing.pubkey });
                            newEncryptedPrv = self.bitgo.encrypt({ password: secret, input: keychain.prv });
                            sharedKeychain = {
                                pub: keychain.pub,
                                encryptedPrv: newEncryptedPrv,
                                fromPubKey: eckey.getPublicKeyBuffer().toString('hex'),
                                toPubKey: sharing.pubkey,
                                path: sharing.path,
                            };
                        }
                        return [3 /*break*/, 5];
                    case 4:
                        e_1 = _a.sent();
                        if (e_1.message === 'No encrypted keychains on this wallet.') {
                            sharedKeychain = {};
                            // ignore this error because this looks like a cold wallet
                        }
                        else {
                            throw e_1;
                        }
                        return [3 /*break*/, 5];
                    case 5:
                        options = {
                            user: sharing.userId,
                            permissions: params.permissions,
                            reshare: params.reshare,
                            message: params.message,
                            disableEmail: params.disableEmail,
                        };
                        if (sharedKeychain) {
                            options.keychain = sharedKeychain;
                        }
                        else if (params.skipKeychain) {
                            options.keychain = {};
                        }
                        return [2 /*return*/, self.createShare(options)];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Remove user from wallet
     * @param params
     * - userId Id of the user to remove
     * @param callback
     * @return {*}
     */
    Wallet.prototype.removeUser = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['userId'], [], callback);
        var userId = params.userId;
        return this.bitgo.del(this.url('/user/' + userId))
            .result()
            .nodeify(callback);
    };
    /**
     * Fetch a transaction prebuild (unsigned transaction) from BitGo
     *
     * @param {Object} params
     * @param {{address: string, amount: string}} params.recipients - list of recipients and necessary recipient information
     * @param {Number} params.numBlocks - Estimates the approximate fee per kilobyte necessary for a transaction confirmation within numBlocks blocks
     * @param {Number} params.feeRate - the desired feeRate for the transaction in base units/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in base units/kB
     * @param {Number} params.minConfirms - Minimum number of confirmations unspents going into this transaction should have
     * @param {Boolean} params.enforceMinConfirmsForChange - Enforce minimum number of confirmations on change (internal) inputs.
     * @param {Number} params.targetWalletUnspents - The desired count of unspents in the wallet. If the wallets current unspent count is lower than the target, up to four additional change outputs will be added to the transaction.
     * @param {Number} params.minValue - Ignore unspents smaller than this amount of base units
     * @param {Number} params.maxValue - Ignore unspents larger than this amount of base units
     * @param {Number} params.sequenceId - The sequence ID of the transaction
     * @param {Number} params.lastLedgerSequence - Absolute max ledger the transaction should be accepted in, whereafter it will be rejected.
     * @param {String} params.ledgerSequenceDelta - Relative ledger height (in relation to the current ledger) that the transaction should be accepted in, whereafter it will be rejected.
     * @param {Number} params.gasPrice - Custom gas price to be used for sending the transaction
     * @param {Number} params.gasLimit - Custom gas limit to be used for sending the transaction
     * @param {Boolean} params.noSplitChange - Set to true to disable automatic change splitting for purposes of unspent management
     * @param {Array} params.unspents - The unspents to use in the transaction. Each unspent should be in the form prevTxId:nOutput
     * @param {String} params.changeAddress - Specifies the destination of the change output
     * @param {Number} params.validFromBlock - (Algorand) The minimum round this will run on
     * @param {Number} params.validToBlock - (Algorand) The maximum round this will run on
     * @param {Boolean} params.instant - Build this transaction to conform with instant sending coin-specific method (if available)
     * @param {{value: String, type: String}} params.memo - Memo to use in transaction (supported by Stellar)
     * @param {String} params.addressType - The type of address to create for change. One of `p2sh`, `p2shP2wsh`, and `p2wsh`. Case-sensitive.
     * @param {Boolean} params.hop - Build this as an Ethereum hop transaction
     * @param {Object} params.reservation - Object to reserve the unspents that this tx build uses. Format is reservation = { expireTime: ISODateString, pendingApprovalId: String }
     * @param {String} params.walletPassphrase The passphrase to the wallet user key, to sign commitment data for Ethereum hop transactions
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.prebuildTransaction = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var whitelistedParams, extraParams, queryParams, buildQuery, utxoCoin, blockHeightQuery, queries, _a, buildResponse, blockHeight, prebuild;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        whitelistedParams = _.pick(params, self.prebuildWhitelistedParams());
                        debug('prebuilding transaction: %O', whitelistedParams);
                        if (params.reqId) {
                            self.bitgo.setRequestTracer(params.reqId);
                        }
                        return [4 /*yield*/, self.baseCoin.getExtraPrebuildParams(Object.assign(params, { wallet: self }))];
                    case 1:
                        extraParams = _b.sent();
                        Object.assign(whitelistedParams, extraParams);
                        queryParams = {
                            offlineVerification: params.offlineVerification ? true : undefined,
                        };
                        buildQuery = self.bitgo.post(self.baseCoin.url('/wallet/' + self.id() + '/tx/build'))
                            .query(queryParams)
                            .send(whitelistedParams)
                            .result();
                        utxoCoin = self.baseCoin;
                        blockHeightQuery = _.isFunction(utxoCoin.getLatestBlockHeight) ?
                            utxoCoin.getLatestBlockHeight(params.reqId) :
                            Promise.resolve(undefined);
                        queries = [buildQuery, blockHeightQuery];
                        return [4 /*yield*/, Promise.all(queries)];
                    case 2:
                        _a = _b.sent(), buildResponse = _a[0], blockHeight = _a[1];
                        debug('postprocessing transaction prebuild: %O', buildResponse);
                        if (!_.isUndefined(blockHeight)) {
                            buildResponse.blockHeight = blockHeight;
                        }
                        return [4 /*yield*/, self.baseCoin.postProcessPrebuild(Object.assign(buildResponse, { wallet: self, buildParams: whitelistedParams }))];
                    case 3:
                        prebuild = _b.sent();
                        delete prebuild.wallet;
                        delete prebuild.buildParams;
                        prebuild = _.extend({}, prebuild, { walletId: self.id() });
                        debug('final transaction prebuild: %O', prebuild);
                        return [2 /*return*/, prebuild];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Sign a transaction
     * @param params
     * - txPrebuild
     * - [keychain / key] (object) or prv (string)
     * - walletPassphrase
     * @param callback
     * @return {*}
     */
    Wallet.prototype.signTransaction = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var txPrebuild, presign, userPrv, signingParams;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        txPrebuild = params.txPrebuild;
                        if (!txPrebuild || typeof txPrebuild !== 'object') {
                            throw new Error('txPrebuild must be an object');
                        }
                        return [4 /*yield*/, self.baseCoin.presignTransaction(params)];
                    case 1:
                        presign = _a.sent();
                        userPrv = self.getUserPrv(presign);
                        signingParams = _.extend({}, presign, { txPrebuild: txPrebuild, prv: userPrv });
                        return [2 /*return*/, self.baseCoin.signTransaction(signingParams)];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Get the user private key from either a derivation or an encrypted keychain
     * @param [params.keychain / params.key] (object) or params.prv (string)
     * @param params.walletPassphrase (string)
     */
    Wallet.prototype.getUserPrv = function (params) {
        if (params === void 0) { params = {}; }
        var userKeychain = params.keychain || params.key;
        var userPrv = params.prv;
        if (userPrv && typeof userPrv !== 'string') {
            throw new Error('prv must be a string');
        }
        if (userPrv && params.coldDerivationSeed) {
            // the derivation only makes sense when a key already exists
            var derivation = this.baseCoin.deriveKeyWithSeed({ key: userPrv, seed: params.coldDerivationSeed });
            userPrv = derivation.key;
        }
        else if (!userPrv) {
            if (!userKeychain || typeof userKeychain !== 'object') {
                throw new Error('keychain must be an object');
            }
            var userEncryptedPrv = userKeychain.encryptedPrv;
            if (!userEncryptedPrv) {
                throw new Error('keychain does not have property encryptedPrv');
            }
            if (!params.walletPassphrase) {
                throw new Error('walletPassphrase property missing');
            }
            userPrv = this.bitgo.decrypt({ input: userEncryptedPrv, password: params.walletPassphrase });
        }
        return userPrv;
    };
    /**
     * Get a transaction prebuild from BitGo, validate it, and then decrypt the user key and sign the transaction
     * @param params
     * @param callback
     */
    Wallet.prototype.prebuildAndSignTransaction = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var error, error, error, txPrebuildQuery, keychains, txPrebuild, verificationParams, e_2, signingParams, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (params.prebuildTx && params.recipients) {
                            error = new Error('Only one of prebuildTx and recipients may be specified');
                            error.code = 'both_prebuildtx_and_recipients_specified';
                            throw error;
                        }
                        if (params.recipients && !Array.isArray(params.recipients)) {
                            error = new Error('expecting recipients array');
                            error.code = 'recipients_not_array';
                            throw error;
                        }
                        if (_.isArray(self._permissions) && !self._permissions.includes('spend')) {
                            error = new Error('no spend permission on this wallet');
                            error.code = 'user_not_allowed_to_spend_from_wallet';
                            throw error;
                        }
                        txPrebuildQuery = params.prebuildTx ? Promise.resolve(params.prebuildTx) : self.prebuildTransaction(params);
                        return [4 /*yield*/, self.baseCoin.keychains().getKeysForSigning({ wallet: self, reqId: params.reqId })];
                    case 1:
                        keychains = _a.sent();
                        return [4 /*yield*/, txPrebuildQuery];
                    case 2:
                        txPrebuild = _a.sent();
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        verificationParams = _.pick(params.verification || {}, ['disableNetworking', 'keychains', 'addresses']);
                        return [4 /*yield*/, self.baseCoin.verifyTransaction({
                                txParams: params,
                                txPrebuild: txPrebuild,
                                wallet: self,
                                verification: verificationParams,
                                reqId: params.reqId,
                            })];
                    case 4:
                        _a.sent();
                        return [3 /*break*/, 6];
                    case 5:
                        e_2 = _a.sent();
                        debug('Transaction prebuild failure:', e_2);
                        console.error('transaction prebuild failed local validation:');
                        throw e_2;
                    case 6:
                        signingParams = _.extend({}, params, {
                            txPrebuild: txPrebuild,
                            wallet: {
                                // this is the version of the multisig address at wallet creation time
                                addressVersion: self._wallet.coinSpecific.addressVersion
                            },
                            keychain: keychains[0],
                            backupKeychain: (keychains.length > 1) ? keychains[1] : null,
                            bitgoKeychain: (keychains.length > 2) ? keychains[2] : null,
                        });
                        _a.label = 7;
                    case 7:
                        _a.trys.push([7, 9, , 10]);
                        return [4 /*yield*/, self.signTransaction(signingParams)];
                    case 8: return [2 /*return*/, _a.sent()];
                    case 9:
                        error_1 = _a.sent();
                        if (error_1.message.includes('insufficient funds')) {
                            error_1.code = 'insufficient_funds';
                            error_1.walletBalances = {
                                balanceString: self.balanceString(),
                                confirmedBalanceString: self.confirmedBalanceString(),
                                spendableBalanceString: self.spendableBalanceString(),
                                balance: self.balance(),
                                confirmedBalance: self.confirmedBalance(),
                                spendableBalance: self.spendableBalance()
                            };
                            error_1.txParams = _.omit(params, ['keychain', 'prv', 'passphrase', 'walletPassphrase', 'key']);
                        }
                        throw error_1;
                    case 10: return [2 /*return*/];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Accelerate a transaction's confirmation using Child-Pays-For-Parent (CPFP)
     * @param params
     * @param callback
     */
    Wallet.prototype.accelerateTransaction = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var error, error, error, error, error, submitParams, _a, _b, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        // TODO(BG-9349): change the last check to > 0 and the error message once platform allows multiple transactions to
                        //                be bumped in the same CPFP transaction
                        if (_.isUndefined(params.cpfpTxIds) || !Array.isArray(params.cpfpTxIds) || params.cpfpTxIds.length !== 1) {
                            error = new Error('expecting cpfpTxIds to be an array of length 1');
                            error.code = 'cpfptxids_not_array';
                            throw error;
                        }
                        if (_.isUndefined(params.cpfpFeeRate)) {
                            if (params.noCpfpFeeRate !== true) {
                                error = new Error('cpfpFeeRate must be set unless noCpfpFeeRate is set');
                                error.code = 'cpfpfeerate_not_set';
                                throw error;
                            }
                        }
                        else {
                            if (!_.isInteger(params.cpfpFeeRate) || params.cpfpFeeRate < 0) {
                                error = new Error('cpfpFeeRate must be a non-negative integer');
                                error.code = 'cpfpfeerate_not_nonnegative_integer';
                                throw error;
                            }
                        }
                        if (_.isUndefined(params.maxFee)) {
                            if (params.noMaxFee !== true) {
                                error = new Error('maxFee must be set unless noMaxFee is set');
                                error.code = 'maxfee_not_set';
                                throw error;
                            }
                        }
                        else {
                            if (!_.isInteger(params.maxFee) || params.maxFee < 0) {
                                error = new Error('maxFee must be a non-negative integer');
                                error.code = 'maxfee_not_nonnegative_integer';
                                throw error;
                            }
                        }
                        if (params.recipients !== undefined) {
                            if (!Array.isArray(params.recipients) || params.recipients.length !== 0) {
                                throw new Error("invalid value for 'recipients': must be empty array when set");
                            }
                        }
                        params.recipients = [];
                        _b = (_a = Object).assign;
                        _c = [params];
                        return [4 /*yield*/, self.prebuildAndSignTransaction(params)];
                    case 1:
                        submitParams = _b.apply(_a, _c.concat([_d.sent()]));
                        delete submitParams.wallet;
                        return [4 /*yield*/, self.submitTransaction(submitParams)];
                    case 2: return [2 /*return*/, _d.sent()];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Submit a half-signed transaction to BitGo
     * @param params
     * - txHex: transaction hex to submit
     * - halfSigned: object containing transaction (txHex or txBase64) to submit
     * @param callback
     */
    Wallet.prototype.submitTransaction = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, [], ['otp', 'txHex'], callback);
        var hasTxHex = !!params.txHex;
        var hasHalfSigned = !!params.halfSigned;
        if ((hasTxHex && hasHalfSigned) || (!hasTxHex && !hasHalfSigned)) {
            throw new Error('must supply either txHex or halfSigned, but not both');
        }
        return this.bitgo.post(this.baseCoin.url('/wallet/' + this.id() + '/tx/send'))
            .send(params)
            .result()
            .nodeify(callback);
    };
    /**
     * Send coins to a recipient
     * @param params
     * @param params.address - the destination address
     * @param params.amount - the amount in satoshis/wei/base value to be sent
     * @param params.message - optional message to attach to transaction
     * @param params.data - [Ethereum Specific] optional data to pass to transaction
     * @param params.walletPassphrase - the passphrase to be used to decrypt the user key on this wallet
     * @param params.prv - the private key in string form, if walletPassphrase is not available
     * @param params.minConfirms - the minimum confirmation threshold for inputs
     * @param params.enforceMinConfirmsForChange - whether to enforce minConfirms for change inputs
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.send = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['address'], ['message', 'data'], callback);
        if (_.isUndefined(params.amount)) {
            throw new Error('missing required parameter amount');
        }
        if (_.isUndefined(params.address)) {
            throw new Error('missing required parameter amount');
        }
        var coin = this.baseCoin;
        var amount = new bignumber_js_1.BigNumber(params.amount);
        if (amount.isNegative()) {
            throw new Error('invalid argument for amount - positive number greater than zero or numeric string expected');
        }
        if (!coin.valuelessTransferAllowed() && amount.isZero()) {
            throw new Error('invalid argument for amount - positive number greater than zero or numeric string expected');
        }
        var recipients = [{
                address: params.address,
                amount: params.amount,
            }];
        if (params.data && coin.transactionDataAllowed()) {
            recipients[0].data = params.data;
        }
        var sendManyOptions = Object.assign({}, params, { recipients: recipients });
        return this.sendMany(sendManyOptions).nodeify(callback);
    };
    /**
     * Send money to multiple recipients
     * 1. Gets the user keychain by checking the wallet for a key which has an encrypted prv
     * 2. Decrypts user key
     * 3. Creates the transaction with default fee
     * 4. Signs transaction with decrypted user key
     * 5. Sends the transaction to BitGo
     * @param {object} params
     * @param {{address: string, amount: string}} params.recipients - list of recipients and necessary recipient information
     * @param {Number} params.numBlocks - Estimates the approximate fee per kilobyte necessary for a transaction confirmation within numBlocks blocks
     * @param {Number} params.feeRate - the desired feeRate for the transaction in satothis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - Enforces minConfirms on change inputs
     * @param {Number} params.targetWalletUnspents - The desired count of unspents in the wallet
     * @param {String} params.message - optional message to attach to transaction
     * @param {Number} params.minValue - Ignore unspents smaller than this amount of satoshis
     * @param {Number} params.maxValue - Ignore unspents larger than this amount of satoshis
     * @param {Number} params.sequenceId - The sequence ID of the transaction
     * @param {Number} params.lastLedgerSequence - Absolute max ledger the transaction should be accepted in, whereafter it will be rejected.
     * @param {String} params.ledgerSequenceDelta - Relative ledger height (in relation to the current ledger) that the transaction should be accepted in, whereafter it will be rejected.
     * @param {Number} params.gasPrice - Custom gas price to be used for sending the transaction
     * @param {Boolean} params.noSplitChange - Set to true to disable automatic change splitting for purposes of unspent management
     * @param {Array} params.unspents - The unspents to use in the transaction. Each unspent should be in the form prevTxId:nOutput
     * @param {String} params.comment - Any additional comment to attach to the transaction
     * @param {String} params.otp - Two factor auth code to enable sending the transaction
     * @param {String} params.changeAddress - Specifies the destination of the change output
     * @param {Boolean} params.instant - Send this transaction using coin-specific instant sending method (if available)
     * @param {{value: String, type: String}} params.memo - Memo to use in transaction (supported by Stellar)
     * @param {String} params.type - Type of the transaction (e.g. trustline)
     * @param {{token: params, action: String, limit: String}[]} options.trustlines - Array of trustlines to manage (supported by Stellar)
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.sendMany = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var reqId, coin, halfSignedTransaction, selectParams, finalTxParams;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        common.validateParams(params, [], ['comment', 'otp'], callback);
                        debug('sendMany called');
                        reqId = params.reqId || new util_1.RequestTracer();
                        params.reqId = reqId;
                        coin = self.baseCoin;
                        if (_.isObject(params.recipients)) {
                            params.recipients.map(function (recipient) {
                                var amount = new bignumber_js_1.BigNumber(recipient.amount);
                                if (amount.isNegative()) {
                                    throw new Error('invalid argument for amount - positive number greater than zero or numeric string expected');
                                }
                                if (!coin.valuelessTransferAllowed() && amount.isZero()) {
                                    throw new Error('invalid argument for amount - positive number greater than zero or numeric string expected');
                                }
                            });
                        }
                        return [4 /*yield*/, self.prebuildAndSignTransaction(params)];
                    case 1:
                        halfSignedTransaction = _a.sent();
                        selectParams = _.pick(params, [
                            'recipients', 'numBlocks', 'feeRate', 'maxFeeRate', 'minConfirms',
                            'enforceMinConfirmsForChange', 'targetWalletUnspents',
                            'message', 'minValue', 'maxValue', 'sequenceId',
                            'lastLedgerSequence', 'ledgerSequenceDelta', 'gasPrice',
                            'noSplitChange', 'unspents', 'comment', 'otp', 'changeAddress',
                            'instant', 'memo', 'type', 'trustlines',
                        ]);
                        finalTxParams = _.extend({}, halfSignedTransaction, selectParams);
                        self.bitgo.setRequestTracer(reqId);
                        return [2 /*return*/, self.bitgo.post(self.url('/tx/send'))
                                .send(finalTxParams)
                                .result()];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Recover an unsupported token from a BitGo multisig wallet
     * params are validated in Eth.prototype.recoverToken
     * @param params
     * @param params.tokenContractAddress the contract address of the unsupported token
     * @param params.recipient the destination address recovered tokens should be sent to
     * @param params.walletPassphrase the wallet passphrase
     * @param params.prv the xprv
     * @param callback
     */
    Wallet.prototype.recoverToken = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var tokenContractAddress, recipient, recoverTokenOptions;
            return __generator(this, function (_a) {
                if (self.baseCoin.getFamily() !== 'eth') {
                    throw new Error('token recovery only supported for eth wallets');
                }
                tokenContractAddress = params.tokenContractAddress, recipient = params.recipient;
                if (_.isUndefined(tokenContractAddress)) {
                    throw new Error('missing required string parameter tokenContractAddress');
                }
                if (_.isUndefined(recipient)) {
                    throw new Error('missing required string parameter recipient');
                }
                recoverTokenOptions = Object.assign({ tokenContractAddress: tokenContractAddress, recipient: recipient }, params, { wallet: self });
                return [2 /*return*/, self.baseCoin.recoverToken(recoverTokenOptions)];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Get transaction metadata for the oldest transaction that is still pending or attempted
     * @param params
     * @param callback
     * @returns {Object} Object with txid, walletId, tx, and fee (if supported for coin)
     */
    Wallet.prototype.getFirstPendingTransaction = function (params, callback) {
        if (params === void 0) { params = {}; }
        return internal.getFirstPendingTransaction({ walletId: this.id() }, this.baseCoin, this.bitgo).asCallback(callback);
    };
    /**
     * Change the fee on the pending transaction that corresponds to the given txid to the given new fee
     * @param params
     * @param {String} params.txid The transaction Id corresponding to the transaction whose fee is to be changed
     * @param {String} params.fee The new fee to apply to the denoted transaction
     * @param callback
     * @returns {String} The transaction ID of the new transaction that contains the new fee rate
     */
    Wallet.prototype.changeFee = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                common.validateParams(params, ['txid', 'fee'], [], callback);
                return [2 /*return*/, self.bitgo.post(self.baseCoin.url('/wallet/' + self.id() + '/tx/changeFee'))
                        .send(params)
                        .result()];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Fetch info from merchant server
     * @param {Object} params The params passed into the function
     * @param {String} params.url The Url to retrieve info from
     * @param callback
     * @returns {Object} The info returned from the merchant server
     * @deprecated
     */
    Wallet.prototype.getPaymentInfo = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function coGetPaymentInfo() {
            return __generator(this, function (_a) {
                params = params || {};
                common.validateParams(params, ['url'], [], callback);
                return [2 /*return*/, self.bitgo.get(self.url('/paymentInfo'))
                        .query(params)
                        .result()];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Send json payment response
     * @param {Object} params The params passed into the function
     * @param {String} params.paymentUrl - The url to send the fully signed transaction to
     * @param {String} params.txHex - The transaction hex of the payment
     * @param {String} params.memo {String} - A memo supplied by the merchant, to be inserted into the transfer as the comment
     * @param {String} params.expires {String} - ISO Date format of when the payment request expires
     * @param callback
     * @returns {Object} The info returned from the merchant server Payment Ack
     * @deprecated
     */
    Wallet.prototype.sendPaymentResponse = function (params, callback) {
        if (params === void 0) { params = {}; }
        return this.bitgo.post(this.url('/sendPayment'))
            .send(params)
            .result()
            .asCallback(callback);
    };
    /**
     * Create a policy rule
     * @param params
     * @param params.condition condition object
     * @param params.action action object
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.createPolicyRule = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                common.validateParams(params, ['id', 'type'], ['message'], callback);
                if (!_.isObject(params.condition)) {
                    throw new Error('missing parameter: conditions object');
                }
                if (!_.isObject(params.action)) {
                    throw new Error('missing parameter: action object');
                }
                return [2 /*return*/, self.bitgo.post(self.url('/policy/rule'))
                        .send(params)
                        .result()];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Update a policy rule
     * @param params
     * @param params.condition condition object
     * @param params.action action object
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.setPolicyRule = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                common.validateParams(params, ['id', 'type'], ['message'], callback);
                if (!_.isObject(params.condition)) {
                    throw new Error('missing parameter: conditions object');
                }
                if (!_.isObject(params.action)) {
                    throw new Error('missing parameter: action object');
                }
                return [2 /*return*/, self.bitgo.put(self.url('/policy/rule'))
                        .send(params)
                        .result()];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Remove Policy Rule
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.removePolicyRule = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                common.validateParams(params, ['id'], ['message'], callback);
                return [2 /*return*/, self.bitgo.del(self.url('/policy/rule'))
                        .send(params)
                        .result()];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Remove this wallet
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.remove = function (params, callback) {
        if (params === void 0) { params = {}; }
        return this.bitgo.del(this.url()).result().asCallback(callback);
    };
    /**
     * Create a trading account from this wallet
     */
    Wallet.prototype.toTradingAccount = function () {
        if (this.baseCoin.getFamily() !== 'ofc') {
            throw new Error('Can only convert an Offchain (OFC) wallet to a trading account');
        }
        return new tradingAccount_1.TradingAccount(this._wallet.enterprise, this, this.bitgo);
    };
    /**
     * Creates and downloads PDF keycard for wallet (requires response from wallets.generateWallet)
     *
     * Note: this is example code and is not the version used on bitgo.com
     *
     * @param params
     *   * jsPDF - an instance of the jsPDF library
     *   * QRCode - an instance of the QRious library
     *   * userKeychain - a wallet's private user keychain
     *   * backupKeychain - a wallet's private backup keychain
     *   * bitgoKeychain - a wallet's private bitgo keychain
     *   * passphrase - the wallet passphrase
     *   * passcodeEncryptionCode - the encryption secret used for Box D
     *   * activationCode - a randomly generated six-digit activation code
     *   * walletKeyID - the Key ID used for deriving a cold wallet's signing key
     *   * backupKeyID - the Key ID used for deriving a cold wallet's backup key
     * @returns {*}
     */
    Wallet.prototype.downloadKeycard = function (params) {
        if (params === void 0) { params = {}; }
        if (!window || !window.location) {
            throw new Error('The downloadKeycard function is only callable within a browser.');
        }
        // Grab parameters with default for activationCode
        var jsPDF = params.jsPDF, QRCode = params.QRCode, userKeychain = params.userKeychain, backupKeychain = params.backupKeychain, bitgoKeychain = params.bitgoKeychain, passphrase = params.passphrase, passcodeEncryptionCode = params.passcodeEncryptionCode, walletKeyID = params.walletKeyID, backupKeyID = params.backupKeyID, _a = params.activationCode, activationCode = _a === void 0 ? Math.floor(Math.random() * 900000 + 100000).toString() : _a;
        if (!jsPDF || typeof jsPDF !== 'function') {
            throw new Error('Please pass in a valid jsPDF instance');
        }
        // Validate keychains
        if (!userKeychain || typeof userKeychain !== 'object') {
            throw new Error("Wallet keychain must have a 'user' property");
        }
        if (!backupKeychain || typeof backupKeychain !== 'object') {
            throw new Error('Backup keychain is required and must be an object');
        }
        if (!bitgoKeychain || typeof bitgoKeychain !== 'object') {
            throw new Error('Bitgo keychain is required and must be an object');
        }
        if (walletKeyID && typeof walletKeyID !== 'string') {
            throw new Error('walletKeyID must be a string');
        }
        if (backupKeyID && typeof backupKeyID !== 'string') {
            throw new Error('backupKeyID must be a string');
        }
        // Validate activation code if provided
        if (typeof activationCode !== 'string') {
            throw new Error('Activation Code must be a string');
        }
        if (activationCode.length !== 6) {
            throw new Error('Activation code must be six characters');
        }
        var coinShortName = this.baseCoin.type;
        var coinName = this.baseCoin.getFullName();
        var walletLabel = this._wallet.label;
        var doc = keycard_1.drawKeycard({
            jsPDF: jsPDF,
            QRCode: QRCode,
            encrypt: this.bitgo.encrypt,
            coinShortName: coinShortName,
            coinName: coinName,
            activationCode: activationCode,
            walletLabel: walletLabel,
            passphrase: passphrase,
            passcodeEncryptionCode: passcodeEncryptionCode,
            userKeychain: userKeychain,
            backupKeychain: backupKeychain,
            bitgoKeychain: bitgoKeychain,
            walletKeyID: walletKeyID,
            backupKeyID: backupKeyID,
        });
        // Save the PDF on the user's browser
        doc.save("BitGo Keycard for " + walletLabel + ".pdf");
    };
    /**
     * Builds a set of consolidation transactions for a wallet.
     * @param params
     *     fromAddresses - these are the on-chain receive addresses we want to pick a consolidation amount from
     * @param callback
     */
    Wallet.prototype.buildAccountConsolidations = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var whitelistedParams, buildResponse, consolidations, _i, buildResponse_1, consolidateAccountBuild, prebuild;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!self.baseCoin.allowsAccountConsolidations()) {
                            throw new Error(self.baseCoin.getFullName() + " does not allow account consolidations.");
                        }
                        whitelistedParams = _.pick(params, self.prebuildConsolidateTransactionParams());
                        debug('prebuilding consolidation transaction: %O', whitelistedParams);
                        if (params.reqId) {
                            self.bitgo.setRequestTracer(params.reqId);
                        }
                        return [4 /*yield*/, self.bitgo.post(self.baseCoin.url('/wallet/' + self.id() + '/consolidateAccount/build'))
                                .send(whitelistedParams)
                                .result()];
                    case 1:
                        buildResponse = _a.sent();
                        consolidations = [];
                        _i = 0, buildResponse_1 = buildResponse;
                        _a.label = 2;
                    case 2:
                        if (!(_i < buildResponse_1.length)) return [3 /*break*/, 5];
                        consolidateAccountBuild = buildResponse_1[_i];
                        return [4 /*yield*/, self.baseCoin.postProcessPrebuild(Object.assign(consolidateAccountBuild, { wallet: self, buildParams: whitelistedParams }))];
                    case 3:
                        prebuild = _a.sent();
                        delete prebuild.wallet;
                        delete prebuild.buildParams;
                        prebuild = _.extend({}, prebuild, { walletId: self.id() });
                        debug('final consolidation transaction prebuild: %O', prebuild);
                        consolidations.push(prebuild);
                        _a.label = 4;
                    case 4:
                        _i++;
                        return [3 /*break*/, 2];
                    case 5: return [2 /*return*/, consolidations];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Builds and sends a set of consolidation transactions for a wallet.
     * @param params
     *     fromAddresses - these are the on-chain receive addresses we want to pick a consolidation amount from
     */
    Wallet.prototype.sendAccountConsolidation = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var signedPrebuild;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!self.baseCoin.allowsAccountConsolidations()) {
                            throw new Error(self.baseCoin.getFullName() + " does not allow account consolidations.");
                        }
                        // one of a set of consolidation transactions
                        if (typeof params.prebuildTx === 'string' || params.prebuildTx === undefined) {
                            throw new Error('Invalid build of account consolidation.');
                        }
                        if (!params.prebuildTx.consolidateId) {
                            throw new Error('Failed to find consolidation id on consolidation transaction.');
                        }
                        return [4 /*yield*/, self.prebuildAndSignTransaction(params)];
                    case 1:
                        signedPrebuild = _a.sent();
                        // decorate with our consolidation id
                        signedPrebuild.consolidateId = params.prebuildTx.consolidateId;
                        delete signedPrebuild.wallet;
                        return [4 /*yield*/, self.submitTransaction(signedPrebuild)];
                    case 2: return [2 /*return*/, _a.sent()];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Builds and sends a set of account consolidations. This is intended to flush many balances to the root wallet balance.
     * @param params
     * @param callback
     */
    Wallet.prototype.sendAccountConsolidations = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var unsignedBuilds, successfulTxs, failedTxs, _i, unsignedBuilds_1, unsignedBuild, unsignedBuildWithOptions, sendTx, e_3;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!self.baseCoin.allowsAccountConsolidations()) {
                            throw new Error(self.baseCoin.getFullName() + " does not allow account consolidations.");
                        }
                        return [4 /*yield*/, self.buildAccountConsolidations(params)];
                    case 1:
                        unsignedBuilds = _a.sent();
                        if (!(unsignedBuilds && unsignedBuilds.length > 0)) return [3 /*break*/, 8];
                        successfulTxs = [];
                        failedTxs = new Array();
                        _i = 0, unsignedBuilds_1 = unsignedBuilds;
                        _a.label = 2;
                    case 2:
                        if (!(_i < unsignedBuilds_1.length)) return [3 /*break*/, 7];
                        unsignedBuild = unsignedBuilds_1[_i];
                        unsignedBuildWithOptions = Object.assign({}, params);
                        unsignedBuildWithOptions.prebuildTx = unsignedBuild;
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, self.sendAccountConsolidation(unsignedBuildWithOptions)];
                    case 4:
                        sendTx = _a.sent();
                        successfulTxs.push(sendTx);
                        return [3 /*break*/, 6];
                    case 5:
                        e_3 = _a.sent();
                        failedTxs.push(e_3);
                        return [3 /*break*/, 6];
                    case 6:
                        _i++;
                        return [3 /*break*/, 2];
                    case 7: return [2 /*return*/, {
                            success: successfulTxs,
                            failure: failedTxs,
                        }];
                    case 8: return [2 /*return*/];
                }
            });
        }).call(this).asCallback(callback);
    };
    return Wallet;
}());
exports.Wallet = Wallet;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2FsbGV0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3YyL3dhbGxldC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDZDQUF5QztBQUN6QyxtQ0FBcUM7QUFDckMsMEJBQTRCO0FBQzVCLGdDQUFrQztBQUVsQyxzQ0FBMkM7QUFFM0Msa0NBQW9DO0FBQ3BDLG9DQUFtRDtBQVFuRCw4Q0FBZ0Q7QUFDaEQsOENBQWlEO0FBRWpELDJEQUEwRDtBQUUxRCxxREFBeUU7QUFDekUsd0NBQWdEO0FBRWhELElBQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0FBQzFDLElBQU0sRUFBRSxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUM7QUFzWjlCO0lBTUUsZ0JBQVksS0FBWSxFQUFFLFFBQWtCLEVBQUUsVUFBZTtRQUMzRCxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixJQUFJLENBQUMsT0FBTyxHQUFHLFVBQVUsQ0FBQztRQUMxQixJQUFNLE1BQU0sR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxVQUFVLENBQUMsQ0FBQztRQUN4QyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDdEIsSUFBTSxXQUFXLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7WUFDL0QsSUFBSSxDQUFDLFlBQVksR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxhQUFhLENBQUMsQ0FBQztTQUN2RDtJQUNILENBQUM7SUFFRDs7O09BR0c7SUFDSCxvQkFBRyxHQUFILFVBQUksS0FBa0I7UUFBbEIsc0JBQUEsRUFBQSxVQUFrQjtRQUNwQixP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QUMsT0FBTyxDQUFDO1NBQ2hDO1FBRUQsSUFBSSxNQUFNLENBQUMsT0FBTyxFQUFFO1lBQ2xCLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsRUFBRTtnQkFDL0IsTUFBTSxJQUFJLEtBQUssQ0FBQyw0Q0FBNEMsQ0FBQyxDQUFDO2FBQy9EO1lBQ0QsS0FBSyxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDO1NBQ2hDO1FBRUQsSUFBSSxNQUFNLENBQUMsTUFBTSxFQUFFO1lBQ2pCLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDOUIsTUFBTSxJQUFJLEtBQUssQ0FBQywyQ0FBMkMsQ0FBQyxDQUFDO2FBQzlEO1lBQ0QsS0FBSyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO1NBQzlCO1FBRUQsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQzdCLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsRUFBRTtnQkFDaEMsTUFBTSxJQUFJLEtBQUssQ0FBQyw2Q0FBNkMsQ0FBQyxDQUFDO2FBQ2hFO1lBQ0QsS0FBSyxDQUFDLFFBQVEsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDO1NBQ2xDO1FBRUQsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQzVCLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsRUFBRTtnQkFDL0IsTUFBTSxJQUFJLEtBQUssQ0FBQyw0Q0FBNEMsQ0FBQyxDQUFDO2FBQy9EO1lBQ0QsS0FBSyxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDO1NBQ2hDO1FBRUQsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQy9CLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsRUFBRTtnQkFDbkMsTUFBTSxJQUFJLEtBQUssQ0FBQyxnREFBZ0QsQ0FBQyxDQUFDO2FBQ25FO1lBQ0QsS0FBSyxDQUFDLFVBQVUsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDO1NBQ3RDO1FBRUQsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQzFCLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFO2dCQUM3RCxNQUFNLElBQUksS0FBSyxDQUFDLG1EQUFtRCxDQUFDLENBQUM7YUFDdEU7WUFFRCxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFO2dCQUMvQixNQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFBLEtBQUs7b0JBQ3hCLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFO3dCQUN0QixNQUFNLElBQUksS0FBSyxDQUFDLDBEQUEwRCxDQUFDLENBQUM7cUJBQzdFO2dCQUNILENBQUMsQ0FBQyxDQUFDO2FBQ0o7WUFDRCxLQUFLLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUM7U0FDNUI7UUFFRCxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDekIsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUM1QixNQUFNLElBQUksS0FBSyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7YUFDNUQ7WUFDRCxLQUFLLENBQUMsSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUM7U0FDMUI7UUFFRCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUM7YUFDekMsS0FBSyxDQUFDLEtBQUssQ0FBQzthQUNaLE1BQU0sRUFBRTthQUNSLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILDRCQUFXLEdBQVgsVUFBWSxNQUErQixFQUFFLFFBQTRCO1FBQTdELHVCQUFBLEVBQUEsV0FBK0I7UUFDekMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFFcEQsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksR0FBRyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7YUFDdEQsTUFBTSxFQUFFO2FBQ1IsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3ZCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gscUNBQW9CLEdBQXBCLFVBQXFCLE1BQXdDLEVBQUUsUUFBNEI7UUFBdEUsdUJBQUEsRUFBQSxXQUF3QztRQUMzRCxNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxDQUFDLFlBQVksQ0FBQyxFQUFFLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUU1RCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsdUJBQXVCLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2FBQ3pFLE1BQU0sRUFBRTthQUNSLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7T0FnQkc7SUFDSCxpQ0FBZ0IsR0FBaEIsVUFBaUIsTUFBb0MsRUFBRSxRQUF5QztRQUEvRSx1QkFBQSxFQUFBLFdBQW9DO1FBQ25ELElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNsQixPQUFPLEVBQUUsQ0FBbUI7OztnQkFDcEIsY0FBYyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFO29CQUNwQyxVQUFVLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxRQUFRLEVBQUUsYUFBYSxFQUFFLE9BQU8sRUFBRSxhQUFhO29CQUNwRiw2QkFBNkIsRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLGtCQUFrQjtpQkFDM0UsQ0FBQyxDQUFDO2dCQUVILHNCQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsbUJBQW1CLENBQUMsQ0FBQzt5QkFDakQsS0FBSyxDQUFDLGNBQWMsQ0FBQzt5QkFDckIsTUFBTSxFQUFFLEVBQUM7O1NBQ2IsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gseUJBQVEsR0FBUixVQUFTLE1BQTRCLEVBQUUsUUFBNEI7UUFBMUQsdUJBQUEsRUFBQSxXQUE0QjtRQUNuQyxJQUFNLEtBQUssR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLFFBQVEsRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsYUFBYSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUVwSSxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUM7YUFDekMsS0FBSyxDQUFDLEtBQUssQ0FBQzthQUNaLE1BQU0sRUFBRTthQUNSLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQThCRztJQUNLLCtCQUFjLEdBQXRCLFVBQXVCLFNBQXlCLEVBQUUsTUFBK0QsRUFBRSxRQUE0QjtRQUE3Rix1QkFBQSxFQUFBLFdBQStEO1FBQy9HLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNsQixPQUFPLEVBQUUsQ0FBQzs7Ozs7d0JBQ1IsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxFQUFFLENBQUMsa0JBQWtCLEVBQUUsTUFBTSxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUM7d0JBRXBFLEtBQUssR0FBRyxJQUFJLG9CQUFhLEVBQUUsQ0FBQzt3QkFDNUIsY0FBYyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFOzRCQUNwQyxTQUFTOzRCQUNULFlBQVk7NEJBQ1osa0JBQWtCOzRCQUNsQixvQkFBb0I7NEJBRXBCLFVBQVU7NEJBQ1YsVUFBVTs0QkFDVixXQUFXOzRCQUNYLGFBQWE7NEJBQ2IsNkJBQTZCOzRCQUU3QixTQUFTLEtBQUssYUFBYSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLHFCQUFxQjs0QkFDN0QsbUJBQW1CO3lCQUNwQixDQUFDLENBQUM7d0JBQ0gsSUFBSSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQzt3QkFDbEIscUJBQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFJLFNBQVMsYUFBVSxDQUFDLENBQUM7aUNBQ3RFLElBQUksQ0FBQyxjQUFjLENBQUM7aUNBQ3BCLE1BQU0sRUFBRSxFQUFBOzt3QkFGTCxRQUFRLEdBQUcsU0FFTjt3QkFFTSxxQkFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLE9BQUEsRUFBRSxDQUFDLEVBQUE7O3dCQUFuRixRQUFRLEdBQUcsU0FBd0U7d0JBQ25GLGlCQUFpQixHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLE1BQU0sRUFBRSxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsUUFBUSxVQUFBLEVBQUUsQ0FBQyxDQUFDO3dCQUN6RCxxQkFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLGlCQUFpQixDQUFDLEVBQUE7O3dCQUFqRSxpQkFBaUIsR0FBRyxTQUE2Qzt3QkFDakUsWUFBWSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsU0FBUyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7d0JBQ2xELGFBQWEsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxpQkFBaUIsRUFBRSxZQUFZLENBQUMsQ0FBQzt3QkFFcEUsSUFBSSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQzt3QkFDbkMsc0JBQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBRSxHQUFHLFVBQVUsQ0FBQyxDQUFDO2lDQUNqRixJQUFJLENBQUMsYUFBYSxDQUFDO2lDQUNuQixNQUFNLEVBQUUsRUFBQzs7O1NBQ2IsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQW9CRztJQUNILG9DQUFtQixHQUFuQixVQUFvQixNQUF1QyxFQUFFLFFBQTRCO1FBQXJFLHVCQUFBLEVBQUEsV0FBdUM7UUFDekQsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLGFBQWEsRUFBRSxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDOUQsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7OztPQWlCRztJQUNILCtCQUFjLEdBQWQsVUFBZSxNQUFrQyxFQUFFLFFBQTRCO1FBQWhFLHVCQUFBLEVBQUEsV0FBa0M7UUFDL0MsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLFFBQVEsRUFBRSxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDekQsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsMkNBQTBCLEdBQTFCLFVBQTJCLFVBQW9CLEVBQUUsUUFBNEI7UUFBbEQsMkJBQUEsRUFBQSxlQUFvQjtRQUM3QyxJQUFNLElBQUksR0FBRyxJQUFJLENBQUM7UUFDbEIsT0FBTyxFQUFFLENBQUM7Ozs7O3dCQUNSLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsS0FBSyxLQUFLLEVBQUU7NEJBQ3ZDLE1BQU0sSUFBSSxLQUFLLENBQUMsK0JBQStCLENBQUMsQ0FBQzt5QkFDbEQ7d0JBRUQsS0FBQSxJQUFJLENBQUE7d0JBQVcscUJBQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDO2dDQUNuRCxvQkFBb0IsRUFBRSxVQUFVOzZCQUNqQyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUE7O3dCQUZYLEdBQUssT0FBTyxHQUFHLFNBRUosQ0FBQzs7OztTQUNiLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7T0FjRztJQUNILHNCQUFLLEdBQUwsVUFBTSxNQUF5QixFQUFFLFFBQTRCO1FBQXZELHVCQUFBLEVBQUEsV0FBeUI7UUFDN0IsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLE9BQU8sRUFBRSxDQUFDOzs7Ozt3QkFDUixNQUFNLEdBQUcsTUFBTSxJQUFJLEVBQUUsQ0FBQzt3QkFDdEIsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLGtCQUFrQixFQUFFLE1BQU0sRUFBRSxLQUFLLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQzt3QkFFMUYsSUFBSSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxFQUFFOzRCQUN0RCxJQUFJLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxLQUFLLElBQUksQ0FBQyxhQUFhLEVBQUUsRUFBRTtnQ0FDMUQsTUFBTSxJQUFJLEtBQUssQ0FBQyw2R0FBNkcsQ0FBQyxDQUFDOzZCQUNoSTs0QkFFSyxLQUFLLEdBQUcsSUFBSSxDQUFDLHNCQUFzQixFQUFFLENBQUM7NEJBQzVDLElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsSUFBSSxLQUFLLEtBQUssR0FBRyxFQUFFO2dDQUN6QyxNQUFNLElBQUksS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUM7NkJBQ3RDOzRCQUNBLE1BQWMsQ0FBQyxVQUFVLEdBQUcsQ0FBQztvQ0FDNUIsT0FBTyxFQUFFLE1BQU0sQ0FBQyxPQUFPO29DQUN2QixNQUFNLEVBQUUsS0FBSztpQ0FDZCxDQUFDLENBQUM7NEJBRUgsc0JBQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBQzt5QkFDOUI7d0JBR0ssS0FBSyxHQUFHLElBQUksb0JBQWEsRUFBRSxDQUFDO3dCQUM1QixjQUFjLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxTQUFTLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxvQkFBb0IsRUFBRSxtQkFBbUIsQ0FBQyxDQUFDLENBQUM7d0JBQ3ZILElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUM7d0JBQ2xCLHFCQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLENBQUM7aUNBQzdELElBQUksQ0FBQyxjQUFjLENBQUM7aUNBQ3BCLE1BQU0sRUFBRSxFQUFBOzt3QkFGTCxRQUFRLEdBQUcsU0FFTjt3QkFHTSxxQkFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLE9BQUEsRUFBRSxDQUFDLEVBQUE7O3dCQUFuRixRQUFRLEdBQUcsU0FBd0U7d0JBQ25GLGlCQUFpQixHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLE1BQU0sRUFBRSxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7d0JBQ3JGLHFCQUFNLElBQUksQ0FBQyxlQUFlLENBQUMsaUJBQWlCLENBQUMsRUFBQTs7d0JBQWpFLGlCQUFpQixHQUFHLFNBQTZDO3dCQUVqRSxZQUFZLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO3dCQUN2QyxhQUFhLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsaUJBQWlCLEVBQUUsWUFBWSxDQUFDLENBQUM7d0JBQ3BFLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUM7d0JBQ25DLHNCQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUUsR0FBRyxVQUFVLENBQUMsQ0FBQztpQ0FDakYsSUFBSSxDQUFDLGFBQWEsQ0FBQztpQ0FDbkIsTUFBTSxFQUFFLEVBQUM7OztTQUNiLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILHVCQUFNLEdBQU4sVUFBTyxNQUEwQixFQUFFLFFBQTRCO1FBQXhELHVCQUFBLEVBQUEsV0FBMEI7UUFDL0IsTUFBTSxHQUFHLE1BQU0sSUFBSSxFQUFFLENBQUM7UUFDdEIsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUVoRCxJQUFJLE1BQU0sQ0FBQyxRQUFRLEVBQUU7WUFDbkIsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxFQUFFO2dCQUNoQyxNQUFNLElBQUksS0FBSyxDQUFDLCtDQUErQyxDQUFDLENBQUM7YUFDbEU7U0FDRjtRQUVELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQzthQUN4QyxNQUFNLEVBQUU7YUFDUixPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsZ0NBQWUsR0FBZixVQUFnQixNQUFtQyxFQUFFLFFBQTRCO1FBQWpFLHVCQUFBLEVBQUEsV0FBbUM7UUFDakQsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBRTdELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBRSxHQUFHLFlBQVksR0FBRyxNQUFNLENBQUMsRUFBRSxHQUFHLFVBQVUsQ0FBQyxDQUFDO2FBQzVHLElBQUksQ0FBQyxNQUFNLENBQUM7YUFDWixNQUFNLEVBQUU7YUFDUixPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsMEJBQVMsR0FBVCxVQUFVLE1BQTZCLEVBQUUsUUFBNEI7UUFBM0QsdUJBQUEsRUFBQSxXQUE2QjtRQUNyQyxNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBRWhELElBQU0sS0FBSyxHQUFxQixFQUFFLENBQUM7UUFFbkMsSUFBSSxNQUFNLENBQUMsSUFBSSxFQUFFO1lBQ2YsS0FBSyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQztTQUM1QjtRQUVELElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUNqQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUU7Z0JBQzlCLE1BQU0sSUFBSSxLQUFLLENBQUMsMkNBQTJDLENBQUMsQ0FBQzthQUM5RDtZQUNELEtBQUssQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztTQUM5QjtRQUVELElBQUksTUFBTSxDQUFDLElBQUksRUFBRTtZQUNmLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDNUIsTUFBTSxJQUFJLEtBQUssQ0FBQyx5Q0FBeUMsQ0FBQyxDQUFDO2FBQzVEO1lBQ0QsS0FBSyxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDO1NBQzFCO1FBRUQsSUFBSSxNQUFNLENBQUMsS0FBSyxFQUFFO1lBQ2hCLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRTtnQkFDN0IsTUFBTSxJQUFJLEtBQUssQ0FBQywwQ0FBMEMsQ0FBQyxDQUFDO2FBQzdEO1lBQ0QsS0FBSyxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDO1NBQzVCO1FBRUQsSUFBSSxNQUFNLENBQUMsYUFBYSxFQUFFO1lBQ3hCLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsRUFBRTtnQkFDckMsTUFBTSxJQUFJLEtBQUssQ0FBQyxrREFBa0QsQ0FBQyxDQUFDO2FBQ3JFO1lBQ0QsS0FBSyxDQUFDLGFBQWEsR0FBRyxNQUFNLENBQUMsYUFBYSxDQUFDO1NBQzVDO1FBRUQsSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ2pDLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDL0IsTUFBTSxJQUFJLEtBQUssQ0FBQyw0Q0FBNEMsQ0FBQyxDQUFDO2FBQy9EO1lBQ0QsS0FBSyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO1NBQzlCO1FBRUQsSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ2pDLElBQUksQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDN0IsTUFBTSxJQUFJLEtBQUssQ0FBQyxxREFBcUQsQ0FBQyxDQUFDO2FBQ3hFO1lBQ0QsS0FBSyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO1NBQzlCO1FBRUQsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFLEdBQUcsWUFBWSxDQUFDLENBQUM7YUFDbEYsS0FBSyxDQUFDLEtBQUssQ0FBQzthQUNaLE1BQU0sRUFBRTthQUNSLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCwyQkFBVSxHQUFWLFVBQVcsTUFBOEIsRUFBRSxRQUE0QjtRQUE1RCx1QkFBQSxFQUFBLFdBQThCO1FBQ3ZDLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLEVBQUUsRUFBRSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUMvRCxJQUFJLEtBQUssQ0FBQztRQUNWLElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUU7WUFDN0QsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDO1NBQ3REO1FBQ0QsSUFBSSxNQUFNLENBQUMsT0FBTyxFQUFFO1lBQ2xCLEtBQUssR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDO1NBQ3hCO2FBQU07WUFDTCxLQUFLLEdBQUcsTUFBTSxDQUFDLEVBQUUsQ0FBQztTQUNuQjtRQUVELElBQUksTUFBTSxDQUFDLEtBQUssRUFBRTtZQUNoQixJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUMzQztRQUVELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsYUFBVyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUUsaUJBQVksa0JBQWtCLENBQUMsS0FBSyxDQUFHLENBQUMsQ0FBQzthQUN4RyxNQUFNLEVBQUU7YUFDUixPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7OztPQWNHO0lBQ0gsOEJBQWEsR0FBYixVQUFjLE1BQWlDLEVBQUUsUUFBNEI7UUFBL0QsdUJBQUEsRUFBQSxXQUFpQztRQUM3QyxJQUFNLElBQUksR0FBRyxJQUFJLENBQUM7UUFDbEIsT0FBTyxFQUFFLENBQUM7Ozs7O3dCQUNGLGFBQWEsR0FBeUIsRUFBRSxDQUFDO3dCQUN6QyxLQUFLLEdBQUcsSUFBSSxvQkFBYSxFQUFFLENBQUM7d0JBR2hDLEtBQUssR0FLSCxNQUFNLE1BTEgsRUFDTCxRQUFRLEdBSU4sTUFBTSxTQUpBLEVBQ1IsS0FBSyxHQUdILE1BQU0sTUFISCxFQUNMLFdBQVcsR0FFVCxNQUFNLFlBRkcsRUFDWCxLQUNFLE1BQU0sTUFEQyxFQUFULEtBQUssbUJBQUcsQ0FBQyxLQUFBLENBQ0E7d0JBRVgsSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLEVBQUU7NEJBQ3pCLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxFQUFFO2dDQUN2QixNQUFNLElBQUksS0FBSyxDQUFDLDRCQUE0QixDQUFDLENBQUM7NkJBQy9DOzRCQUNELGFBQWEsQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO3lCQUM3Qjt3QkFFRCxJQUFJLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsRUFBRTs0QkFDNUIsSUFBSSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUU7Z0NBQ2hGLE1BQU0sSUFBSSxLQUFLLENBQUMsaURBQWlELENBQUMsQ0FBQzs2QkFDcEU7NEJBQ0QsYUFBYSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7eUJBQ25DO3dCQUVELElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxFQUFFOzRCQUN6QixJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRTtnQ0FDdEIsTUFBTSxJQUFJLEtBQUssQ0FBQywwQkFBMEIsQ0FBQyxDQUFDOzZCQUM3Qzs0QkFDRCxhQUFhLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQzt5QkFDN0I7d0JBRUQsSUFBSSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxJQUFJLENBQUMsSUFBSSxLQUFLLEdBQUcsR0FBRyxFQUFFOzRCQUNwRCxNQUFNLElBQUksS0FBSyxDQUFDLDRDQUE0QyxDQUFDLENBQUM7eUJBQy9EO3dCQUVELElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxFQUFFOzRCQUMvQixJQUFJLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsRUFBRTtnQ0FDN0IsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDOzZCQUNwRDs0QkFDRCxhQUFhLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQzt5QkFDekM7d0JBR2lCLHFCQUFNLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFnQixFQUNoRSxVQUFBLENBQUMsSUFBSSxPQUFBLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxLQUFLLE9BQUEsRUFBRSxDQUFDLEVBQS9DLENBQStDLENBQ3JELEVBQUE7O3dCQUZLLFNBQVMsR0FBRyxTQUVqQjt3QkFDSyxXQUFXLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLHdCQUF3QixDQUFDLENBQUM7d0JBRTVELFlBQVksR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsU0FBVSxzQkFBc0I7Ozs7O3dDQUNyRSxJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxDQUFDO3dDQUNoQixxQkFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFLEdBQUcsVUFBVSxDQUFDLENBQUM7aURBQ25HLElBQUksQ0FBQyxhQUFhLENBQUM7aURBQ25CLE1BQU0sRUFBRSxFQUFBOzt3Q0FGTCxVQUFVLEdBQUcsU0FFUjt3Q0FFWCx5QkFBeUI7d0NBQ3pCLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLEVBQUU7NENBRS9CLHFCQUFxQixPQUFPLENBQUMsMEJBQTBCLENBQUMsaUJBQXhDLENBQXlDOzRDQUNqRSxVQUFVLENBQUMsV0FBVyxHQUFHLGtCQUFnQixDQUFDLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxDQUFDO3lDQUN4RTt3Q0FFRCxVQUFVLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQzt3Q0FDM0IsZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsVUFBVSxFQUFFLEVBQUUsV0FBVyxhQUFBLEVBQUUsQ0FBQyxDQUFDO3dDQUVsRSxJQUFJLGdCQUFnQixDQUFDLEtBQUssRUFBRTs0Q0FDMUIsTUFBTSxJQUFJLCtCQUFzQixDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxDQUFDO3lDQUMxRDt3Q0FFRCxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO3dDQUU5QyxzQkFBTyxVQUFVLEVBQUM7Ozt5QkFDbkIsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO3dCQUVmLElBQUksWUFBWSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7NEJBQzdCLHNCQUFPLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFBQzt5QkFDeEI7O3dCQUdZLHFCQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLEVBQUE7NEJBRDVDLHVCQUNFLFlBQVMsR0FBRSxTQUErQjtpQ0FDMUM7OztTQUNILENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILDhCQUFhLEdBQWIsVUFBYyxNQUFpQyxFQUFFLFFBQTRCO1FBQS9ELHVCQUFBLEVBQUEsV0FBaUM7UUFDN0MsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLE9BQU8sRUFBRSxDQUFDOzs7Z0JBQ0YsT0FBTyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUM7Z0JBRS9CLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFO29CQUN4QixNQUFNLElBQUksS0FBSyxDQUFDLDJDQUEyQyxDQUFDLENBQUM7aUJBQzlEO2dCQUVLLFNBQVMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7Z0JBQ3RDLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsR0FBRyxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO2dCQUVoRSxzQkFBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUM7O1NBQ3JELENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsNkJBQVksR0FBWixVQUFhLE1BQThCLEVBQUUsUUFBNEI7UUFBNUQsdUJBQUEsRUFBQSxXQUE4QjtRQUN6QyxJQUFNLEtBQUssR0FBc0IsRUFBRSxDQUFDO1FBQ3BDLElBQUksTUFBTSxDQUFDLE1BQU0sRUFBRTtZQUNqQixJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUU7Z0JBQzlCLE1BQU0sSUFBSSxLQUFLLENBQUMsMkNBQTJDLENBQUMsQ0FBQzthQUM5RDtZQUNELEtBQUssQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztTQUM5QjtRQUVELElBQUksTUFBTSxDQUFDLEtBQUssRUFBRTtZQUNoQixJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUU7Z0JBQzdCLE1BQU0sSUFBSSxLQUFLLENBQUMsMENBQTBDLENBQUMsQ0FBQzthQUM3RDtZQUNELEtBQUssQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQztTQUM1QjtRQUVELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQzthQUN6QyxLQUFLLENBQUMsS0FBSyxDQUFDO2FBQ1osTUFBTSxFQUFFO2FBQ1IsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3ZCLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNILGdDQUFlLEdBQWYsVUFBZ0IsTUFBbUMsRUFBRSxRQUE0QjtRQUFqRSx1QkFBQSxFQUFBLFdBQW1DO1FBQ2pELE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxZQUFZLEVBQUUsbUJBQW1CLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUU1RixJQUFNLGFBQWEsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQztRQUMxQyxJQUFNLG9CQUFvQixHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsaUJBQWlCLENBQUM7UUFDeEQsSUFBSSxDQUFDLGFBQWEsSUFBSSxDQUFDLG9CQUFvQixFQUFFO1lBQzNDLE1BQU0sSUFBSSxLQUFLLENBQUMsb0RBQW9ELENBQUMsQ0FBQztTQUN2RTtRQUVELElBQUksYUFBYSxJQUFJLG9CQUFvQixFQUFFO1lBQ3pDLE1BQU0sSUFBSSxLQUFLLENBQUMsa0VBQWtFLENBQUMsQ0FBQztTQUNyRjtRQUVELDhGQUE4RjtRQUM5RixvQ0FBb0M7UUFFcEMsNERBQTREO1FBQzVELElBQU0sY0FBYyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsWUFBWSxFQUFFLG1CQUFtQixDQUFDLENBQUMsQ0FBQztRQUUzRSxJQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDO1FBQ25DLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLEdBQUcsU0FBUyxHQUFHLFdBQVcsQ0FBQyxDQUFDO2FBQ3JFLElBQUksQ0FBQyxjQUFjLENBQUM7YUFDcEIsTUFBTSxFQUFFO2FBQ1IsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3ZCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsMkJBQVUsR0FBVixVQUFXLE1BQWlDLEVBQUUsUUFBNEI7UUFBL0QsdUJBQUEsRUFBQSxXQUFpQztRQUMxQyxNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsRUFBRSxFQUFFLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFFN0QsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDO2FBQzFDLElBQUksQ0FBQyxNQUFNLENBQUM7YUFDWixNQUFNLEVBQUU7YUFDUixPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCw4QkFBYSxHQUFiLFVBQWMsTUFBaUMsRUFBRSxRQUE0QjtRQUEvRCx1QkFBQSxFQUFBLFdBQWlDO1FBQzdDLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxFQUFFLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUU3RCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUM7YUFDekMsSUFBSSxDQUFDLE1BQU0sQ0FBQzthQUNaLE1BQU0sRUFBRTthQUNSLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILHlDQUF3QixHQUF4QixVQUF5QixNQUFlLEVBQUUsUUFBNEI7UUFBN0MsdUJBQUEsRUFBQSxXQUFlO1FBQ3RDLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNsQixJQUFNLFdBQVcsR0FBRyxFQUFFLENBQUMsVUFBVyxLQUFhOzs7Ozt3QkFDN0MsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxJQUFJLEtBQUssSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUU7NEJBQzNELE1BQU0sSUFBSSxLQUFLLENBQUMsd0NBQXdDLENBQUMsQ0FBQzt5QkFDM0Q7d0JBRUssTUFBTSxHQUFHLEVBQUUsRUFBRSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUM7d0JBRS9CLHFCQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFBOzt3QkFBdEQsUUFBUSxHQUFHLFNBQTJDO3dCQUM1RCxnRkFBZ0Y7d0JBQ2hGLElBQUksUUFBUSxDQUFDLFlBQVksRUFBRTs0QkFDekIsc0JBQU8sUUFBUSxFQUFDO3lCQUNqQjt3QkFDRCxzQkFBTyxXQUFXLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxFQUFDOzs7U0FDL0IsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUVkLE9BQU8sV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsdUJBQU0sR0FBTixVQUFPLE1BQTBCLEVBQUUsUUFBNEI7UUFBeEQsdUJBQUEsRUFBQSxXQUEwQjtRQUMvQixJQUFNLElBQUksR0FBRyxJQUFJLENBQUM7UUFDbEIsT0FBTyxFQUFFLENBQUM7Ozs7O3dCQUNSLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLEVBQUUsRUFBRSxDQUFDLGtCQUFrQixFQUFFLEtBQUssQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDO3dCQUV6RSxzQkFBc0I7d0JBQ3RCLElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsRUFBRTs0QkFDdkUsTUFBTSxJQUFJLEtBQUssQ0FBQyw4Q0FBOEMsQ0FBQyxDQUFDO3lCQUNqRTt3QkFFRCxJQUFJLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFBRTs0QkFDekQsTUFBTSxJQUFJLEtBQUssQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO3lCQUN6Qzt3QkFFRCxJQUFJLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLEVBQUU7NEJBQ25GLE1BQU0sSUFBSSxLQUFLLENBQUMsbUNBQW1DLENBQUMsQ0FBQzt5QkFDdEQ7d0JBRUQsSUFBSSxNQUFNLENBQUMsR0FBRyxFQUFFOzRCQUNkLHNCQUFPLE1BQU0sQ0FBQyxHQUFHLEVBQUM7eUJBQ25CO3dCQUVvQixxQkFBTSxJQUFJLENBQUMsd0JBQXdCLEVBQUUsRUFBQTs7d0JBQXBELFlBQVksR0FBRyxTQUFxQzt3QkFDcEQsZ0JBQWdCLEdBQUcsWUFBWSxDQUFDLFlBQVksQ0FBQzt3QkFHbkQsSUFBSTs0QkFDRixPQUFPLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsRUFBRSxLQUFLLEVBQUUsZ0JBQWdCLEVBQUUsUUFBUSxFQUFFLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLENBQUM7eUJBQzlGO3dCQUFDLE9BQU8sQ0FBQyxFQUFFOzRCQUNWLE1BQU0sSUFBSSxLQUFLLENBQUMsb0NBQW9DLENBQUMsQ0FBQzt5QkFDdkQ7d0JBRUQsc0JBQU8sT0FBTyxFQUFDOzs7U0FDaEIsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCw0QkFBVyxHQUFYLFVBQVksTUFBK0IsRUFBRSxRQUE0QjtRQUE3RCx1QkFBQSxFQUFBLFdBQStCO1FBQ3pDLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLENBQUMsTUFBTSxFQUFFLGFBQWEsQ0FBQyxFQUFFLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUVyRSxJQUFJLE1BQU0sQ0FBQyxRQUFRLElBQUksQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUNsRCxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLFlBQVksSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsVUFBVSxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxRQUFRLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRTtnQkFDOUksTUFBTSxJQUFJLEtBQUssQ0FBQyw4RUFBOEUsQ0FBQyxDQUFDO2FBQ2pHO1NBQ0Y7UUFFRCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7YUFDdkMsSUFBSSxDQUFDLE1BQU0sQ0FBQzthQUNaLE1BQU0sRUFBRTthQUNSLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCw0QkFBVyxHQUFYLFVBQVksTUFBK0IsRUFBRSxRQUE0QjtRQUE3RCx1QkFBQSxFQUFBLFdBQStCO1FBQ3pDLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNsQixPQUFPLEVBQUUsQ0FBQzs7Ozs7d0JBQ1IsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxPQUFPLEVBQUUsYUFBYSxDQUFDLEVBQUUsQ0FBQyxrQkFBa0IsRUFBRSxTQUFTLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQzt3QkFFbkcsSUFBSSxNQUFNLENBQUMsT0FBTyxLQUFLLFNBQVMsSUFBSSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxFQUFFOzRCQUNoRSxNQUFNLElBQUksS0FBSyxDQUFDLG1DQUFtQyxDQUFDLENBQUM7eUJBQ3REO3dCQUVELElBQUksTUFBTSxDQUFDLFlBQVksS0FBSyxTQUFTLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsRUFBRTs0QkFDMUUsTUFBTSxJQUFJLEtBQUssQ0FBQyx5Q0FBeUMsQ0FBQyxDQUFDO3lCQUM1RDt3QkFDSyxhQUFhLEdBQUcsQ0FBQyxNQUFNLENBQUMsWUFBWSxJQUFJLE1BQU0sQ0FBQyxXQUFXLElBQUksTUFBTSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7d0JBRS9HLElBQUksTUFBTSxDQUFDLFlBQVksS0FBSyxTQUFTLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsRUFBRTs0QkFDMUUsTUFBTSxJQUFJLEtBQUssQ0FBQyx3Q0FBd0MsQ0FBQyxDQUFDO3lCQUMzRDt3QkFFRCxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUU7NEJBQzdCLE1BQU0sSUFBSSxLQUFLLENBQUMseUNBQXlDLENBQUMsQ0FBQzt5QkFDNUQ7d0JBRWUscUJBQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsRUFBRSxDQUFDLEVBQUE7O3dCQUEvRSxPQUFPLEdBQUcsU0FBcUU7NkJBRWpGLGFBQWEsRUFBYix3QkFBYTs7Ozt3QkFFSSxxQkFBTSxJQUFJLENBQUMsd0JBQXdCLENBQUMsRUFBRSxDQUFDLEVBQUE7O3dCQUFsRCxRQUFRLEdBQUcsU0FBdUM7d0JBQ3hELHlDQUF5Qzt3QkFDekMsSUFBSSxRQUFRLENBQUMsWUFBWSxFQUFFOzRCQUN6QixJQUFJLENBQUMsTUFBTSxDQUFDLGdCQUFnQixFQUFFO2dDQUM1QixNQUFNLElBQUksS0FBSyxDQUFDLG1DQUFtQyxDQUFDLENBQUM7NkJBQ3REOzRCQUNELElBQUk7Z0NBQ0YsUUFBUSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxFQUFFLFFBQVEsRUFBRSxNQUFNLENBQUMsZ0JBQWdCLEVBQUUsS0FBSyxFQUFFLFFBQVEsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDOzZCQUN4Rzs0QkFBQyxPQUFPLENBQUMsRUFBRTtnQ0FDVixNQUFNLElBQUksS0FBSyxDQUFDLGlDQUFpQyxDQUFDLENBQUM7NkJBQ3BEOzRCQUVLLEtBQUssR0FBRyx1QkFBYSxFQUFFLENBQUM7NEJBQ3hCLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsY0FBYyxFQUFFLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDOzRCQUNwRixlQUFlLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQzs0QkFFdEYsY0FBYyxHQUFHO2dDQUNmLEdBQUcsRUFBRSxRQUFRLENBQUMsR0FBRztnQ0FDakIsWUFBWSxFQUFFLGVBQWU7Z0NBQzdCLFVBQVUsRUFBRSxLQUFLLENBQUMsa0JBQWtCLEVBQUUsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDO2dDQUN0RCxRQUFRLEVBQUUsT0FBTyxDQUFDLE1BQU07Z0NBQ3hCLElBQUksRUFBRSxPQUFPLENBQUMsSUFBSTs2QkFDbkIsQ0FBQzt5QkFDSDs7Ozt3QkFFRCxJQUFJLEdBQUMsQ0FBQyxPQUFPLEtBQUssd0NBQXdDLEVBQUU7NEJBQzFELGNBQWMsR0FBRyxFQUFFLENBQUM7NEJBQ3BCLDBEQUEwRDt5QkFDM0Q7NkJBQU07NEJBQ0wsTUFBTSxHQUFDLENBQUM7eUJBQ1Q7Ozt3QkFJQyxPQUFPLEdBQXVCOzRCQUNsQyxJQUFJLEVBQUUsT0FBTyxDQUFDLE1BQU07NEJBQ3BCLFdBQVcsRUFBRSxNQUFNLENBQUMsV0FBVzs0QkFDL0IsT0FBTyxFQUFFLE1BQU0sQ0FBQyxPQUFPOzRCQUN2QixPQUFPLEVBQUUsTUFBTSxDQUFDLE9BQU87NEJBQ3ZCLFlBQVksRUFBRSxNQUFNLENBQUMsWUFBWTt5QkFDbEMsQ0FBQzt3QkFFRixJQUFJLGNBQWMsRUFBRTs0QkFDbEIsT0FBTyxDQUFDLFFBQVEsR0FBRyxjQUFjLENBQUM7eUJBQ25DOzZCQUFNLElBQUksTUFBTSxDQUFDLFlBQVksRUFBRTs0QkFDOUIsT0FBTyxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7eUJBQ3ZCO3dCQUVELHNCQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLEVBQUM7OztTQUNsQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsMkJBQVUsR0FBVixVQUFXLE1BQThCLEVBQUUsUUFBNEI7UUFBNUQsdUJBQUEsRUFBQSxXQUE4QjtRQUN2QyxNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxDQUFDLFFBQVEsQ0FBQyxFQUFFLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUV4RCxJQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO1FBQzdCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEdBQUcsTUFBTSxDQUFDLENBQUM7YUFDL0MsTUFBTSxFQUFFO2FBQ1IsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3ZCLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQStCRztJQUNILG9DQUFtQixHQUFuQixVQUFvQixNQUF1QyxFQUFFLFFBQWtEO1FBQTNGLHVCQUFBLEVBQUEsV0FBdUM7UUFDekQsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLE9BQU8sRUFBRSxDQUE0Qjs7Ozs7d0JBRTdCLGlCQUFpQixHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyx5QkFBeUIsRUFBRSxDQUFDLENBQUM7d0JBQzNFLEtBQUssQ0FBQyw2QkFBNkIsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO3dCQUV4RCxJQUFJLE1BQU0sQ0FBQyxLQUFLLEVBQUU7NEJBQ2hCLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO3lCQUMzQzt3QkFDbUIscUJBQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxzQkFBc0IsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQUE7O3dCQUFqRyxXQUFXLEdBQUcsU0FBbUY7d0JBQ3ZHLE1BQU0sQ0FBQyxNQUFNLENBQUMsaUJBQWlCLEVBQUUsV0FBVyxDQUFDLENBQUM7d0JBQ3hDLFdBQVcsR0FBRzs0QkFDbEIsbUJBQW1CLEVBQUUsTUFBTSxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFNBQVM7eUJBQ25FLENBQUM7d0JBRUksVUFBVSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUcsV0FBVyxDQUFDLENBQUM7NkJBQ3hGLEtBQUssQ0FBQyxXQUFXLENBQUM7NkJBQ2xCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQzs2QkFDdkIsTUFBTSxFQUFFLENBQUM7d0JBQ04sUUFBUSxHQUFHLElBQUksQ0FBQyxRQUE0QixDQUFDO3dCQUM3QyxnQkFBZ0IsR0FBRyxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLENBQUM7NEJBQ3BFLFFBQVEsQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQzs0QkFDN0MsT0FBTyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQzt3QkFDdkIsT0FBTyxHQUFHLENBQUMsVUFBVSxFQUFFLGdCQUFnQixDQUFDLENBQUM7d0JBQ1YscUJBQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsRUFBQTs7d0JBQXpELEtBQStCLFNBQTBCLEVBQXhELGFBQWEsUUFBQSxFQUFFLFdBQVcsUUFBQTt3QkFDakMsS0FBSyxDQUFDLHlDQUF5QyxFQUFFLGFBQWEsQ0FBQyxDQUFDO3dCQUNoRSxJQUFJLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxXQUFXLENBQUMsRUFBRTs0QkFDL0IsYUFBYSxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7eUJBQ3pDO3dCQUNtQyxxQkFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLG1CQUFtQixDQUN6RSxNQUFNLENBQUMsTUFBTSxDQUFDLGFBQWEsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLGlCQUFpQixFQUFFLENBQUMsQ0FDL0UsRUFBQTs7d0JBRkcsUUFBUSxHQUF3QixTQUVuQzt3QkFDRCxPQUFPLFFBQVEsQ0FBQyxNQUFNLENBQUM7d0JBQ3ZCLE9BQU8sUUFBUSxDQUFDLFdBQVcsQ0FBQzt3QkFDNUIsUUFBUSxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLFFBQVEsRUFBRSxFQUFFLFFBQVEsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO3dCQUMzRCxLQUFLLENBQUMsZ0NBQWdDLEVBQUUsUUFBUSxDQUFDLENBQUM7d0JBQ2xELHNCQUFPLFFBQXFDLEVBQUM7OztTQUM5QyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDSCxnQ0FBZSxHQUFmLFVBQ0UsTUFBeUMsRUFDekMsUUFBMEM7UUFEMUMsdUJBQUEsRUFBQSxXQUF5QztRQUd6QyxJQUFNLElBQUksR0FBRyxJQUFJLENBQUM7UUFDbEIsT0FBTyxFQUFFLENBQW9COzs7Ozt3QkFDckIsVUFBVSxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUM7d0JBQ3JDLElBQUksQ0FBQyxVQUFVLElBQUksT0FBTyxVQUFVLEtBQUssUUFBUSxFQUFFOzRCQUNqRCxNQUFNLElBQUksS0FBSyxDQUFDLDhCQUE4QixDQUFDLENBQUM7eUJBQ2pEO3dCQUNlLHFCQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsa0JBQWtCLENBQUMsTUFBTSxDQUFDLEVBQUE7O3dCQUF4RCxPQUFPLEdBQUcsU0FBOEM7d0JBQ3hELE9BQU8sR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDO3dCQUNuQyxhQUFhLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsT0FBTyxFQUFFLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQzt3QkFDdEYsc0JBQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUMsYUFBYSxDQUFDLEVBQUM7OztTQUNyRCxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILDJCQUFVLEdBQVYsVUFBVyxNQUE4QjtRQUE5Qix1QkFBQSxFQUFBLFdBQThCO1FBQ3ZDLElBQU0sWUFBWSxHQUFHLE1BQU0sQ0FBQyxRQUFRLElBQUksTUFBTSxDQUFDLEdBQUcsQ0FBQztRQUNuRCxJQUFJLE9BQU8sR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDO1FBQ3pCLElBQUksT0FBTyxJQUFJLE9BQU8sT0FBTyxLQUFLLFFBQVEsRUFBRTtZQUMxQyxNQUFNLElBQUksS0FBSyxDQUFDLHNCQUFzQixDQUFDLENBQUM7U0FDekM7UUFDRCxJQUFJLE9BQU8sSUFBSSxNQUFNLENBQUMsa0JBQWtCLEVBQUU7WUFDeEMsNERBQTREO1lBQzVELElBQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsaUJBQWlCLENBQUMsRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLENBQUMsa0JBQWtCLEVBQUUsQ0FBQyxDQUFDO1lBQ3RHLE9BQU8sR0FBRyxVQUFVLENBQUMsR0FBRyxDQUFDO1NBQzFCO2FBQU0sSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUNuQixJQUFJLENBQUMsWUFBWSxJQUFJLE9BQU8sWUFBWSxLQUFLLFFBQVEsRUFBRTtnQkFDckQsTUFBTSxJQUFJLEtBQUssQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO2FBQy9DO1lBQ0QsSUFBTSxnQkFBZ0IsR0FBRyxZQUFZLENBQUMsWUFBWSxDQUFDO1lBQ25ELElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtnQkFDckIsTUFBTSxJQUFJLEtBQUssQ0FBQyw4Q0FBOEMsQ0FBQyxDQUFDO2FBQ2pFO1lBQ0QsSUFBSSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRTtnQkFDNUIsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDO2FBQ3REO1lBRUQsT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEVBQUUsS0FBSyxFQUFFLGdCQUFnQixFQUFFLFFBQVEsRUFBRSxNQUFNLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxDQUFDO1NBQzlGO1FBQ0QsT0FBTyxPQUFPLENBQUM7SUFDakIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCwyQ0FBMEIsR0FBMUIsVUFBMkIsTUFBOEMsRUFBRSxRQUEwQztRQUExRix1QkFBQSxFQUFBLFdBQThDO1FBQ3ZFLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNsQixPQUFPLEVBQUUsQ0FBb0I7Ozs7O3dCQUMzQixJQUFJLE1BQU0sQ0FBQyxVQUFVLElBQUksTUFBTSxDQUFDLFVBQVUsRUFBRTs0QkFDcEMsS0FBSyxHQUFRLElBQUksS0FBSyxDQUFDLHdEQUF3RCxDQUFDLENBQUM7NEJBQ3ZGLEtBQUssQ0FBQyxJQUFJLEdBQUcsMENBQTBDLENBQUM7NEJBQ3hELE1BQU0sS0FBSyxDQUFDO3lCQUNiO3dCQUVELElBQUksTUFBTSxDQUFDLFVBQVUsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxFQUFFOzRCQUNwRCxLQUFLLEdBQVEsSUFBSSxLQUFLLENBQUMsNEJBQTRCLENBQUMsQ0FBQzs0QkFDM0QsS0FBSyxDQUFDLElBQUksR0FBRyxzQkFBc0IsQ0FBQzs0QkFDcEMsTUFBTSxLQUFLLENBQUM7eUJBQ2I7d0JBRUQsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFOzRCQUNsRSxLQUFLLEdBQVEsSUFBSSxLQUFLLENBQUMsb0NBQW9DLENBQUMsQ0FBQzs0QkFDbkUsS0FBSyxDQUFDLElBQUksR0FBRyx1Q0FBdUMsQ0FBQzs0QkFDckQsTUFBTSxLQUFLLENBQUM7eUJBQ2I7d0JBSUssZUFBZSxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsTUFBTSxDQUFDLENBQUM7d0JBR2hHLHFCQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLENBQUMsaUJBQWlCLENBQUMsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBQTs7d0JBQXBHLFNBQVMsR0FBRyxTQUF3Rjt3QkFFdkYscUJBQU0sZUFBZSxFQUFBOzt3QkFBbEMsVUFBVSxHQUFHLFNBQXFCOzs7O3dCQUdoQyxrQkFBa0IsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLElBQUksRUFBRSxFQUFFLENBQUMsbUJBQW1CLEVBQUUsV0FBVyxFQUFFLFdBQVcsQ0FBQyxDQUFDLENBQUM7d0JBQzlHLHFCQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsaUJBQWlCLENBQUM7Z0NBQ3BDLFFBQVEsRUFBRSxNQUFNO2dDQUNoQixVQUFVLFlBQUE7Z0NBQ1YsTUFBTSxFQUFFLElBQUk7Z0NBQ1osWUFBWSxFQUFFLGtCQUFrQjtnQ0FDaEMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxLQUFLOzZCQUNwQixDQUFDLEVBQUE7O3dCQU5GLFNBTUUsQ0FBQzs7Ozt3QkFFSCxLQUFLLENBQUMsK0JBQStCLEVBQUUsR0FBQyxDQUFDLENBQUM7d0JBQzFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsK0NBQStDLENBQUMsQ0FBQzt3QkFDL0QsTUFBTSxHQUFDLENBQUM7O3dCQUlKLGFBQWEsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxNQUFNLEVBQUU7NEJBQ3pDLFVBQVUsRUFBRSxVQUFVOzRCQUN0QixNQUFNLEVBQUU7Z0NBQ04sc0VBQXNFO2dDQUN0RSxjQUFjLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsY0FBYzs2QkFDekQ7NEJBQ0QsUUFBUSxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUM7NEJBQ3RCLGNBQWMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSTs0QkFDNUQsYUFBYSxFQUFFLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJO3lCQUM1RCxDQUFDLENBQUM7Ozs7d0JBR00scUJBQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxhQUFhLENBQUMsRUFBQTs0QkFBaEQsc0JBQU8sU0FBeUMsRUFBQzs7O3dCQUVqRCxJQUFJLE9BQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLG9CQUFvQixDQUFDLEVBQUU7NEJBQ2hELE9BQUssQ0FBQyxJQUFJLEdBQUcsb0JBQW9CLENBQUM7NEJBQ2xDLE9BQUssQ0FBQyxjQUFjLEdBQUc7Z0NBQ3JCLGFBQWEsRUFBRSxJQUFJLENBQUMsYUFBYSxFQUFFO2dDQUNuQyxzQkFBc0IsRUFBRSxJQUFJLENBQUMsc0JBQXNCLEVBQUU7Z0NBQ3JELHNCQUFzQixFQUFFLElBQUksQ0FBQyxzQkFBc0IsRUFBRTtnQ0FDckQsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUU7Z0NBQ3ZCLGdCQUFnQixFQUFFLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtnQ0FDekMsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixFQUFFOzZCQUMxQyxDQUFDOzRCQUNGLE9BQUssQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxVQUFVLEVBQUUsS0FBSyxFQUFFLFlBQVksRUFBRSxrQkFBa0IsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO3lCQUMvRjt3QkFDRCxNQUFNLE9BQUssQ0FBQzs7OztTQUVmLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsc0NBQXFCLEdBQXJCLFVBQXNCLE1BQXlDLEVBQUUsUUFBNEI7UUFBdkUsdUJBQUEsRUFBQSxXQUF5QztRQUM3RCxJQUFNLElBQUksR0FBRyxJQUFJLENBQUM7UUFDbEIsT0FBTyxFQUFFLENBQUM7Ozs7O3dCQUNSLGtIQUFrSDt3QkFDbEgsd0RBQXdEO3dCQUN4RCxJQUFJLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksTUFBTSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFOzRCQUNsRyxLQUFLLEdBQVEsSUFBSSxLQUFLLENBQUMsZ0RBQWdELENBQUMsQ0FBQzs0QkFDL0UsS0FBSyxDQUFDLElBQUksR0FBRyxxQkFBcUIsQ0FBQzs0QkFDbkMsTUFBTSxLQUFLLENBQUM7eUJBQ2I7d0JBRUQsSUFBSSxDQUFDLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsRUFBRTs0QkFDckMsSUFBSSxNQUFNLENBQUMsYUFBYSxLQUFLLElBQUksRUFBRTtnQ0FDM0IsS0FBSyxHQUFRLElBQUksS0FBSyxDQUFDLHFEQUFxRCxDQUFDLENBQUM7Z0NBQ3BGLEtBQUssQ0FBQyxJQUFJLEdBQUcscUJBQXFCLENBQUM7Z0NBQ25DLE1BQU0sS0FBSyxDQUFDOzZCQUNiO3lCQUNGOzZCQUFNOzRCQUNMLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsSUFBSSxNQUFNLENBQUMsV0FBVyxHQUFHLENBQUMsRUFBRTtnQ0FDeEQsS0FBSyxHQUFRLElBQUksS0FBSyxDQUFDLDRDQUE0QyxDQUFDLENBQUM7Z0NBQzNFLEtBQUssQ0FBQyxJQUFJLEdBQUcscUNBQXFDLENBQUM7Z0NBQ25ELE1BQU0sS0FBSyxDQUFDOzZCQUNiO3lCQUNGO3dCQUVELElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUU7NEJBQ2hDLElBQUksTUFBTSxDQUFDLFFBQVEsS0FBSyxJQUFJLEVBQUU7Z0NBQ3RCLEtBQUssR0FBUSxJQUFJLEtBQUssQ0FBQywyQ0FBMkMsQ0FBQyxDQUFDO2dDQUMxRSxLQUFLLENBQUMsSUFBSSxHQUFHLGdCQUFnQixDQUFDO2dDQUM5QixNQUFNLEtBQUssQ0FBQzs2QkFDYjt5QkFDRjs2QkFBTTs0QkFDTCxJQUFJLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7Z0NBQzlDLEtBQUssR0FBUSxJQUFJLEtBQUssQ0FBQyx1Q0FBdUMsQ0FBQyxDQUFDO2dDQUN0RSxLQUFLLENBQUMsSUFBSSxHQUFHLGdDQUFnQyxDQUFDO2dDQUM5QyxNQUFNLEtBQUssQ0FBQzs2QkFDYjt5QkFDRjt3QkFFRCxJQUFJLE1BQU0sQ0FBQyxVQUFVLEtBQUssU0FBUyxFQUFFOzRCQUNuQyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksTUFBTSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO2dDQUN2RSxNQUFNLElBQUksS0FBSyxDQUFDLDhEQUE4RCxDQUFDLENBQUM7NkJBQ2pGO3lCQUNGO3dCQUVELE1BQU0sQ0FBQyxVQUFVLEdBQUcsRUFBRSxDQUFDO3dCQUdGLEtBQUEsQ0FBQSxLQUFBLE1BQU0sQ0FBQSxDQUFDLE1BQU0sQ0FBQTs4QkFBQyxNQUFNO3dCQUFFLHFCQUFNLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxNQUFNLENBQUMsRUFBQTs7d0JBQWxGLFlBQVksR0FBRyx3QkFBc0IsU0FBNkMsR0FBQzt3QkFDekYsT0FBTyxZQUFZLENBQUMsTUFBTSxDQUFDO3dCQUNwQixxQkFBTSxJQUFJLENBQUMsaUJBQWlCLENBQUMsWUFBWSxDQUFDLEVBQUE7NEJBQWpELHNCQUFPLFNBQTBDLEVBQUM7OztTQUNuRCxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsa0NBQWlCLEdBQWpCLFVBQWtCLE1BQXFDLEVBQUUsUUFBNEI7UUFBbkUsdUJBQUEsRUFBQSxXQUFxQztRQUNyRCxNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxFQUFFLEVBQUUsQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFDOUQsSUFBTSxRQUFRLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUM7UUFDaEMsSUFBTSxhQUFhLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUM7UUFFMUMsSUFBSSxDQUFDLFFBQVEsSUFBSSxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxJQUFJLENBQUMsYUFBYSxDQUFDLEVBQUU7WUFDaEUsTUFBTSxJQUFJLEtBQUssQ0FBQyxzREFBc0QsQ0FBQyxDQUFDO1NBQ3pFO1FBQ0QsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFHLFVBQVUsQ0FBQyxDQUFDO2FBQzNFLElBQUksQ0FBQyxNQUFNLENBQUM7YUFDWixNQUFNLEVBQUU7YUFDUixPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7O09BYUc7SUFDSCxxQkFBSSxHQUFKLFVBQUssTUFBd0IsRUFBRSxRQUE0QjtRQUF0RCx1QkFBQSxFQUFBLFdBQXdCO1FBQzNCLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFFMUUsSUFBSSxDQUFDLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUNoQyxNQUFNLElBQUksS0FBSyxDQUFDLG1DQUFtQyxDQUFDLENBQUM7U0FDdEQ7UUFFRCxJQUFJLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ2pDLE1BQU0sSUFBSSxLQUFLLENBQUMsbUNBQW1DLENBQUMsQ0FBQztTQUN0RDtRQUVELElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7UUFFM0IsSUFBTSxNQUFNLEdBQUcsSUFBSSx3QkFBUyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM1QyxJQUFJLE1BQU0sQ0FBQyxVQUFVLEVBQUUsRUFBRTtZQUN2QixNQUFNLElBQUksS0FBSyxDQUFDLDRGQUE0RixDQUFDLENBQUM7U0FDL0c7UUFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLHdCQUF3QixFQUFFLElBQUksTUFBTSxDQUFDLE1BQU0sRUFBRSxFQUFFO1lBQ3ZELE1BQU0sSUFBSSxLQUFLLENBQUMsNEZBQTRGLENBQUMsQ0FBQztTQUMvRztRQUVELElBQU0sVUFBVSxHQUFrQyxDQUFDO2dCQUNqRCxPQUFPLEVBQUUsTUFBTSxDQUFDLE9BQU87Z0JBQ3ZCLE1BQU0sRUFBRSxNQUFNLENBQUMsTUFBTTthQUN0QixDQUFDLENBQUM7UUFFSCxJQUFJLE1BQU0sQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLHNCQUFzQixFQUFFLEVBQUU7WUFDaEQsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDO1NBQ2xDO1FBRUQsSUFBTSxlQUFlLEdBQW9CLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLE1BQU0sRUFBRSxFQUFFLFVBQVUsWUFBQSxFQUFFLENBQUMsQ0FBQztRQUNuRixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzFELENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BaUNHO0lBQ0gseUJBQVEsR0FBUixVQUFTLE1BQTRCLEVBQUUsUUFBNEI7UUFBMUQsdUJBQUEsRUFBQSxXQUE0QjtRQUNuQyxJQUFNLElBQUksR0FBRyxJQUFJLENBQUM7UUFDbEIsT0FBTyxFQUFFLENBQUM7Ozs7O3dCQUNSLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLEVBQUUsRUFBRSxDQUFDLFNBQVMsRUFBRSxLQUFLLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQzt3QkFDaEUsS0FBSyxDQUFDLGlCQUFpQixDQUFDLENBQUM7d0JBQ25CLEtBQUssR0FBRyxNQUFNLENBQUMsS0FBSyxJQUFJLElBQUksb0JBQWEsRUFBRSxDQUFDO3dCQUNsRCxNQUFNLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQzt3QkFDZixJQUFJLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQzt3QkFDM0IsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsRUFBRTs0QkFDakMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsVUFBUyxTQUFTO2dDQUN0QyxJQUFNLE1BQU0sR0FBRyxJQUFJLHdCQUFTLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2dDQUMvQyxJQUFJLE1BQU0sQ0FBQyxVQUFVLEVBQUUsRUFBRTtvQ0FDdkIsTUFBTSxJQUFJLEtBQUssQ0FBQyw0RkFBNEYsQ0FBQyxDQUFDO2lDQUMvRztnQ0FDRCxJQUFJLENBQUMsSUFBSSxDQUFDLHdCQUF3QixFQUFFLElBQUksTUFBTSxDQUFDLE1BQU0sRUFBRSxFQUFFO29DQUN2RCxNQUFNLElBQUksS0FBSyxDQUFDLDRGQUE0RixDQUFDLENBQUM7aUNBQy9HOzRCQUNILENBQUMsQ0FBQyxDQUFDO3lCQUNKO3dCQUU2QixxQkFBTSxJQUFJLENBQUMsMEJBQTBCLENBQUMsTUFBTSxDQUFDLEVBQUE7O3dCQUFyRSxxQkFBcUIsR0FBRyxTQUE2Qzt3QkFDckUsWUFBWSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFOzRCQUNsQyxZQUFZLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsYUFBYTs0QkFDakUsNkJBQTZCLEVBQUUsc0JBQXNCOzRCQUNyRCxTQUFTLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxZQUFZOzRCQUMvQyxvQkFBb0IsRUFBRSxxQkFBcUIsRUFBRSxVQUFVOzRCQUN2RCxlQUFlLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsZUFBZTs0QkFDOUQsU0FBUyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsWUFBWTt5QkFDeEMsQ0FBQyxDQUFDO3dCQUNHLGFBQWEsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxxQkFBcUIsRUFBRSxZQUFZLENBQUMsQ0FBQzt3QkFDeEUsSUFBSSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQzt3QkFDbkMsc0JBQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztpQ0FDekMsSUFBSSxDQUFDLGFBQWEsQ0FBQztpQ0FDbkIsTUFBTSxFQUFFLEVBQUM7OztTQUNiLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7Ozs7Ozs7O09BU0c7SUFDSCw2QkFBWSxHQUFaLFVBQWEsTUFBZ0MsRUFBRSxRQUE0QjtRQUE5RCx1QkFBQSxFQUFBLFdBQWdDO1FBQzNDLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNsQixPQUFPLEVBQUUsQ0FBQzs7O2dCQUNSLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsS0FBSyxLQUFLLEVBQUU7b0JBQ3ZDLE1BQU0sSUFBSSxLQUFLLENBQUMsK0NBQStDLENBQUMsQ0FBQztpQkFDbEU7Z0JBR0Msb0JBQW9CLEdBRWxCLE1BQU0scUJBRlksRUFDcEIsU0FBUyxHQUNQLE1BQU0sVUFEQyxDQUNBO2dCQUVYLElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxvQkFBb0IsQ0FBQyxFQUFFO29CQUN2QyxNQUFNLElBQUksS0FBSyxDQUFDLHdEQUF3RCxDQUFDLENBQUM7aUJBQzNFO2dCQUVELElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsRUFBRTtvQkFDNUIsTUFBTSxJQUFJLEtBQUssQ0FBQyw2Q0FBNkMsQ0FBQyxDQUFDO2lCQUNoRTtnQkFFSyxtQkFBbUIsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsb0JBQW9CLHNCQUFBLEVBQUUsU0FBUyxXQUFBLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztnQkFDekcsc0JBQVEsSUFBSSxDQUFDLFFBQWdCLENBQUMsWUFBWSxDQUFDLG1CQUFtQixDQUFDLEVBQUM7O1NBQ2pFLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILDJDQUEwQixHQUExQixVQUEyQixNQUFlLEVBQUUsUUFBNEI7UUFBN0MsdUJBQUEsRUFBQSxXQUFlO1FBQ3hDLE9BQU8sUUFBUSxDQUFDLDBCQUEwQixDQUFDLEVBQUUsUUFBUSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN0SCxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILDBCQUFTLEdBQVQsVUFBVSxNQUE2QixFQUFFLFFBQTRCO1FBQTNELHVCQUFBLEVBQUEsV0FBNkI7UUFDckMsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLE9BQU8sRUFBRSxDQUFDOztnQkFDUixNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsRUFBRSxFQUFFLEVBQUUsUUFBUSxDQUFDLENBQUM7Z0JBRTdELHNCQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUcsZUFBZSxDQUFDLENBQUM7eUJBQ2hGLElBQUksQ0FBQyxNQUFNLENBQUM7eUJBQ1osTUFBTSxFQUFFLEVBQUM7O1NBQ2IsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCwrQkFBYyxHQUFkLFVBQWUsTUFBOEIsRUFBRSxRQUE0QjtRQUE1RCx1QkFBQSxFQUFBLFdBQThCO1FBQzNDLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNsQixPQUFPLEVBQUUsQ0FBQyxTQUFVLGdCQUFnQjs7Z0JBQ2xDLE1BQU0sR0FBRyxNQUFNLElBQUksRUFBRSxDQUFDO2dCQUN0QixNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQztnQkFFckQsc0JBQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsQ0FBQzt5QkFDNUMsS0FBSyxDQUFDLE1BQU0sQ0FBQzt5QkFDYixNQUFNLEVBQUUsRUFBQzs7U0FDYixDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNILG9DQUFtQixHQUFuQixVQUFvQixNQUFlLEVBQUUsUUFBNEI7UUFBN0MsdUJBQUEsRUFBQSxXQUFlO1FBQ2pDLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsQ0FBQzthQUM3QyxJQUFJLENBQUMsTUFBTSxDQUFDO2FBQ1osTUFBTSxFQUFFO2FBQ1IsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0gsaUNBQWdCLEdBQWhCLFVBQWlCLE1BQW9DLEVBQUUsUUFBNEI7UUFBbEUsdUJBQUEsRUFBQSxXQUFvQztRQUNuRCxJQUFNLElBQUksR0FBRyxJQUFJLENBQUM7UUFDbEIsT0FBTyxFQUFFLENBQUM7O2dCQUNSLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUM7Z0JBRXJFLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsRUFBRTtvQkFDakMsTUFBTSxJQUFJLEtBQUssQ0FBQyxzQ0FBc0MsQ0FBQyxDQUFDO2lCQUN6RDtnQkFFRCxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUU7b0JBQzlCLE1BQU0sSUFBSSxLQUFLLENBQUMsa0NBQWtDLENBQUMsQ0FBQztpQkFDckQ7Z0JBRUQsc0JBQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsQ0FBQzt5QkFDN0MsSUFBSSxDQUFDLE1BQU0sQ0FBQzt5QkFDWixNQUFNLEVBQUUsRUFBQzs7U0FDYixDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILDhCQUFhLEdBQWIsVUFBYyxNQUFnQixFQUFFLFFBQTRCO1FBQTlDLHVCQUFBLEVBQUEsV0FBZ0I7UUFDNUIsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLE9BQU8sRUFBRSxDQUFDOztnQkFDUixNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDO2dCQUVyRSxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLEVBQUU7b0JBQ2pDLE1BQU0sSUFBSSxLQUFLLENBQUMsc0NBQXNDLENBQUMsQ0FBQztpQkFDekQ7Z0JBRUQsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFO29CQUM5QixNQUFNLElBQUksS0FBSyxDQUFDLGtDQUFrQyxDQUFDLENBQUM7aUJBQ3JEO2dCQUVELHNCQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLENBQUM7eUJBQzVDLElBQUksQ0FBQyxNQUFNLENBQUM7eUJBQ1osTUFBTSxFQUFFLEVBQUM7O1NBQ2IsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsaUNBQWdCLEdBQWhCLFVBQWlCLE1BQW9DLEVBQUUsUUFBNEI7UUFBbEUsdUJBQUEsRUFBQSxXQUFvQztRQUNuRCxJQUFNLElBQUksR0FBRyxJQUFJLENBQUM7UUFDbEIsT0FBTyxFQUFFLENBQUM7O2dCQUNSLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQztnQkFFN0Qsc0JBQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsQ0FBQzt5QkFDNUMsSUFBSSxDQUFDLE1BQU0sQ0FBQzt5QkFDWixNQUFNLEVBQUUsRUFBQzs7U0FDYixDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCx1QkFBTSxHQUFOLFVBQU8sTUFBZSxFQUFFLFFBQTRCO1FBQTdDLHVCQUFBLEVBQUEsV0FBZTtRQUNwQixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNsRSxDQUFDO0lBRUQ7O09BRUc7SUFDSCxpQ0FBZ0IsR0FBaEI7UUFDRSxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLEtBQUssS0FBSyxFQUFFO1lBQ3ZDLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0VBQWdFLENBQUMsQ0FBQztTQUNuRjtRQUNELE9BQU8sSUFBSSwrQkFBYyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDdkUsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7OztPQWlCRztJQUNILGdDQUFlLEdBQWYsVUFBZ0IsTUFBbUM7UUFBbkMsdUJBQUEsRUFBQSxXQUFtQztRQUNqRCxJQUFJLENBQUMsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRTtZQUMvQixNQUFNLElBQUksS0FBSyxDQUFDLGlFQUFpRSxDQUFDLENBQUM7U0FDcEY7UUFFRCxrREFBa0Q7UUFFaEQsSUFBQSxvQkFBSyxFQUNMLHNCQUFNLEVBQ04sa0NBQVksRUFDWixzQ0FBYyxFQUNkLG9DQUFhLEVBQ2IsOEJBQVUsRUFDVixzREFBc0IsRUFDdEIsZ0NBQVcsRUFDWCxnQ0FBVyxFQUNYLDBCQUF1RSxFQUF2RSw0RkFBdUUsQ0FDOUQ7UUFFWCxJQUFJLENBQUMsS0FBSyxJQUFJLE9BQU8sS0FBSyxLQUFLLFVBQVUsRUFBRTtZQUN6QyxNQUFNLElBQUksS0FBSyxDQUFDLHVDQUF1QyxDQUFDLENBQUM7U0FDMUQ7UUFFRCxxQkFBcUI7UUFDckIsSUFBSSxDQUFDLFlBQVksSUFBSSxPQUFPLFlBQVksS0FBSyxRQUFRLEVBQUU7WUFDckQsTUFBTSxJQUFJLEtBQUssQ0FBQyw2Q0FBNkMsQ0FBQyxDQUFDO1NBQ2hFO1FBRUQsSUFBSSxDQUFDLGNBQWMsSUFBSSxPQUFPLGNBQWMsS0FBSyxRQUFRLEVBQUU7WUFDekQsTUFBTSxJQUFJLEtBQUssQ0FBQyxtREFBbUQsQ0FBQyxDQUFDO1NBQ3RFO1FBRUQsSUFBSSxDQUFDLGFBQWEsSUFBSSxPQUFPLGFBQWEsS0FBSyxRQUFRLEVBQUU7WUFDdkQsTUFBTSxJQUFJLEtBQUssQ0FBQyxrREFBa0QsQ0FBQyxDQUFDO1NBQ3JFO1FBRUQsSUFBSSxXQUFXLElBQUksT0FBTyxXQUFXLEtBQUssUUFBUSxFQUFFO1lBQ2xELE1BQU0sSUFBSSxLQUFLLENBQUMsOEJBQThCLENBQUMsQ0FBQztTQUNqRDtRQUVELElBQUksV0FBVyxJQUFJLE9BQU8sV0FBVyxLQUFLLFFBQVEsRUFBRTtZQUNsRCxNQUFNLElBQUksS0FBSyxDQUFDLDhCQUE4QixDQUFDLENBQUM7U0FDakQ7UUFFRCx1Q0FBdUM7UUFDdkMsSUFBSSxPQUFPLGNBQWMsS0FBSyxRQUFRLEVBQUU7WUFDdEMsTUFBTSxJQUFJLEtBQUssQ0FBQyxrQ0FBa0MsQ0FBQyxDQUFDO1NBQ3JEO1FBRUQsSUFBSSxjQUFjLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUMvQixNQUFNLElBQUksS0FBSyxDQUFDLHdDQUF3QyxDQUFDLENBQUM7U0FDM0Q7UUFFRCxJQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQztRQUN6QyxJQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQzdDLElBQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDO1FBRXZDLElBQU0sR0FBRyxHQUFHLHFCQUFXLENBQUM7WUFDdEIsS0FBSyxPQUFBO1lBQ0wsTUFBTSxRQUFBO1lBQ04sT0FBTyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTztZQUMzQixhQUFhLGVBQUE7WUFDYixRQUFRLFVBQUE7WUFDUixjQUFjLGdCQUFBO1lBQ2QsV0FBVyxhQUFBO1lBQ1gsVUFBVSxZQUFBO1lBQ1Ysc0JBQXNCLHdCQUFBO1lBQ3RCLFlBQVksY0FBQTtZQUNaLGNBQWMsZ0JBQUE7WUFDZCxhQUFhLGVBQUE7WUFDYixXQUFXLGFBQUE7WUFDWCxXQUFXLGFBQUE7U0FDWixDQUFDLENBQUM7UUFFSCxxQ0FBcUM7UUFDckMsR0FBRyxDQUFDLElBQUksQ0FBQyx1QkFBcUIsV0FBVyxTQUFNLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCwyQ0FBMEIsR0FBMUIsVUFBMkIsTUFBaUQsRUFBRSxRQUFvRDtRQUF2Ryx1QkFBQSxFQUFBLFdBQWlEO1FBQzFFLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNsQixPQUFPLEVBQUUsQ0FBOEI7Ozs7O3dCQUNyQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQywyQkFBMkIsRUFBRSxFQUFFOzRCQUNoRCxNQUFNLElBQUksS0FBSyxDQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLDRDQUF5QyxDQUFDLENBQUM7eUJBQzFGO3dCQUdLLGlCQUFpQixHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxvQ0FBb0MsRUFBRSxDQUFDLENBQUM7d0JBQ3RGLEtBQUssQ0FBQywyQ0FBMkMsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO3dCQUV0RSxJQUFJLE1BQU0sQ0FBQyxLQUFLLEVBQUU7NEJBQ2hCLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO3lCQUMzQzt3QkFHcUIscUJBQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsR0FBRywyQkFBMkIsQ0FBQyxDQUFDO2lDQUNqSCxJQUFJLENBQUMsaUJBQWlCLENBQUM7aUNBQ3ZCLE1BQU0sRUFBRSxFQUFBOzt3QkFGTCxhQUFhLEdBQUcsU0FFWDt3QkFHTCxjQUFjLEdBQXlCLEVBQUUsQ0FBQzs4QkFDRyxFQUFiLCtCQUFhOzs7NkJBQWIsQ0FBQSwyQkFBYSxDQUFBO3dCQUF4Qyx1QkFBdUI7d0JBQ0kscUJBQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxtQkFBbUIsQ0FDekUsTUFBTSxDQUFDLE1BQU0sQ0FBQyx1QkFBdUIsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLGlCQUFpQixFQUFFLENBQUMsQ0FDekYsRUFBQTs7d0JBRkcsUUFBUSxHQUF3QixTQUVuQzt3QkFFRCxPQUFPLFFBQVEsQ0FBQyxNQUFNLENBQUM7d0JBQ3ZCLE9BQU8sUUFBUSxDQUFDLFdBQVcsQ0FBQzt3QkFFNUIsUUFBUSxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLFFBQVEsRUFBRSxFQUFFLFFBQVEsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO3dCQUMzRCxLQUFLLENBQUMsOENBQThDLEVBQUUsUUFBUSxDQUFDLENBQUM7d0JBRWhFLGNBQWMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7Ozt3QkFYTSxJQUFhLENBQUE7OzRCQWNuRCxzQkFBTyxjQUFjLEVBQUM7OztTQUN2QixDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILHlDQUF3QixHQUF4QixVQUF5QixNQUE4QyxFQUFFLFFBQTRCO1FBQTVFLHVCQUFBLEVBQUEsV0FBOEM7UUFDckUsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLE9BQU8sRUFBRSxDQUFNOzs7Ozt3QkFDYixJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQywyQkFBMkIsRUFBRSxFQUFFOzRCQUNoRCxNQUFNLElBQUksS0FBSyxDQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLDRDQUF5QyxDQUFDLENBQUM7eUJBQzFGO3dCQUVELDZDQUE2Qzt3QkFDN0MsSUFBSSxPQUFPLE1BQU0sQ0FBQyxVQUFVLEtBQUssUUFBUSxJQUFJLE1BQU0sQ0FBQyxVQUFVLEtBQUssU0FBUyxFQUFFOzRCQUM1RSxNQUFNLElBQUksS0FBSyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7eUJBQzVEO3dCQUVELElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLGFBQWEsRUFBRTs0QkFDcEMsTUFBTSxJQUFJLEtBQUssQ0FBQywrREFBK0QsQ0FBQyxDQUFDO3lCQUNsRjt3QkFFc0IscUJBQU0sSUFBSSxDQUFDLDBCQUEwQixDQUFDLE1BQU0sQ0FBQyxFQUFBOzt3QkFBOUQsY0FBYyxHQUFHLFNBQTZDO3dCQUVwRSxxQ0FBcUM7d0JBQ3JDLGNBQWMsQ0FBQyxhQUFhLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUM7d0JBRS9ELE9BQU8sY0FBYyxDQUFDLE1BQU0sQ0FBQzt3QkFFdEIscUJBQU0sSUFBSSxDQUFDLGlCQUFpQixDQUFDLGNBQWMsQ0FBQyxFQUFBOzRCQUFuRCxzQkFBTyxTQUE0QyxFQUFDOzs7U0FDckQsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCwwQ0FBeUIsR0FBekIsVUFBMEIsTUFBaUQsRUFBRSxRQUE0QjtRQUEvRSx1QkFBQSxFQUFBLFdBQWlEO1FBQ3pFLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNsQixPQUFPLEVBQUUsQ0FBTTs7Ozs7d0JBQ2IsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsMkJBQTJCLEVBQUUsRUFBRTs0QkFDaEQsTUFBTSxJQUFJLEtBQUssQ0FBSSxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSw0Q0FBeUMsQ0FBQyxDQUFDO3lCQUMxRjt3QkFHc0IscUJBQU0sSUFBSSxDQUFDLDBCQUEwQixDQUFDLE1BQU0sQ0FBQyxFQUFBOzt3QkFBOUQsY0FBYyxHQUFHLFNBQTZDOzZCQUNoRSxDQUFBLGNBQWMsSUFBSSxjQUFjLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQSxFQUEzQyx3QkFBMkM7d0JBQ3ZDLGFBQWEsR0FBVSxFQUFFLENBQUM7d0JBQzFCLFNBQVMsR0FBRyxJQUFJLEtBQUssRUFBUyxDQUFDOzhCQUNLLEVBQWQsaUNBQWM7Ozs2QkFBZCxDQUFBLDRCQUFjLENBQUE7d0JBQS9CLGFBQWE7d0JBRWhCLHdCQUF3QixHQUFzQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxNQUFNLENBQUMsQ0FBQzt3QkFDOUYsd0JBQXdCLENBQUMsVUFBVSxHQUFHLGFBQWEsQ0FBQzs7Ozt3QkFFbkMscUJBQU0sSUFBSSxDQUFDLHdCQUF3QixDQUFDLHdCQUF3QixDQUFDLEVBQUE7O3dCQUF0RSxNQUFNLEdBQUcsU0FBNkQ7d0JBQzVFLGFBQWEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7Ozs7d0JBRTNCLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBQyxDQUFDLENBQUM7Ozt3QkFSTSxJQUFjLENBQUE7OzRCQVkxQyxzQkFBTzs0QkFDTCxPQUFPLEVBQUUsYUFBYTs0QkFDdEIsT0FBTyxFQUFFLFNBQVM7eUJBQ25CLEVBQUM7Ozs7U0FFTCxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBQ0gsYUFBQztBQUFELENBQUMsQUFyN0RELElBcTdEQztBQXI3RFksd0JBQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0ICogYXMgQmx1ZWJpcmQgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0ICogYXMgZGVidWdMaWIgZnJvbSAnZGVidWcnO1xuXG5pbXBvcnQgeyBtYWtlUmFuZG9tS2V5IH0gZnJvbSAnLi4vYml0Y29pbic7XG5pbXBvcnQgeyBCaXRHbyB9IGZyb20gJy4uL2JpdGdvJztcbmltcG9ydCAqIGFzIGNvbW1vbiBmcm9tICcuLi9jb21tb24nO1xuaW1wb3J0IHsgQWRkcmVzc0dlbmVyYXRpb25FcnJvciB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQge1xuICBCYXNlQ29pbixcbiAgU2lnbmVkVHJhbnNhY3Rpb24sIFRyYW5zYWN0aW9uUHJlYnVpbGQsXG4gIFZlcmlmaWNhdGlvbk9wdGlvbnMsXG59IGZyb20gJy4vYmFzZUNvaW4nO1xuaW1wb3J0IHsgQWJzdHJhY3RVdHhvQ29pbiB9IGZyb20gJy4vY29pbnMvYWJzdHJhY3RVdHhvQ29pbic7XG5pbXBvcnQgeyBFdGggfSBmcm9tICcuL2NvaW5zJztcbmltcG9ydCAqIGFzIGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwvaW50ZXJuYWwnO1xuaW1wb3J0IHsgZHJhd0tleWNhcmQgfSBmcm9tICcuL2ludGVybmFsL2tleWNhcmQnO1xuaW1wb3J0IHsgS2V5Y2hhaW4gfSBmcm9tICcuL2tleWNoYWlucyc7XG5pbXBvcnQgeyBUcmFkaW5nQWNjb3VudCB9IGZyb20gJy4vdHJhZGluZy90cmFkaW5nQWNjb3VudCc7XG5pbXBvcnQgeyBOb2RlQ2FsbGJhY2sgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IFBlbmRpbmdBcHByb3ZhbCwgUGVuZGluZ0FwcHJvdmFsRGF0YSB9IGZyb20gJy4vcGVuZGluZ0FwcHJvdmFsJztcbmltcG9ydCB7IFJlcXVlc3RUcmFjZXIgfSBmcm9tICcuL2ludGVybmFsL3V0aWwnO1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnTGliKCdiaXRnbzp2Mjp3YWxsZXQnKTtcbmNvbnN0IGNvID0gQmx1ZWJpcmQuY29yb3V0aW5lO1xuXG50eXBlIE1hbmFnZVVuc3BlbnRzID0gJ2NvbnNvbGlkYXRlJyB8ICdmYW5vdXQnO1xuXG5leHBvcnQgaW50ZXJmYWNlIE1heGltdW1TcGVuZGFibGVPcHRpb25zIHtcbiAgICBtaW5WYWx1ZT86IG51bWJlcjtcbiAgICBtYXhWYWx1ZT86IG51bWJlcjtcbiAgICBtaW5IZWlnaHQ/OiBudW1iZXI7XG4gICAgbWluQ29uZmlybXM/OiBudW1iZXI7XG4gICAgZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlPzogYm9vbGVhbjtcbiAgICBmZWVSYXRlPzogbnVtYmVyO1xuICAgIG1heEZlZVJhdGU/OiBudW1iZXI7XG4gICAgcmVjaXBpZW50QWRkcmVzcz86IHN0cmluZztcbiAgICBsaW1pdD86IG51bWJlcjtcbiAgICB0YXJnZXQ/OiBudW1iZXI7XG4gICAgcGxhaW5UYXJnZXQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWF4aW11bVNwZW5kYWJsZSB7XG4gICAgbWF4aW11bVNwZW5kYWJsZTogbnVtYmVyO1xuICAgIGNvaW46IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNZW1vIHtcbiAgICB2YWx1ZTogc3RyaW5nO1xuICAgIHR5cGU6IHN0cmluZztcbn1cblxuLyoqXG4gKiBBIHNtYWxsIHNldCBvZiBwYXJhbWV0ZXJzIHNob3VsZCBiZSB1c2VkIGZvciBidWlsZGluZyBhIGNvbnNvbGlkYXRpb24gdHJhbnNhY3Rpb246XG4gKiAtIHdhbGxldFBhc3NwaHJhc2UgLSBuZWNlc3NhcnkgZm9yIHNpZ25pbmdcbiAqIC0gZmVlUmF0ZVxuICogLSBtYXhGZWVSYXRlXG4gKiAtIHZhbGlkRnJvbUJsb2NrXG4gKiAtIHZhbGlkVG9CbG9ja1xuICpcbiAqIFdoYXQgc2hvdWxkbid0IGJlIHBhc3NlZCAodGhlc2Ugd2lsbCBiZSBpZ25vcmVkKTpcbiAqIC0gcmVjaXBpZW50c1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEJ1aWxkQ29uc29saWRhdGlvblRyYW5zYWN0aW9uT3B0aW9ucyBleHRlbmRzIFByZWJ1aWxkVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgZnJvbUFkZHJlc3Nlcz86IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByZWJ1aWxkVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgICByZXFJZD86IFJlcXVlc3RUcmFjZXI7XG4gICAgcmVjaXBpZW50cz86IHtcbiAgICAgICAgYWRkcmVzczogc3RyaW5nO1xuICAgICAgICBhbW91bnQ6IHN0cmluZyB8IG51bWJlcjtcbiAgICB9W107XG4gICAgbnVtQmxvY2tzPzogbnVtYmVyO1xuICAgIGZlZVJhdGU/OiBudW1iZXI7XG4gICAgbWF4RmVlUmF0ZT86IG51bWJlcjtcbiAgICBtaW5Db25maXJtcz86IG51bWJlcjtcbiAgICBlbmZvcmNlTWluQ29uZmlybXNGb3JDaGFuZ2U/OiBib29sZWFuO1xuICAgIHRhcmdldFdhbGxldFVuc3BlbnRzPzogbnVtYmVyO1xuICAgIG1pblZhbHVlPzogbnVtYmVyO1xuICAgIG1heFZhbHVlPzogbnVtYmVyO1xuICAgIHNlcXVlbmNlSWQ/OiBudW1iZXI7XG4gICAgbGFzdExlZGdlclNlcXVlbmNlPzogbnVtYmVyO1xuICAgIGxlZGdlclNlcXVlbmNlRGVsdGE/OiBzdHJpbmc7XG4gICAgZ2FzUHJpY2U/OiBudW1iZXI7XG4gICAgbm9TcGxpdENoYW5nZT86IGJvb2xlYW47XG4gICAgdW5zcGVudHM/OiBhbnlbXTtcbiAgICBjaGFuZ2VBZGRyZXNzPzogc3RyaW5nO1xuICAgIHZhbGlkRnJvbUJsb2NrPzogbnVtYmVyO1xuICAgIHZhbGlkVG9CbG9jaz86IG51bWJlcjtcbiAgICBpbnN0YW50PzogYm9vbGVhbjtcbiAgICBtZW1vPzogTWVtbztcbiAgICBhZGRyZXNzVHlwZT86IHN0cmluZztcbiAgICBob3A/OiBib29sZWFuO1xuICAgIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG4gICAgcmVzZXJ2YXRpb24/OiB7XG4gICAgICBleHBpcmVUaW1lPzogc3RyaW5nO1xuICAgICAgcGVuZGluZ0FwcHJvdmFsSWQ/OiBzdHJpbmc7XG4gICAgfTtcbiAgICBvZmZsaW5lVmVyaWZpY2F0aW9uPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcmVidWlsZEFuZFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgZXh0ZW5kcyBQcmVidWlsZFRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gICAgcHJlYnVpbGRUeD86IHN0cmluZyB8IFByZWJ1aWxkVHJhbnNhY3Rpb25SZXN1bHQ7XG4gICAgdmVyaWZpY2F0aW9uPzogVmVyaWZpY2F0aW9uT3B0aW9ucztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcmVidWlsZFRyYW5zYWN0aW9uUmVzdWx0IGV4dGVuZHMgVHJhbnNhY3Rpb25QcmVidWlsZCB7XG4gICAgd2FsbGV0SWQ6IHN0cmluZztcbiAgICAvLyBDb25zb2xpZGF0ZSBJRCBpcyB1c2VkIGZvciBjb25zb2xpZGF0ZSBhY2NvdW50IHRyYW5zYWN0aW9ucyBhbmQgaW5kaWNhdGVzIGlmIHRoaXMgaXNcbiAgICAvLyBhIGNvbnNvbGlkYXRpb24gYW5kIHdoYXQgY29uc29saWRhdGUgZ3JvdXAgaXQgc2hvdWxkIGJlIHJlZmVyZW5jZWQgYnkuXG4gICAgY29uc29saWRhdGVJZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBXYWxsZXRTaWduVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgICB0eFByZWJ1aWxkPzogVHJhbnNhY3Rpb25QcmVidWlsZDtcbiAgICBwcnY/OiBzdHJpbmc7XG4gICAgaXNMYXN0U2lnbmF0dXJlPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZXRVc2VyUHJ2T3B0aW9ucyB7XG4gICAga2V5Y2hhaW4/OiBLZXljaGFpbjtcbiAgICBrZXk/OiBLZXljaGFpbjtcbiAgICBwcnY/OiBzdHJpbmc7XG4gICAgY29sZERlcml2YXRpb25TZWVkPzogc3RyaW5nO1xuICAgIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2FsbGV0Q29pblNwZWNpZmljIHtcbiAgdG9rZW5GbHVzaFRocmVzaG9sZHM/OiBhbnk7XG4gIGFkZHJlc3NWZXJzaW9uPzogbnVtYmVyO1xuICBiYXNlQWRkcmVzcz86IHN0cmluZztcbiAgcm9vdEFkZHJlc3M/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFnaW5hdGlvbk9wdGlvbnMge1xuICBwcmV2SWQ/OiBzdHJpbmc7XG4gIGxpbWl0PzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdldFRyYW5zYWN0aW9uT3B0aW9ucyBleHRlbmRzIFBhZ2luYXRpb25PcHRpb25zIHtcbiAgdHhIYXNoPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zZmVyc09wdGlvbnMgZXh0ZW5kcyBQYWdpbmF0aW9uT3B0aW9ucyB7XG4gIHR4SGFzaD86IHN0cmluZztcbiAgYWxsVG9rZW5zPzogc3RyaW5nO1xuICBzZWFyY2hMYWJlbD86IHN0cmluZztcbiAgYWRkcmVzcz86IHN0cmluZ1tdIHwgc3RyaW5nO1xuICBkYXRlR3RlPzogc3RyaW5nO1xuICBkYXRlTHQ/OiBzdHJpbmc7XG4gIHZhbHVlR3RlPzogc3RyaW5nO1xuICB2YWx1ZUx0Pzogc3RyaW5nO1xuICBpbmNsdWRlSGV4PzogYm9vbGVhbjtcbiAgc3RhdGU/OiBzdHJpbmdbXSB8IHN0cmluZztcbiAgdHlwZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZXRUcmFuc2Zlck9wdGlvbnMge1xuICBpZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2ZlckJ5U2VxdWVuY2VJZE9wdGlvbnMge1xuICBzZXF1ZW5jZUlkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVuc3BlbnRzT3B0aW9ucyBleHRlbmRzIFBhZ2luYXRpb25PcHRpb25zIHtcbiAgbWluVmFsdWU/OiBudW1iZXI7XG4gIG1heFZhbHVlPzogbnVtYmVyO1xuICBtaW5IZWlnaHQ/OiBudW1iZXI7XG4gIG1pbkNvbmZpcm1zPzogbnVtYmVyO1xuICB0YXJnZXQ/OiBudW1iZXI7XG4gIHNlZ3dpdD86IGJvb2xlYW47XG4gIGNoYWlucz86IG51bWJlcltdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbnNvbGlkYXRlVW5zcGVudHNPcHRpb25zIHtcbiAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbiAgeHBydj86IHN0cmluZztcbiAgbWluVmFsdWU/OiBudW1iZXI7XG4gIG1heFZhbHVlPzogbnVtYmVyO1xuICBtaW5IZWlnaHQ/OiBudW1iZXJcbiAgbnVtVW5zcGVudHNUb01ha2U/OiBudW1iZXI7XG4gIGZlZVR4Q29uZmlybVRhcmdldD86IG51bWJlcjtcbiAgbGltaXQ/OiBudW1iZXI7XG4gIG1pbkNvbmZpcm1zPzogbnVtYmVyO1xuICBlbmZvcmNlTWluQ29uZmlybXNGb3JDaGFuZ2U/OiBib29sZWFuO1xuICBmZWVSYXRlPzogbnVtYmVyO1xuICBtYXhGZWVSYXRlPzogbnVtYmVyO1xuICBtYXhGZWVQZXJjZW50YWdlPzogbnVtYmVyO1xuICBjb21tZW50Pzogc3RyaW5nO1xuICBvdHA/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmFub3V0VW5zcGVudHNPcHRpb25zIHtcbiAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbiAgeHBydj86IHN0cmluZztcbiAgbWluVmFsdWU/OiBudW1iZXI7XG4gIG1heFZhbHVlPzogbnVtYmVyO1xuICBtaW5IZWlnaHQ/OiBudW1iZXJcbiAgbWF4TnVtSW5wdXRzVG9Vc2U/OiBudW1iZXI7XG4gIG51bVVuc3BlbnRzVG9NYWtlPzogbnVtYmVyO1xuICBtaW5Db25maXJtcz86IG51bWJlcjtcbiAgZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlPzogYm9vbGVhbjtcbiAgZmVlUmF0ZT86IG51bWJlcjtcbiAgbWF4RmVlUmF0ZT86IG51bWJlcjtcbiAgbWF4RmVlUGVyY2VudGFnZT86IG51bWJlcjtcbiAgZmVlVHhDb25maXJtVGFyZ2V0PzogbnVtYmVyO1xuICBjb21tZW50Pzogc3RyaW5nO1xuICBvdHA/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3dlZXBPcHRpb25zIHtcbiAgYWRkcmVzcz86IHN0cmluZztcbiAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbiAgeHBydj86IHN0cmluZztcbiAgb3RwPzogc3RyaW5nO1xuICBmZWVSYXRlPzogbnVtYmVyO1xuICBtYXhGZWVSYXRlPzogbnVtYmVyO1xuICBmZWVUeENvbmZpcm1UYXJnZXQ/OiBudW1iZXI7XG4gIGFsbG93UGFydGlhbFN3ZWVwPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGcmVlemVPcHRpb25zIHtcbiAgZHVyYXRpb24/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNmZXJDb21tZW50T3B0aW9ucyB7XG4gIGlkPzogc3RyaW5nO1xuICBjb21tZW50Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFkZHJlc3Nlc09wdGlvbnMgZXh0ZW5kcyBQYWdpbmF0aW9uT3B0aW9ucyB7XG4gIG1pbmU/OiBib29sZWFuO1xuICBzb3J0PzogbnVtYmVyO1xuICBsYWJlbENvbnRhaW5zPzogc3RyaW5nO1xuICBzZWd3aXQ/OiBib29sZWFuO1xuICBjaGFpbnM/OiBudW1iZXJbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZXRBZGRyZXNzT3B0aW9ucyB7XG4gIGFkZHJlc3M/OiBzdHJpbmc7XG4gIGlkPzogc3RyaW5nO1xuICByZXFJZD86IFJlcXVlc3RUcmFjZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlQWRkcmVzc09wdGlvbnMge1xuICBjaGFpbj86IG51bWJlcjtcbiAgZ2FzUHJpY2U/OiBudW1iZXIgfCBzdHJpbmc7XG4gIGNvdW50PzogbnVtYmVyO1xuICBsYWJlbD86IHN0cmluZztcbiAgbG93UHJpb3JpdHk/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVwZGF0ZUFkZHJlc3NPcHRpb25zIHtcbiAgbGFiZWw/OiBzdHJpbmc7XG4gIGFkZHJlc3M/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2ltdWxhdGVXZWJob29rT3B0aW9ucyB7XG4gIHdlYmhvb2tJZD86IHN0cmluZztcbiAgdHJhbnNmZXJJZD86IHN0cmluZztcbiAgcGVuZGluZ0FwcHJvdmFsSWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTW9kaWZ5V2ViaG9va09wdGlvbnMge1xuICB1cmw/OiBzdHJpbmc7XG4gIHR5cGU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2V0UHJ2T3B0aW9ucyB7XG4gIHBydj86IHN0cmluZztcbiAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDcmVhdGVTaGFyZU9wdGlvbnMge1xuICB1c2VyPzogc3RyaW5nO1xuICBwZXJtaXNzaW9ucz86IHN0cmluZztcbiAga2V5Y2hhaW4/OiB7XG4gICAgcHViPzogc3RyaW5nO1xuICAgIGVuY3J5cHRlZFBydj86IHN0cmluZztcbiAgICBmcm9tUHViS2V5Pzogc3RyaW5nO1xuICAgIHRvUHViS2V5Pzogc3RyaW5nO1xuICAgIHBhdGg/OiBzdHJpbmc7XG4gIH0sXG4gIHJlc2hhcmU/OiBib29sZWFuO1xuICBtZXNzYWdlPzogc3RyaW5nO1xuICBkaXNhYmxlRW1haWw/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNoYXJlV2FsbGV0T3B0aW9ucyB7XG4gIGVtYWlsPzogc3RyaW5nO1xuICBwZXJtaXNzaW9ucz86IHN0cmluZztcbiAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbiAgbWVzc2FnZT86IHN0cmluZztcbiAgcmVzaGFyZT86IGJvb2xlYW47XG4gIHNraXBLZXljaGFpbj86IGJvb2xlYW47XG4gIGRpc2FibGVFbWFpbD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVtb3ZlVXNlck9wdGlvbnMge1xuICB1c2VySWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWNjZWxlcmF0ZVRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIGNwZnBUeElkcz86IHN0cmluZ1tdO1xuICBjcGZwRmVlUmF0ZT86IG51bWJlcjtcbiAgbm9DcGZwRmVlUmF0ZT86IGJvb2xlYW47XG4gIG1heEZlZT86IG51bWJlcjtcbiAgbm9NYXhGZWU/OiBib29sZWFuO1xuICByZWNpcGllbnRzPzoge1xuICAgIGFkZHJlc3M6IHN0cmluZztcbiAgICBhbW91bnQ6IHN0cmluZztcbiAgfVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN1Ym1pdFRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIG90cD86IHN0cmluZztcbiAgdHhIZXg/OiBzdHJpbmc7XG4gIGhhbGZTaWduZWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VuZE9wdGlvbnMge1xuICBhZGRyZXNzPzogc3RyaW5nO1xuICBhbW91bnQ/OiBudW1iZXIgfCBzdHJpbmc7XG4gIGRhdGE/OiBzdHJpbmc7XG4gIG1lc3NhZ2U/OiBzdHJpbmc7XG4gIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG4gIHBydj86IHN0cmluZztcbiAgbWluQ29uZmlybXM/OiBudW1iZXI7XG4gIGVuZm9yY2VNaW5Db25maXJtc0ZvckNoYW5nZT86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZW5kTWFueU9wdGlvbnMge1xuICByZXFJZD86IFJlcXVlc3RUcmFjZXI7XG4gIHJlY2lwaWVudHM/OiB7XG4gICAgYWRkcmVzczogc3RyaW5nO1xuICAgIGFtb3VudDogc3RyaW5nIHwgbnVtYmVyO1xuICAgIGRhdGE/OiBzdHJpbmc7XG4gIH1bXTtcbiAgbnVtQmxvY2tzPzogbnVtYmVyO1xuICBmZWVSYXRlPzogbnVtYmVyO1xuICBtYXhGZWVSYXRlPzogbnVtYmVyO1xuICBtaW5Db25maXJtcz86IG51bWJlcjtcbiAgZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlPzogYm9vbGVhbjtcbiAgdGFyZ2V0V2FsbGV0VW5zcGVudHM/OiBudW1iZXI7XG4gIG1lc3NhZ2U/OiBzdHJpbmc7XG4gIG1pblZhbHVlPzogbnVtYmVyO1xuICBtYXhWYWx1ZT86IG51bWJlcjtcbiAgc2VxdWVuY2VJZD86IG51bWJlcjtcbiAgbGFzdExlZGdlclNlcXVlbmNlPzogbnVtYmVyO1xuICBsZWRnZXJTZXF1ZW5jZURlbHRhPzogc3RyaW5nO1xuICBnYXNQcmljZT86IG51bWJlcjtcbiAgbm9TcGxpdENoYW5nZT86IGJvb2xlYW47XG4gIHVuc3BlbnRzPzogc3RyaW5nW107XG4gIGNvbW1lbnQ/OiBzdHJpbmc7XG4gIG90cD86IHN0cmluZztcbiAgY2hhbmdlQWRkcmVzcz86IHN0cmluZztcbiAgaW5zdGFudD86IGJvb2xlYW47XG4gIG1lbW8/OiBNZW1vO1xufVxuXG5pbnRlcmZhY2UgV2FsbGV0RGF0YSB7XG4gIGlkOiBzdHJpbmc7XG4gIGFwcHJvdmFsc1JlcXVpcmVkOiBudW1iZXI7XG4gIGJhbGFuY2U6IG51bWJlcjtcbiAgY29uZmlybWVkQmFsYW5jZTogbnVtYmVyO1xuICBzcGVuZGFibGVCYWxhbmNlOiBudW1iZXI7XG4gIGJhbGFuY2VTdHJpbmc6IHN0cmluZztcbiAgY29uZmlybWVkQmFsYW5jZVN0cmluZzogc3RyaW5nO1xuICBzcGVuZGFibGVCYWxhbmNlU3RyaW5nOiBzdHJpbmc7XG4gIGNvaW46IHN0cmluZztcbiAgbGFiZWw6IHN0cmluZztcbiAga2V5czogc3RyaW5nW107XG4gIHJlY2VpdmVBZGRyZXNzOiB7XG4gICAgYWRkcmVzczogc3RyaW5nO1xuICB9O1xuICBtaWdyYXRlZEZyb20/OiBzdHJpbmc7XG4gIGNvaW5TcGVjaWZpYzogV2FsbGV0Q29pblNwZWNpZmljO1xuICBwZW5kaW5nQXBwcm92YWxzOiBQZW5kaW5nQXBwcm92YWxEYXRhW107XG4gIGVudGVycHJpc2U6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWNvdmVyVG9rZW5PcHRpb25zIHtcbiAgdG9rZW5Db250cmFjdEFkZHJlc3M/OiBzdHJpbmc7XG4gIHJlY2lwaWVudD86IHN0cmluZztcbiAgYnJvYWRjYXN0PzogYm9vbGVhbjtcbiAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbiAgcHJ2Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENoYW5nZUZlZU9wdGlvbnMge1xuICB0eGlkPzogc3RyaW5nO1xuICBmZWU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlUG9saWN5UnVsZU9wdGlvbnMge1xuICBpZD86IHN0cmluZztcbiAgdHlwZT86IHN0cmluZztcbiAgbWVzc2FnZT86IHN0cmluZztcbiAgY29uZGl0aW9uPzogdW5rbm93bjtcbiAgYWN0aW9uPzogdW5rbm93bjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZXRQb2xpY3lSdWxlT3B0aW9ucyB7XG4gIGlkPzogc3RyaW5nO1xuICB0eXBlPzogc3RyaW5nO1xuICBtZXNzYWdlPzogc3RyaW5nO1xuICBjb25kaXRpb24/OiB1bmtub3duO1xuICBhY3Rpb24/OiB1bmtub3duO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlbW92ZVBvbGljeVJ1bGVPcHRpb25zIHtcbiAgaWQ/OiBzdHJpbmc7XG4gIG1lc3NhZ2U/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRG93bmxvYWRLZXljYXJkT3B0aW9ucyB7XG4gIGpzUERGPzogYW55O1xuICBRUkNvZGU/OiBhbnk7XG4gIHVzZXJLZXljaGFpbj86IEtleWNoYWluO1xuICBiYWNrdXBLZXljaGFpbj86IEtleWNoYWluO1xuICBiaXRnb0tleWNoYWluPzogS2V5Y2hhaW47XG4gIHBhc3NwaHJhc2U/OiBzdHJpbmc7XG4gIHBhc3Njb2RlRW5jcnlwdGlvbkNvZGU/OiBzdHJpbmc7XG4gIGFjdGl2YXRpb25Db2RlPzogc3RyaW5nO1xuICB3YWxsZXRLZXlJRD86IHN0cmluZztcbiAgYmFja3VwS2V5SUQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBXYWxsZXQge1xuICBwdWJsaWMgcmVhZG9ubHkgYml0Z286IEJpdEdvO1xuICBwdWJsaWMgcmVhZG9ubHkgYmFzZUNvaW46IEJhc2VDb2luO1xuICBwcml2YXRlIF93YWxsZXQ6IFdhbGxldERhdGE7XG4gIHByaXZhdGUgcmVhZG9ubHkgX3Blcm1pc3Npb25zPzogc3RyaW5nW107XG5cbiAgY29uc3RydWN0b3IoYml0Z286IEJpdEdvLCBiYXNlQ29pbjogQmFzZUNvaW4sIHdhbGxldERhdGE6IGFueSkge1xuICAgIHRoaXMuYml0Z28gPSBiaXRnbztcbiAgICB0aGlzLmJhc2VDb2luID0gYmFzZUNvaW47XG4gICAgdGhpcy5fd2FsbGV0ID0gd2FsbGV0RGF0YTtcbiAgICBjb25zdCB1c2VySWQgPSBfLmdldChiaXRnbywgJ191c2VyLmlkJyk7XG4gICAgaWYgKF8uaXNTdHJpbmcodXNlcklkKSkge1xuICAgICAgY29uc3QgdXNlckRldGFpbHMgPSBfLmZpbmQod2FsbGV0RGF0YS51c2VycywgeyB1c2VyOiB1c2VySWQgfSk7XG4gICAgICB0aGlzLl9wZXJtaXNzaW9ucyA9IF8uZ2V0KHVzZXJEZXRhaWxzLCAncGVybWlzc2lvbnMnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgYSBVUkwgdXNpbmcgdGhpcyB3YWxsZXQncyBpZCB3aGljaCBjYW4gYmUgdXNlZCBmb3IgQml0R28gQVBJIG9wZXJhdGlvbnNcbiAgICogQHBhcmFtIGV4dHJhIEFQSSBzcGVjaWZpYyBzdHJpbmcgdG8gYXBwZW5kIHRvIHRoZSB3YWxsZXQgaWRcbiAgICovXG4gIHVybChleHRyYTogc3RyaW5nID0gJycpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmJhc2VDb2luLnVybCgnL3dhbGxldC8nICsgdGhpcy5pZCgpICsgZXh0cmEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGlzIHdhbGxldCdzIGlkXG4gICAqL1xuICBpZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXQuaWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBudW1iZXIgb2YgYXBwcm92YWxzIHJlcXVpcmVkIGZvciBzcGVuZGluZyBmdW5kcyBmcm9tIHRoaXMgd2FsbGV0XG4gICAqL1xuICBhcHByb3ZhbHNSZXF1aXJlZCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXQuYXBwcm92YWxzUmVxdWlyZWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IGJhbGFuY2Ugb2YgdGhpcyB3YWxsZXRcbiAgICovXG4gIGJhbGFuY2UoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0LmJhbGFuY2U7XG4gIH1cblxuICBwcmVidWlsZFdoaXRlbGlzdGVkUGFyYW1zKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gW1xuICAgICAgJ3JlY2lwaWVudHMnLCAnbnVtQmxvY2tzJywgJ2ZlZVJhdGUnLCAnbWF4RmVlUmF0ZScsICdtaW5Db25maXJtcycsICdlbmZvcmNlTWluQ29uZmlybXNGb3JDaGFuZ2UnLFxuICAgICAgJ3RhcmdldFdhbGxldFVuc3BlbnRzJywgJ21lc3NhZ2UnLCAnbWluVmFsdWUnLCAnbWF4VmFsdWUnLCAnc2VxdWVuY2VJZCcsICdsYXN0TGVkZ2VyU2VxdWVuY2UnLFxuICAgICAgJ2xlZGdlclNlcXVlbmNlRGVsdGEnLCAnZ2FzUHJpY2UnLCAnZ2FzTGltaXQnLCAnbm9TcGxpdENoYW5nZScsICd1bnNwZW50cycsICdjaGFuZ2VBZGRyZXNzJywgJ2luc3RhbnQnLCAnbWVtbycsICdhZGRyZXNzVHlwZScsXG4gICAgICAnY3BmcFR4SWRzJywgJ2NwZnBGZWVSYXRlJywgJ21heEZlZScsICdpZGZWZXJzaW9uJywgJ2lkZlNpZ25lZFRpbWVzdGFtcCcsICdpZGZVc2VySWQnLCAnc3RyYXRlZ3knLFxuICAgICAgJ3ZhbGlkRnJvbUJsb2NrJywgJ3ZhbGlkVG9CbG9jaycsICd0eXBlJywgJ3RydXN0bGluZXMnLCAncmVzZXJ2YXRpb24nLFxuICAgIF07XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBhIHN0cmljdCBzdWItc2V0IG9mIHByZWJ1aWxkV2hpdGVsaXN0ZWRQYXJhbXMuXG4gICAqL1xuICBwcmVidWlsZENvbnNvbGlkYXRlVHJhbnNhY3Rpb25QYXJhbXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBbXG4gICAgICAnZmVlUmF0ZScsICdtYXhGZWVSYXRlJywgJ21lbW8nLCAndmFsaWRGcm9tQmxvY2snLCAndmFsaWRUb0Jsb2NrJyxcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29uZmlybWVkIGJhbGFuY2Ugb2YgdGhpcyB3YWxsZXRcbiAgICovXG4gIGNvbmZpcm1lZEJhbGFuY2UoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0LmNvbmZpcm1lZEJhbGFuY2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzcGVuZGFibGUgYmFsYW5jZSBvZiB0aGlzIHdhbGxldFxuICAgKi9cbiAgc3BlbmRhYmxlQmFsYW5jZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXQuc3BlbmRhYmxlQmFsYW5jZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGJhbGFuY2Ugb2YgdGhpcyB3YWxsZXRcbiAgICpcbiAgICogVGhpcyBpcyB1c2VmdWwgd2hlbiBiYWxhbmNlcyBoYXZlIHRoZSBwb3RlbnRpYWwgdG8gb3ZlcmZsb3cgc3RhbmRhcmQgamF2YXNjcmlwdCBudW1iZXJzXG4gICAqL1xuICBiYWxhbmNlU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3dhbGxldC5iYWxhbmNlU3RyaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29uZmlybWVkIGJhbGFuY2Ugb2YgdGhpcyB3YWxsZXRcbiAgICpcbiAgICogVGhpcyBpcyB1c2VmdWwgd2hlbiBiYWxhbmNlcyBoYXZlIHRoZSBwb3RlbnRpYWwgdG8gb3ZlcmZsb3cgc3RhbmRhcmQgamF2YXNjcmlwdCBudW1iZXJzXG4gICAqL1xuICBjb25maXJtZWRCYWxhbmNlU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3dhbGxldC5jb25maXJtZWRCYWxhbmNlU3RyaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3BlbmRhYmxlIGJhbGFuY2Ugb2YgdGhpcyB3YWxsZXRcbiAgICpcbiAgICogVGhpcyBpcyB1c2VmdWwgd2hlbiBiYWxhbmNlcyBoYXZlIHRoZSBwb3RlbnRpYWwgdG8gb3ZlcmZsb3cgc3RhbmRhcmQgamF2YXNjcmlwdCBudW1iZXJzXG4gICAqL1xuICBzcGVuZGFibGVCYWxhbmNlU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3dhbGxldC5zcGVuZGFibGVCYWxhbmNlU3RyaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29pbiBpZGVudGlmaWVyIGZvciB0aGUgdHlwZSBvZiBjb2luIHRoaXMgd2FsbGV0IGhvbGRzXG4gICAqL1xuICBjb2luKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3dhbGxldC5jb2luO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGFiZWwgKG5hbWUpIGZvciB0aGlzIHdhbGxldFxuICAgKi9cbiAgcHVibGljIGxhYmVsKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3dhbGxldC5sYWJlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHB1YmxpYyBvYmplY3QgaWRzIGZvciB0aGUga2V5Y2hhaW5zIG9uIHRoaXMgd2FsbGV0LlxuICAgKi9cbiAgcHVibGljIGtleUlkcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuX3dhbGxldC5rZXlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHJlY2VpdmUgYWRkcmVzcyBmb3IgdGhpcyB3YWxsZXRcbiAgICovXG4gIHB1YmxpYyByZWNlaXZlQWRkcmVzcygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXQucmVjZWl2ZUFkZHJlc3MuYWRkcmVzcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdhbGxldCBpZCBvZiB0aGUgd2FsbGV0IHRoYXQgdGhpcyB3YWxsZXQgd2FzIG1pZ3JhdGVkIGZyb20uXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCBpZiB0aGlzIGlzIGEgQkNIIHdhbGxldCB0aGF0IHdhcyBjcmVhdGVkIGZyb20gYSBCVEMgd2FsbGV0LFxuICAgKiB0aGUgQkNIIHdhbGxldCBtaWdyYXRlZCBmcm9tIGZpZWxkIHdvdWxkIGhhdmUgdGhlIEJUQyB3YWxsZXQgaWQuXG4gICAqL1xuICBwdWJsaWMgbWlncmF0ZWRGcm9tKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX3dhbGxldC5taWdyYXRlZEZyb207XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB0b2tlbiBmbHVzaCB0aHJlc2hvbGRzIGZvciB0aGlzIHdhbGxldFxuICAgKiBAcmV0dXJuIHsqfE9iamVjdH0gcGFpcnMgb2YgeyBbdG9rZW5OYW1lXTogdGhyZXNob2xkcyB9IGJhc2UgdW5pdHNcbiAgICovXG4gIHRva2VuRmx1c2hUaHJlc2hvbGRzKCk6IGFueSB7XG4gICAgaWYgKHRoaXMuYmFzZUNvaW4uZ2V0RmFtaWx5KCkgIT09ICdldGgnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBzdXBwb3J0ZWQgZm9yIHRoaXMgd2FsbGV0Jyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93YWxsZXQuY29pblNwZWNpZmljLnRva2VuRmx1c2hUaHJlc2hvbGRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB3YWxsZXQgcHJvcGVydGllcyB3aGljaCBhcmUgc3BlY2lmaWMgdG8gY2VydGFpbiBjb2luIGltcGxlbWVudGF0aW9uc1xuICAgKi9cbiAgY29pblNwZWNpZmljKCk6IFdhbGxldENvaW5TcGVjaWZpYyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX3dhbGxldC5jb2luU3BlY2lmaWM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBwZW5kaW5nIGFwcHJvdmFscyBvbiB0aGlzIHdhbGxldFxuICAgKi9cbiAgcGVuZGluZ0FwcHJvdmFscygpOiBQZW5kaW5nQXBwcm92YWxbXSB7XG4gICAgcmV0dXJuIHRoaXMuX3dhbGxldC5wZW5kaW5nQXBwcm92YWxzLm1hcCgoY3VycmVudEFwcHJvdmFsKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFBlbmRpbmdBcHByb3ZhbCh0aGlzLmJpdGdvLCB0aGlzLmJhc2VDb2luLCBjdXJyZW50QXBwcm92YWwsIHRoaXMpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZnJlc2ggdGhlIHdhbGxldCBvYmplY3QgYnkgc3luY2luZyB3aXRoIHRoZSBiYWNrLWVuZFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7V2FsbGV0fVxuICAgKi9cbiAgcmVmcmVzaChwYXJhbXM6IHt9ID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFdhbGxldD4pOiBCbHVlYmlyZDxXYWxsZXQ+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288V2FsbGV0PihmdW5jdGlvbiAqKCkge1xuICAgICAgc2VsZi5fd2FsbGV0ID0geWllbGQgc2VsZi5iaXRnby5nZXQoc2VsZi51cmwoKSkucmVzdWx0KCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3QgdGhlIHRyYW5zYWN0aW9ucyBmb3IgYSBnaXZlbiB3YWxsZXRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICB0cmFuc2FjdGlvbnMocGFyYW1zOiBQYWdpbmF0aW9uT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3QgcXVlcnk6IFBhZ2luYXRpb25PcHRpb25zID0ge307XG5cbiAgICBpZiAocGFyYW1zLnByZXZJZCkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5wcmV2SWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwcmV2SWQgYXJndW1lbnQsIGV4cGVjdGluZyBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LnByZXZJZCA9IHBhcmFtcy5wcmV2SWQ7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5saW1pdCkge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy5saW1pdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGxpbWl0IGFyZ3VtZW50LCBleHBlY3RpbmcgbnVtYmVyJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5saW1pdCA9IHBhcmFtcy5saW1pdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5iaXRnby5nZXQodGhpcy5iYXNlQ29pbi51cmwoJy93YWxsZXQvJyArIHRoaXMuX3dhbGxldC5pZCArICcvdHgnKSlcbiAgICAgIC5xdWVyeShxdWVyeSlcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3QgdGhlIHRyYW5zYWN0aW9ucyBmb3IgYSBnaXZlbiB3YWxsZXRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiAgLSB0eEhhc2ggdGhlIHRyYW5zYWN0aW9uIGhhc2ggdG8gc2VhcmNoIGZvclxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBnZXRUcmFuc2FjdGlvbihwYXJhbXM6IEdldFRyYW5zYWN0aW9uT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd0eEhhc2gnXSwgW10sIGNhbGxiYWNrKTtcblxuICAgIGNvbnN0IHF1ZXJ5OiBQYWdpbmF0aW9uT3B0aW9ucyA9IHt9O1xuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMucHJldklkKSkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5wcmV2SWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwcmV2SWQgYXJndW1lbnQsIGV4cGVjdGluZyBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LnByZXZJZCA9IHBhcmFtcy5wcmV2SWQ7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5saW1pdCkpIHtcbiAgICAgIGlmICghXy5pc0ludGVnZXIocGFyYW1zLmxpbWl0KSB8fCBwYXJhbXMubGltaXQgPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBsaW1pdCBhcmd1bWVudCwgZXhwZWN0aW5nIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LmxpbWl0ID0gcGFyYW1zLmxpbWl0O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmJpdGdvLmdldCh0aGlzLnVybCgnL3R4LycgKyBwYXJhbXMudHhIYXNoKSlcbiAgICAgIC5xdWVyeShxdWVyeSlcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3QgdGhlIHRyYW5zZmVycyBmb3IgYSBnaXZlbiB3YWxsZXRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICB0cmFuc2ZlcnMocGFyYW1zOiBUcmFuc2ZlcnNPcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBxdWVyeTogVHJhbnNmZXJzT3B0aW9ucyA9IHt9O1xuICAgIGlmIChwYXJhbXMucHJldklkKSB7XG4gICAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnByZXZJZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHByZXZJZCBhcmd1bWVudCwgZXhwZWN0aW5nIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgcXVlcnkucHJldklkID0gcGFyYW1zLnByZXZJZDtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmxpbWl0KSB7XG4gICAgICBpZiAoIV8uaXNOdW1iZXIocGFyYW1zLmxpbWl0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbGltaXQgYXJndW1lbnQsIGV4cGVjdGluZyBudW1iZXInKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LmxpbWl0ID0gcGFyYW1zLmxpbWl0O1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuYWxsVG9rZW5zKSB7XG4gICAgICBpZiAoIV8uaXNCb29sZWFuKHBhcmFtcy5hbGxUb2tlbnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhbGxUb2tlbnMgYXJndW1lbnQsIGV4cGVjdGluZyBib29sZWFuJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5hbGxUb2tlbnMgPSBwYXJhbXMuYWxsVG9rZW5zO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuc2VhcmNoTGFiZWwpIHtcbiAgICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMuc2VhcmNoTGFiZWwpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzZWFyY2hMYWJlbCBhcmd1bWVudCwgZXhwZWN0aW5nIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgcXVlcnkuc2VhcmNoTGFiZWwgPSBwYXJhbXMuc2VhcmNoTGFiZWw7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5hZGRyZXNzKSB7XG4gICAgICBpZiAoIV8uaXNBcnJheShwYXJhbXMuYWRkcmVzcykgJiYgIV8uaXNTdHJpbmcocGFyYW1zLmFkZHJlc3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhZGRyZXNzIGFyZ3VtZW50LCBleHBlY3Rpbmcgc3RyaW5nIG9yIGFycmF5Jyk7XG4gICAgICB9XG4gICAgICBpZiAoXy5pc0FycmF5KHBhcmFtcy5hZGRyZXNzKSkge1xuICAgICAgICBwYXJhbXMuYWRkcmVzcy5mb3JFYWNoKGFkZHJlc3MgPT4ge1xuICAgICAgICAgIGlmICghXy5pc1N0cmluZyhhZGRyZXNzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFkZHJlc3MgYXJndW1lbnQsIGV4cGVjdGluZyBhcnJheSBvZiBhZGRyZXNzIHN0cmluZ3MnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcXVlcnkuYWRkcmVzcyA9IHBhcmFtcy5hZGRyZXNzO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuZGF0ZUd0ZSkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5kYXRlR3RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZGF0ZUd0ZSBhcmd1bWVudCwgZXhwZWN0aW5nIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgcXVlcnkuZGF0ZUd0ZSA9IHBhcmFtcy5kYXRlR3RlO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuZGF0ZUx0KSB7XG4gICAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLmRhdGVMdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGRhdGVMdCBhcmd1bWVudCwgZXhwZWN0aW5nIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgcXVlcnkuZGF0ZUx0ID0gcGFyYW1zLmRhdGVMdDtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNOaWwocGFyYW1zLnZhbHVlR3RlKSkge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy52YWx1ZUd0ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHZhbHVlR3RlIGFyZ3VtZW50LCBleHBlY3RpbmcgbnVtYmVyJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS52YWx1ZUd0ZSA9IHBhcmFtcy52YWx1ZUd0ZTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNOaWwocGFyYW1zLnZhbHVlTHQpKSB7XG4gICAgICBpZiAoIV8uaXNOdW1iZXIocGFyYW1zLnZhbHVlTHQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB2YWx1ZUx0IGFyZ3VtZW50LCBleHBlY3RpbmcgbnVtYmVyJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS52YWx1ZUx0ID0gcGFyYW1zLnZhbHVlTHQ7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzTmlsKHBhcmFtcy5pbmNsdWRlSGV4KSkge1xuICAgICAgaWYgKCFfLmlzQm9vbGVhbihwYXJhbXMuaW5jbHVkZUhleCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluY2x1ZGVIZXggYXJndW1lbnQsIGV4cGVjdGluZyBib29sZWFuJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5pbmNsdWRlSGV4ID0gcGFyYW1zLmluY2x1ZGVIZXg7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzTmlsKHBhcmFtcy5zdGF0ZSkpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXJhbXMuc3RhdGUpICYmICFfLmlzU3RyaW5nKHBhcmFtcy5zdGF0ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHN0YXRlIGFyZ3VtZW50LCBleHBlY3Rpbmcgc3RyaW5nIG9yIGFycmF5Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtcy5zdGF0ZSkpIHtcbiAgICAgICAgcGFyYW1zLnN0YXRlLmZvckVhY2goc3RhdGUgPT4ge1xuICAgICAgICAgIGlmICghXy5pc1N0cmluZyhzdGF0ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzdGF0ZSBhcmd1bWVudCwgZXhwZWN0aW5nIGFycmF5IG9mIHN0YXRlIHN0cmluZ3MnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcXVlcnkuc3RhdGUgPSBwYXJhbXMuc3RhdGU7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzTmlsKHBhcmFtcy50eXBlKSkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy50eXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdHlwZSBhcmd1bWVudCwgZXhwZWN0aW5nIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgcXVlcnkudHlwZSA9IHBhcmFtcy50eXBlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmJpdGdvLmdldCh0aGlzLnVybCgnL3RyYW5zZmVyJykpXG4gICAgICAucXVlcnkocXVlcnkpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdHJhbnNmZXJzIG9uIHRoaXMgd2FsbGV0XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBnZXRUcmFuc2ZlcihwYXJhbXM6IEdldFRyYW5zZmVyT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydpZCddLCBbXSwgY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHRoaXMuYml0Z28uZ2V0KHRoaXMudXJsKCcvdHJhbnNmZXIvJyArIHBhcmFtcy5pZCkpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB0cmFuc2FjdGlvbiBieSBzZXF1ZW5jZSBpZCBmb3IgYSBnaXZlbiB3YWxsZXRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHRyYW5zZmVyQnlTZXF1ZW5jZUlkKHBhcmFtczogVHJhbnNmZXJCeVNlcXVlbmNlSWRPcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3NlcXVlbmNlSWQnXSwgW10sIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiB0aGlzLmJpdGdvLmdldCh0aGlzLnVybCgnL3RyYW5zZmVyL3NlcXVlbmNlSWQvJyArIHBhcmFtcy5zZXF1ZW5jZUlkKSlcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWF4aW11bSBhbW91bnQgeW91IGNhbiBzcGVuZCBpbiBhIHNpbmdsZSB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gcGFyYW1ldGVycyBvYmplY3RcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5saW1pdCAtIG1heGltdW0gbnVtYmVyIG9mIHNlbGVjdGFibGUgdW5zcGVudHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5taW5WYWx1ZSAtIHRoZSBtaW5pbXVtIHZhbHVlIG9mIHVuc3BlbnRzIHRvIHVzZSBpbiBzYXRvc2hpc1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1heFZhbHVlIC0gdGhlIG1heGltdW0gdmFsdWUgb2YgdW5zcGVudHMgdG8gdXNlIGluIHNhdG9zaGlzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWluSGVpZ2h0IC0gdGhlIG1pbmltdW0gaGVpZ2h0IG9mIHVuc3BlbnRzIG9uIHRoZSBibG9jayBjaGFpbiB0byB1c2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5taW5Db25maXJtcyAtIGFsbCBzZWxlY3RlZCB1bnNwZW50cyB3aWxsIGhhdmUgYXQgbGVhc3QgdGhpcyBtYW55IGNvbmZpcm1hdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBwYXJhbXMuZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlIC0gRW5mb3JjZXMgbWluQ29uZmlybXMgb24gY2hhbmdlIGlucHV0c1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLmZlZVJhdGUgLSBmZWUgcmF0ZSB0byB1c2UgaW4gY2FsY3VsYXRpb24gb2YgbWF4aW11bSBzcGVuZGFibGUgaW4gc2F0b3NoaXMva0JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5tYXhGZWVSYXRlIC0gdXBwZXIgbGltaXQgZm9yIGZlZVJhdGUgaW4gc2F0b3NoaXMva0JcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5yZWNpcGllbnRBZGRyZXNzIC0gcmVjaXBpZW50IGFkZHJlc3NlcyBmb3IgYSBtb3JlIGFjY3VyYXRlIGNhbGN1bGF0aW9uIG9mIHRoZSBtYXhpbXVtIGF2YWlsYWJsZSB0byBzZW5kXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7e21heGltdW1TcGVuZGFibGU6IE51bWJlciwgY29pbjogU3RyaW5nfX1cbiAgICogTk9URSA6IGZlZVR4Q29uZmlybVRhcmdldCBvbWl0dGVkIG9uIHB1cnBvc2UgYmVjYXVzZSBnYXVnaW5nIHRoZSBtYXhpbXVtIHNwZW5kYWJsZSBhbW91bnQgd2l0aCBkeW5hbWljIGZlZXMgZG9lcyBub3QgbWFrZSBzZW5zZVxuICAgKi9cbiAgbWF4aW11bVNwZW5kYWJsZShwYXJhbXM6IE1heGltdW1TcGVuZGFibGVPcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPE1heGltdW1TcGVuZGFibGU+KTogQmx1ZWJpcmQ8TWF4aW11bVNwZW5kYWJsZT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxNYXhpbXVtU3BlbmRhYmxlPihmdW5jdGlvbiAqKCkge1xuICAgICAgY29uc3QgZmlsdGVyZWRQYXJhbXMgPSBfLnBpY2socGFyYW1zLCBbXG4gICAgICAgICdtaW5WYWx1ZScsICdtYXhWYWx1ZScsICdtaW5IZWlnaHQnLCAndGFyZ2V0JywgJ3BsYWluVGFyZ2V0JywgJ2xpbWl0JywgJ21pbkNvbmZpcm1zJyxcbiAgICAgICAgJ2VuZm9yY2VNaW5Db25maXJtc0ZvckNoYW5nZScsICdmZWVSYXRlJywgJ21heEZlZVJhdGUnLCAncmVjaXBpZW50QWRkcmVzcydcbiAgICAgIF0pO1xuXG4gICAgICByZXR1cm4gc2VsZi5iaXRnby5nZXQoc2VsZi51cmwoJy9tYXhpbXVtU3BlbmRhYmxlJykpXG4gICAgICAgIC5xdWVyeShmaWx0ZXJlZFBhcmFtcylcbiAgICAgICAgLnJlc3VsdCgpO1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdCB0aGUgdW5zcGVudHMgZm9yIGEgZ2l2ZW4gd2FsbGV0XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgdW5zcGVudHMocGFyYW1zOiBVbnNwZW50c09wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHF1ZXJ5ID0gXy5waWNrKHBhcmFtcywgWydwcmV2SWQnLCAnbGltaXQnLCAnbWluVmFsdWUnLCAnbWF4VmFsdWUnLCAnbWluSGVpZ2h0JywgJ21pbkNvbmZpcm1zJywgJ3RhcmdldCcsICdzZWd3aXQnLCAnY2hhaW5zJ10pO1xuXG4gICAgcmV0dXJuIHRoaXMuYml0Z28uZ2V0KHRoaXMudXJsKCcvdW5zcGVudHMnKSlcbiAgICAgIC5xdWVyeShxdWVyeSlcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnNvbGlkYXRlIG9yIGZhbm91dCB1bnNwZW50cyBvbiBhIHdhbGxldFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcm91dGVOYW1lIC0gZWl0aGVyIGBjb25zb2xpZGF0ZWAgb3IgYGZhbm91dGBcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIHBhcmFtZXRlcnMgb2JqZWN0XG4gICAqXG4gICAqIFdhbGxldCBwYXJhbWV0ZXJzOlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLndhbGxldFBhc3NwaHJhc2UgLSB0aGUgdXNlcnMgd2FsbGV0IHBhc3NwaHJhc2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy54cHJ2IC0gdGhlIHByaXZhdGUga2V5IGluIHN0cmluZyBmb3JtIGlmIHRoZSB3YWxsZXRQYXNzcGhyYXNlIGlzIG5vdCBhdmFpbGFibGVcbiAgICpcbiAgICogRmVlIHBhcmFtZXRlcnM6XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMuZmVlUmF0ZSAtIFRoZSBmZWUgcmF0ZSB0byB1c2UgZm9yIHRoZSBjb25zb2xpZGF0aW9uIGluIHNhdG9zaGlzL2tCXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWF4RmVlUmF0ZSAtIHVwcGVyIGxpbWl0IGZvciBmZWVSYXRlIGluIHNhdG9zaGlzL2tCXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWF4RmVlUGVyY2VudGFnZSAtIHRoZSBtYXhpbXVtIHJlbGF0aXZlIHBvcnRpb24gdGhhdCB5b3UncmUgd2lsbGluZyB0byBzcGVuZCB0b3dhcmRzIGZlZXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5mZWVUeENvbmZpcm1UYXJnZXQgLSBlc3RpbWF0ZSB0aGUgZmVlcyB0byBhaW0gZm9yIGZpcnN0IGNvbmZpcm1hdGlvbiB3aXRoIHRoaXMgbnVtYmVyIG9mIGJsb2Nrc1xuICAgKlxuICAgKiBJbnB1dCBwYXJhbWV0ZXJzOlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1pblZhbHVlIC0gdGhlIG1pbmltdW0gdmFsdWUgb2YgdW5zcGVudHMgdG8gdXNlIGluIHNhdG9zaGlzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWF4VmFsdWUgLSB0aGUgbWF4aW11bSB2YWx1ZSBvZiB1bnNwZW50cyB0byB1c2UgaW4gc2F0b3NoaXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5taW5IZWlnaHQgLSB0aGUgbWluaW11bSBoZWlnaHQgb2YgdW5zcGVudHMgb24gdGhlIGJsb2NrIGNoYWluIHRvIHVzZVxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1pbkNvbmZpcm1zIC0gYWxsIHNlbGVjdGVkIHVuc3BlbnRzIHdpbGwgaGF2ZSBhdCBsZWFzdCB0aGlzIG1hbnkgY29uZmlybWF0aW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHBhcmFtcy5lbmZvcmNlTWluQ29uZmlybXNGb3JDaGFuZ2UgLSBpZiB0cnVlLCBtaW5Db25maXJtcyBhbHNvIGFwcGxpZXMgdG8gY2hhbmdlIG91dHB1dHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5saW1pdCAgICAgICAgICAgICAgICBmb3Igcm91dGVOYW1lID09PSAnY29uc29saWRhdGUnXG4gICAqICAgICAgICAgICAgICAgICBwYXJhbXMubWF4TnVtVW5zcGVudHNUb1VzZSAgZm9yIHJvdXRlTmFtZSA9PT0gJ2Zhbm91dCdcbiAgICogICAgICAgICAgICAgICAgICAtIG1heGltdW0gbnVtYmVyIG9mIHVuc3BlbnRzIHlvdSB3YW50IHRvIHVzZSBpbiB0aGUgdHJhbnNhY3Rpb25cbiAgICogT3V0cHV0IHBhcmFtZXRlcnM6XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubnVtVW5zcGVudHNUb01ha2UgLSB0aGUgbnVtYmVyIG9mIG5ldyB1bnNwZW50cyB0byBtYWtlXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgcHJpdmF0ZSBtYW5hZ2VVbnNwZW50cyhyb3V0ZU5hbWU6IE1hbmFnZVVuc3BlbnRzLCBwYXJhbXM6IENvbnNvbGlkYXRlVW5zcGVudHNPcHRpb25zIHwgRmFub3V0VW5zcGVudHNPcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24gKigpIHtcbiAgICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbJ3dhbGxldFBhc3NwaHJhc2UnLCAneHBydiddLCBjYWxsYmFjayk7XG5cbiAgICAgIGNvbnN0IHJlcUlkID0gbmV3IFJlcXVlc3RUcmFjZXIoKTtcbiAgICAgIGNvbnN0IGZpbHRlcmVkUGFyYW1zID0gXy5waWNrKHBhcmFtcywgW1xuICAgICAgICAnZmVlUmF0ZScsXG4gICAgICAgICdtYXhGZWVSYXRlJyxcbiAgICAgICAgJ21heEZlZVBlcmNlbnRhZ2UnLFxuICAgICAgICAnZmVlVHhDb25maXJtVGFyZ2V0JyxcblxuICAgICAgICAnbWluVmFsdWUnLFxuICAgICAgICAnbWF4VmFsdWUnLFxuICAgICAgICAnbWluSGVpZ2h0JyxcbiAgICAgICAgJ21pbkNvbmZpcm1zJyxcbiAgICAgICAgJ2VuZm9yY2VNaW5Db25maXJtc0ZvckNoYW5nZScsXG5cbiAgICAgICAgcm91dGVOYW1lID09PSAnY29uc29saWRhdGUnID8gJ2xpbWl0JyA6ICdtYXhOdW1VbnNwZW50c1RvVXNlJyxcbiAgICAgICAgJ251bVVuc3BlbnRzVG9NYWtlJyxcbiAgICAgIF0pO1xuICAgICAgc2VsZi5iaXRnby5zZXRSZXF1ZXN0VHJhY2VyKHJlcUlkKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgc2VsZi5iaXRnby5wb3N0KHNlbGYudXJsKGAvJHtyb3V0ZU5hbWV9VW5zcGVudHNgKSlcbiAgICAgICAgLnNlbmQoZmlsdGVyZWRQYXJhbXMpXG4gICAgICAgIC5yZXN1bHQoKTtcblxuICAgICAgY29uc3Qga2V5Y2hhaW4gPSB5aWVsZCBzZWxmLmJhc2VDb2luLmtleWNoYWlucygpLmdldCh7IGlkOiBzZWxmLl93YWxsZXQua2V5c1swXSwgcmVxSWQgfSk7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvblBhcmFtcyA9IF8uZXh0ZW5kKHt9LCBwYXJhbXMsIHsgdHhQcmVidWlsZDogcmVzcG9uc2UsIGtleWNoYWluIH0pO1xuICAgICAgY29uc3Qgc2lnbmVkVHJhbnNhY3Rpb24gPSB5aWVsZCBzZWxmLnNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvblBhcmFtcyk7XG4gICAgICBjb25zdCBzZWxlY3RQYXJhbXMgPSBfLnBpY2socGFyYW1zLCBbJ2NvbW1lbnQnLCAnb3RwJ10pO1xuICAgICAgY29uc3QgZmluYWxUeFBhcmFtcyA9IF8uZXh0ZW5kKHt9LCBzaWduZWRUcmFuc2FjdGlvbiwgc2VsZWN0UGFyYW1zKTtcblxuICAgICAgc2VsZi5iaXRnby5zZXRSZXF1ZXN0VHJhY2VyKHJlcUlkKTtcbiAgICAgIHJldHVybiBzZWxmLmJpdGdvLnBvc3Qoc2VsZi5iYXNlQ29pbi51cmwoJy93YWxsZXQvJyArIHNlbGYuX3dhbGxldC5pZCArICcvdHgvc2VuZCcpKVxuICAgICAgICAuc2VuZChmaW5hbFR4UGFyYW1zKVxuICAgICAgICAucmVzdWx0KCk7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zb2xpZGF0ZSB1bnNwZW50cyBvbiBhIHdhbGxldFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gcGFyYW1ldGVycyBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlIC0gdGhlIHVzZXJzIHdhbGxldCBwYXNzcGhyYXNlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMueHBydiAtIHRoZSBwcml2YXRlIGtleSBpbiBzdHJpbmcgZm9ybSBpZiB0aGUgd2FsbGV0UGFzc3BocmFzZSBpcyBub3QgYXZhaWxhYmxlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMuZmVlUmF0ZSAtIFRoZSBmZWUgcmF0ZSB0byB1c2UgZm9yIHRoZSBjb25zb2xpZGF0aW9uIGluIHNhdG9zaGlzL2tCXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWF4RmVlUmF0ZSAtIHVwcGVyIGxpbWl0IGZvciBmZWVSYXRlIGluIHNhdG9zaGlzL2tCXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWF4RmVlUGVyY2VudGFnZSAtIHRoZSBtYXhpbXVtIHJlbGF0aXZlIHBvcnRpb24gdGhhdCB5b3UncmUgd2lsbGluZyB0byBzcGVuZCB0b3dhcmRzIGZlZXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5mZWVUeENvbmZpcm1UYXJnZXQgLSBlc3RpbWF0ZSB0aGUgZmVlcyB0byBhaW0gZm9yIGZpcnN0IGNvbmZpcm1hdGlvbiB3aXRoIHRoaXMgbnVtYmVyIG9mIGJsb2Nrc1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1pblZhbHVlIC0gdGhlIG1pbmltdW0gdmFsdWUgb2YgdW5zcGVudHMgdG8gdXNlIGluIHNhdG9zaGlzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWF4VmFsdWUgLSB0aGUgbWF4aW11bSB2YWx1ZSBvZiB1bnNwZW50cyB0byB1c2UgaW4gc2F0b3NoaXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5taW5IZWlnaHQgLSB0aGUgbWluaW11bSBoZWlnaHQgb2YgdW5zcGVudHMgb24gdGhlIGJsb2NrIGNoYWluIHRvIHVzZVxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1pbkNvbmZpcm1zIC0gYWxsIHNlbGVjdGVkIHVuc3BlbnRzIHdpbGwgaGF2ZSBhdCBsZWFzdCB0aGlzIG1hbnkgY29uZmlybWF0aW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHBhcmFtcy5lbmZvcmNlTWluQ29uZmlybXNGb3JDaGFuZ2UgLSBpZiB0cnVlLCBtaW5Db25maXJtcyBhbHNvIGFwcGxpZXMgdG8gY2hhbmdlIG91dHB1dHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5saW1pdCAgICAgICAgICAgICAgICBmb3Igcm91dGVOYW1lID09PSAnY29uc29saWRhdGUnXG4gICAqICAgICAgICAgICAgICAgICBwYXJhbXMubWF4TnVtVW5zcGVudHNUb1VzZSAgZm9yIHJvdXRlTmFtZSA9PT0gJ2Zhbm91dCdcbiAgICogICAgICAgICAgICAgICAgICAtIG1heGltdW0gbnVtYmVyIG9mIHVuc3BlbnRzIHlvdSB3YW50IHRvIHVzZSBpbiB0aGUgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5udW1VbnNwZW50c1RvTWFrZSAtIHRoZSBudW1iZXIgb2YgbmV3IHVuc3BlbnRzIHRvIG1ha2VcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBjb25zb2xpZGF0ZVVuc3BlbnRzKHBhcmFtczogQ29uc29saWRhdGVVbnNwZW50c09wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIHJldHVybiB0aGlzLm1hbmFnZVVuc3BlbnRzKCdjb25zb2xpZGF0ZScsIHBhcmFtcywgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEZhbm91dCB1bnNwZW50cyBvbiBhIHdhbGxldFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gcGFyYW1ldGVycyBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlIC0gdGhlIHVzZXJzIHdhbGxldCBwYXNzcGhyYXNlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMueHBydiAtIHRoZSBwcml2YXRlIGtleSBpbiBzdHJpbmcgZm9ybSBpZiB0aGUgd2FsbGV0UGFzc3BocmFzZSBpcyBub3QgYXZhaWxhYmxlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWluVmFsdWUgLSB0aGUgbWluaW11bSB2YWx1ZSBvZiB1bnNwZW50cyB0byB1c2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5tYXhWYWx1ZSAtIHRoZSBtYXhpbXVtIHZhbHVlIG9mIHVuc3BlbnRzIHRvIHVzZVxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1pbkhlaWdodCAtIHRoZSBtaW5pbXVtIGhlaWdodCBvZiB1bnNwZW50cyBvbiB0aGUgYmxvY2sgY2hhaW4gdG8gdXNlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWluQ29uZmlybXMgLSBhbGwgc2VsZWN0ZWQgdW5zcGVudHMgd2lsbCBoYXZlIGF0IGxlYXN0IHRoaXMgbWFueSBjb25maXJtYXRpb25zXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWF4RmVlUGVyY2VudGFnZSAtIHRoZSBtYXhpbXVtIHByb3BvcnRpb24gb2YgYW4gdW5zcGVudCB5b3UgYXJlIHdpbGxpbmcgdG8gbG9zZSB0byBmZWVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMuZmVlVHhDb25maXJtVGFyZ2V0IC0gZXN0aW1hdGUgdGhlIGZlZXMgdG8gYWltIGZvciBmaXJzdCBjb25maXJtYXRpb24gd2l0aCB0aGlzIG51bWJlciBvZiBibG9ja3NcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5mZWVSYXRlIC0gVGhlIGRlc2lyZWQgZmVlIHJhdGUgZm9yIHRoZSB0cmFuc2FjdGlvbiBpbiBzYXRvc2hpcy9rQlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1heEZlZVJhdGUgLSBUaGUgbWF4IGxpbWl0IGZvciBhIGZlZSByYXRlIGluIHNhdG9zaGlzL2tCXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWF4TnVtSW5wdXRzVG9Vc2UgLSB0aGUgbnVtYmVyIG9mIHVuc3BlbnRzIHlvdSB3YW50IHRvIHVzZSBpbiB0aGUgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5udW1VbnNwZW50c1RvTWFrZSAtIHRoZSBudW1iZXIgb2YgbmV3IHVuc3BlbnRzIHRvIG1ha2VcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBmYW5vdXRVbnNwZW50cyhwYXJhbXM6IEZhbm91dFVuc3BlbnRzT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMubWFuYWdlVW5zcGVudHMoJ2Zhbm91dCcsIHBhcmFtcywgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdG9rZW4gZmx1c2ggdGhyZXNob2xkcyBmb3IgdGhlIHdhbGxldC4gVXBkYXRlcyB0aGUgd2FsbGV0LlxuICAgKiBUb2tlbnMgd2lsbCBvbmx5IGJlIGZsdXNoZWQgZnJvbSBmb3J3YXJkZXIgY29udHJhY3RzIGlmIHRoZSBiYWxhbmNlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdGhyZXNob2xkIGRlZmluZWQgaGVyZS5cbiAgICogQHBhcmFtIHRocmVzaG9sZHMge09iamVjdH0gLSBwYWlycyBvZiB7IFt0b2tlbk5hbWVdOiB0aHJlc2hvbGQgfSAoYmFzZSB1bml0cylcbiAgICogQHBhcmFtIFtjYWxsYmFja11cbiAgICovXG4gIHVwZGF0ZVRva2VuRmx1c2hUaHJlc2hvbGRzKHRocmVzaG9sZHM6IGFueSA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uICooKSB7XG4gICAgICBpZiAoc2VsZi5iYXNlQ29pbi5nZXRGYW1pbHkoKSAhPT0gJ2V0aCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3Qgc3VwcG9ydGVkIGZvciB0aGlzIHdhbGxldCcpO1xuICAgICAgfVxuXG4gICAgICBzZWxmLl93YWxsZXQgPSB5aWVsZCBzZWxmLmJpdGdvLnB1dChzZWxmLnVybCgpKS5zZW5kKHtcbiAgICAgICAgdG9rZW5GbHVzaFRocmVzaG9sZHM6IHRocmVzaG9sZHNcbiAgICAgIH0pLnJlc3VsdCgpO1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogU3dlZXAgZnVuZHMgZm9yIGEgd2FsbGV0XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBwYXJhbWV0ZXJzIG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLmFkZHJlc3MgLSBUaGUgYWRkcmVzcyB0byBzZW5kIGFsbCB0aGUgZnVuZHMgaW4gdGhlIHdhbGxldCB0b1xuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLndhbGxldFBhc3NwaHJhc2UgLSB0aGUgdXNlcnMgd2FsbGV0IHBhc3NwaHJhc2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy54cHJ2IC0gdGhlIHByaXZhdGUga2V5IGluIHN0cmluZyBmb3JtIGlmIHRoZSB3YWxsZXRQYXNzcGhyYXNlIGlzIG5vdCBhdmFpbGFibGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5vdHAgLSBUd28gZmFjdG9yIGF1dGggY29kZSB0byBlbmFibGUgc2VuZGluZyB0aGUgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5mZWVUeENvbmZpcm1UYXJnZXQgLSBFc3RpbWF0ZSB0aGUgZmVlcyB0byBhaW0gZm9yIGZpcnN0IGNvbmZpcm1hdGlvbiB3aXRoaW4gdGhpcyBudW1iZXIgb2YgYmxvY2tzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMuZmVlUmF0ZSAtIFRoZSBkZXNpcmVkIGZlZSByYXRlIGZvciB0aGUgdHJhbnNhY3Rpb24gaW4gc2F0b3NoaXMva0JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMubWF4RmVlUmF0ZV0gLSB1cHBlciBsaW1pdCBmb3IgZmVlUmF0ZSBpbiBzYXRvc2hpcy9rQlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbXMuYWxsb3dQYXJ0aWFsU3dlZXBdIC0gYWxsb3dzIHN3ZWVwaW5nIDIwMCB1bnNwZW50cyB3aGVuIHRoZSB3YWxsZXQgaGFzIG1vcmUgdGhhbiB0aGF0XG4gICAqIEBwYXJhbSBbY2FsbGJhY2tdXG4gICAqIEByZXR1cm5zIHR4SGV4IHtTdHJpbmd9IHRoZSB0eEhleCBvZiB0aGUgc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAqL1xuICBzd2VlcChwYXJhbXM6IFN3ZWVwT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uICooKSB7XG4gICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ2FkZHJlc3MnXSwgWyd3YWxsZXRQYXNzcGhyYXNlJywgJ3hwcnYnLCAnb3RwJ10sIGNhbGxiYWNrKTtcblxuICAgICAgaWYgKFsnZXRoJywgJ3hycCddLmluY2x1ZGVzKHNlbGYuYmFzZUNvaW4uZ2V0RmFtaWx5KCkpKSB7XG4gICAgICAgIGlmIChzZWxmLmNvbmZpcm1lZEJhbGFuY2VTdHJpbmcoKSAhPT0gc2VsZi5iYWxhbmNlU3RyaW5nKCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBzd2VlcCB3aGVuIHVuY29uZmlybWVkIGZ1bmRzIGV4aXN0IG9uIHRoZSB3YWxsZXQsIHBsZWFzZSB3YWl0IHVudGlsIGFsbCBpbmJvdW5kIHRyYW5zYWN0aW9ucyBjb25maXJtJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YWx1ZSA9IHNlbGYuc3BlbmRhYmxlQmFsYW5jZVN0cmluZygpO1xuICAgICAgICBpZiAoXy5pc1VuZGVmaW5lZCh2YWx1ZSkgfHwgdmFsdWUgPT09ICcwJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gZnVuZHMgdG8gc3dlZXAnKTtcbiAgICAgICAgfVxuICAgICAgICAocGFyYW1zIGFzIGFueSkucmVjaXBpZW50cyA9IFt7XG4gICAgICAgICAgYWRkcmVzczogcGFyYW1zLmFkZHJlc3MsXG4gICAgICAgICAgYW1vdW50OiB2YWx1ZSxcbiAgICAgICAgfV07XG5cbiAgICAgICAgcmV0dXJuIHNlbGYuc2VuZE1hbnkocGFyYW1zKTtcbiAgICAgIH1cbiAgICAgIC8vIHRoZSBmb2xsb3dpbmcgZmxvdyB3b3JrcyBmb3IgYWxsIFVUWE8gY29pbnNcblxuICAgICAgY29uc3QgcmVxSWQgPSBuZXcgUmVxdWVzdFRyYWNlcigpO1xuICAgICAgY29uc3QgZmlsdGVyZWRQYXJhbXMgPSBfLnBpY2socGFyYW1zLCBbJ2FkZHJlc3MnLCAnZmVlUmF0ZScsICdtYXhGZWVSYXRlJywgJ2ZlZVR4Q29uZmlybVRhcmdldCcsICdhbGxvd1BhcnRpYWxTd2VlcCddKTtcbiAgICAgIHNlbGYuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihyZXFJZCk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHNlbGYuYml0Z28ucG9zdChzZWxmLnVybCgnL3N3ZWVwV2FsbGV0JykpXG4gICAgICAgIC5zZW5kKGZpbHRlcmVkUGFyYW1zKVxuICAgICAgICAucmVzdWx0KCk7XG4gICAgICAvLyBUT0RPKEJHLTM1ODgpOiBhZGQgdHhIZXggdmFsaWRhdGlvbiB0byBwcm90ZWN0IG1hbiBpbiB0aGUgbWlkZGxlIGF0dGFja3MgcmVwbGFjaW5nIHRoZSB0eEhleFxuXG4gICAgICBjb25zdCBrZXljaGFpbiA9IHlpZWxkIHNlbGYuYmFzZUNvaW4ua2V5Y2hhaW5zKCkuZ2V0KHsgaWQ6IHNlbGYuX3dhbGxldC5rZXlzWzBdLCByZXFJZCB9KTtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uUGFyYW1zID0gXy5leHRlbmQoe30sIHBhcmFtcywgeyB0eFByZWJ1aWxkOiByZXNwb25zZSwga2V5Y2hhaW46IGtleWNoYWluLCBwcnY6IHBhcmFtcy54cHJ2IH0pO1xuICAgICAgY29uc3Qgc2lnbmVkVHJhbnNhY3Rpb24gPSB5aWVsZCBzZWxmLnNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvblBhcmFtcyk7XG5cbiAgICAgIGNvbnN0IHNlbGVjdFBhcmFtcyA9IF8ucGljayhwYXJhbXMsIFsnb3RwJ10pO1xuICAgICAgY29uc3QgZmluYWxUeFBhcmFtcyA9IF8uZXh0ZW5kKHt9LCBzaWduZWRUcmFuc2FjdGlvbiwgc2VsZWN0UGFyYW1zKTtcbiAgICAgIHNlbGYuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihyZXFJZCk7XG4gICAgICByZXR1cm4gc2VsZi5iaXRnby5wb3N0KHNlbGYuYmFzZUNvaW4udXJsKCcvd2FsbGV0LycgKyBzZWxmLl93YWxsZXQuaWQgKyAnL3R4L3NlbmQnKSlcbiAgICAgICAgLnNlbmQoZmluYWxUeFBhcmFtcylcbiAgICAgICAgLnJlc3VsdCgpO1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogRnJlZXplIGEgZ2l2ZW4gd2FsbGV0XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgZnJlZXplKHBhcmFtczogRnJlZXplT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbXSwgY2FsbGJhY2spO1xuXG4gICAgaWYgKHBhcmFtcy5kdXJhdGlvbikge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy5kdXJhdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGR1cmF0aW9uOiBzaG91bGQgYmUgbnVtYmVyIG9mIHNlY29uZHMnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5iaXRnby5wb3N0KHRoaXMudXJsKCcvZnJlZXplJykpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgY29tbWVudCBvZiBhIHRyYW5zZmVyXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgdHJhbnNmZXJDb21tZW50KHBhcmFtczogVHJhbnNmZXJDb21tZW50T3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydpZCddLCBbJ2NvbW1lbnQnXSwgY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHRoaXMuYml0Z28ucG9zdCh0aGlzLmJhc2VDb2luLnVybCgnL3dhbGxldC8nICsgdGhpcy5fd2FsbGV0LmlkICsgJy90cmFuc2Zlci8nICsgcGFyYW1zLmlkICsgJy9jb21tZW50JykpXG4gICAgICAuc2VuZChwYXJhbXMpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IHRoZSBhZGRyZXNzZXMgZm9yIGEgZ2l2ZW4gd2FsbGV0XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgYWRkcmVzc2VzKHBhcmFtczogQWRkcmVzc2VzT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFtdLCBjYWxsYmFjayk7XG5cbiAgICBjb25zdCBxdWVyeTogQWRkcmVzc2VzT3B0aW9ucyA9IHt9O1xuXG4gICAgaWYgKHBhcmFtcy5taW5lKSB7XG4gICAgICBxdWVyeS5taW5lID0gISFwYXJhbXMubWluZTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLnByZXZJZCkpIHtcbiAgICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMucHJldklkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJldklkIGFyZ3VtZW50LCBleHBlY3Rpbmcgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5wcmV2SWQgPSBwYXJhbXMucHJldklkO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuc29ydCkge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy5zb3J0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc29ydCBhcmd1bWVudCwgZXhwZWN0aW5nIG51bWJlcicpO1xuICAgICAgfVxuICAgICAgcXVlcnkuc29ydCA9IHBhcmFtcy5zb3J0O1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMubGltaXQpIHtcbiAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMubGltaXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBsaW1pdCBhcmd1bWVudCwgZXhwZWN0aW5nIG51bWJlcicpO1xuICAgICAgfVxuICAgICAgcXVlcnkubGltaXQgPSBwYXJhbXMubGltaXQ7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5sYWJlbENvbnRhaW5zKSB7XG4gICAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLmxhYmVsQ29udGFpbnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBsYWJlbENvbnRhaW5zIGFyZ3VtZW50LCBleHBlY3Rpbmcgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5sYWJlbENvbnRhaW5zID0gcGFyYW1zLmxhYmVsQ29udGFpbnM7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5zZWd3aXQpKSB7XG4gICAgICBpZiAoIV8uaXNCb29sZWFuKHBhcmFtcy5zZWd3aXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzZWd3aXQgYXJndW1lbnQsIGV4cGVjdGluZyBib29sZWFuJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5zZWd3aXQgPSBwYXJhbXMuc2Vnd2l0O1xuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuY2hhaW5zKSkge1xuICAgICAgaWYgKCFfLmlzQXJyYXkocGFyYW1zLmNoYWlucykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNoYWlucyBhcmd1bWVudCwgZXhwZWN0aW5nIGFycmF5IG9mIG51bWJlcnMnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LmNoYWlucyA9IHBhcmFtcy5jaGFpbnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYml0Z28uZ2V0KHRoaXMuYmFzZUNvaW4udXJsKCcvd2FsbGV0LycgKyB0aGlzLl93YWxsZXQuaWQgKyAnL2FkZHJlc3NlcycpKVxuICAgICAgLnF1ZXJ5KHF1ZXJ5KVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgc2luZ2xlIHdhbGxldCBhZGRyZXNzIGJ5IGl0cyBpZFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGdldEFkZHJlc3MocGFyYW1zOiBHZXRBZGRyZXNzT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFsnYWRkcmVzcycsICdpZCddLCBjYWxsYmFjayk7XG4gICAgbGV0IHF1ZXJ5O1xuICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5hZGRyZXNzKSAmJiBfLmlzVW5kZWZpbmVkKHBhcmFtcy5pZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYWRkcmVzcyBvciBpZCBvZiBhZGRyZXNzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMuYWRkcmVzcykge1xuICAgICAgcXVlcnkgPSBwYXJhbXMuYWRkcmVzcztcbiAgICB9IGVsc2Uge1xuICAgICAgcXVlcnkgPSBwYXJhbXMuaWQ7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5yZXFJZCkge1xuICAgICAgdGhpcy5iaXRnby5zZXRSZXF1ZXN0VHJhY2VyKHBhcmFtcy5yZXFJZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYml0Z28uZ2V0KHRoaXMuYmFzZUNvaW4udXJsKGAvd2FsbGV0LyR7dGhpcy5fd2FsbGV0LmlkfS9hZGRyZXNzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHF1ZXJ5KX1gKSlcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBvbmUgb3IgbW9yZSBuZXcgYWRkcmVzcyhlcykgZm9yIHVzZSB3aXRoIHRoaXMgd2FsbGV0LlxuICAgKlxuICAgKiBJZiB0aGUgYGNvdW50YCBmaWVsZCBpcyBkZWZpbmVkIGFuZCBncmVhdGVyIHRoYW4gMSwgYW4gb2JqZWN0IHdpdGggYSBzaW5nbGVcbiAgICogYXJyYXkgcHJvcGVydHkgbmFtZWQgYGFkZHJlc3Nlc2AgY29udGFpbmluZyBgY291bnRgIGFkZHJlc3Mgb2JqZWN0c1xuICAgKiB3aWxsIGJlIHJldHVybmVkLiBPdGhlcndpc2UsIGEgc2luZ2xlIGFkZHJlc3Mgb2JqZWN0IGlzIHJldHVybmVkLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMuY2hhaW4gb24gd2hpY2ggdGhlIG5ldyBhZGRyZXNzIHNob3VsZCBiZSBjcmVhdGVkXG4gICAqIEBwYXJhbSB7KE51bWJlcnxTdHJpbmcpfSBwYXJhbXMuZ2FzUHJpY2UgZ2FzIHByaWNlIGZvciBuZXcgYWRkcmVzcyBjcmVhdGlvbiwgaWYgYXBwbGljYWJsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLmxhYmVsIGxhYmVsIGZvciB0aGUgbmV3IGFkZHJlc3MoZXMpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMuY291bnQ9MSBudW1iZXIgb2YgbmV3IGFkZHJlc3NlcyB3aGljaCBzaG91bGQgYmUgY3JlYXRlZCAobWF4aW11bSAyNTApXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFyYW1zLmxvd1ByaW9yaXR5IEV0aGVyZXVtLXNwZWNpZmljIHBhcmFtIHRvIGNyZWF0ZSBhZGRyZXNzIHVzaW5nIGxvdyBwcmlvcml0eSBmZWUgYWRkcmVzc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGNyZWF0ZUFkZHJlc3MocGFyYW1zOiBDcmVhdGVBZGRyZXNzT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uICooKSB7XG4gICAgICBjb25zdCBhZGRyZXNzUGFyYW1zOiBDcmVhdGVBZGRyZXNzT3B0aW9ucyA9IHt9O1xuICAgICAgY29uc3QgcmVxSWQgPSBuZXcgUmVxdWVzdFRyYWNlcigpO1xuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGNoYWluLFxuICAgICAgICBnYXNQcmljZSxcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGxvd1ByaW9yaXR5LFxuICAgICAgICBjb3VudCA9IDEsXG4gICAgICB9ID0gcGFyYW1zO1xuXG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQoY2hhaW4pKSB7XG4gICAgICAgIGlmICghXy5pc0ludGVnZXIoY2hhaW4pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGFpbiBoYXMgdG8gYmUgYW4gaW50ZWdlcicpO1xuICAgICAgICB9XG4gICAgICAgIGFkZHJlc3NQYXJhbXMuY2hhaW4gPSBjaGFpbjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKGdhc1ByaWNlKSkge1xuICAgICAgICBpZiAoIV8uaXNJbnRlZ2VyKGdhc1ByaWNlKSAmJiAoaXNOYU4oTnVtYmVyKGdhc1ByaWNlKSkgfHwgIV8uaXNTdHJpbmcoZ2FzUHJpY2UpKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZ2FzUHJpY2UgaGFzIHRvIGJlIGFuIGludGVnZXIgb3IgbnVtZXJpYyBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRyZXNzUGFyYW1zLmdhc1ByaWNlID0gZ2FzUHJpY2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghXy5pc1VuZGVmaW5lZChsYWJlbCkpIHtcbiAgICAgICAgaWYgKCFfLmlzU3RyaW5nKGxhYmVsKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbGFiZWwgaGFzIHRvIGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkcmVzc1BhcmFtcy5sYWJlbCA9IGxhYmVsO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV8uaXNJbnRlZ2VyKGNvdW50KSB8fCBjb3VudCA8PSAwIHx8IGNvdW50ID4gMjUwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bnQgaGFzIHRvIGJlIGEgbnVtYmVyIGJldHdlZW4gMSBhbmQgMjUwJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghXy5pc1VuZGVmaW5lZChsb3dQcmlvcml0eSkpIHtcbiAgICAgICAgaWYgKCFfLmlzQm9vbGVhbihsb3dQcmlvcml0eSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xvd1ByaW9yaXR5IGhhcyB0byBiZSBhIGJvb2xlYW4nKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRyZXNzUGFyYW1zLmxvd1ByaW9yaXR5ID0gbG93UHJpb3JpdHk7XG4gICAgICB9XG5cbiAgICAgIC8vIGdldCBrZXljaGFpbnMgZm9yIGFkZHJlc3MgdmVyaWZpY2F0aW9uXG4gICAgICBjb25zdCBrZXljaGFpbnMgPSB5aWVsZCBCbHVlYmlyZC5tYXAoc2VsZi5fd2FsbGV0LmtleXMgYXMgc3RyaW5nW10sXG4gICAgICAgIGsgPT4gc2VsZi5iYXNlQ29pbi5rZXljaGFpbnMoKS5nZXQoeyBpZDogaywgcmVxSWQgfSlcbiAgICAgICk7XG4gICAgICBjb25zdCByb290QWRkcmVzcyA9IF8uZ2V0KHNlbGYuX3dhbGxldCwgJ3JlY2VpdmVBZGRyZXNzLmFkZHJlc3MnKTtcblxuICAgICAgY29uc3QgbmV3QWRkcmVzc2VzID0gXy50aW1lcyhjb3VudCwgY28oZnVuY3Rpb24gKmNyZWF0ZUFuZFZlcmlmeUFkZHJlc3MoKSB7XG4gICAgICAgIHNlbGYuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihyZXFJZCk7XG4gICAgICAgIGNvbnN0IG5ld0FkZHJlc3MgPSB5aWVsZCBzZWxmLmJpdGdvLnBvc3Qoc2VsZi5iYXNlQ29pbi51cmwoJy93YWxsZXQvJyArIHNlbGYuX3dhbGxldC5pZCArICcvYWRkcmVzcycpKVxuICAgICAgICAgIC5zZW5kKGFkZHJlc3NQYXJhbXMpXG4gICAgICAgICAgLnJlc3VsdCgpO1xuXG4gICAgICAgIC8vIGluZmVyIGl0cyBhZGRyZXNzIHR5cGVcbiAgICAgICAgaWYgKF8uaXNPYmplY3QobmV3QWRkcmVzcy5jb2luU3BlY2lmaWMpKSB7XG4gICAgICAgICAgLy8gbmVlZCBkeW5hbWljIGltcG9ydCB0byBicmVhayBjaXJjdWxhciBkZXBlbmRlbmN5LCB0aGlzIGlzIHVnbHlcbiAgICAgICAgICBjb25zdCB7IEFic3RyYWN0VXR4b0NvaW4gfSA9IHJlcXVpcmUoJy4vY29pbnMvYWJzdHJhY3RVdHhvQ29pbicpO1xuICAgICAgICAgIG5ld0FkZHJlc3MuYWRkcmVzc1R5cGUgPSBBYnN0cmFjdFV0eG9Db2luLmluZmVyQWRkcmVzc1R5cGUobmV3QWRkcmVzcyk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdBZGRyZXNzLmtleWNoYWlucyA9IGtleWNoYWlucztcbiAgICAgICAgY29uc3QgdmVyaWZpY2F0aW9uRGF0YSA9IF8ubWVyZ2Uoe30sIG5ld0FkZHJlc3MsIHsgcm9vdEFkZHJlc3MgfSk7XG5cbiAgICAgICAgaWYgKHZlcmlmaWNhdGlvbkRhdGEuZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQWRkcmVzc0dlbmVyYXRpb25FcnJvcih2ZXJpZmljYXRpb25EYXRhLmVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuYmFzZUNvaW4udmVyaWZ5QWRkcmVzcyh2ZXJpZmljYXRpb25EYXRhKTtcblxuICAgICAgICByZXR1cm4gbmV3QWRkcmVzcztcbiAgICAgIH0pLmJpbmQodGhpcykpO1xuXG4gICAgICBpZiAobmV3QWRkcmVzc2VzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gbmV3QWRkcmVzc2VzWzBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzZXM6IHlpZWxkIFByb21pc2UuYWxsKG5ld0FkZHJlc3NlcyksXG4gICAgICB9O1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHByb3BlcnRpZXMgb24gYW4gYWRkcmVzc1xuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHVwZGF0ZUFkZHJlc3MocGFyYW1zOiBVcGRhdGVBZGRyZXNzT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uICooKSB7XG4gICAgICBjb25zdCBhZGRyZXNzID0gcGFyYW1zLmFkZHJlc3M7XG5cbiAgICAgIGlmICghXy5pc1N0cmluZyhhZGRyZXNzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgc3RyaW5nIHBhcmFtZXRlciBhZGRyZXNzJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHB1dFBhcmFtcyA9IF8ucGljayhwYXJhbXMsIFsnbGFiZWwnXSk7XG4gICAgICBjb25zdCB1cmwgPSBzZWxmLnVybCgnL2FkZHJlc3MvJyArIGVuY29kZVVSSUNvbXBvbmVudChhZGRyZXNzKSk7XG5cbiAgICAgIHJldHVybiBzZWxmLmJpdGdvLnB1dCh1cmwpLnNlbmQocHV0UGFyYW1zKS5yZXN1bHQoKTtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3Qgd2ViaG9va3Mgb24gdGhpcyB3YWxsZXRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGxpc3RXZWJob29rcyhwYXJhbXM6IFBhZ2luYXRpb25PcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBxdWVyeTogUGFnaW5hdGlvbk9wdGlvbnMgPSB7fTtcbiAgICBpZiAocGFyYW1zLnByZXZJZCkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5wcmV2SWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwcmV2SWQgYXJndW1lbnQsIGV4cGVjdGluZyBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LnByZXZJZCA9IHBhcmFtcy5wcmV2SWQ7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5saW1pdCkge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy5saW1pdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGxpbWl0IGFyZ3VtZW50LCBleHBlY3RpbmcgbnVtYmVyJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5saW1pdCA9IHBhcmFtcy5saW1pdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5iaXRnby5nZXQodGhpcy51cmwoJy93ZWJob29rcycpKVxuICAgICAgLnF1ZXJ5KHF1ZXJ5KVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogU2ltdWxhdGUgd2FsbGV0IHdlYmhvb2ssIGN1cnJlbnRseSBmb3Igd2ViaG9va3Mgb2YgdHlwZSB0cmFuc2ZlciBhbmQgcGVuZGluZyBhcHByb3ZhbFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIC0gd2ViaG9va0lkIChyZXF1aXJlZCkgaWQgb2YgdGhlIHdlYmhvb2sgdG8gYmUgc2ltdWxhdGVkXG4gICAqIC0gdHJhbnNmZXJJZCAob3B0aW9uYWwgYnV0IHJlcXVpcmVkIGZvciB0cmFuc2ZlciB3ZWJob29rcykgaWQgb2YgdGhlIHNpbXVsYXRlZCB0cmFuc2ZlclxuICAgKiAtIHBlbmRpbmdBcHByb3ZhbElkIChvcHRpb25hbCBidXQgcmVxdWlyZWQgZm9yIHBlbmRpbmcgYXBwcm92YWwgd2ViaG9va3MpIGlkIG9mIHRoZSBzaW11bGF0ZWQgcGVuZGluZyBhcHByb3ZhbFxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBzaW11bGF0ZVdlYmhvb2socGFyYW1zOiBTaW11bGF0ZVdlYmhvb2tPcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3dlYmhvb2tJZCddLCBbJ3RyYW5zZmVySWQnLCAncGVuZGluZ0FwcHJvdmFsSWQnXSwgY2FsbGJhY2spO1xuXG4gICAgY29uc3QgaGFzVHJhbnNmZXJJZCA9ICEhcGFyYW1zLnRyYW5zZmVySWQ7XG4gICAgY29uc3QgaGFzUGVuZGluZ0FwcHJvdmFsSWQgPSAhIXBhcmFtcy5wZW5kaW5nQXBwcm92YWxJZDtcbiAgICBpZiAoIWhhc1RyYW5zZmVySWQgJiYgIWhhc1BlbmRpbmdBcHByb3ZhbElkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3Qgc3VwcGx5IGVpdGhlciB0cmFuc2ZlcklkIG9yIHBlbmRpbmdBcHByb3ZhbElkJyk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1RyYW5zZmVySWQgJiYgaGFzUGVuZGluZ0FwcHJvdmFsSWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBzdXBwbHkgZWl0aGVyIHRyYW5zZmVySWQgb3IgcGVuZGluZ0FwcHJvdmFsSWQsIGJ1dCBub3QgYm90aCcpO1xuICAgIH1cblxuICAgIC8vIGRlcGVuZGluZyBvbiB0aGUgY29pbiB0eXBlIG9mIHRoZSB3YWxsZXQsIHRoZSB0eEhhc2ggaGFzIHRvIGFkaGVyZSB0byBpdHMgcmVzcGVjdGl2ZSBmb3JtYXRcbiAgICAvLyBidXQgdGhlIHNlcnZlciB0YWtlcyBjYXJlIG9mIHRoYXRcblxuICAgIC8vIG9ubHkgdGFrZSB0aGUgdHJhbnNmZXJJZCBhbmQgcGVuZGluZ0FwcHJvdmFsSWQgcHJvcGVydGllc1xuICAgIGNvbnN0IGZpbHRlcmVkUGFyYW1zID0gXy5waWNrKHBhcmFtcywgWyd0cmFuc2ZlcklkJywgJ3BlbmRpbmdBcHByb3ZhbElkJ10pO1xuXG4gICAgY29uc3Qgd2ViaG9va0lkID0gcGFyYW1zLndlYmhvb2tJZDtcbiAgICByZXR1cm4gdGhpcy5iaXRnby5wb3N0KHRoaXMudXJsKCcvd2ViaG9va3MvJyArIHdlYmhvb2tJZCArICcvc2ltdWxhdGUnKSlcbiAgICAgIC5zZW5kKGZpbHRlcmVkUGFyYW1zKVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgd2ViaG9vayB0byB0aGlzIHdhbGxldFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgYWRkV2ViaG9vayhwYXJhbXM6IE1vZGlmeVdlYmhvb2tPcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3VybCcsICd0eXBlJ10sIFtdLCBjYWxsYmFjayk7XG5cbiAgICByZXR1cm4gdGhpcy5iaXRnby5wb3N0KHRoaXMudXJsKCcvd2ViaG9va3MnKSlcbiAgICAgIC5zZW5kKHBhcmFtcylcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHdlYmhvb2sgZnJvbSB0aGlzIHdhbGxldFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgcmVtb3ZlV2ViaG9vayhwYXJhbXM6IE1vZGlmeVdlYmhvb2tPcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3VybCcsICd0eXBlJ10sIFtdLCBjYWxsYmFjayk7XG5cbiAgICByZXR1cm4gdGhpcy5iaXRnby5kZWwodGhpcy51cmwoJy93ZWJob29rcycpKVxuICAgICAgLnNlbmQocGFyYW1zKVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdXNlciBrZXkgY2hhaW4gZm9yIHRoaXMgd2FsbGV0XG4gICAqXG4gICAqIFRoZSB1c2VyIGtleSBjaGFpbiBpcyB0aGUgZmlyc3Qga2V5Y2hhaW4gb2YgdGhlIHdhbGxldCBhbmQgdXN1YWxseSBoYXMgdGhlIGVuY3J5cHRlZCBwcnYgc3RvcmVkIG9uIEJpdEdvLlxuICAgKiBVc2VmdWwgd2hlbiB0cnlpbmcgdG8gZ2V0IHRoZSB1c2Vycycga2V5Y2hhaW4gZnJvbSB0aGUgc2VydmVyIGJlZm9yZSBkZWNyeXB0aW5nIHRvIHNpZ24gYSB0cmFuc2FjdGlvbi5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGdldEVuY3J5cHRlZFVzZXJLZXljaGFpbihwYXJhbXM6IHt9ID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCB0cnlLZXlDaGFpbiA9IGNvKGZ1bmN0aW9uICooaW5kZXg6IG51bWJlcikge1xuICAgICAgaWYgKCFzZWxmLl93YWxsZXQua2V5cyB8fCBpbmRleCA+PSBzZWxmLl93YWxsZXQua2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBlbmNyeXB0ZWQga2V5Y2hhaW5zIG9uIHRoaXMgd2FsbGV0LicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJhbXMgPSB7IGlkOiBzZWxmLl93YWxsZXQua2V5c1tpbmRleF0gfTtcblxuICAgICAgY29uc3Qga2V5Y2hhaW4gPSB5aWVsZCBzZWxmLmJhc2VDb2luLmtleWNoYWlucygpLmdldChwYXJhbXMpO1xuICAgICAgLy8gSWYgd2UgZmluZCB0aGUgcHJ2LCB0aGVuIHRoaXMgaXMgcHJvYmFibHkgdGhlIHVzZXIga2V5Y2hhaW4gd2UncmUgbG9va2luZyBmb3JcbiAgICAgIGlmIChrZXljaGFpbi5lbmNyeXB0ZWRQcnYpIHtcbiAgICAgICAgcmV0dXJuIGtleWNoYWluO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyeUtleUNoYWluKGluZGV4ICsgMSk7XG4gICAgfSkuYmluZCh0aGlzKTtcblxuICAgIHJldHVybiB0cnlLZXlDaGFpbigwKS5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB1bmVuY3J5cHRlZCBwcml2YXRlIGtleSBmb3IgdGhpcyB3YWxsZXQgKGJlIGNhcmVmdWwhKVxuICAgKiBSZXF1aXJlcyB3YWxsZXQgcGFzc3BocmFzZVxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgZ2V0UHJ2KHBhcmFtczogR2V0UHJ2T3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uICooKSB7XG4gICAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgWyd3YWxsZXRQYXNzcGhyYXNlJywgJ3BydiddLCBjYWxsYmFjayk7XG5cbiAgICAgIC8vIFByZXBhcmUgc2lnbmluZyBrZXlcbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5wcnYpICYmIF8uaXNVbmRlZmluZWQocGFyYW1zLndhbGxldFBhc3NwaHJhc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBlaXRoZXIgcHJvdmlkZSBwcnYgb3Igd2FsbGV0IHBhc3NwaHJhc2UnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5wcnYpICYmICFfLmlzU3RyaW5nKHBhcmFtcy5wcnYpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHJ2IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlKSAmJiAhXy5pc1N0cmluZyhwYXJhbXMud2FsbGV0UGFzc3BocmFzZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3YWxsZXRQYXNzcGhyYXNlIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5wcnYpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5wcnY7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVzZXJLZXljaGFpbiA9IHlpZWxkIHNlbGYuZ2V0RW5jcnlwdGVkVXNlcktleWNoYWluKCk7XG4gICAgICBjb25zdCB1c2VyRW5jcnlwdGVkUHJ2ID0gdXNlcktleWNoYWluLmVuY3J5cHRlZFBydjtcblxuICAgICAgbGV0IHVzZXJQcnY7XG4gICAgICB0cnkge1xuICAgICAgICB1c2VyUHJ2ID0gc2VsZi5iaXRnby5kZWNyeXB0KHsgaW5wdXQ6IHVzZXJFbmNyeXB0ZWRQcnYsIHBhc3N3b3JkOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlcnJvciBkZWNyeXB0aW5nIHdhbGxldCBwYXNzcGhyYXNlJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1c2VyUHJ2O1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhbiBlbmNyeXB0ZWQgd2FsbGV0IHNoYXJlIHRvIEJpdEdvLlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgY3JlYXRlU2hhcmUocGFyYW1zOiBDcmVhdGVTaGFyZU9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsndXNlcicsICdwZXJtaXNzaW9ucyddLCBbXSwgY2FsbGJhY2spO1xuXG4gICAgaWYgKHBhcmFtcy5rZXljaGFpbiAmJiAhXy5pc0VtcHR5KHBhcmFtcy5rZXljaGFpbikpIHtcbiAgICAgIGlmICghcGFyYW1zLmtleWNoYWluLnB1YiB8fCAhcGFyYW1zLmtleWNoYWluLmVuY3J5cHRlZFBydiB8fCAhcGFyYW1zLmtleWNoYWluLmZyb21QdWJLZXkgfHwgIXBhcmFtcy5rZXljaGFpbi50b1B1YktleSB8fCAhcGFyYW1zLmtleWNoYWluLnBhdGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlcyBrZXljaGFpbiBwYXJhbWV0ZXJzIC0gcHViLCBlbmNyeXB0ZWRQcnYsIGZyb21QdWJLZXksIHRvUHViS2V5LCBwYXRoJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYml0Z28ucG9zdCh0aGlzLnVybCgnL3NoYXJlJykpXG4gICAgICAuc2VuZChwYXJhbXMpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaGFyZSB0aGlzIHdhbGxldCB3aXRoIGFub3RoZXIgQml0R28gdXNlci5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBzaGFyZVdhbGxldChwYXJhbXM6IFNoYXJlV2FsbGV0T3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uICooKSB7XG4gICAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ2VtYWlsJywgJ3Blcm1pc3Npb25zJ10sIFsnd2FsbGV0UGFzc3BocmFzZScsICdtZXNzYWdlJ10sIGNhbGxiYWNrKTtcblxuICAgICAgaWYgKHBhcmFtcy5yZXNoYXJlICE9PSB1bmRlZmluZWQgJiYgIV8uaXNCb29sZWFuKHBhcmFtcy5yZXNoYXJlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHJlc2hhcmUgdG8gYmUgYSBib29sZWFuLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLnNraXBLZXljaGFpbiAhPT0gdW5kZWZpbmVkICYmICFfLmlzQm9vbGVhbihwYXJhbXMuc2tpcEtleWNoYWluKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHNraXBLZXljaGFpbiB0byBiZSBhIGJvb2xlYW4uICcpO1xuICAgICAgfVxuICAgICAgY29uc3QgbmVlZHNLZXljaGFpbiA9ICFwYXJhbXMuc2tpcEtleWNoYWluICYmIHBhcmFtcy5wZXJtaXNzaW9ucyAmJiBwYXJhbXMucGVybWlzc2lvbnMuaW5kZXhPZignc3BlbmQnKSAhPT0gLTE7XG5cbiAgICAgIGlmIChwYXJhbXMuZGlzYWJsZUVtYWlsICE9PSB1bmRlZmluZWQgJiYgIV8uaXNCb29sZWFuKHBhcmFtcy5kaXNhYmxlRW1haWwpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZGlzYWJsZUVtYWlsIHRvIGJlIGEgYm9vbGVhbi4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5lbWFpbCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHN0cmluZyBwYXJhbWV0ZXIgZW1haWwnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2hhcmluZyA9IHlpZWxkIHNlbGYuYml0Z28uZ2V0U2hhcmluZ0tleSh7IGVtYWlsOiBwYXJhbXMuZW1haWwudG9Mb3dlckNhc2UoKSB9KTtcbiAgICAgIGxldCBzaGFyZWRLZXljaGFpbjtcbiAgICAgIGlmIChuZWVkc0tleWNoYWluKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qga2V5Y2hhaW4gPSB5aWVsZCBzZWxmLmdldEVuY3J5cHRlZFVzZXJLZXljaGFpbih7fSk7XG4gICAgICAgICAgLy8gRGVjcnlwdCB0aGUgdXNlciBrZXkgd2l0aCBhIHBhc3NwaHJhc2VcbiAgICAgICAgICBpZiAoa2V5Y2hhaW4uZW5jcnlwdGVkUHJ2KSB7XG4gICAgICAgICAgICBpZiAoIXBhcmFtcy53YWxsZXRQYXNzcGhyYXNlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB3YWxsZXRQYXNzcGhyYXNlIGFyZ3VtZW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBrZXljaGFpbi5wcnYgPSBzZWxmLmJpdGdvLmRlY3J5cHQoeyBwYXNzd29yZDogcGFyYW1zLndhbGxldFBhc3NwaHJhc2UsIGlucHV0OiBrZXljaGFpbi5lbmNyeXB0ZWRQcnYgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGRlY3J5cHQgdXNlciBrZXljaGFpbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBlY2tleSA9IG1ha2VSYW5kb21LZXkoKTtcbiAgICAgICAgICAgIGNvbnN0IHNlY3JldCA9IHNlbGYuYml0Z28uZ2V0RUNESFNlY3JldCh7IGVja2V5OiBlY2tleSwgb3RoZXJQdWJLZXlIZXg6IHNoYXJpbmcucHVia2V5IH0pO1xuICAgICAgICAgICAgY29uc3QgbmV3RW5jcnlwdGVkUHJ2ID0gc2VsZi5iaXRnby5lbmNyeXB0KHsgcGFzc3dvcmQ6IHNlY3JldCwgaW5wdXQ6IGtleWNoYWluLnBydiB9KTtcblxuICAgICAgICAgICAgc2hhcmVkS2V5Y2hhaW4gPSB7XG4gICAgICAgICAgICAgIHB1Yjoga2V5Y2hhaW4ucHViLFxuICAgICAgICAgICAgICBlbmNyeXB0ZWRQcnY6IG5ld0VuY3J5cHRlZFBydixcbiAgICAgICAgICAgICAgZnJvbVB1YktleTogZWNrZXkuZ2V0UHVibGljS2V5QnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgICAgICB0b1B1YktleTogc2hhcmluZy5wdWJrZXksXG4gICAgICAgICAgICAgIHBhdGg6IHNoYXJpbmcucGF0aCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGUubWVzc2FnZSA9PT0gJ05vIGVuY3J5cHRlZCBrZXljaGFpbnMgb24gdGhpcyB3YWxsZXQuJykge1xuICAgICAgICAgICAgc2hhcmVkS2V5Y2hhaW4gPSB7fTtcbiAgICAgICAgICAgIC8vIGlnbm9yZSB0aGlzIGVycm9yIGJlY2F1c2UgdGhpcyBsb29rcyBsaWtlIGEgY29sZCB3YWxsZXRcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3B0aW9uczogQ3JlYXRlU2hhcmVPcHRpb25zID0ge1xuICAgICAgICB1c2VyOiBzaGFyaW5nLnVzZXJJZCxcbiAgICAgICAgcGVybWlzc2lvbnM6IHBhcmFtcy5wZXJtaXNzaW9ucyxcbiAgICAgICAgcmVzaGFyZTogcGFyYW1zLnJlc2hhcmUsXG4gICAgICAgIG1lc3NhZ2U6IHBhcmFtcy5tZXNzYWdlLFxuICAgICAgICBkaXNhYmxlRW1haWw6IHBhcmFtcy5kaXNhYmxlRW1haWwsXG4gICAgICB9O1xuXG4gICAgICBpZiAoc2hhcmVkS2V5Y2hhaW4pIHtcbiAgICAgICAgb3B0aW9ucy5rZXljaGFpbiA9IHNoYXJlZEtleWNoYWluO1xuICAgICAgfSBlbHNlIGlmIChwYXJhbXMuc2tpcEtleWNoYWluKSB7XG4gICAgICAgIG9wdGlvbnMua2V5Y2hhaW4gPSB7fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuY3JlYXRlU2hhcmUob3B0aW9ucyk7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdXNlciBmcm9tIHdhbGxldFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIC0gdXNlcklkIElkIG9mIHRoZSB1c2VyIHRvIHJlbW92ZVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIHJlbW92ZVVzZXIocGFyYW1zOiBSZW1vdmVVc2VyT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd1c2VySWQnXSwgW10sIGNhbGxiYWNrKTtcblxuICAgIGNvbnN0IHVzZXJJZCA9IHBhcmFtcy51c2VySWQ7XG4gICAgcmV0dXJuIHRoaXMuYml0Z28uZGVsKHRoaXMudXJsKCcvdXNlci8nICsgdXNlcklkKSlcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgdHJhbnNhY3Rpb24gcHJlYnVpbGQgKHVuc2lnbmVkIHRyYW5zYWN0aW9uKSBmcm9tIEJpdEdvXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICogQHBhcmFtIHt7YWRkcmVzczogc3RyaW5nLCBhbW91bnQ6IHN0cmluZ319IHBhcmFtcy5yZWNpcGllbnRzIC0gbGlzdCBvZiByZWNpcGllbnRzIGFuZCBuZWNlc3NhcnkgcmVjaXBpZW50IGluZm9ybWF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubnVtQmxvY2tzIC0gRXN0aW1hdGVzIHRoZSBhcHByb3hpbWF0ZSBmZWUgcGVyIGtpbG9ieXRlIG5lY2Vzc2FyeSBmb3IgYSB0cmFuc2FjdGlvbiBjb25maXJtYXRpb24gd2l0aGluIG51bUJsb2NrcyBibG9ja3NcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5mZWVSYXRlIC0gdGhlIGRlc2lyZWQgZmVlUmF0ZSBmb3IgdGhlIHRyYW5zYWN0aW9uIGluIGJhc2UgdW5pdHMva0JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5tYXhGZWVSYXRlIC0gdXBwZXIgbGltaXQgZm9yIGZlZVJhdGUgaW4gYmFzZSB1bml0cy9rQlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1pbkNvbmZpcm1zIC0gTWluaW11bSBudW1iZXIgb2YgY29uZmlybWF0aW9ucyB1bnNwZW50cyBnb2luZyBpbnRvIHRoaXMgdHJhbnNhY3Rpb24gc2hvdWxkIGhhdmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBwYXJhbXMuZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlIC0gRW5mb3JjZSBtaW5pbXVtIG51bWJlciBvZiBjb25maXJtYXRpb25zIG9uIGNoYW5nZSAoaW50ZXJuYWwpIGlucHV0cy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy50YXJnZXRXYWxsZXRVbnNwZW50cyAtIFRoZSBkZXNpcmVkIGNvdW50IG9mIHVuc3BlbnRzIGluIHRoZSB3YWxsZXQuIElmIHRoZSB3YWxsZXTigJlzIGN1cnJlbnQgdW5zcGVudCBjb3VudCBpcyBsb3dlciB0aGFuIHRoZSB0YXJnZXQsIHVwIHRvIGZvdXIgYWRkaXRpb25hbCBjaGFuZ2Ugb3V0cHV0cyB3aWxsIGJlIGFkZGVkIHRvIHRoZSB0cmFuc2FjdGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5taW5WYWx1ZSAtIElnbm9yZSB1bnNwZW50cyBzbWFsbGVyIHRoYW4gdGhpcyBhbW91bnQgb2YgYmFzZSB1bml0c1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1heFZhbHVlIC0gSWdub3JlIHVuc3BlbnRzIGxhcmdlciB0aGFuIHRoaXMgYW1vdW50IG9mIGJhc2UgdW5pdHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5zZXF1ZW5jZUlkIC0gVGhlIHNlcXVlbmNlIElEIG9mIHRoZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLmxhc3RMZWRnZXJTZXF1ZW5jZSAtIEFic29sdXRlIG1heCBsZWRnZXIgdGhlIHRyYW5zYWN0aW9uIHNob3VsZCBiZSBhY2NlcHRlZCBpbiwgd2hlcmVhZnRlciBpdCB3aWxsIGJlIHJlamVjdGVkLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLmxlZGdlclNlcXVlbmNlRGVsdGEgLSBSZWxhdGl2ZSBsZWRnZXIgaGVpZ2h0IChpbiByZWxhdGlvbiB0byB0aGUgY3VycmVudCBsZWRnZXIpIHRoYXQgdGhlIHRyYW5zYWN0aW9uIHNob3VsZCBiZSBhY2NlcHRlZCBpbiwgd2hlcmVhZnRlciBpdCB3aWxsIGJlIHJlamVjdGVkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLmdhc1ByaWNlIC0gQ3VzdG9tIGdhcyBwcmljZSB0byBiZSB1c2VkIGZvciBzZW5kaW5nIHRoZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLmdhc0xpbWl0IC0gQ3VzdG9tIGdhcyBsaW1pdCB0byBiZSB1c2VkIGZvciBzZW5kaW5nIHRoZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHBhcmFtcy5ub1NwbGl0Q2hhbmdlIC0gU2V0IHRvIHRydWUgdG8gZGlzYWJsZSBhdXRvbWF0aWMgY2hhbmdlIHNwbGl0dGluZyBmb3IgcHVycG9zZXMgb2YgdW5zcGVudCBtYW5hZ2VtZW50XG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcy51bnNwZW50cyAtIFRoZSB1bnNwZW50cyB0byB1c2UgaW4gdGhlIHRyYW5zYWN0aW9uLiBFYWNoIHVuc3BlbnQgc2hvdWxkIGJlIGluIHRoZSBmb3JtIHByZXZUeElkOm5PdXRwdXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5jaGFuZ2VBZGRyZXNzIC0gU3BlY2lmaWVzIHRoZSBkZXN0aW5hdGlvbiBvZiB0aGUgY2hhbmdlIG91dHB1dFxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLnZhbGlkRnJvbUJsb2NrIC0gKEFsZ29yYW5kKSBUaGUgbWluaW11bSByb3VuZCB0aGlzIHdpbGwgcnVuIG9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMudmFsaWRUb0Jsb2NrIC0gKEFsZ29yYW5kKSBUaGUgbWF4aW11bSByb3VuZCB0aGlzIHdpbGwgcnVuIG9uXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFyYW1zLmluc3RhbnQgLSBCdWlsZCB0aGlzIHRyYW5zYWN0aW9uIHRvIGNvbmZvcm0gd2l0aCBpbnN0YW50IHNlbmRpbmcgY29pbi1zcGVjaWZpYyBtZXRob2QgKGlmIGF2YWlsYWJsZSlcbiAgICogQHBhcmFtIHt7dmFsdWU6IFN0cmluZywgdHlwZTogU3RyaW5nfX0gcGFyYW1zLm1lbW8gLSBNZW1vIHRvIHVzZSBpbiB0cmFuc2FjdGlvbiAoc3VwcG9ydGVkIGJ5IFN0ZWxsYXIpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMuYWRkcmVzc1R5cGUgLSBUaGUgdHlwZSBvZiBhZGRyZXNzIHRvIGNyZWF0ZSBmb3IgY2hhbmdlLiBPbmUgb2YgYHAyc2hgLCBgcDJzaFAyd3NoYCwgYW5kIGBwMndzaGAuIENhc2Utc2Vuc2l0aXZlLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHBhcmFtcy5ob3AgLSBCdWlsZCB0aGlzIGFzIGFuIEV0aGVyZXVtIGhvcCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zLnJlc2VydmF0aW9uIC0gT2JqZWN0IHRvIHJlc2VydmUgdGhlIHVuc3BlbnRzIHRoYXQgdGhpcyB0eCBidWlsZCB1c2VzLiBGb3JtYXQgaXMgcmVzZXJ2YXRpb24gPSB7IGV4cGlyZVRpbWU6IElTT0RhdGVTdHJpbmcsIHBlbmRpbmdBcHByb3ZhbElkOiBTdHJpbmcgfVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLndhbGxldFBhc3NwaHJhc2UgVGhlIHBhc3NwaHJhc2UgdG8gdGhlIHdhbGxldCB1c2VyIGtleSwgdG8gc2lnbiBjb21taXRtZW50IGRhdGEgZm9yIEV0aGVyZXVtIGhvcCB0cmFuc2FjdGlvbnNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgcHJlYnVpbGRUcmFuc2FjdGlvbihwYXJhbXM6IFByZWJ1aWxkVHJhbnNhY3Rpb25PcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFByZWJ1aWxkVHJhbnNhY3Rpb25SZXN1bHQ+KTogQmx1ZWJpcmQ8UHJlYnVpbGRUcmFuc2FjdGlvblJlc3VsdD4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxQcmVidWlsZFRyYW5zYWN0aW9uUmVzdWx0PihmdW5jdGlvbiAqKCkge1xuICAgICAgLy8gV2hpdGVsaXN0IHBhcmFtcyB0byBidWlsZCB0eFxuICAgICAgY29uc3Qgd2hpdGVsaXN0ZWRQYXJhbXMgPSBfLnBpY2socGFyYW1zLCBzZWxmLnByZWJ1aWxkV2hpdGVsaXN0ZWRQYXJhbXMoKSk7XG4gICAgICBkZWJ1ZygncHJlYnVpbGRpbmcgdHJhbnNhY3Rpb246ICVPJywgd2hpdGVsaXN0ZWRQYXJhbXMpO1xuXG4gICAgICBpZiAocGFyYW1zLnJlcUlkKSB7XG4gICAgICAgIHNlbGYuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihwYXJhbXMucmVxSWQpO1xuICAgICAgfVxuICAgICAgY29uc3QgZXh0cmFQYXJhbXMgPSB5aWVsZCBzZWxmLmJhc2VDb2luLmdldEV4dHJhUHJlYnVpbGRQYXJhbXMoT2JqZWN0LmFzc2lnbihwYXJhbXMsIHsgd2FsbGV0OiBzZWxmIH0pKTtcbiAgICAgIE9iamVjdC5hc3NpZ24od2hpdGVsaXN0ZWRQYXJhbXMsIGV4dHJhUGFyYW1zKTtcbiAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0ge1xuICAgICAgICBvZmZsaW5lVmVyaWZpY2F0aW9uOiBwYXJhbXMub2ZmbGluZVZlcmlmaWNhdGlvbiA/IHRydWUgOiB1bmRlZmluZWQsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBidWlsZFF1ZXJ5ID0gc2VsZi5iaXRnby5wb3N0KHNlbGYuYmFzZUNvaW4udXJsKCcvd2FsbGV0LycgKyBzZWxmLmlkKCkgKyAnL3R4L2J1aWxkJykpXG4gICAgICAgIC5xdWVyeShxdWVyeVBhcmFtcylcbiAgICAgICAgLnNlbmQod2hpdGVsaXN0ZWRQYXJhbXMpXG4gICAgICAgIC5yZXN1bHQoKTtcbiAgICAgIGNvbnN0IHV0eG9Db2luID0gc2VsZi5iYXNlQ29pbiBhcyBBYnN0cmFjdFV0eG9Db2luO1xuICAgICAgY29uc3QgYmxvY2tIZWlnaHRRdWVyeSA9IF8uaXNGdW5jdGlvbih1dHhvQ29pbi5nZXRMYXRlc3RCbG9ja0hlaWdodCkgP1xuICAgICAgICB1dHhvQ29pbi5nZXRMYXRlc3RCbG9ja0hlaWdodChwYXJhbXMucmVxSWQpIDpcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICBjb25zdCBxdWVyaWVzID0gW2J1aWxkUXVlcnksIGJsb2NrSGVpZ2h0UXVlcnldO1xuICAgICAgY29uc3QgW2J1aWxkUmVzcG9uc2UsIGJsb2NrSGVpZ2h0XSA9IHlpZWxkIFByb21pc2UuYWxsKHF1ZXJpZXMpO1xuICAgICAgZGVidWcoJ3Bvc3Rwcm9jZXNzaW5nIHRyYW5zYWN0aW9uIHByZWJ1aWxkOiAlTycsIGJ1aWxkUmVzcG9uc2UpO1xuICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKGJsb2NrSGVpZ2h0KSkge1xuICAgICAgICBidWlsZFJlc3BvbnNlLmJsb2NrSGVpZ2h0ID0gYmxvY2tIZWlnaHQ7XG4gICAgICB9XG4gICAgICBsZXQgcHJlYnVpbGQ6IFRyYW5zYWN0aW9uUHJlYnVpbGQgPSB5aWVsZCBzZWxmLmJhc2VDb2luLnBvc3RQcm9jZXNzUHJlYnVpbGQoXG4gICAgICAgIE9iamVjdC5hc3NpZ24oYnVpbGRSZXNwb25zZSwgeyB3YWxsZXQ6IHNlbGYsIGJ1aWxkUGFyYW1zOiB3aGl0ZWxpc3RlZFBhcmFtcyB9KVxuICAgICAgKTtcbiAgICAgIGRlbGV0ZSBwcmVidWlsZC53YWxsZXQ7XG4gICAgICBkZWxldGUgcHJlYnVpbGQuYnVpbGRQYXJhbXM7XG4gICAgICBwcmVidWlsZCA9IF8uZXh0ZW5kKHt9LCBwcmVidWlsZCwgeyB3YWxsZXRJZDogc2VsZi5pZCgpIH0pO1xuICAgICAgZGVidWcoJ2ZpbmFsIHRyYW5zYWN0aW9uIHByZWJ1aWxkOiAlTycsIHByZWJ1aWxkKTtcbiAgICAgIHJldHVybiBwcmVidWlsZCBhcyBQcmVidWlsZFRyYW5zYWN0aW9uUmVzdWx0O1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogU2lnbiBhIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogLSB0eFByZWJ1aWxkXG4gICAqIC0gW2tleWNoYWluIC8ga2V5XSAob2JqZWN0KSBvciBwcnYgKHN0cmluZylcbiAgICogLSB3YWxsZXRQYXNzcGhyYXNlXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgc2lnblRyYW5zYWN0aW9uKFxuICAgIHBhcmFtczogV2FsbGV0U2lnblRyYW5zYWN0aW9uT3B0aW9ucyA9IHt9LFxuICAgIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFNpZ25lZFRyYW5zYWN0aW9uPlxuICApOiBCbHVlYmlyZDxTaWduZWRUcmFuc2FjdGlvbj4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxTaWduZWRUcmFuc2FjdGlvbj4oZnVuY3Rpb24gKigpIHtcbiAgICAgIGNvbnN0IHR4UHJlYnVpbGQgPSBwYXJhbXMudHhQcmVidWlsZDtcbiAgICAgIGlmICghdHhQcmVidWlsZCB8fCB0eXBlb2YgdHhQcmVidWlsZCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eFByZWJ1aWxkIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICB9XG4gICAgICBjb25zdCBwcmVzaWduID0geWllbGQgc2VsZi5iYXNlQ29pbi5wcmVzaWduVHJhbnNhY3Rpb24ocGFyYW1zKTtcbiAgICAgIGNvbnN0IHVzZXJQcnYgPSBzZWxmLmdldFVzZXJQcnYocHJlc2lnbik7XG4gICAgICBjb25zdCBzaWduaW5nUGFyYW1zID0gXy5leHRlbmQoe30sIHByZXNpZ24sIHsgdHhQcmVidWlsZDogdHhQcmVidWlsZCwgcHJ2OiB1c2VyUHJ2IH0pO1xuICAgICAgcmV0dXJuIHNlbGYuYmFzZUNvaW4uc2lnblRyYW5zYWN0aW9uKHNpZ25pbmdQYXJhbXMpO1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB1c2VyIHByaXZhdGUga2V5IGZyb20gZWl0aGVyIGEgZGVyaXZhdGlvbiBvciBhbiBlbmNyeXB0ZWQga2V5Y2hhaW5cbiAgICogQHBhcmFtIFtwYXJhbXMua2V5Y2hhaW4gLyBwYXJhbXMua2V5XSAob2JqZWN0KSBvciBwYXJhbXMucHJ2IChzdHJpbmcpXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSAoc3RyaW5nKVxuICAgKi9cbiAgZ2V0VXNlclBydihwYXJhbXM6IEdldFVzZXJQcnZPcHRpb25zID0ge30pOiBzdHJpbmcge1xuICAgIGNvbnN0IHVzZXJLZXljaGFpbiA9IHBhcmFtcy5rZXljaGFpbiB8fCBwYXJhbXMua2V5O1xuICAgIGxldCB1c2VyUHJ2ID0gcGFyYW1zLnBydjtcbiAgICBpZiAodXNlclBydiAmJiB0eXBlb2YgdXNlclBydiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncHJ2IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKHVzZXJQcnYgJiYgcGFyYW1zLmNvbGREZXJpdmF0aW9uU2VlZCkge1xuICAgICAgLy8gdGhlIGRlcml2YXRpb24gb25seSBtYWtlcyBzZW5zZSB3aGVuIGEga2V5IGFscmVhZHkgZXhpc3RzXG4gICAgICBjb25zdCBkZXJpdmF0aW9uID0gdGhpcy5iYXNlQ29pbi5kZXJpdmVLZXlXaXRoU2VlZCh7IGtleTogdXNlclBydiwgc2VlZDogcGFyYW1zLmNvbGREZXJpdmF0aW9uU2VlZCB9KTtcbiAgICAgIHVzZXJQcnYgPSBkZXJpdmF0aW9uLmtleTtcbiAgICB9IGVsc2UgaWYgKCF1c2VyUHJ2KSB7XG4gICAgICBpZiAoIXVzZXJLZXljaGFpbiB8fCB0eXBlb2YgdXNlcktleWNoYWluICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2tleWNoYWluIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICB9XG4gICAgICBjb25zdCB1c2VyRW5jcnlwdGVkUHJ2ID0gdXNlcktleWNoYWluLmVuY3J5cHRlZFBydjtcbiAgICAgIGlmICghdXNlckVuY3J5cHRlZFBydikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2tleWNoYWluIGRvZXMgbm90IGhhdmUgcHJvcGVydHkgZW5jcnlwdGVkUHJ2Jyk7XG4gICAgICB9XG4gICAgICBpZiAoIXBhcmFtcy53YWxsZXRQYXNzcGhyYXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignd2FsbGV0UGFzc3BocmFzZSBwcm9wZXJ0eSBtaXNzaW5nJyk7XG4gICAgICB9XG5cbiAgICAgIHVzZXJQcnYgPSB0aGlzLmJpdGdvLmRlY3J5cHQoeyBpbnB1dDogdXNlckVuY3J5cHRlZFBydiwgcGFzc3dvcmQ6IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdXNlclBydjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB0cmFuc2FjdGlvbiBwcmVidWlsZCBmcm9tIEJpdEdvLCB2YWxpZGF0ZSBpdCwgYW5kIHRoZW4gZGVjcnlwdCB0aGUgdXNlciBrZXkgYW5kIHNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBwcmVidWlsZEFuZFNpZ25UcmFuc2FjdGlvbihwYXJhbXM6IFByZWJ1aWxkQW5kU2lnblRyYW5zYWN0aW9uT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxTaWduZWRUcmFuc2FjdGlvbj4pOiBCbHVlYmlyZDxTaWduZWRUcmFuc2FjdGlvbj4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxTaWduZWRUcmFuc2FjdGlvbj4oZnVuY3Rpb24gKigpIHtcbiAgICAgIGlmIChwYXJhbXMucHJlYnVpbGRUeCAmJiBwYXJhbXMucmVjaXBpZW50cykge1xuICAgICAgICBjb25zdCBlcnJvcjogYW55ID0gbmV3IEVycm9yKCdPbmx5IG9uZSBvZiBwcmVidWlsZFR4IGFuZCByZWNpcGllbnRzIG1heSBiZSBzcGVjaWZpZWQnKTtcbiAgICAgICAgZXJyb3IuY29kZSA9ICdib3RoX3ByZWJ1aWxkdHhfYW5kX3JlY2lwaWVudHNfc3BlY2lmaWVkJztcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMucmVjaXBpZW50cyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXMucmVjaXBpZW50cykpIHtcbiAgICAgICAgY29uc3QgZXJyb3I6IGFueSA9IG5ldyBFcnJvcignZXhwZWN0aW5nIHJlY2lwaWVudHMgYXJyYXknKTtcbiAgICAgICAgZXJyb3IuY29kZSA9ICdyZWNpcGllbnRzX25vdF9hcnJheSc7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5pc0FycmF5KHNlbGYuX3Blcm1pc3Npb25zKSAmJiAhc2VsZi5fcGVybWlzc2lvbnMuaW5jbHVkZXMoJ3NwZW5kJykpIHtcbiAgICAgICAgY29uc3QgZXJyb3I6IGFueSA9IG5ldyBFcnJvcignbm8gc3BlbmQgcGVybWlzc2lvbiBvbiB0aGlzIHdhbGxldCcpO1xuICAgICAgICBlcnJvci5jb2RlID0gJ3VzZXJfbm90X2FsbG93ZWRfdG9fc3BlbmRfZnJvbV93YWxsZXQnO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgLy8gY2FsbCBwcmVidWlsZFRyYW5zYWN0aW9uIGFuZCBrZXljaGFpbnMtZ2V0IGluIHBhcmFsbGVsXG4gICAgICAvLyB0aGUgcHJlYnVpbGQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgcHJvdmlkaW5nIGFuIGV4cGxpY2l0IHR4XG4gICAgICBjb25zdCB0eFByZWJ1aWxkUXVlcnkgPSBwYXJhbXMucHJlYnVpbGRUeCA/IFByb21pc2UucmVzb2x2ZShwYXJhbXMucHJlYnVpbGRUeCkgOiBzZWxmLnByZWJ1aWxkVHJhbnNhY3Rpb24ocGFyYW1zKTtcblxuICAgICAgLy8gcmV0cmlldmUgb3VyIGtleWNoYWlucyBuZWVkZWQgdG8gcnVuIHRoZSBwcmVidWlsZCAtIHNvbWUgY29pbnMgdXNlIGFsbCBwdWJzXG4gICAgICBjb25zdCBrZXljaGFpbnMgPSB5aWVsZCBzZWxmLmJhc2VDb2luLmtleWNoYWlucygpLmdldEtleXNGb3JTaWduaW5nKHsgd2FsbGV0OiBzZWxmLCByZXFJZDogcGFyYW1zLnJlcUlkIH0pO1xuXG4gICAgICBjb25zdCB0eFByZWJ1aWxkID0geWllbGQgdHhQcmVidWlsZFF1ZXJ5O1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB2ZXJpZmljYXRpb25QYXJhbXMgPSBfLnBpY2socGFyYW1zLnZlcmlmaWNhdGlvbiB8fCB7fSwgWydkaXNhYmxlTmV0d29ya2luZycsICdrZXljaGFpbnMnLCAnYWRkcmVzc2VzJ10pO1xuICAgICAgICB5aWVsZCBzZWxmLmJhc2VDb2luLnZlcmlmeVRyYW5zYWN0aW9uKHtcbiAgICAgICAgICB0eFBhcmFtczogcGFyYW1zLFxuICAgICAgICAgIHR4UHJlYnVpbGQsXG4gICAgICAgICAgd2FsbGV0OiBzZWxmLFxuICAgICAgICAgIHZlcmlmaWNhdGlvbjogdmVyaWZpY2F0aW9uUGFyYW1zLFxuICAgICAgICAgIHJlcUlkOiBwYXJhbXMucmVxSWQsXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkZWJ1ZygnVHJhbnNhY3Rpb24gcHJlYnVpbGQgZmFpbHVyZTonLCBlKTtcbiAgICAgICAgY29uc29sZS5lcnJvcigndHJhbnNhY3Rpb24gcHJlYnVpbGQgZmFpbGVkIGxvY2FsIHZhbGlkYXRpb246Jyk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG5cbiAgICAgIC8vIHBhc3Mgb3VyIHRocmVlIGtleXNcbiAgICAgIGNvbnN0IHNpZ25pbmdQYXJhbXMgPSBfLmV4dGVuZCh7fSwgcGFyYW1zLCB7XG4gICAgICAgIHR4UHJlYnVpbGQ6IHR4UHJlYnVpbGQsXG4gICAgICAgIHdhbGxldDoge1xuICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIHZlcnNpb24gb2YgdGhlIG11bHRpc2lnIGFkZHJlc3MgYXQgd2FsbGV0IGNyZWF0aW9uIHRpbWVcbiAgICAgICAgICBhZGRyZXNzVmVyc2lvbjogc2VsZi5fd2FsbGV0LmNvaW5TcGVjaWZpYy5hZGRyZXNzVmVyc2lvblxuICAgICAgICB9LFxuICAgICAgICBrZXljaGFpbjoga2V5Y2hhaW5zWzBdLFxuICAgICAgICBiYWNrdXBLZXljaGFpbjogKGtleWNoYWlucy5sZW5ndGggPiAxKSA/IGtleWNoYWluc1sxXSA6IG51bGwsXG4gICAgICAgIGJpdGdvS2V5Y2hhaW46IChrZXljaGFpbnMubGVuZ3RoID4gMikgPyBrZXljaGFpbnNbMl0gOiBudWxsLFxuICAgICAgfSk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB5aWVsZCBzZWxmLnNpZ25UcmFuc2FjdGlvbihzaWduaW5nUGFyYW1zKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdpbnN1ZmZpY2llbnQgZnVuZHMnKSkge1xuICAgICAgICAgIGVycm9yLmNvZGUgPSAnaW5zdWZmaWNpZW50X2Z1bmRzJztcbiAgICAgICAgICBlcnJvci53YWxsZXRCYWxhbmNlcyA9IHtcbiAgICAgICAgICAgIGJhbGFuY2VTdHJpbmc6IHNlbGYuYmFsYW5jZVN0cmluZygpLFxuICAgICAgICAgICAgY29uZmlybWVkQmFsYW5jZVN0cmluZzogc2VsZi5jb25maXJtZWRCYWxhbmNlU3RyaW5nKCksXG4gICAgICAgICAgICBzcGVuZGFibGVCYWxhbmNlU3RyaW5nOiBzZWxmLnNwZW5kYWJsZUJhbGFuY2VTdHJpbmcoKSxcbiAgICAgICAgICAgIGJhbGFuY2U6IHNlbGYuYmFsYW5jZSgpLFxuICAgICAgICAgICAgY29uZmlybWVkQmFsYW5jZTogc2VsZi5jb25maXJtZWRCYWxhbmNlKCksXG4gICAgICAgICAgICBzcGVuZGFibGVCYWxhbmNlOiBzZWxmLnNwZW5kYWJsZUJhbGFuY2UoKVxuICAgICAgICAgIH07XG4gICAgICAgICAgZXJyb3IudHhQYXJhbXMgPSBfLm9taXQocGFyYW1zLCBbJ2tleWNoYWluJywgJ3BydicsICdwYXNzcGhyYXNlJywgJ3dhbGxldFBhc3NwaHJhc2UnLCAna2V5J10pO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQWNjZWxlcmF0ZSBhIHRyYW5zYWN0aW9uJ3MgY29uZmlybWF0aW9uIHVzaW5nIENoaWxkLVBheXMtRm9yLVBhcmVudCAoQ1BGUClcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGFjY2VsZXJhdGVUcmFuc2FjdGlvbihwYXJhbXM6IEFjY2VsZXJhdGVUcmFuc2FjdGlvbk9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqKCkge1xuICAgICAgLy8gVE9ETyhCRy05MzQ5KTogY2hhbmdlIHRoZSBsYXN0IGNoZWNrIHRvID4gMCBhbmQgdGhlIGVycm9yIG1lc3NhZ2Ugb25jZSBwbGF0Zm9ybSBhbGxvd3MgbXVsdGlwbGUgdHJhbnNhY3Rpb25zIHRvXG4gICAgICAvLyAgICAgICAgICAgICAgICBiZSBidW1wZWQgaW4gdGhlIHNhbWUgQ1BGUCB0cmFuc2FjdGlvblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLmNwZnBUeElkcykgfHwgIUFycmF5LmlzQXJyYXkocGFyYW1zLmNwZnBUeElkcykgfHwgcGFyYW1zLmNwZnBUeElkcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgY29uc3QgZXJyb3I6IGFueSA9IG5ldyBFcnJvcignZXhwZWN0aW5nIGNwZnBUeElkcyB0byBiZSBhbiBhcnJheSBvZiBsZW5ndGggMScpO1xuICAgICAgICBlcnJvci5jb2RlID0gJ2NwZnB0eGlkc19ub3RfYXJyYXknO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLmNwZnBGZWVSYXRlKSkge1xuICAgICAgICBpZiAocGFyYW1zLm5vQ3BmcEZlZVJhdGUgIT09IHRydWUpIHtcbiAgICAgICAgICBjb25zdCBlcnJvcjogYW55ID0gbmV3IEVycm9yKCdjcGZwRmVlUmF0ZSBtdXN0IGJlIHNldCB1bmxlc3Mgbm9DcGZwRmVlUmF0ZSBpcyBzZXQnKTtcbiAgICAgICAgICBlcnJvci5jb2RlID0gJ2NwZnBmZWVyYXRlX25vdF9zZXQnO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIV8uaXNJbnRlZ2VyKHBhcmFtcy5jcGZwRmVlUmF0ZSkgfHwgcGFyYW1zLmNwZnBGZWVSYXRlIDwgMCkge1xuICAgICAgICAgIGNvbnN0IGVycm9yOiBhbnkgPSBuZXcgRXJyb3IoJ2NwZnBGZWVSYXRlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcicpO1xuICAgICAgICAgIGVycm9yLmNvZGUgPSAnY3BmcGZlZXJhdGVfbm90X25vbm5lZ2F0aXZlX2ludGVnZXInO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5tYXhGZWUpKSB7XG4gICAgICAgIGlmIChwYXJhbXMubm9NYXhGZWUgIT09IHRydWUpIHtcbiAgICAgICAgICBjb25zdCBlcnJvcjogYW55ID0gbmV3IEVycm9yKCdtYXhGZWUgbXVzdCBiZSBzZXQgdW5sZXNzIG5vTWF4RmVlIGlzIHNldCcpO1xuICAgICAgICAgIGVycm9yLmNvZGUgPSAnbWF4ZmVlX25vdF9zZXQnO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIV8uaXNJbnRlZ2VyKHBhcmFtcy5tYXhGZWUpIHx8IHBhcmFtcy5tYXhGZWUgPCAwKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3I6IGFueSA9IG5ldyBFcnJvcignbWF4RmVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcicpO1xuICAgICAgICAgIGVycm9yLmNvZGUgPSAnbWF4ZmVlX25vdF9ub25uZWdhdGl2ZV9pbnRlZ2VyJztcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLnJlY2lwaWVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zLnJlY2lwaWVudHMpIHx8IHBhcmFtcy5yZWNpcGllbnRzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB2YWx1ZSBmb3IgJ3JlY2lwaWVudHMnOiBtdXN0IGJlIGVtcHR5IGFycmF5IHdoZW4gc2V0YCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcGFyYW1zLnJlY2lwaWVudHMgPSBbXTtcblxuICAgICAgLy8gV2UgbXVzdCBwYXNzIHRoZSBidWlsZCBwYXJhbXMgdGhyb3VnaCB0byBzdWJtaXQgaW4gY2FzZSB0aGUgQ1BGUCB0eCBldmVyIGhhcyB0byBiZSByZWJ1aWx0LlxuICAgICAgY29uc3Qgc3VibWl0UGFyYW1zID0gT2JqZWN0LmFzc2lnbihwYXJhbXMsIHlpZWxkIHNlbGYucHJlYnVpbGRBbmRTaWduVHJhbnNhY3Rpb24ocGFyYW1zKSk7XG4gICAgICBkZWxldGUgc3VibWl0UGFyYW1zLndhbGxldDtcbiAgICAgIHJldHVybiB5aWVsZCBzZWxmLnN1Ym1pdFRyYW5zYWN0aW9uKHN1Ym1pdFBhcmFtcyk7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJtaXQgYSBoYWxmLXNpZ25lZCB0cmFuc2FjdGlvbiB0byBCaXRHb1xuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIC0gdHhIZXg6IHRyYW5zYWN0aW9uIGhleCB0byBzdWJtaXRcbiAgICogLSBoYWxmU2lnbmVkOiBvYmplY3QgY29udGFpbmluZyB0cmFuc2FjdGlvbiAodHhIZXggb3IgdHhCYXNlNjQpIHRvIHN1Ym1pdFxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHN1Ym1pdFRyYW5zYWN0aW9uKHBhcmFtczogU3VibWl0VHJhbnNhY3Rpb25PcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgWydvdHAnLCAndHhIZXgnXSwgY2FsbGJhY2spO1xuICAgIGNvbnN0IGhhc1R4SGV4ID0gISFwYXJhbXMudHhIZXg7XG4gICAgY29uc3QgaGFzSGFsZlNpZ25lZCA9ICEhcGFyYW1zLmhhbGZTaWduZWQ7XG5cbiAgICBpZiAoKGhhc1R4SGV4ICYmIGhhc0hhbGZTaWduZWQpIHx8ICghaGFzVHhIZXggJiYgIWhhc0hhbGZTaWduZWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3Qgc3VwcGx5IGVpdGhlciB0eEhleCBvciBoYWxmU2lnbmVkLCBidXQgbm90IGJvdGgnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYml0Z28ucG9zdCh0aGlzLmJhc2VDb2luLnVybCgnL3dhbGxldC8nICsgdGhpcy5pZCgpICsgJy90eC9zZW5kJykpXG4gICAgICAuc2VuZChwYXJhbXMpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGNvaW5zIHRvIGEgcmVjaXBpZW50XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy5hZGRyZXNzIC0gdGhlIGRlc3RpbmF0aW9uIGFkZHJlc3NcbiAgICogQHBhcmFtIHBhcmFtcy5hbW91bnQgLSB0aGUgYW1vdW50IGluIHNhdG9zaGlzL3dlaS9iYXNlIHZhbHVlIHRvIGJlIHNlbnRcbiAgICogQHBhcmFtIHBhcmFtcy5tZXNzYWdlIC0gb3B0aW9uYWwgbWVzc2FnZSB0byBhdHRhY2ggdG8gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhIC0gW0V0aGVyZXVtIFNwZWNpZmljXSBvcHRpb25hbCBkYXRhIHRvIHBhc3MgdG8gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlIC0gdGhlIHBhc3NwaHJhc2UgdG8gYmUgdXNlZCB0byBkZWNyeXB0IHRoZSB1c2VyIGtleSBvbiB0aGlzIHdhbGxldFxuICAgKiBAcGFyYW0gcGFyYW1zLnBydiAtIHRoZSBwcml2YXRlIGtleSBpbiBzdHJpbmcgZm9ybSwgaWYgd2FsbGV0UGFzc3BocmFzZSBpcyBub3QgYXZhaWxhYmxlXG4gICAqIEBwYXJhbSBwYXJhbXMubWluQ29uZmlybXMgLSB0aGUgbWluaW11bSBjb25maXJtYXRpb24gdGhyZXNob2xkIGZvciBpbnB1dHNcbiAgICogQHBhcmFtIHBhcmFtcy5lbmZvcmNlTWluQ29uZmlybXNGb3JDaGFuZ2UgLSB3aGV0aGVyIHRvIGVuZm9yY2UgbWluQ29uZmlybXMgZm9yIGNoYW5nZSBpbnB1dHNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgc2VuZChwYXJhbXM6IFNlbmRPcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ2FkZHJlc3MnXSwgWydtZXNzYWdlJywgJ2RhdGEnXSwgY2FsbGJhY2spO1xuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLmFtb3VudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgYW1vdW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLmFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyIGFtb3VudCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvaW4gPSB0aGlzLmJhc2VDb2luO1xuXG4gICAgY29uc3QgYW1vdW50ID0gbmV3IEJpZ051bWJlcihwYXJhbXMuYW1vdW50KTtcbiAgICBpZiAoYW1vdW50LmlzTmVnYXRpdmUoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IGZvciBhbW91bnQgLSBwb3NpdGl2ZSBudW1iZXIgZ3JlYXRlciB0aGFuIHplcm8gb3IgbnVtZXJpYyBzdHJpbmcgZXhwZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvaW4udmFsdWVsZXNzVHJhbnNmZXJBbGxvd2VkKCkgJiYgYW1vdW50LmlzWmVybygpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQgZm9yIGFtb3VudCAtIHBvc2l0aXZlIG51bWJlciBncmVhdGVyIHRoYW4gemVybyBvciBudW1lcmljIHN0cmluZyBleHBlY3RlZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlY2lwaWVudHM6IFNlbmRNYW55T3B0aW9uc1sncmVjaXBpZW50cyddID0gW3tcbiAgICAgIGFkZHJlc3M6IHBhcmFtcy5hZGRyZXNzLFxuICAgICAgYW1vdW50OiBwYXJhbXMuYW1vdW50LFxuICAgIH1dO1xuXG4gICAgaWYgKHBhcmFtcy5kYXRhICYmIGNvaW4udHJhbnNhY3Rpb25EYXRhQWxsb3dlZCgpKSB7XG4gICAgICByZWNpcGllbnRzWzBdLmRhdGEgPSBwYXJhbXMuZGF0YTtcbiAgICB9XG5cbiAgICBjb25zdCBzZW5kTWFueU9wdGlvbnM6IFNlbmRNYW55T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcywgeyByZWNpcGllbnRzIH0pO1xuICAgIHJldHVybiB0aGlzLnNlbmRNYW55KHNlbmRNYW55T3B0aW9ucykubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBtb25leSB0byBtdWx0aXBsZSByZWNpcGllbnRzXG4gICAqIDEuIEdldHMgdGhlIHVzZXIga2V5Y2hhaW4gYnkgY2hlY2tpbmcgdGhlIHdhbGxldCBmb3IgYSBrZXkgd2hpY2ggaGFzIGFuIGVuY3J5cHRlZCBwcnZcbiAgICogMi4gRGVjcnlwdHMgdXNlciBrZXlcbiAgICogMy4gQ3JlYXRlcyB0aGUgdHJhbnNhY3Rpb24gd2l0aCBkZWZhdWx0IGZlZVxuICAgKiA0LiBTaWducyB0cmFuc2FjdGlvbiB3aXRoIGRlY3J5cHRlZCB1c2VyIGtleVxuICAgKiA1LiBTZW5kcyB0aGUgdHJhbnNhY3Rpb24gdG8gQml0R29cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgKiBAcGFyYW0ge3thZGRyZXNzOiBzdHJpbmcsIGFtb3VudDogc3RyaW5nfX0gcGFyYW1zLnJlY2lwaWVudHMgLSBsaXN0IG9mIHJlY2lwaWVudHMgYW5kIG5lY2Vzc2FyeSByZWNpcGllbnQgaW5mb3JtYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5udW1CbG9ja3MgLSBFc3RpbWF0ZXMgdGhlIGFwcHJveGltYXRlIGZlZSBwZXIga2lsb2J5dGUgbmVjZXNzYXJ5IGZvciBhIHRyYW5zYWN0aW9uIGNvbmZpcm1hdGlvbiB3aXRoaW4gbnVtQmxvY2tzIGJsb2Nrc1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLmZlZVJhdGUgLSB0aGUgZGVzaXJlZCBmZWVSYXRlIGZvciB0aGUgdHJhbnNhY3Rpb24gaW4gc2F0b3RoaXMva0JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5tYXhGZWVSYXRlIC0gdXBwZXIgbGltaXQgZm9yIGZlZVJhdGUgaW4gc2F0b3NoaXMva0JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5taW5Db25maXJtcyAtIGFsbCBzZWxlY3RlZCB1bnNwZW50cyB3aWxsIGhhdmUgYXQgbGVhc3QgdGhpcyBtYW55IGNvbmZpcm1hdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBwYXJhbXMuZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlIC0gRW5mb3JjZXMgbWluQ29uZmlybXMgb24gY2hhbmdlIGlucHV0c1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLnRhcmdldFdhbGxldFVuc3BlbnRzIC0gVGhlIGRlc2lyZWQgY291bnQgb2YgdW5zcGVudHMgaW4gdGhlIHdhbGxldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLm1lc3NhZ2UgLSBvcHRpb25hbCBtZXNzYWdlIHRvIGF0dGFjaCB0byB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1pblZhbHVlIC0gSWdub3JlIHVuc3BlbnRzIHNtYWxsZXIgdGhhbiB0aGlzIGFtb3VudCBvZiBzYXRvc2hpc1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1heFZhbHVlIC0gSWdub3JlIHVuc3BlbnRzIGxhcmdlciB0aGFuIHRoaXMgYW1vdW50IG9mIHNhdG9zaGlzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMuc2VxdWVuY2VJZCAtIFRoZSBzZXF1ZW5jZSBJRCBvZiB0aGUgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5sYXN0TGVkZ2VyU2VxdWVuY2UgLSBBYnNvbHV0ZSBtYXggbGVkZ2VyIHRoZSB0cmFuc2FjdGlvbiBzaG91bGQgYmUgYWNjZXB0ZWQgaW4sIHdoZXJlYWZ0ZXIgaXQgd2lsbCBiZSByZWplY3RlZC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5sZWRnZXJTZXF1ZW5jZURlbHRhIC0gUmVsYXRpdmUgbGVkZ2VyIGhlaWdodCAoaW4gcmVsYXRpb24gdG8gdGhlIGN1cnJlbnQgbGVkZ2VyKSB0aGF0IHRoZSB0cmFuc2FjdGlvbiBzaG91bGQgYmUgYWNjZXB0ZWQgaW4sIHdoZXJlYWZ0ZXIgaXQgd2lsbCBiZSByZWplY3RlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5nYXNQcmljZSAtIEN1c3RvbSBnYXMgcHJpY2UgdG8gYmUgdXNlZCBmb3Igc2VuZGluZyB0aGUgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtCb29sZWFufSBwYXJhbXMubm9TcGxpdENoYW5nZSAtIFNldCB0byB0cnVlIHRvIGRpc2FibGUgYXV0b21hdGljIGNoYW5nZSBzcGxpdHRpbmcgZm9yIHB1cnBvc2VzIG9mIHVuc3BlbnQgbWFuYWdlbWVudFxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMudW5zcGVudHMgLSBUaGUgdW5zcGVudHMgdG8gdXNlIGluIHRoZSB0cmFuc2FjdGlvbi4gRWFjaCB1bnNwZW50IHNob3VsZCBiZSBpbiB0aGUgZm9ybSBwcmV2VHhJZDpuT3V0cHV0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMuY29tbWVudCAtIEFueSBhZGRpdGlvbmFsIGNvbW1lbnQgdG8gYXR0YWNoIHRvIHRoZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLm90cCAtIFR3byBmYWN0b3IgYXV0aCBjb2RlIHRvIGVuYWJsZSBzZW5kaW5nIHRoZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLmNoYW5nZUFkZHJlc3MgLSBTcGVjaWZpZXMgdGhlIGRlc3RpbmF0aW9uIG9mIHRoZSBjaGFuZ2Ugb3V0cHV0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFyYW1zLmluc3RhbnQgLSBTZW5kIHRoaXMgdHJhbnNhY3Rpb24gdXNpbmcgY29pbi1zcGVjaWZpYyBpbnN0YW50IHNlbmRpbmcgbWV0aG9kIChpZiBhdmFpbGFibGUpXG4gICAqIEBwYXJhbSB7e3ZhbHVlOiBTdHJpbmcsIHR5cGU6IFN0cmluZ319IHBhcmFtcy5tZW1vIC0gTWVtbyB0byB1c2UgaW4gdHJhbnNhY3Rpb24gKHN1cHBvcnRlZCBieSBTdGVsbGFyKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLnR5cGUgLSBUeXBlIG9mIHRoZSB0cmFuc2FjdGlvbiAoZS5nLiB0cnVzdGxpbmUpXG4gICAqIEBwYXJhbSB7e3Rva2VuOiBwYXJhbXMsIGFjdGlvbjogU3RyaW5nLCBsaW1pdDogU3RyaW5nfVtdfSBvcHRpb25zLnRydXN0bGluZXMgLSBBcnJheSBvZiB0cnVzdGxpbmVzIHRvIG1hbmFnZSAoc3VwcG9ydGVkIGJ5IFN0ZWxsYXIpXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHNlbmRNYW55KHBhcmFtczogU2VuZE1hbnlPcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24gKigpIHtcbiAgICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbJ2NvbW1lbnQnLCAnb3RwJ10sIGNhbGxiYWNrKTtcbiAgICAgIGRlYnVnKCdzZW5kTWFueSBjYWxsZWQnKTtcbiAgICAgIGNvbnN0IHJlcUlkID0gcGFyYW1zLnJlcUlkIHx8IG5ldyBSZXF1ZXN0VHJhY2VyKCk7XG4gICAgICBwYXJhbXMucmVxSWQgPSByZXFJZDtcbiAgICAgIGNvbnN0IGNvaW4gPSBzZWxmLmJhc2VDb2luO1xuICAgICAgaWYgKF8uaXNPYmplY3QocGFyYW1zLnJlY2lwaWVudHMpKSB7XG4gICAgICAgIHBhcmFtcy5yZWNpcGllbnRzLm1hcChmdW5jdGlvbihyZWNpcGllbnQpIHtcbiAgICAgICAgICBjb25zdCBhbW91bnQgPSBuZXcgQmlnTnVtYmVyKHJlY2lwaWVudC5hbW91bnQpO1xuICAgICAgICAgIGlmIChhbW91bnQuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQgZm9yIGFtb3VudCAtIHBvc2l0aXZlIG51bWJlciBncmVhdGVyIHRoYW4gemVybyBvciBudW1lcmljIHN0cmluZyBleHBlY3RlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWNvaW4udmFsdWVsZXNzVHJhbnNmZXJBbGxvd2VkKCkgJiYgYW1vdW50LmlzWmVybygpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQgZm9yIGFtb3VudCAtIHBvc2l0aXZlIG51bWJlciBncmVhdGVyIHRoYW4gemVybyBvciBudW1lcmljIHN0cmluZyBleHBlY3RlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGhhbGZTaWduZWRUcmFuc2FjdGlvbiA9IHlpZWxkIHNlbGYucHJlYnVpbGRBbmRTaWduVHJhbnNhY3Rpb24ocGFyYW1zKTtcbiAgICAgIGNvbnN0IHNlbGVjdFBhcmFtcyA9IF8ucGljayhwYXJhbXMsIFtcbiAgICAgICAgJ3JlY2lwaWVudHMnLCAnbnVtQmxvY2tzJywgJ2ZlZVJhdGUnLCAnbWF4RmVlUmF0ZScsICdtaW5Db25maXJtcycsXG4gICAgICAgICdlbmZvcmNlTWluQ29uZmlybXNGb3JDaGFuZ2UnLCAndGFyZ2V0V2FsbGV0VW5zcGVudHMnLFxuICAgICAgICAnbWVzc2FnZScsICdtaW5WYWx1ZScsICdtYXhWYWx1ZScsICdzZXF1ZW5jZUlkJyxcbiAgICAgICAgJ2xhc3RMZWRnZXJTZXF1ZW5jZScsICdsZWRnZXJTZXF1ZW5jZURlbHRhJywgJ2dhc1ByaWNlJyxcbiAgICAgICAgJ25vU3BsaXRDaGFuZ2UnLCAndW5zcGVudHMnLCAnY29tbWVudCcsICdvdHAnLCAnY2hhbmdlQWRkcmVzcycsXG4gICAgICAgICdpbnN0YW50JywgJ21lbW8nLCAndHlwZScsICd0cnVzdGxpbmVzJyxcbiAgICAgIF0pO1xuICAgICAgY29uc3QgZmluYWxUeFBhcmFtcyA9IF8uZXh0ZW5kKHt9LCBoYWxmU2lnbmVkVHJhbnNhY3Rpb24sIHNlbGVjdFBhcmFtcyk7XG4gICAgICBzZWxmLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocmVxSWQpO1xuICAgICAgcmV0dXJuIHNlbGYuYml0Z28ucG9zdChzZWxmLnVybCgnL3R4L3NlbmQnKSlcbiAgICAgICAgLnNlbmQoZmluYWxUeFBhcmFtcylcbiAgICAgICAgLnJlc3VsdCgpO1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogUmVjb3ZlciBhbiB1bnN1cHBvcnRlZCB0b2tlbiBmcm9tIGEgQml0R28gbXVsdGlzaWcgd2FsbGV0XG4gICAqIHBhcmFtcyBhcmUgdmFsaWRhdGVkIGluIEV0aC5wcm90b3R5cGUucmVjb3ZlclRva2VuXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy50b2tlbkNvbnRyYWN0QWRkcmVzcyB0aGUgY29udHJhY3QgYWRkcmVzcyBvZiB0aGUgdW5zdXBwb3J0ZWQgdG9rZW5cbiAgICogQHBhcmFtIHBhcmFtcy5yZWNpcGllbnQgdGhlIGRlc3RpbmF0aW9uIGFkZHJlc3MgcmVjb3ZlcmVkIHRva2VucyBzaG91bGQgYmUgc2VudCB0b1xuICAgKiBAcGFyYW0gcGFyYW1zLndhbGxldFBhc3NwaHJhc2UgdGhlIHdhbGxldCBwYXNzcGhyYXNlXG4gICAqIEBwYXJhbSBwYXJhbXMucHJ2IHRoZSB4cHJ2XG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgcmVjb3ZlclRva2VuKHBhcmFtczogUmVjb3ZlclRva2VuT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uICooKSB7XG4gICAgICBpZiAoc2VsZi5iYXNlQ29pbi5nZXRGYW1pbHkoKSAhPT0gJ2V0aCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b2tlbiByZWNvdmVyeSBvbmx5IHN1cHBvcnRlZCBmb3IgZXRoIHdhbGxldHMnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qge1xuICAgICAgICB0b2tlbkNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgcmVjaXBpZW50LFxuICAgICAgfSA9IHBhcmFtcztcblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQodG9rZW5Db250cmFjdEFkZHJlc3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBzdHJpbmcgcGFyYW1ldGVyIHRva2VuQ29udHJhY3RBZGRyZXNzJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHJlY2lwaWVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHN0cmluZyBwYXJhbWV0ZXIgcmVjaXBpZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlY292ZXJUb2tlbk9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgdG9rZW5Db250cmFjdEFkZHJlc3MsIHJlY2lwaWVudCB9LCBwYXJhbXMsIHsgd2FsbGV0OiBzZWxmIH0pO1xuICAgICAgcmV0dXJuIChzZWxmLmJhc2VDb2luIGFzIEV0aCkucmVjb3ZlclRva2VuKHJlY292ZXJUb2tlbk9wdGlvbnMpO1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRyYW5zYWN0aW9uIG1ldGFkYXRhIGZvciB0aGUgb2xkZXN0IHRyYW5zYWN0aW9uIHRoYXQgaXMgc3RpbGwgcGVuZGluZyBvciBhdHRlbXB0ZWRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge09iamVjdH0gT2JqZWN0IHdpdGggdHhpZCwgd2FsbGV0SWQsIHR4LCBhbmQgZmVlIChpZiBzdXBwb3J0ZWQgZm9yIGNvaW4pXG4gICAqL1xuICBnZXRGaXJzdFBlbmRpbmdUcmFuc2FjdGlvbihwYXJhbXM6IHt9ID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICByZXR1cm4gaW50ZXJuYWwuZ2V0Rmlyc3RQZW5kaW5nVHJhbnNhY3Rpb24oeyB3YWxsZXRJZDogdGhpcy5pZCgpIH0sIHRoaXMuYmFzZUNvaW4sIHRoaXMuYml0Z28pLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIENoYW5nZSB0aGUgZmVlIG9uIHRoZSBwZW5kaW5nIHRyYW5zYWN0aW9uIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGdpdmVuIHR4aWQgdG8gdGhlIGdpdmVuIG5ldyBmZWVcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLnR4aWQgVGhlIHRyYW5zYWN0aW9uIElkIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHRyYW5zYWN0aW9uIHdob3NlIGZlZSBpcyB0byBiZSBjaGFuZ2VkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMuZmVlIFRoZSBuZXcgZmVlIHRvIGFwcGx5IHRvIHRoZSBkZW5vdGVkIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgdHJhbnNhY3Rpb24gSUQgb2YgdGhlIG5ldyB0cmFuc2FjdGlvbiB0aGF0IGNvbnRhaW5zIHRoZSBuZXcgZmVlIHJhdGVcbiAgICovXG4gIGNoYW5nZUZlZShwYXJhbXM6IENoYW5nZUZlZU9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqKCkge1xuICAgICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd0eGlkJywgJ2ZlZSddLCBbXSwgY2FsbGJhY2spO1xuXG4gICAgICByZXR1cm4gc2VsZi5iaXRnby5wb3N0KHNlbGYuYmFzZUNvaW4udXJsKCcvd2FsbGV0LycgKyBzZWxmLmlkKCkgKyAnL3R4L2NoYW5nZUZlZScpKVxuICAgICAgICAuc2VuZChwYXJhbXMpXG4gICAgICAgIC5yZXN1bHQoKTtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGluZm8gZnJvbSBtZXJjaGFudCBzZXJ2ZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBUaGUgcGFyYW1zIHBhc3NlZCBpbnRvIHRoZSBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLnVybCBUaGUgVXJsIHRvIHJldHJpZXZlIGluZm8gZnJvbVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIGluZm8gcmV0dXJuZWQgZnJvbSB0aGUgbWVyY2hhbnQgc2VydmVyXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBnZXRQYXltZW50SW5mbyhwYXJhbXM6IHsgdXJsPzogc3RyaW5nOyB9ID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24gKmNvR2V0UGF5bWVudEluZm8oKSB7XG4gICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3VybCddLCBbXSwgY2FsbGJhY2spO1xuXG4gICAgICByZXR1cm4gc2VsZi5iaXRnby5nZXQoc2VsZi51cmwoJy9wYXltZW50SW5mbycpKVxuICAgICAgICAucXVlcnkocGFyYW1zKVxuICAgICAgICAucmVzdWx0KCk7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGpzb24gcGF5bWVudCByZXNwb25zZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIFRoZSBwYXJhbXMgcGFzc2VkIGludG8gdGhlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMucGF5bWVudFVybCAtIFRoZSB1cmwgdG8gc2VuZCB0aGUgZnVsbHkgc2lnbmVkIHRyYW5zYWN0aW9uIHRvXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMudHhIZXggLSBUaGUgdHJhbnNhY3Rpb24gaGV4IG9mIHRoZSBwYXltZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMubWVtbyB7U3RyaW5nfSAtIEEgbWVtbyBzdXBwbGllZCBieSB0aGUgbWVyY2hhbnQsIHRvIGJlIGluc2VydGVkIGludG8gdGhlIHRyYW5zZmVyIGFzIHRoZSBjb21tZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMuZXhwaXJlcyB7U3RyaW5nfSAtIElTTyBEYXRlIGZvcm1hdCBvZiB3aGVuIHRoZSBwYXltZW50IHJlcXVlc3QgZXhwaXJlc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIGluZm8gcmV0dXJuZWQgZnJvbSB0aGUgbWVyY2hhbnQgc2VydmVyIFBheW1lbnQgQWNrXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBzZW5kUGF5bWVudFJlc3BvbnNlKHBhcmFtczoge30gPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIHJldHVybiB0aGlzLmJpdGdvLnBvc3QodGhpcy51cmwoJy9zZW5kUGF5bWVudCcpKVxuICAgICAgLnNlbmQocGFyYW1zKVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgcG9saWN5IHJ1bGVcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLmNvbmRpdGlvbiBjb25kaXRpb24gb2JqZWN0XG4gICAqIEBwYXJhbSBwYXJhbXMuYWN0aW9uIGFjdGlvbiBvYmplY3RcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgY3JlYXRlUG9saWN5UnVsZShwYXJhbXM6IENyZWF0ZVBvbGljeVJ1bGVPcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24gKigpIHtcbiAgICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnaWQnLCAndHlwZSddLCBbJ21lc3NhZ2UnXSwgY2FsbGJhY2spO1xuXG4gICAgICBpZiAoIV8uaXNPYmplY3QocGFyYW1zLmNvbmRpdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHBhcmFtZXRlcjogY29uZGl0aW9ucyBvYmplY3QnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfLmlzT2JqZWN0KHBhcmFtcy5hY3Rpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBwYXJhbWV0ZXI6IGFjdGlvbiBvYmplY3QnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuYml0Z28ucG9zdChzZWxmLnVybCgnL3BvbGljeS9ydWxlJykpXG4gICAgICAgIC5zZW5kKHBhcmFtcylcbiAgICAgICAgLnJlc3VsdCgpO1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGEgcG9saWN5IHJ1bGVcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLmNvbmRpdGlvbiBjb25kaXRpb24gb2JqZWN0XG4gICAqIEBwYXJhbSBwYXJhbXMuYWN0aW9uIGFjdGlvbiBvYmplY3RcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgc2V0UG9saWN5UnVsZShwYXJhbXM6IGFueSA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uICooKSB7XG4gICAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ2lkJywgJ3R5cGUnXSwgWydtZXNzYWdlJ10sIGNhbGxiYWNrKTtcblxuICAgICAgaWYgKCFfLmlzT2JqZWN0KHBhcmFtcy5jb25kaXRpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBwYXJhbWV0ZXI6IGNvbmRpdGlvbnMgb2JqZWN0Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghXy5pc09iamVjdChwYXJhbXMuYWN0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcGFyYW1ldGVyOiBhY3Rpb24gb2JqZWN0Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLmJpdGdvLnB1dChzZWxmLnVybCgnL3BvbGljeS9ydWxlJykpXG4gICAgICAgIC5zZW5kKHBhcmFtcylcbiAgICAgICAgLnJlc3VsdCgpO1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIFBvbGljeSBSdWxlXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgcmVtb3ZlUG9saWN5UnVsZShwYXJhbXM6IFJlbW92ZVBvbGljeVJ1bGVPcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24gKigpIHtcbiAgICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnaWQnXSwgWydtZXNzYWdlJ10sIGNhbGxiYWNrKTtcblxuICAgICAgcmV0dXJuIHNlbGYuYml0Z28uZGVsKHNlbGYudXJsKCcvcG9saWN5L3J1bGUnKSlcbiAgICAgICAgLnNlbmQocGFyYW1zKVxuICAgICAgICAucmVzdWx0KCk7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhpcyB3YWxsZXRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICByZW1vdmUocGFyYW1zOiB7fSA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuYml0Z28uZGVsKHRoaXMudXJsKCkpLnJlc3VsdCgpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHRyYWRpbmcgYWNjb3VudCBmcm9tIHRoaXMgd2FsbGV0XG4gICAqL1xuICB0b1RyYWRpbmdBY2NvdW50KCk6IFRyYWRpbmdBY2NvdW50IHtcbiAgICBpZiAodGhpcy5iYXNlQ29pbi5nZXRGYW1pbHkoKSAhPT0gJ29mYycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG9ubHkgY29udmVydCBhbiBPZmZjaGFpbiAoT0ZDKSB3YWxsZXQgdG8gYSB0cmFkaW5nIGFjY291bnQnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFkaW5nQWNjb3VudCh0aGlzLl93YWxsZXQuZW50ZXJwcmlzZSwgdGhpcywgdGhpcy5iaXRnbyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgZG93bmxvYWRzIFBERiBrZXljYXJkIGZvciB3YWxsZXQgKHJlcXVpcmVzIHJlc3BvbnNlIGZyb20gd2FsbGV0cy5nZW5lcmF0ZVdhbGxldClcbiAgICpcbiAgICogTm90ZTogdGhpcyBpcyBleGFtcGxlIGNvZGUgYW5kIGlzIG5vdCB0aGUgdmVyc2lvbiB1c2VkIG9uIGJpdGdvLmNvbVxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqICAgKiBqc1BERiAtIGFuIGluc3RhbmNlIG9mIHRoZSBqc1BERiBsaWJyYXJ5XG4gICAqICAgKiBRUkNvZGUgLSBhbiBpbnN0YW5jZSBvZiB0aGUgUVJpb3VzIGxpYnJhcnlcbiAgICogICAqIHVzZXJLZXljaGFpbiAtIGEgd2FsbGV0J3MgcHJpdmF0ZSB1c2VyIGtleWNoYWluXG4gICAqICAgKiBiYWNrdXBLZXljaGFpbiAtIGEgd2FsbGV0J3MgcHJpdmF0ZSBiYWNrdXAga2V5Y2hhaW5cbiAgICogICAqIGJpdGdvS2V5Y2hhaW4gLSBhIHdhbGxldCdzIHByaXZhdGUgYml0Z28ga2V5Y2hhaW5cbiAgICogICAqIHBhc3NwaHJhc2UgLSB0aGUgd2FsbGV0IHBhc3NwaHJhc2VcbiAgICogICAqIHBhc3Njb2RlRW5jcnlwdGlvbkNvZGUgLSB0aGUgZW5jcnlwdGlvbiBzZWNyZXQgdXNlZCBmb3IgQm94IERcbiAgICogICAqIGFjdGl2YXRpb25Db2RlIC0gYSByYW5kb21seSBnZW5lcmF0ZWQgc2l4LWRpZ2l0IGFjdGl2YXRpb24gY29kZVxuICAgKiAgICogd2FsbGV0S2V5SUQgLSB0aGUgS2V5IElEIHVzZWQgZm9yIGRlcml2aW5nIGEgY29sZCB3YWxsZXQncyBzaWduaW5nIGtleVxuICAgKiAgICogYmFja3VwS2V5SUQgLSB0aGUgS2V5IElEIHVzZWQgZm9yIGRlcml2aW5nIGEgY29sZCB3YWxsZXQncyBiYWNrdXAga2V5XG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgZG93bmxvYWRLZXljYXJkKHBhcmFtczogRG93bmxvYWRLZXljYXJkT3B0aW9ucyA9IHt9KTogdm9pZCB7XG4gICAgaWYgKCF3aW5kb3cgfHwgIXdpbmRvdy5sb2NhdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZG93bmxvYWRLZXljYXJkIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGFibGUgd2l0aGluIGEgYnJvd3Nlci4nKTtcbiAgICB9XG5cbiAgICAvLyBHcmFiIHBhcmFtZXRlcnMgd2l0aCBkZWZhdWx0IGZvciBhY3RpdmF0aW9uQ29kZVxuICAgIGNvbnN0IHtcbiAgICAgIGpzUERGLFxuICAgICAgUVJDb2RlLFxuICAgICAgdXNlcktleWNoYWluLFxuICAgICAgYmFja3VwS2V5Y2hhaW4sXG4gICAgICBiaXRnb0tleWNoYWluLFxuICAgICAgcGFzc3BocmFzZSxcbiAgICAgIHBhc3Njb2RlRW5jcnlwdGlvbkNvZGUsXG4gICAgICB3YWxsZXRLZXlJRCxcbiAgICAgIGJhY2t1cEtleUlELFxuICAgICAgYWN0aXZhdGlvbkNvZGUgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA5MDAwMDAgKyAxMDAwMDApLnRvU3RyaW5nKCksXG4gICAgfSA9IHBhcmFtcztcblxuICAgIGlmICghanNQREYgfHwgdHlwZW9mIGpzUERGICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwYXNzIGluIGEgdmFsaWQganNQREYgaW5zdGFuY2UnKTtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBrZXljaGFpbnNcbiAgICBpZiAoIXVzZXJLZXljaGFpbiB8fCB0eXBlb2YgdXNlcktleWNoYWluICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBXYWxsZXQga2V5Y2hhaW4gbXVzdCBoYXZlIGEgJ3VzZXInIHByb3BlcnR5YCk7XG4gICAgfVxuXG4gICAgaWYgKCFiYWNrdXBLZXljaGFpbiB8fCB0eXBlb2YgYmFja3VwS2V5Y2hhaW4gIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhY2t1cCBrZXljaGFpbiBpcyByZXF1aXJlZCBhbmQgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICB9XG5cbiAgICBpZiAoIWJpdGdvS2V5Y2hhaW4gfHwgdHlwZW9mIGJpdGdvS2V5Y2hhaW4gIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpdGdvIGtleWNoYWluIGlzIHJlcXVpcmVkIGFuZCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIH1cblxuICAgIGlmICh3YWxsZXRLZXlJRCAmJiB0eXBlb2Ygd2FsbGV0S2V5SUQgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dhbGxldEtleUlEIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAoYmFja3VwS2V5SUQgJiYgdHlwZW9mIGJhY2t1cEtleUlEICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWNrdXBLZXlJRCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgYWN0aXZhdGlvbiBjb2RlIGlmIHByb3ZpZGVkXG4gICAgaWYgKHR5cGVvZiBhY3RpdmF0aW9uQ29kZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWN0aXZhdGlvbiBDb2RlIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aXZhdGlvbkNvZGUubGVuZ3RoICE9PSA2KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGl2YXRpb24gY29kZSBtdXN0IGJlIHNpeCBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuXG4gICAgY29uc3QgY29pblNob3J0TmFtZSA9IHRoaXMuYmFzZUNvaW4udHlwZTtcbiAgICBjb25zdCBjb2luTmFtZSA9IHRoaXMuYmFzZUNvaW4uZ2V0RnVsbE5hbWUoKTtcbiAgICBjb25zdCB3YWxsZXRMYWJlbCA9IHRoaXMuX3dhbGxldC5sYWJlbDtcblxuICAgIGNvbnN0IGRvYyA9IGRyYXdLZXljYXJkKHtcbiAgICAgIGpzUERGLFxuICAgICAgUVJDb2RlLFxuICAgICAgZW5jcnlwdDogdGhpcy5iaXRnby5lbmNyeXB0LFxuICAgICAgY29pblNob3J0TmFtZSxcbiAgICAgIGNvaW5OYW1lLFxuICAgICAgYWN0aXZhdGlvbkNvZGUsXG4gICAgICB3YWxsZXRMYWJlbCxcbiAgICAgIHBhc3NwaHJhc2UsXG4gICAgICBwYXNzY29kZUVuY3J5cHRpb25Db2RlLFxuICAgICAgdXNlcktleWNoYWluLFxuICAgICAgYmFja3VwS2V5Y2hhaW4sXG4gICAgICBiaXRnb0tleWNoYWluLFxuICAgICAgd2FsbGV0S2V5SUQsXG4gICAgICBiYWNrdXBLZXlJRCxcbiAgICB9KTtcblxuICAgIC8vIFNhdmUgdGhlIFBERiBvbiB0aGUgdXNlcidzIGJyb3dzZXJcbiAgICBkb2Muc2F2ZShgQml0R28gS2V5Y2FyZCBmb3IgJHt3YWxsZXRMYWJlbH0ucGRmYCk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGEgc2V0IG9mIGNvbnNvbGlkYXRpb24gdHJhbnNhY3Rpb25zIGZvciBhIHdhbGxldC5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiAgICAgZnJvbUFkZHJlc3NlcyAtIHRoZXNlIGFyZSB0aGUgb24tY2hhaW4gcmVjZWl2ZSBhZGRyZXNzZXMgd2Ugd2FudCB0byBwaWNrIGEgY29uc29saWRhdGlvbiBhbW91bnQgZnJvbVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGJ1aWxkQWNjb3VudENvbnNvbGlkYXRpb25zKHBhcmFtczogQnVpbGRDb25zb2xpZGF0aW9uVHJhbnNhY3Rpb25PcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFByZWJ1aWxkVHJhbnNhY3Rpb25SZXN1bHRbXT4pOiBCbHVlYmlyZDxQcmVidWlsZFRyYW5zYWN0aW9uUmVzdWx0W10+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288UHJlYnVpbGRUcmFuc2FjdGlvblJlc3VsdFtdPihmdW5jdGlvbiAqKCkge1xuICAgICAgaWYgKCFzZWxmLmJhc2VDb2luLmFsbG93c0FjY291bnRDb25zb2xpZGF0aW9ucygpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtzZWxmLmJhc2VDb2luLmdldEZ1bGxOYW1lKCl9IGRvZXMgbm90IGFsbG93IGFjY291bnQgY29uc29saWRhdGlvbnMuYCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdoaXRlbGlzdCBwYXJhbXMgdG8gYnVpbGQgdHhcbiAgICAgIGNvbnN0IHdoaXRlbGlzdGVkUGFyYW1zID0gXy5waWNrKHBhcmFtcywgc2VsZi5wcmVidWlsZENvbnNvbGlkYXRlVHJhbnNhY3Rpb25QYXJhbXMoKSk7XG4gICAgICBkZWJ1ZygncHJlYnVpbGRpbmcgY29uc29saWRhdGlvbiB0cmFuc2FjdGlvbjogJU8nLCB3aGl0ZWxpc3RlZFBhcmFtcyk7XG5cbiAgICAgIGlmIChwYXJhbXMucmVxSWQpIHtcbiAgICAgICAgc2VsZi5iaXRnby5zZXRSZXF1ZXN0VHJhY2VyKHBhcmFtcy5yZXFJZCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHRoaXMgY291bGQgcmV0dXJuIDEwMCBidWlsZCB0cmFuc2FjdGlvbnNcbiAgICAgIGNvbnN0IGJ1aWxkUmVzcG9uc2UgPSB5aWVsZCBzZWxmLmJpdGdvLnBvc3Qoc2VsZi5iYXNlQ29pbi51cmwoJy93YWxsZXQvJyArIHNlbGYuaWQoKSArICcvY29uc29saWRhdGVBY2NvdW50L2J1aWxkJykpXG4gICAgICAgIC5zZW5kKHdoaXRlbGlzdGVkUGFyYW1zKVxuICAgICAgICAucmVzdWx0KCk7XG5cbiAgICAgIC8vIHdlIG5lZWQgdG8gc3RlcCBvdmVyIGVhY2ggcHJlYnVpbGQgbm93IC0gc2hvdWxkIGJlIGluIGFuIGFycmF5IGluIHRoZSBib2R5XG4gICAgICBjb25zdCBjb25zb2xpZGF0aW9uczpUcmFuc2FjdGlvblByZWJ1aWxkW10gPSBbXTtcbiAgICAgIGZvciAoY29uc3QgY29uc29saWRhdGVBY2NvdW50QnVpbGQgb2YgYnVpbGRSZXNwb25zZSkge1xuICAgICAgICBsZXQgcHJlYnVpbGQ6IFRyYW5zYWN0aW9uUHJlYnVpbGQgPSB5aWVsZCBzZWxmLmJhc2VDb2luLnBvc3RQcm9jZXNzUHJlYnVpbGQoXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihjb25zb2xpZGF0ZUFjY291bnRCdWlsZCwgeyB3YWxsZXQ6IHNlbGYsIGJ1aWxkUGFyYW1zOiB3aGl0ZWxpc3RlZFBhcmFtcyB9KVxuICAgICAgICApO1xuXG4gICAgICAgIGRlbGV0ZSBwcmVidWlsZC53YWxsZXQ7XG4gICAgICAgIGRlbGV0ZSBwcmVidWlsZC5idWlsZFBhcmFtcztcblxuICAgICAgICBwcmVidWlsZCA9IF8uZXh0ZW5kKHt9LCBwcmVidWlsZCwgeyB3YWxsZXRJZDogc2VsZi5pZCgpIH0pO1xuICAgICAgICBkZWJ1ZygnZmluYWwgY29uc29saWRhdGlvbiB0cmFuc2FjdGlvbiBwcmVidWlsZDogJU8nLCBwcmVidWlsZCk7XG5cbiAgICAgICAgY29uc29saWRhdGlvbnMucHVzaChwcmVidWlsZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb25zb2xpZGF0aW9ucztcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhbmQgc2VuZHMgYSBzZXQgb2YgY29uc29saWRhdGlvbiB0cmFuc2FjdGlvbnMgZm9yIGEgd2FsbGV0LlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqICAgICBmcm9tQWRkcmVzc2VzIC0gdGhlc2UgYXJlIHRoZSBvbi1jaGFpbiByZWNlaXZlIGFkZHJlc3NlcyB3ZSB3YW50IHRvIHBpY2sgYSBjb25zb2xpZGF0aW9uIGFtb3VudCBmcm9tXG4gICAqL1xuICBzZW5kQWNjb3VudENvbnNvbGlkYXRpb24ocGFyYW1zOiBQcmVidWlsZEFuZFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxhbnk+KGZ1bmN0aW9uICooKSB7XG4gICAgICBpZiAoIXNlbGYuYmFzZUNvaW4uYWxsb3dzQWNjb3VudENvbnNvbGlkYXRpb25zKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3NlbGYuYmFzZUNvaW4uZ2V0RnVsbE5hbWUoKX0gZG9lcyBub3QgYWxsb3cgYWNjb3VudCBjb25zb2xpZGF0aW9ucy5gKTtcbiAgICAgIH1cblxuICAgICAgLy8gb25lIG9mIGEgc2V0IG9mIGNvbnNvbGlkYXRpb24gdHJhbnNhY3Rpb25zXG4gICAgICBpZiAodHlwZW9mIHBhcmFtcy5wcmVidWlsZFR4ID09PSAnc3RyaW5nJyB8fCBwYXJhbXMucHJlYnVpbGRUeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBidWlsZCBvZiBhY2NvdW50IGNvbnNvbGlkYXRpb24uJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcGFyYW1zLnByZWJ1aWxkVHguY29uc29saWRhdGVJZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmaW5kIGNvbnNvbGlkYXRpb24gaWQgb24gY29uc29saWRhdGlvbiB0cmFuc2FjdGlvbi4nKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2lnbmVkUHJlYnVpbGQgPSB5aWVsZCBzZWxmLnByZWJ1aWxkQW5kU2lnblRyYW5zYWN0aW9uKHBhcmFtcyk7XG5cbiAgICAgIC8vIGRlY29yYXRlIHdpdGggb3VyIGNvbnNvbGlkYXRpb24gaWRcbiAgICAgIHNpZ25lZFByZWJ1aWxkLmNvbnNvbGlkYXRlSWQgPSBwYXJhbXMucHJlYnVpbGRUeC5jb25zb2xpZGF0ZUlkO1xuXG4gICAgICBkZWxldGUgc2lnbmVkUHJlYnVpbGQud2FsbGV0O1xuXG4gICAgICByZXR1cm4geWllbGQgc2VsZi5zdWJtaXRUcmFuc2FjdGlvbihzaWduZWRQcmVidWlsZCk7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYW5kIHNlbmRzIGEgc2V0IG9mIGFjY291bnQgY29uc29saWRhdGlvbnMuIFRoaXMgaXMgaW50ZW5kZWQgdG8gZmx1c2ggbWFueSBiYWxhbmNlcyB0byB0aGUgcm9vdCB3YWxsZXQgYmFsYW5jZS5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHNlbmRBY2NvdW50Q29uc29saWRhdGlvbnMocGFyYW1zOiBCdWlsZENvbnNvbGlkYXRpb25UcmFuc2FjdGlvbk9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxhbnk+KGZ1bmN0aW9uICooKSB7XG4gICAgICBpZiAoIXNlbGYuYmFzZUNvaW4uYWxsb3dzQWNjb3VudENvbnNvbGlkYXRpb25zKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3NlbGYuYmFzZUNvaW4uZ2V0RnVsbE5hbWUoKX0gZG9lcyBub3QgYWxsb3cgYWNjb3VudCBjb25zb2xpZGF0aW9ucy5gKTtcbiAgICAgIH1cblxuICAgICAgLy8gdGhpcyBnaXZlcyB1cyBhIHNldCBvZiBhY2NvdW50IGNvbnNvbGlkYXRpb24gdHJhbnNhY3Rpb25zXG4gICAgICBjb25zdCB1bnNpZ25lZEJ1aWxkcyA9IHlpZWxkIHNlbGYuYnVpbGRBY2NvdW50Q29uc29saWRhdGlvbnMocGFyYW1zKTtcbiAgICAgIGlmICh1bnNpZ25lZEJ1aWxkcyAmJiB1bnNpZ25lZEJ1aWxkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NmdWxUeHM6IGFueVtdID0gW107XG4gICAgICAgIGNvbnN0IGZhaWxlZFR4cyA9IG5ldyBBcnJheTxFcnJvcj4oKTtcbiAgICAgICAgZm9yIChjb25zdCB1bnNpZ25lZEJ1aWxkIG9mIHVuc2lnbmVkQnVpbGRzKSB7XG4gICAgICAgICAgLy8gZm9sZCBhbnkgb2YgdGhlIHBhcmFtZXRlcnMgd2UgdXNlZCB0byBidWlsZCB0aGlzIHRyYW5zYWN0aW9uIGludG8gdGhlIHVuc2lnbmVkQnVpbGRcbiAgICAgICAgICBjb25zdCB1bnNpZ25lZEJ1aWxkV2l0aE9wdGlvbnM6IFByZWJ1aWxkQW5kU2lnblRyYW5zYWN0aW9uT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyk7XG4gICAgICAgICAgdW5zaWduZWRCdWlsZFdpdGhPcHRpb25zLnByZWJ1aWxkVHggPSB1bnNpZ25lZEJ1aWxkO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzZW5kVHggPSB5aWVsZCBzZWxmLnNlbmRBY2NvdW50Q29uc29saWRhdGlvbih1bnNpZ25lZEJ1aWxkV2l0aE9wdGlvbnMpO1xuICAgICAgICAgICAgc3VjY2Vzc2Z1bFR4cy5wdXNoKHNlbmRUeCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZmFpbGVkVHhzLnB1c2goZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBzdWNjZXNzZnVsVHhzLFxuICAgICAgICAgIGZhaWx1cmU6IGZhaWxlZFR4cyxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG59XG4iXX0=