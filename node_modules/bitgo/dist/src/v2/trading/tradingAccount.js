"use strict";
/**
 * @prettier
 */
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 */
var bignumber_js_1 = require("bignumber.js");
var Bluebird = require("bluebird");
var tradingPartners_1 = require("./tradingPartners");
var affirmations_1 = require("./affirmations");
var settlements_1 = require("./settlements");
var co = Bluebird.coroutine;
var TRADE_PAYLOAD_VERSION = '1.2.0';
var TradingAccount = /** @class */ (function () {
    function TradingAccount(enterpriseId, wallet, bitgo) {
        this.enterpriseId = enterpriseId;
        this.wallet = wallet;
        this.bitgo = bitgo;
    }
    Object.defineProperty(TradingAccount.prototype, "id", {
        get: function () {
            return this.wallet.id();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Builds a payload authorizing trade from this trading account.
     * @param params
     * @param params.amounts[] array of amounts that will be traded as part of the settlement
     * @param params.amounts[].accountId the accountId corresponding with the sending and receiving amounts for the settlement
     * @param params.amounts[].sendAmount amount of currency sent by trading account of given accountId
     * @param params.amounts[].sendCurrency currency of amount sent by trading account of given accountId
     * @param params.amounts[].receiveAmount amount of currency received by trading account of given accountId
     * @param params.amounts[].receiveCurrency currency of amount received by trading account of given accountId
     * @param callback
     * @returns unsigned trade payload for the given parameters. This object should be stringified with JSON.stringify() before being submitted
     */
    TradingAccount.prototype.buildPayload = function (params, callback) {
        return co(function buildTradePayload() {
            var url, body, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.bitgo.microservicesUrl("/api/trade/v1/enterprise/" + this.enterpriseId + "/account/" + this.id + "/payload");
                        body = {
                            version: TRADE_PAYLOAD_VERSION,
                            amounts: params.amounts,
                        };
                        return [4 /*yield*/, this.bitgo
                                .post(url)
                                .send(body)
                                .result()];
                    case 1:
                        response = _a.sent();
                        if (!this.verifyPayload(params, response.payload)) {
                            throw new Error('Unable to verify trade payload. You may need to update the BitGo SDK, or the payload may have been tampered with.');
                        }
                        return [2 /*return*/, JSON.parse(response.payload)];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Verifies that a payload received from BitGo sufficiently matches the expected parameters. This is used to prevent
     * man-in-the-middle attacks which could maliciously alter the contents of a payload.
     * @param params parameters used to build the payload
     * @param payload payload received from the BitGo API
     * @returns true if the payload's sensitive fields match, false if the payload may have been tampered with
     */
    TradingAccount.prototype.verifyPayload = function (params, payload) {
        var payloadObj = JSON.parse(payload);
        var paramsCopy = JSON.parse(JSON.stringify(params)); // needs to be a deep copy
        // Verifies that for each party in the payload, we requested a matching party, only checking sensitive fields
        var validAmounts = 0;
        var _loop_1 = function (amount) {
            var matchingExpectedParty = paramsCopy.amounts.findIndex(function (expectedAmount) {
                return amount.accountId === expectedAmount.accountId &&
                    amount.sendCurrency === expectedAmount.sendCurrency &&
                    amount.sendSubtotal === expectedAmount.sendAmount &&
                    amount.receiveAmount === expectedAmount.receiveAmount &&
                    amount.receiveCurrency === expectedAmount.receiveCurrency;
            });
            if (matchingExpectedParty === -1) {
                return "break";
            }
            if (amount.fees && amount.fees.length > 0) {
                var feeTotal = new bignumber_js_1.BigNumber(0);
                for (var _i = 0, _a = amount.fees; _i < _a.length; _i++) {
                    var fee = _a[_i];
                    feeTotal = feeTotal.plus(new bignumber_js_1.BigNumber(fee.feeAmount));
                }
                var expectedTotalAmount = new bignumber_js_1.BigNumber(paramsCopy.amounts[matchingExpectedParty].sendAmount).plus(feeTotal);
                if (expectedTotalAmount.toString() !== amount.sendAmount) {
                    return "break";
                }
            }
            // matching party found, and fee found
            validAmounts = validAmounts + 1;
            // delete so we ensure no duplicates
            paramsCopy.amounts.splice(matchingExpectedParty, 1);
        };
        for (var _i = 0, _a = payloadObj.amounts; _i < _a.length; _i++) {
            var amount = _a[_i];
            var state_1 = _loop_1(amount);
            if (state_1 === "break")
                break;
        }
        return (payloadObj.accountId === this.id &&
            payloadObj.amounts.length === params.amounts.length &&
            validAmounts === payloadObj.amounts.length);
    };
    /**
     * Calculates the necessary fees to complete a settlement between two parties, based on the amounts and currencies of the settlement.
     * @param params
     * @param params.counterpartyAccountId Account ID of the counterparty of the settlement
     * @param params.sendCurrency Currency to be sent as part of the settlement
     * @param params.sendAmount Amount of currency (in base units such as cents, satoshis, or wei) to be sent
     * @param params.receiveCurrency Currency to be received as part of the settlement
     * @param params.receiveAmount Amount of currency (in base units such as cents, satoshis, or wei) to be received
     * @param callback
     * @returns Fee rate, currency, and total amount of the described settlement
     */
    TradingAccount.prototype.calculateSettlementFees = function (params, callback) {
        var url = this.bitgo.microservicesUrl("/api/trade/v1/enterprise/" + this.enterpriseId + "/account/" + this.id + "/calculatefees");
        return this.bitgo
            .post(url)
            .send(params)
            .result()
            .asCallback(callback);
    };
    /**
     * Signs a pre-built trade payload with the user key on this trading account
     * @param params
     * @param params.payload trade payload object from TradingAccount::buildPayload()
     * @param params.walletPassphrase passphrase on this trading account, used to unlock the account user key
     * @param callback
     * @returns hex-encoded signature of the payload
     */
    TradingAccount.prototype.signPayload = function (params, callback) {
        var self = this;
        return co(function signPayload() {
            var key, prv, payload;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, self.wallet.baseCoin.keychains().get({ id: self.wallet.keyIds()[0] })];
                    case 1:
                        key = _a.sent();
                        prv = self.wallet.bitgo.decrypt({
                            input: key.encryptedPrv,
                            password: params.walletPassphrase,
                        });
                        payload = JSON.stringify(params.payload);
                        return [4 /*yield*/, self.wallet.baseCoin.signMessage({ prv: prv }, payload)];
                    case 2: return [2 /*return*/, (_a.sent()).toString('hex')];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    TradingAccount.prototype.affirmations = function () {
        return new affirmations_1.Affirmations(this.bitgo, this.enterpriseId, this);
    };
    TradingAccount.prototype.settlements = function () {
        return new settlements_1.Settlements(this.bitgo, this.enterpriseId, this);
    };
    TradingAccount.prototype.partners = function () {
        return new tradingPartners_1.TradingPartners(this.bitgo, this.enterpriseId, this);
    };
    return TradingAccount;
}());
exports.TradingAccount = TradingAccount;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhZGluZ0FjY291bnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvdjIvdHJhZGluZy90cmFkaW5nQWNjb3VudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7O0dBRUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUg7R0FDRztBQUNILDZDQUF5QztBQUN6QyxtQ0FBcUM7QUFNckMscURBQW9EO0FBQ3BELCtDQUE4QztBQUM5Qyw2Q0FBNEM7QUFFNUMsSUFBTSxFQUFFLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQztBQUU5QixJQUFNLHFCQUFxQixHQUFHLE9BQU8sQ0FBQztBQWlDdEM7SUFNRSx3QkFBWSxZQUFvQixFQUFFLE1BQWMsRUFBRSxLQUFZO1FBQzVELElBQUksQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFDO1FBQ2pDLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0lBQ3JCLENBQUM7SUFFRCxzQkFBSSw4QkFBRTthQUFOO1lBQ0UsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxDQUFDO1FBQzFCLENBQUM7OztPQUFBO0lBRUQ7Ozs7Ozs7Ozs7O09BV0c7SUFDSCxxQ0FBWSxHQUFaLFVBQWEsTUFBOEIsRUFBRSxRQUFnQztRQUMzRSxPQUFPLEVBQUUsQ0FBVSxTQUFVLGlCQUFpQjs7Ozs7d0JBQ3RDLEdBQUcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUNyQyw4QkFBNEIsSUFBSSxDQUFDLFlBQVksaUJBQVksSUFBSSxDQUFDLEVBQUUsYUFBVSxDQUMzRSxDQUFDO3dCQUVJLElBQUksR0FBRzs0QkFDWCxPQUFPLEVBQUUscUJBQXFCOzRCQUM5QixPQUFPLEVBQUUsTUFBTSxDQUFDLE9BQU87eUJBQ3hCLENBQUM7d0JBRWUscUJBQU0sSUFBSSxDQUFDLEtBQUs7aUNBQzlCLElBQUks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RUFBRSxFQUFFLE9BQU8sQ0FBQyxFQUFBOzRCQUFoRSxzQkFBTyxDQUFDLFNBQXdELENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUM7OztTQUNuRixDQUFDO2FBQ0MsSUFBSSxDQUFDLElBQUksQ0FBQzthQUNWLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUMxQixDQUFDO0lBRUQscUNBQVksR0FBWjtRQUNFLE9BQU8sSUFBSSwyQkFBWSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsQ0FBQztJQUMvRCxDQUFDO0lBRUQsb0NBQVcsR0FBWDtRQUNFLE9BQU8sSUFBSSx5QkFBVyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsQ0FBQztJQUM5RCxDQUFDO0lBRUQsaUNBQVEsR0FBUjtRQUNFLE9BQU8sSUFBSSxpQ0FBZSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNsRSxDQUFDO0lBQ0gscUJBQUM7QUFBRCxDQUFDLEFBNUtELElBNEtDO0FBNUtZLHdDQUFjIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJldHRpZXJcbiAqL1xuXG4vKipcbiAqL1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCAqIGFzIEJsdWViaXJkIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCB7IEJpdEdvIH0gZnJvbSAnLi4vLi4vYml0Z28nO1xuXG5pbXBvcnQgeyBOb2RlQ2FsbGJhY2sgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBXYWxsZXQgfSBmcm9tICcuLi93YWxsZXQnO1xuaW1wb3J0IHsgUGF5bG9hZCB9IGZyb20gJy4vcGF5bG9hZCc7XG5pbXBvcnQgeyBUcmFkaW5nUGFydG5lcnMgfSBmcm9tICcuL3RyYWRpbmdQYXJ0bmVycyc7XG5pbXBvcnQgeyBBZmZpcm1hdGlvbnMgfSBmcm9tICcuL2FmZmlybWF0aW9ucyc7XG5pbXBvcnQgeyBTZXR0bGVtZW50cyB9IGZyb20gJy4vc2V0dGxlbWVudHMnO1xuXG5jb25zdCBjbyA9IEJsdWViaXJkLmNvcm91dGluZTtcblxuY29uc3QgVFJBREVfUEFZTE9BRF9WRVJTSU9OID0gJzEuMi4wJztcblxuZXhwb3J0IGludGVyZmFjZSBCdWlsZFBheWxvYWRQYXJhbWV0ZXJzIHtcbiAgYW1vdW50czogQnVpbGRQYXlsb2FkQW1vdW50c1tdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJ1aWxkUGF5bG9hZEFtb3VudHMge1xuICBhY2NvdW50SWQ6IHN0cmluZztcbiAgc2VuZEFtb3VudDogc3RyaW5nO1xuICBzZW5kQ3VycmVuY3k6IHN0cmluZztcbiAgcmVjZWl2ZUFtb3VudDogc3RyaW5nO1xuICByZWNlaXZlQ3VycmVuY3k6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTaWduUGF5bG9hZFBhcmFtZXRlcnMge1xuICBwYXlsb2FkOiBQYXlsb2FkO1xuICB3YWxsZXRQYXNzcGhyYXNlOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2V0dGxlbWVudEZlZXMge1xuICBmZWVSYXRlOiBzdHJpbmc7XG4gIGZlZUFtb3VudDogc3RyaW5nO1xuICBmZWVDdXJyZW5jeTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENhbGN1bGF0ZVNldHRsZW1lbnRGZWVzUGFyYW1zIHtcbiAgY291bnRlcnBhcnR5QWNjb3VudElkOiBzdHJpbmc7XG4gIHNlbmRDdXJyZW5jeTogc3RyaW5nO1xuICBzZW5kQW1vdW50OiBzdHJpbmc7XG4gIHJlY2VpdmVDdXJyZW5jeTogc3RyaW5nO1xuICByZWNlaXZlQW1vdW50OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBUcmFkaW5nQWNjb3VudCB7XG4gIHByaXZhdGUgcmVhZG9ubHkgYml0Z286IEJpdEdvO1xuICBwcml2YXRlIHJlYWRvbmx5IGVudGVycHJpc2VJZDogc3RyaW5nO1xuXG4gIHB1YmxpYyB3YWxsZXQ6IFdhbGxldDtcblxuICBjb25zdHJ1Y3RvcihlbnRlcnByaXNlSWQ6IHN0cmluZywgd2FsbGV0OiBXYWxsZXQsIGJpdGdvOiBCaXRHbykge1xuICAgIHRoaXMuZW50ZXJwcmlzZUlkID0gZW50ZXJwcmlzZUlkO1xuICAgIHRoaXMud2FsbGV0ID0gd2FsbGV0O1xuICAgIHRoaXMuYml0Z28gPSBiaXRnbztcbiAgfVxuXG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy53YWxsZXQuaWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBwYXlsb2FkIGF1dGhvcml6aW5nIHRyYWRlIGZyb20gdGhpcyB0cmFkaW5nIGFjY291bnQuXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy5hbW91bnRzW10gYXJyYXkgb2YgYW1vdW50cyB0aGF0IHdpbGwgYmUgdHJhZGVkIGFzIHBhcnQgb2YgdGhlIHNldHRsZW1lbnRcbiAgICogQHBhcmFtIHBhcmFtcy5hbW91bnRzW10uYWNjb3VudElkIHRoZSBhY2NvdW50SWQgY29ycmVzcG9uZGluZyB3aXRoIHRoZSBzZW5kaW5nIGFuZCByZWNlaXZpbmcgYW1vdW50cyBmb3IgdGhlIHNldHRsZW1lbnRcbiAgICogQHBhcmFtIHBhcmFtcy5hbW91bnRzW10uc2VuZEFtb3VudCBhbW91bnQgb2YgY3VycmVuY3kgc2VudCBieSB0cmFkaW5nIGFjY291bnQgb2YgZ2l2ZW4gYWNjb3VudElkXG4gICAqIEBwYXJhbSBwYXJhbXMuYW1vdW50c1tdLnNlbmRDdXJyZW5jeSBjdXJyZW5jeSBvZiBhbW91bnQgc2VudCBieSB0cmFkaW5nIGFjY291bnQgb2YgZ2l2ZW4gYWNjb3VudElkXG4gICAqIEBwYXJhbSBwYXJhbXMuYW1vdW50c1tdLnJlY2VpdmVBbW91bnQgYW1vdW50IG9mIGN1cnJlbmN5IHJlY2VpdmVkIGJ5IHRyYWRpbmcgYWNjb3VudCBvZiBnaXZlbiBhY2NvdW50SWRcbiAgICogQHBhcmFtIHBhcmFtcy5hbW91bnRzW10ucmVjZWl2ZUN1cnJlbmN5IGN1cnJlbmN5IG9mIGFtb3VudCByZWNlaXZlZCBieSB0cmFkaW5nIGFjY291bnQgb2YgZ2l2ZW4gYWNjb3VudElkXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB1bnNpZ25lZCB0cmFkZSBwYXlsb2FkIGZvciB0aGUgZ2l2ZW4gcGFyYW1ldGVycy4gVGhpcyBvYmplY3Qgc2hvdWxkIGJlIHN0cmluZ2lmaWVkIHdpdGggSlNPTi5zdHJpbmdpZnkoKSBiZWZvcmUgYmVpbmcgc3VibWl0dGVkXG4gICAqL1xuICBidWlsZFBheWxvYWQocGFyYW1zOiBCdWlsZFBheWxvYWRQYXJhbWV0ZXJzLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxQYXlsb2FkPik6IEJsdWViaXJkPFBheWxvYWQ+IHtcbiAgICByZXR1cm4gY288UGF5bG9hZD4oZnVuY3Rpb24qIGJ1aWxkVHJhZGVQYXlsb2FkKCkge1xuICAgICAgY29uc3QgdXJsID0gdGhpcy5iaXRnby5taWNyb3NlcnZpY2VzVXJsKFxuICAgICAgICBgL2FwaS90cmFkZS92MS9lbnRlcnByaXNlLyR7dGhpcy5lbnRlcnByaXNlSWR9L2FjY291bnQvJHt0aGlzLmlkfS9wYXlsb2FkYFxuICAgICAgKTtcblxuICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgdmVyc2lvbjogVFJBREVfUEFZTE9BRF9WRVJTSU9OLFxuICAgICAgICBhbW91bnRzOiBwYXJhbXMuYW1vdW50cyxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5iaXRnb1xuICAgICAgICAucG9zdCh1cmwpXG4gICAgICAgIC5zZW5kKGJvZHkpXG4gICAgICAgIC5yZXN1bHQoKTtcblxuICAgICAgaWYgKCF0aGlzLnZlcmlmeVBheWxvYWQocGFyYW1zLCByZXNwb25zZS5wYXlsb2FkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1VuYWJsZSB0byB2ZXJpZnkgdHJhZGUgcGF5bG9hZC4gWW91IG1heSBuZWVkIHRvIHVwZGF0ZSB0aGUgQml0R28gU0RLLCBvciB0aGUgcGF5bG9hZCBtYXkgaGF2ZSBiZWVuIHRhbXBlcmVkIHdpdGguJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShyZXNwb25zZS5wYXlsb2FkKSBhcyBQYXlsb2FkO1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmaWVzIHRoYXQgYSBwYXlsb2FkIHJlY2VpdmVkIGZyb20gQml0R28gc3VmZmljaWVudGx5IG1hdGNoZXMgdGhlIGV4cGVjdGVkIHBhcmFtZXRlcnMuIFRoaXMgaXMgdXNlZCB0byBwcmV2ZW50XG4gICAqIG1hbi1pbi10aGUtbWlkZGxlIGF0dGFja3Mgd2hpY2ggY291bGQgbWFsaWNpb3VzbHkgYWx0ZXIgdGhlIGNvbnRlbnRzIG9mIGEgcGF5bG9hZC5cbiAgICogQHBhcmFtIHBhcmFtcyBwYXJhbWV0ZXJzIHVzZWQgdG8gYnVpbGQgdGhlIHBheWxvYWRcbiAgICogQHBhcmFtIHBheWxvYWQgcGF5bG9hZCByZWNlaXZlZCBmcm9tIHRoZSBCaXRHbyBBUElcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcGF5bG9hZCdzIHNlbnNpdGl2ZSBmaWVsZHMgbWF0Y2gsIGZhbHNlIGlmIHRoZSBwYXlsb2FkIG1heSBoYXZlIGJlZW4gdGFtcGVyZWQgd2l0aFxuICAgKi9cbiAgdmVyaWZ5UGF5bG9hZChwYXJhbXM6IEJ1aWxkUGF5bG9hZFBhcmFtZXRlcnMsIHBheWxvYWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHBheWxvYWRPYmogPSBKU09OLnBhcnNlKHBheWxvYWQpO1xuICAgIGNvbnN0IHBhcmFtc0NvcHkgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHBhcmFtcykpOyAvLyBuZWVkcyB0byBiZSBhIGRlZXAgY29weVxuXG4gICAgLy8gVmVyaWZpZXMgdGhhdCBmb3IgZWFjaCBwYXJ0eSBpbiB0aGUgcGF5bG9hZCwgd2UgcmVxdWVzdGVkIGEgbWF0Y2hpbmcgcGFydHksIG9ubHkgY2hlY2tpbmcgc2Vuc2l0aXZlIGZpZWxkc1xuICAgIGxldCB2YWxpZEFtb3VudHMgPSAwO1xuICAgIGZvciAoY29uc3QgYW1vdW50IG9mIHBheWxvYWRPYmouYW1vdW50cykge1xuICAgICAgY29uc3QgbWF0Y2hpbmdFeHBlY3RlZFBhcnR5ID0gcGFyYW1zQ29weS5hbW91bnRzLmZpbmRJbmRleChcbiAgICAgICAgZXhwZWN0ZWRBbW91bnQgPT5cbiAgICAgICAgICBhbW91bnQuYWNjb3VudElkID09PSBleHBlY3RlZEFtb3VudC5hY2NvdW50SWQgJiZcbiAgICAgICAgICBhbW91bnQuc2VuZEN1cnJlbmN5ID09PSBleHBlY3RlZEFtb3VudC5zZW5kQ3VycmVuY3kgJiZcbiAgICAgICAgICBhbW91bnQuc2VuZFN1YnRvdGFsID09PSBleHBlY3RlZEFtb3VudC5zZW5kQW1vdW50ICYmXG4gICAgICAgICAgYW1vdW50LnJlY2VpdmVBbW91bnQgPT09IGV4cGVjdGVkQW1vdW50LnJlY2VpdmVBbW91bnQgJiZcbiAgICAgICAgICBhbW91bnQucmVjZWl2ZUN1cnJlbmN5ID09PSBleHBlY3RlZEFtb3VudC5yZWNlaXZlQ3VycmVuY3lcbiAgICAgICk7XG5cbiAgICAgIGlmIChtYXRjaGluZ0V4cGVjdGVkUGFydHkgPT09IC0xKSB7XG4gICAgICAgIC8vIG1hdGNoaW5nRXhwZWN0ZWRQYXJ0eSBub3QgZm91bmQgdG8gdGhlIHBheWxvYWRPYmplY3RcbiAgICAgICAgLy8gcGF5bG9hZCBpcyBub3QgdmFsaWRcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbW91bnQuZmVlcyAmJiBhbW91bnQuZmVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBmZWVUb3RhbCA9IG5ldyBCaWdOdW1iZXIoMCk7XG4gICAgICAgIGZvciAoY29uc3QgZmVlIG9mIGFtb3VudC5mZWVzKSB7XG4gICAgICAgICAgZmVlVG90YWwgPSBmZWVUb3RhbC5wbHVzKG5ldyBCaWdOdW1iZXIoZmVlLmZlZUFtb3VudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXhwZWN0ZWRUb3RhbEFtb3VudCA9IG5ldyBCaWdOdW1iZXIocGFyYW1zQ29weS5hbW91bnRzW21hdGNoaW5nRXhwZWN0ZWRQYXJ0eV0uc2VuZEFtb3VudCkucGx1cyhmZWVUb3RhbCk7XG4gICAgICAgIGlmIChleHBlY3RlZFRvdGFsQW1vdW50LnRvU3RyaW5nKCkgIT09IGFtb3VudC5zZW5kQW1vdW50KSB7XG4gICAgICAgICAgLy8gZXhwZWN0ZWQgdG90YWwgZG9lcyBub3QgbWF0Y2ggdGhlIHNlbmRBbW91bnQgb2YgdGhlIHBheWxvYWRcbiAgICAgICAgICAvLyBwYXlsb2FkIGlzIG5vdCB2YWxpZFxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG1hdGNoaW5nIHBhcnR5IGZvdW5kLCBhbmQgZmVlIGZvdW5kXG4gICAgICB2YWxpZEFtb3VudHMgPSB2YWxpZEFtb3VudHMgKyAxO1xuICAgICAgLy8gZGVsZXRlIHNvIHdlIGVuc3VyZSBubyBkdXBsaWNhdGVzXG4gICAgICBwYXJhbXNDb3B5LmFtb3VudHMuc3BsaWNlKG1hdGNoaW5nRXhwZWN0ZWRQYXJ0eSwgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIHBheWxvYWRPYmouYWNjb3VudElkID09PSB0aGlzLmlkICYmXG4gICAgICBwYXlsb2FkT2JqLmFtb3VudHMubGVuZ3RoID09PSBwYXJhbXMuYW1vdW50cy5sZW5ndGggJiZcbiAgICAgIHZhbGlkQW1vdW50cyA9PT0gcGF5bG9hZE9iai5hbW91bnRzLmxlbmd0aFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgbmVjZXNzYXJ5IGZlZXMgdG8gY29tcGxldGUgYSBzZXR0bGVtZW50IGJldHdlZW4gdHdvIHBhcnRpZXMsIGJhc2VkIG9uIHRoZSBhbW91bnRzIGFuZCBjdXJyZW5jaWVzIG9mIHRoZSBzZXR0bGVtZW50LlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMuY291bnRlcnBhcnR5QWNjb3VudElkIEFjY291bnQgSUQgb2YgdGhlIGNvdW50ZXJwYXJ0eSBvZiB0aGUgc2V0dGxlbWVudFxuICAgKiBAcGFyYW0gcGFyYW1zLnNlbmRDdXJyZW5jeSBDdXJyZW5jeSB0byBiZSBzZW50IGFzIHBhcnQgb2YgdGhlIHNldHRsZW1lbnRcbiAgICogQHBhcmFtIHBhcmFtcy5zZW5kQW1vdW50IEFtb3VudCBvZiBjdXJyZW5jeSAoaW4gYmFzZSB1bml0cyBzdWNoIGFzIGNlbnRzLCBzYXRvc2hpcywgb3Igd2VpKSB0byBiZSBzZW50XG4gICAqIEBwYXJhbSBwYXJhbXMucmVjZWl2ZUN1cnJlbmN5IEN1cnJlbmN5IHRvIGJlIHJlY2VpdmVkIGFzIHBhcnQgb2YgdGhlIHNldHRsZW1lbnRcbiAgICogQHBhcmFtIHBhcmFtcy5yZWNlaXZlQW1vdW50IEFtb3VudCBvZiBjdXJyZW5jeSAoaW4gYmFzZSB1bml0cyBzdWNoIGFzIGNlbnRzLCBzYXRvc2hpcywgb3Igd2VpKSB0byBiZSByZWNlaXZlZFxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMgRmVlIHJhdGUsIGN1cnJlbmN5LCBhbmQgdG90YWwgYW1vdW50IG9mIHRoZSBkZXNjcmliZWQgc2V0dGxlbWVudFxuICAgKi9cbiAgY2FsY3VsYXRlU2V0dGxlbWVudEZlZXMoXG4gICAgcGFyYW1zOiBDYWxjdWxhdGVTZXR0bGVtZW50RmVlc1BhcmFtcyxcbiAgICBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxTZXR0bGVtZW50RmVlcz5cbiAgKTogQmx1ZWJpcmQ8U2V0dGxlbWVudEZlZXM+IHtcbiAgICBjb25zdCB1cmwgPSB0aGlzLmJpdGdvLm1pY3Jvc2VydmljZXNVcmwoXG4gICAgICBgL2FwaS90cmFkZS92MS9lbnRlcnByaXNlLyR7dGhpcy5lbnRlcnByaXNlSWR9L2FjY291bnQvJHt0aGlzLmlkfS9jYWxjdWxhdGVmZWVzYFxuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcy5iaXRnb1xuICAgICAgLnBvc3QodXJsKVxuICAgICAgLnNlbmQocGFyYW1zKVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogU2lnbnMgYSBwcmUtYnVpbHQgdHJhZGUgcGF5bG9hZCB3aXRoIHRoZSB1c2VyIGtleSBvbiB0aGlzIHRyYWRpbmcgYWNjb3VudFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMucGF5bG9hZCB0cmFkZSBwYXlsb2FkIG9iamVjdCBmcm9tIFRyYWRpbmdBY2NvdW50OjpidWlsZFBheWxvYWQoKVxuICAgKiBAcGFyYW0gcGFyYW1zLndhbGxldFBhc3NwaHJhc2UgcGFzc3BocmFzZSBvbiB0aGlzIHRyYWRpbmcgYWNjb3VudCwgdXNlZCB0byB1bmxvY2sgdGhlIGFjY291bnQgdXNlciBrZXlcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIGhleC1lbmNvZGVkIHNpZ25hdHVyZSBvZiB0aGUgcGF5bG9hZFxuICAgKi9cbiAgc2lnblBheWxvYWQocGFyYW1zOiBTaWduUGF5bG9hZFBhcmFtZXRlcnMsIGNhbGxiYWNrPyk6IEJsdWViaXJkPHN0cmluZz4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxzdHJpbmc+KGZ1bmN0aW9uKiBzaWduUGF5bG9hZCgpIHtcbiAgICAgIGNvbnN0IGtleSA9IHlpZWxkIHNlbGYud2FsbGV0LmJhc2VDb2luLmtleWNoYWlucygpLmdldCh7IGlkOiBzZWxmLndhbGxldC5rZXlJZHMoKVswXSB9KTtcbiAgICAgIGNvbnN0IHBydiA9IHNlbGYud2FsbGV0LmJpdGdvLmRlY3J5cHQoe1xuICAgICAgICBpbnB1dDoga2V5LmVuY3J5cHRlZFBydixcbiAgICAgICAgcGFzc3dvcmQ6IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkocGFyYW1zLnBheWxvYWQpO1xuICAgICAgcmV0dXJuICh5aWVsZCBzZWxmLndhbGxldC5iYXNlQ29pbi5zaWduTWVzc2FnZSh7IHBydiB9LCBwYXlsb2FkKSkudG9TdHJpbmcoJ2hleCcpO1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgYWZmaXJtYXRpb25zKCk6IEFmZmlybWF0aW9ucyB7XG4gICAgcmV0dXJuIG5ldyBBZmZpcm1hdGlvbnModGhpcy5iaXRnbywgdGhpcy5lbnRlcnByaXNlSWQsIHRoaXMpO1xuICB9XG5cbiAgc2V0dGxlbWVudHMoKTogU2V0dGxlbWVudHMge1xuICAgIHJldHVybiBuZXcgU2V0dGxlbWVudHModGhpcy5iaXRnbywgdGhpcy5lbnRlcnByaXNlSWQsIHRoaXMpO1xuICB9XG5cbiAgcGFydG5lcnMoKTogVHJhZGluZ1BhcnRuZXJzIHtcbiAgICByZXR1cm4gbmV3IFRyYWRpbmdQYXJ0bmVycyh0aGlzLmJpdGdvLCB0aGlzLmVudGVycHJpc2VJZCwgdGhpcyk7XG4gIH1cbn1cbiJdfQ==