"use strict";
/**
 * @prettier
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 */
var Bluebird = require("bluebird");
var co = Bluebird.coroutine;
var AffirmationStatus;
(function (AffirmationStatus) {
    AffirmationStatus["PENDING"] = "pending";
    AffirmationStatus["OVERDUE"] = "overdue";
    AffirmationStatus["REJECTED"] = "rejected";
    AffirmationStatus["AFFIRMED"] = "affirmed";
    AffirmationStatus["FAILED"] = "failed";
    AffirmationStatus["CANCELED"] = "canceled";
})(AffirmationStatus = exports.AffirmationStatus || (exports.AffirmationStatus = {}));
var Affirmation = /** @class */ (function () {
    function Affirmation(affirmationData, bitgo, enterpriseId) {
        this.bitgo = bitgo;
        this.enterpriseId = enterpriseId;
        this.updateAffirmationData(affirmationData);
    }
    /**
     * Affirms a pending affirmation, authorizing the settlement
     * @param payload payload authorizing the movement of funds from a trading account
     * @param signature signature of the payload with the user key of the trading account
     * @param callback
     */
    Affirmation.prototype.affirm = function (payload, signature, callback) {
        var body = {
            payload: JSON.stringify(payload),
            signature: signature,
        };
        return this.updateStatus(AffirmationStatus.AFFIRMED, body, callback);
    };
    /**
     * Rejects a pending affirmation, cancelling the settlement
     * @param callback
     */
    Affirmation.prototype.reject = function (callback) {
        return this.updateStatus(AffirmationStatus.REJECTED, null, callback);
    };
    /**
     * Cancels a pending affirmation, cancelling the settlement
     * @param callback
     */
    Affirmation.prototype.cancel = function (callback) {
        return this.updateStatus(AffirmationStatus.CANCELED, null, callback);
    };
    Affirmation.prototype.updateStatus = function (status, body, callback) {
        var self = this;
        return co(function updateStatus() {
            var bodyWithStatus, url, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        bodyWithStatus = __assign({ status: status }, body);
                        url = self.bitgo.microservicesUrl("/api/trade/v1/enterprise/" + self.enterpriseId + "/account/" + self.partyAccountId + "/affirmations/" + self.id);
                        return [4 /*yield*/, self.bitgo
                                .put(url)
                                .send(bodyWithStatus)
                                .result()];
                    case 1:
                        response = _a.sent();
                        self.updateAffirmationData(response);
                        return [2 /*return*/];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    Affirmation.prototype.updateAffirmationData = function (affirmationData) {
        this.id = affirmationData.id;
        this.partyAccountId = affirmationData.partyAccountId;
        this.status = affirmationData.status;
        this.settlement = affirmationData.settlement;
        this.lock = affirmationData.lock;
        this.payload = affirmationData.payload;
        this.createdAt = new Date(affirmationData.createdAt);
        this.expireAt = new Date(affirmationData.expireAt);
    };
    return Affirmation;
}());
exports.Affirmation = Affirmation;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWZmaXJtYXRpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvdjIvdHJhZGluZy9hZmZpcm1hdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7O0dBRUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFSDtHQUNHO0FBQ0gsbUNBQXFDO0FBT3JDLElBQU0sRUFBRSxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUM7QUFFOUIsSUFBWSxpQkFPWDtBQVBELFdBQVksaUJBQWlCO0lBQzNCLHdDQUFtQixDQUFBO0lBQ25CLHdDQUFtQixDQUFBO0lBQ25CLDBDQUFxQixDQUFBO0lBQ3JCLDBDQUFxQixDQUFBO0lBQ3JCLHNDQUFpQixDQUFBO0lBQ2pCLDBDQUFxQixDQUFBO0FBQ3ZCLENBQUMsRUFQVyxpQkFBaUIsR0FBakIseUJBQWlCLEtBQWpCLHlCQUFpQixRQU81QjtBQUVEO0lBYUUscUJBQVksZUFBZSxFQUFFLEtBQVksRUFBRSxZQUFvQjtRQUM3RCxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixJQUFJLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQztRQUVqQyxJQUFJLENBQUMscUJBQXFCLENBQUMsZUFBZSxDQUFDLENBQUM7SUFDOUMsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsNEJBQU0sR0FBTixVQUFPLE9BQWdCLEVBQUUsU0FBaUIsRUFBRSxRQUE2QjtRQUN2RSxJQUFNLElBQUksR0FBRztZQUNYLE9BQU8sRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQztZQUNoQyxTQUFTLEVBQUUsU0FBUztTQUNyQixDQUFDO1FBRUYsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLGlCQUFpQixDQUFDLFFBQVEsRUFBRSxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDdkUsQ0FBQztJQUVEOzs7T0FHRztJQUNILDRCQUFNLEdBQU4sVUFBTyxRQUE2QjtRQUNsQyxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsaUJBQWlCLENBQUMsUUFBUSxFQUFFLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztJQUN2RSxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsNEJBQU0sR0FBTixVQUFPLFFBQTZCO1FBQ2xDLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLEVBQUUsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ3ZFLENBQUM7SUFFTyxrQ0FBWSxHQUFwQixVQUFxQixNQUF5QixFQUFFLElBQUssRUFBRSxRQUE2QjtRQUNsRixJQUFNLElBQUksR0FBRyxJQUFJLENBQUM7UUFDbEIsT0FBTyxFQUFFLENBQU8sU0FBVSxZQUFZOzs7Ozt3QkFDOUIsY0FBYyxjQUFLLE1BQU0sUUFBQSxJQUFLLElBQUksQ0FBRSxDQUFDO3dCQUNyQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FDckMsOEJBQTRCLElBQUksQ0FBQyxZQUFZLGlCQUFZLElBQUksQ0FBQyxjQUFjLHNCQUFpQixJQUFJLENBQUMsRUFBSSxDQUN2RyxDQUFDO3dCQUNlLHFCQUFNLElBQUksQ0FBQyxLQUFLO2lDQUM5QixHQUFHLENBQUMsR0FBRyxDQUFDO2lDQUNSLElBQUksQ0FBQyxjQUFjLENBQUM7aUNBQ3BCLE1BQU0sRUFBRSxFQUFBOzt3QkFITCxRQUFRLEdBQUcsU0FHTjt3QkFDWCxJQUFJLENBQUMscUJBQXFCLENBQUMsUUFBUSxDQUFDLENBQUM7Ozs7U0FDdEMsQ0FBQzthQUNDLElBQUksQ0FBQyxJQUFJLENBQUM7YUFDVixVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDMUIsQ0FBQztJQUVPLDJDQUFxQixHQUE3QixVQUE4QixlQUFlO1FBQzNDLElBQUksQ0FBQyxFQUFFLEdBQUcsZUFBZSxDQUFDLEVBQUUsQ0FBQztRQUM3QixJQUFJLENBQUMsY0FBYyxHQUFHLGVBQWUsQ0FBQyxjQUFjLENBQUM7UUFDckQsSUFBSSxDQUFDLE1BQU0sR0FBRyxlQUFlLENBQUMsTUFBTSxDQUFDO1FBQ3JDLElBQUksQ0FBQyxVQUFVLEdBQUcsZUFBZSxDQUFDLFVBQVUsQ0FBQztRQUM3QyxJQUFJLENBQUMsSUFBSSxHQUFHLGVBQWUsQ0FBQyxJQUFZLENBQUM7UUFDekMsSUFBSSxDQUFDLE9BQU8sR0FBRyxlQUFlLENBQUMsT0FBTyxDQUFDO1FBQ3ZDLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxJQUFJLENBQUMsZUFBZSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3JELElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxJQUFJLENBQUMsZUFBZSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JELENBQUM7SUFDSCxrQkFBQztBQUFELENBQUMsQUE5RUQsSUE4RUM7QUE5RVksa0NBQVciLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5cbi8qKlxuICovXG5pbXBvcnQgKiBhcyBCbHVlYmlyZCBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgeyBCaXRHbyB9IGZyb20gJy4uLy4uL2JpdGdvJztcblxuaW1wb3J0IHsgTm9kZUNhbGxiYWNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgTG9jayB9IGZyb20gJy4vbG9jayc7XG5pbXBvcnQgeyBQYXlsb2FkIH0gZnJvbSAnLi9wYXlsb2FkJztcblxuY29uc3QgY28gPSBCbHVlYmlyZC5jb3JvdXRpbmU7XG5cbmV4cG9ydCBlbnVtIEFmZmlybWF0aW9uU3RhdHVzIHtcbiAgUEVORElORyA9ICdwZW5kaW5nJyxcbiAgT1ZFUkRVRSA9ICdvdmVyZHVlJyxcbiAgUkVKRUNURUQgPSAncmVqZWN0ZWQnLFxuICBBRkZJUk1FRCA9ICdhZmZpcm1lZCcsXG4gIEZBSUxFRCA9ICdmYWlsZWQnLFxuICBDQU5DRUxFRCA9ICdjYW5jZWxlZCcsXG59XG5cbmV4cG9ydCBjbGFzcyBBZmZpcm1hdGlvbiB7XG4gIHByaXZhdGUgYml0Z286IEJpdEdvO1xuICBwcml2YXRlIGVudGVycHJpc2VJZDogc3RyaW5nO1xuXG4gIHB1YmxpYyBpZD86IHN0cmluZztcbiAgcHVibGljIHBhcnR5QWNjb3VudElkPzogc3RyaW5nO1xuICBwdWJsaWMgc3RhdHVzPzogQWZmaXJtYXRpb25TdGF0dXM7XG4gIHB1YmxpYyBzZXR0bGVtZW50Pzogc3RyaW5nO1xuICBwdWJsaWMgbG9jaz86IExvY2s7XG4gIHB1YmxpYyBwYXlsb2FkPzogc3RyaW5nO1xuICBwdWJsaWMgY3JlYXRlZEF0PzogRGF0ZTtcbiAgcHVibGljIGV4cGlyZUF0PzogRGF0ZTtcblxuICBjb25zdHJ1Y3RvcihhZmZpcm1hdGlvbkRhdGEsIGJpdGdvOiBCaXRHbywgZW50ZXJwcmlzZUlkOiBzdHJpbmcpIHtcbiAgICB0aGlzLmJpdGdvID0gYml0Z287XG4gICAgdGhpcy5lbnRlcnByaXNlSWQgPSBlbnRlcnByaXNlSWQ7XG5cbiAgICB0aGlzLnVwZGF0ZUFmZmlybWF0aW9uRGF0YShhZmZpcm1hdGlvbkRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFmZmlybXMgYSBwZW5kaW5nIGFmZmlybWF0aW9uLCBhdXRob3JpemluZyB0aGUgc2V0dGxlbWVudFxuICAgKiBAcGFyYW0gcGF5bG9hZCBwYXlsb2FkIGF1dGhvcml6aW5nIHRoZSBtb3ZlbWVudCBvZiBmdW5kcyBmcm9tIGEgdHJhZGluZyBhY2NvdW50XG4gICAqIEBwYXJhbSBzaWduYXR1cmUgc2lnbmF0dXJlIG9mIHRoZSBwYXlsb2FkIHdpdGggdGhlIHVzZXIga2V5IG9mIHRoZSB0cmFkaW5nIGFjY291bnRcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBhZmZpcm0ocGF5bG9hZDogUGF5bG9hZCwgc2lnbmF0dXJlOiBzdHJpbmcsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPHZvaWQ+KTogQmx1ZWJpcmQ8dm9pZD4ge1xuICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICBwYXlsb2FkOiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSxcbiAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlLFxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy51cGRhdGVTdGF0dXMoQWZmaXJtYXRpb25TdGF0dXMuQUZGSVJNRUQsIGJvZHksIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWplY3RzIGEgcGVuZGluZyBhZmZpcm1hdGlvbiwgY2FuY2VsbGluZyB0aGUgc2V0dGxlbWVudFxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHJlamVjdChjYWxsYmFjaz86IE5vZGVDYWxsYmFjazx2b2lkPik6IEJsdWViaXJkPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVTdGF0dXMoQWZmaXJtYXRpb25TdGF0dXMuUkVKRUNURUQsIG51bGwsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWxzIGEgcGVuZGluZyBhZmZpcm1hdGlvbiwgY2FuY2VsbGluZyB0aGUgc2V0dGxlbWVudFxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGNhbmNlbChjYWxsYmFjaz86IE5vZGVDYWxsYmFjazx2b2lkPik6IEJsdWViaXJkPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVTdGF0dXMoQWZmaXJtYXRpb25TdGF0dXMuQ0FOQ0VMRUQsIG51bGwsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlU3RhdHVzKHN0YXR1czogQWZmaXJtYXRpb25TdGF0dXMsIGJvZHk/LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazx2b2lkPik6IEJsdWViaXJkPHZvaWQ+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288dm9pZD4oZnVuY3Rpb24qIHVwZGF0ZVN0YXR1cygpIHtcbiAgICAgIGNvbnN0IGJvZHlXaXRoU3RhdHVzID0geyBzdGF0dXMsIC4uLmJvZHkgfTtcbiAgICAgIGNvbnN0IHVybCA9IHNlbGYuYml0Z28ubWljcm9zZXJ2aWNlc1VybChcbiAgICAgICAgYC9hcGkvdHJhZGUvdjEvZW50ZXJwcmlzZS8ke3NlbGYuZW50ZXJwcmlzZUlkfS9hY2NvdW50LyR7c2VsZi5wYXJ0eUFjY291bnRJZH0vYWZmaXJtYXRpb25zLyR7c2VsZi5pZH1gXG4gICAgICApO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBzZWxmLmJpdGdvXG4gICAgICAgIC5wdXQodXJsKVxuICAgICAgICAuc2VuZChib2R5V2l0aFN0YXR1cylcbiAgICAgICAgLnJlc3VsdCgpO1xuICAgICAgc2VsZi51cGRhdGVBZmZpcm1hdGlvbkRhdGEocmVzcG9uc2UpO1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVBZmZpcm1hdGlvbkRhdGEoYWZmaXJtYXRpb25EYXRhKSB7XG4gICAgdGhpcy5pZCA9IGFmZmlybWF0aW9uRGF0YS5pZDtcbiAgICB0aGlzLnBhcnR5QWNjb3VudElkID0gYWZmaXJtYXRpb25EYXRhLnBhcnR5QWNjb3VudElkO1xuICAgIHRoaXMuc3RhdHVzID0gYWZmaXJtYXRpb25EYXRhLnN0YXR1cztcbiAgICB0aGlzLnNldHRsZW1lbnQgPSBhZmZpcm1hdGlvbkRhdGEuc2V0dGxlbWVudDtcbiAgICB0aGlzLmxvY2sgPSBhZmZpcm1hdGlvbkRhdGEubG9jayBhcyBMb2NrO1xuICAgIHRoaXMucGF5bG9hZCA9IGFmZmlybWF0aW9uRGF0YS5wYXlsb2FkO1xuICAgIHRoaXMuY3JlYXRlZEF0ID0gbmV3IERhdGUoYWZmaXJtYXRpb25EYXRhLmNyZWF0ZWRBdCk7XG4gICAgdGhpcy5leHBpcmVBdCA9IG5ldyBEYXRlKGFmZmlybWF0aW9uRGF0YS5leHBpcmVBdCk7XG4gIH1cbn1cbiJdfQ==