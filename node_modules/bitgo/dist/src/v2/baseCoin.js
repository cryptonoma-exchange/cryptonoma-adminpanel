"use strict";
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @prettier
 */
var bignumber_js_1 = require("bignumber.js");
var bitcoin = require("bitgo-utxo-lib");
var bitcoin_1 = require("../bitcoin");
var bitcoinMessage = require('bitcoinjs-message');
var Bluebird = require("bluebird");
var errors = require("../errors");
var co = Bluebird.coroutine;
var wallet_1 = require("./wallet");
var wallets_1 = require("./wallets");
var markets_1 = require("./markets");
var webhooks_1 = require("./webhooks");
var pendingApprovals_1 = require("./pendingApprovals");
var keychains_1 = require("./keychains");
var enterprises_1 = require("./enterprises");
var BaseCoin = /** @class */ (function () {
    function BaseCoin(bitgo) {
        this.bitgo = bitgo;
        this._url = this.bitgo.url('/', 2);
        this._wallets = new wallets_1.Wallets(this.bitgo, this);
        this._keychains = new keychains_1.Keychains(this.bitgo, this);
        this._webhooks = new webhooks_1.Webhooks(this.bitgo, this);
        this._pendingApprovals = new pendingApprovals_1.PendingApprovals(this.bitgo, this);
        this._enterprises = new enterprises_1.Enterprises(this.bitgo, this);
        this._markets = new markets_1.Markets(this.bitgo, this);
    }
    BaseCoin.prototype.url = function (suffix) {
        return this._url + this.getChain() + suffix;
    };
    BaseCoin.prototype.wallets = function () {
        return this._wallets;
    };
    BaseCoin.prototype.enterprises = function () {
        return this._enterprises;
    };
    BaseCoin.prototype.keychains = function () {
        return this._keychains;
    };
    BaseCoin.prototype.webhooks = function () {
        return this._webhooks;
    };
    BaseCoin.prototype.pendingApprovals = function () {
        return this._pendingApprovals;
    };
    BaseCoin.prototype.markets = function () {
        return this._markets;
    };
    Object.defineProperty(BaseCoin, "coinTokenPatternSeparator", {
        get: function () {
            return this._coinTokenPatternSeparator;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseCoin.prototype, "type", {
        get: function () {
            return this.getChain();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Flag for sending value of 0.
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    BaseCoin.prototype.valuelessTransferAllowed = function () {
        return false;
    };
    /**
     * Flag for sending data along with transactions
     * @returns {boolean} True if okay to send tx data (ETH), false otherwise
     */
    BaseCoin.prototype.transactionDataAllowed = function () {
        return false;
    };
    /**
     * Flag for determining whether this coin supports account consolidations
     * from its receive addresses to the root address.
     * @returns {boolean} True if okay to consolidate over this coin; false, otherwise
     */
    BaseCoin.prototype.allowsAccountConsolidations = function () {
        return false;
    };
    /**
     * Convert a currency amount represented in base units (satoshi, wei, atoms, drops, stroops)
     * to big units (btc, eth, rmg, xrp, xlm)
     */
    BaseCoin.prototype.baseUnitsToBigUnits = function (baseUnits) {
        var dividend = this.getBaseFactor();
        var bigNumber = new bignumber_js_1.BigNumber(baseUnits).dividedBy(dividend);
        // set the format so commas aren't added to large coin amounts
        // @ts-ignore
        return bigNumber.toFormat(null, null, { groupSeparator: '', decimalSeparator: '.' });
    };
    /**
     * Convert a currency amount represented in big units (btc, eth, rmg, xrp, xlm)
     * to base units (satoshi, wei, atoms, drops, stroops)
     * @param bigUnits
     */
    BaseCoin.prototype.bigUnitsToBaseUnits = function (bigUnits) {
        var multiplier = this.getBaseFactor();
        var bigNumber = new bignumber_js_1.BigNumber(bigUnits).times(multiplier);
        if (!bigNumber.isInteger()) {
            throw new Error("non-integer output resulted from multiplying " + bigUnits + " by " + multiplier);
        }
        return bigNumber.toFixed(0);
    };
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     * @param callback
     */
    BaseCoin.prototype.signMessage = function (key, message, callback) {
        return co(function cosignMessage() {
            var privateKey, privateKeyBuffer, isCompressed, prefix;
            return __generator(this, function (_a) {
                privateKey = bitcoin.HDNode.fromBase58(key.prv).getKey();
                privateKeyBuffer = privateKey.d.toBuffer(32);
                isCompressed = privateKey.compressed;
                prefix = bitcoin.networks.bitcoin.messagePrefix;
                return [2 /*return*/, bitcoinMessage.sign(message, privateKeyBuffer, isCompressed, prefix)];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Check whether a coin supports blockTarget for transactions to be included in
     * @returns {boolean}
     */
    BaseCoin.prototype.supportsBlockTarget = function () {
        return false;
    };
    /**
     * Hook to add additional parameters to the wallet generation
     * @param walletParams
     * @param keychains
     * @return {*}
     */
    BaseCoin.prototype.supplementGenerateWallet = function (walletParams, keychains) {
        return Bluebird.resolve(walletParams);
    };
    /**
     * Get extra parameters for prebuilding a tx. Add things like hop transaction params
     */
    BaseCoin.prototype.getExtraPrebuildParams = function (buildParams, callback) {
        return Bluebird.resolve({}).asCallback(callback);
    };
    /**
     * Modify prebuild after receiving it from the server. Add things like nlocktime
     */
    BaseCoin.prototype.postProcessPrebuild = function (prebuildResponse, callback) {
        return Bluebird.resolve(prebuildResponse).asCallback(callback);
    };
    /**
     * Coin-specific things done before signing a transaction, i.e. verification
     */
    BaseCoin.prototype.presignTransaction = function (params, callback) {
        return Bluebird.resolve(params).asCallback(callback);
    };
    /**
     * Create a new wallet object from a wallet data object
     * @param walletParams
     */
    BaseCoin.prototype.newWalletObject = function (walletParams) {
        return new wallet_1.Wallet(this.bitgo, this, walletParams);
    };
    /**
     * Fetch fee estimate information from the server
     * @param {Object} params The params passed into the function
     * @param {Integer} params.numBlocks The number of blocks to target for conformation (Only works for btc)
     * @param callback
     * @returns {Object} The info returned from the merchant server
     */
    BaseCoin.prototype.feeEstimate = function (params, callback) {
        var self = this;
        return co(function coFeeEstimate() {
            var query;
            return __generator(this, function (_a) {
                query = {};
                if (params && params.numBlocks) {
                    query.numBlocks = params.numBlocks;
                }
                return [2 /*return*/, self.bitgo
                        .get(self.url('/tx/fee'))
                        .query(query)
                        .result()];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * The cold wallet tool uses this function to derive an extended key that is based on the passed key and seed
     * @param key
     * @param seed
     * @returns {{key: string, derivationPath: string}}
     */
    BaseCoin.prototype.deriveKeyWithSeed = function (_a) {
        var key = _a.key, seed = _a.seed;
        var derivationPathInput = bitcoin.crypto.hash256("" + seed).toString('hex');
        var derivationPathParts = [
            parseInt(derivationPathInput.slice(0, 7), 16),
            parseInt(derivationPathInput.slice(7, 14), 16),
        ];
        var derivationPath = 'm/999999/' + derivationPathParts.join('/');
        var keyNode = bitcoin.HDNode.fromBase58(key);
        var derivedKeyNode = bitcoin_1.hdPath(keyNode).derive(derivationPath);
        return {
            key: derivedKeyNode.toBase58(),
            derivationPath: derivationPath,
        };
    };
    /**
     * Specifies what key we will need for signing - right now we just need the
     * user key.
     */
    BaseCoin.prototype.keyIdsForSigning = function () {
        return [keychains_1.KeyIndices.USER];
    };
    /**
     * Perform additional checks before adding a bitgo key. Base controller
     * is a no-op, but coin-specific controller may do something
     * @param params
     */
    BaseCoin.prototype.preCreateBitGo = function (params) { };
    BaseCoin.prototype.initiateRecovery = function (params) {
        var self = this;
        return co(function initiateRecovery() {
            function validatePassphraseKey(userKey, passphrase) {
                try {
                    if (!userKey.startsWith('xprv') && !userKey.startsWith('xpub')) {
                        userKey = self.bitgo.decrypt({
                            input: userKey,
                            password: passphrase,
                        });
                    }
                    return bitcoin.HDNode.fromBase58(userKey);
                }
                catch (e) {
                    throw new Error('Failed to decrypt user key with passcode - try again!');
                }
            }
            var keys, userKey, backupKey, bitgoXpub, destinationAddress, passphrase, isKrsRecovery, key, backupHDNode, bitgoHDNode;
            return __generator(this, function (_a) {
                keys = [];
                userKey = params.userKey;
                backupKey = params.backupKey;
                bitgoXpub = params.bitgoKey;
                destinationAddress = params.recoveryDestination;
                passphrase = params.walletPassphrase;
                isKrsRecovery = backupKey.startsWith('xpub') && !userKey.startsWith('xpub');
                key = validatePassphraseKey(userKey, passphrase);
                keys.push(key);
                // Validate the backup key
                try {
                    if (!backupKey.startsWith('xprv') && !isKrsRecovery && !backupKey.startsWith('xpub')) {
                        backupKey = self.bitgo.decrypt({
                            input: backupKey,
                            password: passphrase,
                        });
                    }
                    backupHDNode = bitcoin.HDNode.fromBase58(backupKey);
                    keys.push(backupHDNode);
                }
                catch (e) {
                    throw new Error('Failed to decrypt backup key with passcode - try again!');
                }
                try {
                    bitgoHDNode = bitcoin.HDNode.fromBase58(bitgoXpub);
                    keys.push(bitgoHDNode);
                }
                catch (e) {
                    if (self.getFamily() !== 'xrp') {
                        // in XRP recoveries, the BitGo xpub is optional
                        throw new Error('Failed to parse bitgo xpub!');
                    }
                }
                // Validate the destination address
                try {
                    if (!self.isValidAddress(destinationAddress)) {
                        throw new Error('Invalid destination address!');
                    }
                }
                catch (e) {
                    // if isValidAddress is not implemented, assume the destination
                    // address is valid and let the tx go through. If the destination
                    // is actually invalid (`isValidAddress` returns false and does
                    // not throw), this method will still throw
                    if (!(e instanceof errors.MethodNotImplementedError)) {
                        throw e;
                    }
                }
                return [2 /*return*/, keys];
            });
        }).call(this);
    };
    // Some coins can have their tx info verified, if a public tx decoder is available
    BaseCoin.prototype.verifyRecoveryTransaction = function (txInfo) {
        return Bluebird.reject(new errors.MethodNotImplementedError());
    };
    /**
     * Return wether the given m of n wallet signers/ key amounts are valid for the coin
     */
    BaseCoin.prototype.isValidMofNSetup = function (_a) {
        var m = _a.m, n = _a.n;
        return m === 2 && n === 3;
    };
    BaseCoin._coinTokenPatternSeparator = ':';
    return BaseCoin;
}());
exports.BaseCoin = BaseCoin;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZUNvaW4uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdjIvYmFzZUNvaW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7R0FFRztBQUNILDZDQUF5QztBQUN6Qyx3Q0FBMEM7QUFDMUMsc0NBQW9DO0FBQ3BDLElBQU0sY0FBYyxHQUFHLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0FBQ3BELG1DQUFxQztBQUVyQyxrQ0FBb0M7QUFHcEMsSUFBTSxFQUFFLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQztBQUU5QixtQ0FBa0M7QUFDbEMscUNBQW9DO0FBQ3BDLHFDQUFvQztBQUNwQyx1Q0FBc0M7QUFDdEMsdURBQXNEO0FBQ3RELHlDQUE4RDtBQUM5RCw2Q0FBNEM7QUE2SjVDO0lBV0Usa0JBQXNCLEtBQVk7UUFDaEMsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDbkMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLGlCQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztRQUM5QyxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUkscUJBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ2xELElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxtQkFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDaEQsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksbUNBQWdCLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztRQUNoRSxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUkseUJBQVcsQ0FBQyxJQUFJLENB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T0FBTyxDQUFDLEVBQUU7b0JBQ1YsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFLEtBQUssS0FBSyxFQUFFO3dCQUM5QixnREFBZ0Q7d0JBQ2hELE1BQU0sSUFBSSxLQUFLLENBQUMsNkJBQTZCLENBQUMsQ0FBQztxQkFDaEQ7aUJBQ0Y7Z0JBQ0QsbUNBQW1DO2dCQUNuQyxJQUFJO29CQUNGLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLGtCQUFrQixDQUFDLEVBQUU7d0JBQzVDLE1BQU0sSUFBSSxLQUFLLENBQUMsOEJBQThCLENBQUMsQ0FBQztxQkFDakQ7aUJBQ0Y7Z0JBQUMsT0FBTyxDQUFDLEVBQUU7b0JBQ1YsK0RBQStEO29CQUMvRCxpRUFBaUU7b0JBQ2pFLCtEQUErRDtvQkFDL0QsMkNBQTJDO29CQUMzQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFlBQVksTUFBTSxDQUFDLHlCQUF5QixDQUFDLEVBQUU7d0JBQ3BELE1BQU0sQ0FBQyxDQUFDO3FCQUNUO2lCQUNGO2dCQUVELHNCQUFPLElBQUksRUFBQzs7U0FDYixDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2hCLENBQUM7SUFFRCxrRkFBa0Y7SUFDbEYsNENBQXlCLEdBQXpCLFVBQTBCLE1BQXdDO1FBQ2hFLE9BQU8sUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLE1BQU0sQ0FBQyx5QkFBeUIsRUFBRSxDQUFDLENBQUM7SUFDakUsQ0FBQztJQXNCRDs7T0FFRztJQUNILG1DQUFnQixHQUFoQixVQUFpQixFQUFvQztZQUFsQyxRQUFDLEVBQUUsUUFBQztRQUNyQixPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM1QixDQUFDO0lBN1d5QixtQ0FBMEIsR0FBRyxHQUFHLENBQUM7SUE0WDdELGVBQUM7Q0FBQSxBQXJZRCxJQXFZQztBQXJZcUIsNEJBQVEiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0ICogYXMgYml0Y29pbiBmcm9tICdiaXRnby11dHhvLWxpYic7XG5pbXBvcnQgeyBoZFBhdGggfSBmcm9tICcuLi9iaXRjb2luJztcbmNvbnN0IGJpdGNvaW5NZXNzYWdlID0gcmVxdWlyZSgnYml0Y29pbmpzLW1lc3NhZ2UnKTtcbmltcG9ydCAqIGFzIEJsdWViaXJkIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCB7IEJpdEdvIH0gZnJvbSAnLi4vYml0Z28nO1xuaW1wb3J0ICogYXMgZXJyb3JzIGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBOb2RlQ2FsbGJhY2sgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IFJlcXVlc3RUcmFjZXIgfSBmcm9tICcuL2ludGVybmFsL3V0aWwnO1xuY29uc3QgY28gPSBCbHVlYmlyZC5jb3JvdXRpbmU7XG5cbmltcG9ydCB7IFdhbGxldCB9IGZyb20gJy4vd2FsbGV0JztcbmltcG9ydCB7IFdhbGxldHMgfSBmcm9tICcuL3dhbGxldHMnO1xuaW1wb3J0IHsgTWFya2V0cyB9IGZyb20gJy4vbWFya2V0cyc7XG5pbXBvcnQgeyBXZWJob29rcyB9IGZyb20gJy4vd2ViaG9va3MnO1xuaW1wb3J0IHsgUGVuZGluZ0FwcHJvdmFscyB9IGZyb20gJy4vcGVuZGluZ0FwcHJvdmFscyc7XG5pbXBvcnQgeyBLZXljaGFpbiwgS2V5Y2hhaW5zLCBLZXlJbmRpY2VzIH0gZnJvbSAnLi9rZXljaGFpbnMnO1xuaW1wb3J0IHsgRW50ZXJwcmlzZXMgfSBmcm9tICcuL2VudGVycHJpc2VzJztcblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2FjdGlvblJlY2lwaWVudCB7XG4gIGFkZHJlc3M6IHN0cmluZztcbiAgYW1vdW50OiBzdHJpbmcgfCBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25GZWUge1xuICBmZWU6IHN0cmluZztcbiAgZmVlUmF0ZT86IG51bWJlcjtcbiAgc2l6ZT86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2FjdGlvbkV4cGxhbmF0aW9uIHtcbiAgZGlzcGxheU9yZGVyOiBzdHJpbmdbXTtcbiAgaWQ6IHN0cmluZztcbiAgb3V0cHV0czogVHJhbnNhY3Rpb25SZWNpcGllbnRbXTtcbiAgb3V0cHV0QW1vdW50OiBzdHJpbmc7XG4gIGNoYW5nZU91dHB1dHM6IFRyYW5zYWN0aW9uUmVjaXBpZW50W107XG4gIGNoYW5nZUFtb3VudDogc3RyaW5nO1xuICBmZWU6IFRyYW5zYWN0aW9uRmVlO1xuICBwcm94eT86IHN0cmluZztcbiAgcHJvZHVjZXJzPzogc3RyaW5nW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgS2V5UGFpciB7XG4gIHB1Yj86IHN0cmluZztcbiAgcHJ2OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmVyaWZ5QWRkcmVzc09wdGlvbnMge1xuICBhZGRyZXNzOiBzdHJpbmc7XG4gIGFkZHJlc3NUeXBlPzogc3RyaW5nO1xuICBrZXljaGFpbnM/OiB7XG4gICAgcHViOiBzdHJpbmc7XG4gIH1bXTtcbiAgY29pblNwZWNpZmljPzogQWRkcmVzc0NvaW5TcGVjaWZpYztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2FjdGlvblBhcmFtcyB7XG4gIHJlY2lwaWVudHM/OiBUcmFuc2FjdGlvblJlY2lwaWVudFtdO1xuICB3YWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xuICB0eXBlPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZlcmlmaWNhdGlvbk9wdGlvbnMge1xuICBkaXNhYmxlTmV0d29ya2luZz86IGJvb2xlYW47XG4gIGtleWNoYWlucz86IHtcbiAgICB1c2VyPzogS2V5Y2hhaW47XG4gICAgYmFja3VwPzogS2V5Y2hhaW47XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhQcmVidWlsZDogVHJhbnNhY3Rpb25QcmVidWlsZDtcbiAgdHhQYXJhbXM6IFRyYW5zYWN0aW9uUGFyYW1zO1xuICB3YWxsZXQ6IFdhbGxldDtcbiAgdmVyaWZpY2F0aW9uPzogVmVyaWZpY2F0aW9uT3B0aW9ucztcbiAgcmVxSWQ/OiBSZXF1ZXN0VHJhY2VyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldE9wdGlvbnMge1xuICBsYWJlbDogc3RyaW5nO1xuICBtOiBudW1iZXI7XG4gIG46IG51bWJlcjtcbiAgZW50ZXJwcmlzZT86IHN0cmluZztcbiAgZGlzYWJsZVRyYW5zYWN0aW9uTm90aWZpY2F0aW9ucz86IGJvb2xlYW47XG4gIGdhc1ByaWNlPzogbnVtYmVyO1xuICBrZXlzOiBzdHJpbmdbXTtcbiAgaXNDb2xkOiBib29sZWFuO1xuICBrZXlTaWduYXR1cmVzPzoge1xuICAgIGJhY2t1cDogc3RyaW5nO1xuICAgIGJpdGdvOiBzdHJpbmc7XG4gIH07XG4gIHJvb3RQcml2YXRlS2V5Pzogc3RyaW5nO1xuICBkaXNhYmxlS1JTRW1haWw/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZlZUVzdGltYXRlT3B0aW9ucyB7XG4gIG51bUJsb2Nrcz86IG51bWJlcjtcbiAgaG9wPzogYm9vbGVhbjtcbiAgcmVjaXBpZW50Pzogc3RyaW5nO1xuICBkYXRhPzogc3RyaW5nO1xuICBhbW91bnQ/OiBzdHJpbmc7XG59XG5cbi8vIFRPRE8gKFNES1QtOSk6IHJldmVyc2UgZW5naW5lZXIgYW5kIGFkZCBvcHRpb25zXG4vLyBleHBvcnQgaW50ZXJmYWNlIEV4dHJhUHJlYnVpbGRQYXJhbXNPcHRpb25zIHt9XG5leHBvcnQgdHlwZSBFeHRyYVByZWJ1aWxkUGFyYW1zT3B0aW9ucyA9IGFueTtcblxuLy8gVE9ETyAoU0RLVC05KTogcmV2ZXJzZSBlbmdpbmVlciBhbmQgYWRkIG9wdGlvbnNcbi8vIGV4cG9ydCBpbnRlcmZhY2UgUHJlc2lnblRyYW5zYWN0aW9uT3B0aW9ucyB7fVxuZXhwb3J0IHR5cGUgUHJlc2lnblRyYW5zYWN0aW9uT3B0aW9ucyA9IGFueTtcblxuLy8gVE9ETyAoU0RLVC05KTogcmV2ZXJzZSBlbmdpbmVlciBhbmQgYWRkIG9wdGlvbnNcbi8vIGV4cG9ydCBpbnRlcmZhY2UgUHJlY3JlYXRlQml0R29PcHRpb25zIHt9XG5leHBvcnQgdHlwZSBQcmVjcmVhdGVCaXRHb09wdGlvbnMgPSBhbnk7XG5cbi8vIFRPRE8gKFNES1QtOSk6IHJldmVyc2UgZW5naW5lZXIgYW5kIGFkZCBvcHRpb25zXG4vLyBleHBvcnQgaW50ZXJmYWNlIFZlcmlmeVJlY292ZXJ5VHJhbnNhY3Rpb25PcHRpb25zIHt9XG5leHBvcnQgdHlwZSBWZXJpZnlSZWNvdmVyeVRyYW5zYWN0aW9uT3B0aW9ucyA9IGFueTtcblxuLy8gVE9ETyAoU0RLVC05KTogcmV2ZXJzZSBlbmdpbmVlciBhbmQgYWRkIG9wdGlvbnNcbi8vIGV4cG9ydCBpbnRlcmZhY2UgUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMge31cbmV4cG9ydCB0eXBlIFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zID0gYW55O1xuXG4vLyBUT0RPIChTREtULTkpOiByZXZlcnNlIGVuZ2luZWVyIGFuZCBhZGQgb3B0aW9uc1xuLy8gZXhwb3J0IGludGVyZmFjZSBQYXJzZWRUcmFuc2FjdGlvbiB7fVxuZXhwb3J0IHR5cGUgUGFyc2VkVHJhbnNhY3Rpb24gPSBhbnk7XG5cbi8vIFRPRE8gKFNES1QtOSk6IHJldmVyc2UgZW5naW5lZXIgYW5kIGFkZCBvcHRpb25zXG4vLyBleHBvcnQgaW50ZXJmYWNlIFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zIHt9XG5leHBvcnQgdHlwZSBTaWduVHJhbnNhY3Rpb25PcHRpb25zID0gYW55O1xuXG5leHBvcnQgaW50ZXJmYWNlIEluaXRpYXRlUmVjb3ZlcnlPcHRpb25zIHtcbiAgdXNlcktleTogc3RyaW5nO1xuICBiYWNrdXBLZXk6IHN0cmluZztcbiAgYml0Z29LZXk/OiBzdHJpbmc7IC8vIG9wdGlvbmFsIGZvciB4cnAgcmVjb3Zlcmllc1xuICByZWNvdmVyeURlc3RpbmF0aW9uOiBzdHJpbmc7XG4gIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgS2V5Y2hhaW5zVHJpcGxldCB7XG4gIHVzZXJLZXljaGFpbjogS2V5Y2hhaW47XG4gIGJhY2t1cEtleWNoYWluOiBLZXljaGFpbjtcbiAgYml0Z29LZXljaGFpbjogS2V5Y2hhaW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25QcmVidWlsZCB7XG4gIHR4QmFzZTY0Pzogc3RyaW5nO1xuICB0eEhleD86IHN0cmluZztcbiAgd2FsbGV0PzogV2FsbGV0O1xuICBidWlsZFBhcmFtcz86IGFueTtcbiAgY29uc29saWRhdGVJZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBZGRyZXNzQ29pblNwZWNpZmljIHtcbiAgb3V0cHV0U2NyaXB0Pzogc3RyaW5nO1xuICByZWRlZW1TY3JpcHQ/OiBzdHJpbmc7XG4gIHdpdG5lc3NTY3JpcHQ/OiBzdHJpbmc7XG4gIGJhc2VBZGRyZXNzPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZ1bGx5U2lnbmVkVHJhbnNhY3Rpb24ge1xuICB0eEhleDogc3RyaW5nOyAvLyBUcmFuc2FjdGlvbiBpbiBhbnkgZm9ybWF0IHJlcXVpcmVkIGJ5IGVhY2ggY29pbiwgaS5lLiBpbiBUcm9uIGl0IGlzIGEgc3RyaW5naWZ5ZWQgSlNPTlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhhbGZTaWduZWRUcmFuc2FjdGlvbiB7XG4gIGhhbGZTaWduZWQ/OiB7XG4gICAgdHhIZXg/OiBzdHJpbmc7IC8vIFRyYW5zYWN0aW9uIGluIGFueSBmb3JtYXQgcmVxdWlyZWQgYnkgZWFjaCBjb2luLCBpLmUuIGluIFRyb24gaXQgaXMgYSBzdHJpbmdpZnllZCBKU09OXG4gICAgcGF5bG9hZD86IHN0cmluZztcbiAgICB0eEJhc2U2ND86IHN0cmluZztcbiAgfTtcbn1cblxuZXhwb3J0IHR5cGUgU2lnbmVkVHJhbnNhY3Rpb24gPSBIYWxmU2lnbmVkVHJhbnNhY3Rpb24gfCBGdWxseVNpZ25lZFRyYW5zYWN0aW9uO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZUNvaW4ge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgYml0Z286IEJpdEdvO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX3VybDogc3RyaW5nO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX2VudGVycHJpc2VzOiBFbnRlcnByaXNlcztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF93YWxsZXRzOiBXYWxsZXRzO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX2tleWNoYWluczogS2V5Y2hhaW5zO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX3dlYmhvb2tzOiBXZWJob29rcztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9wZW5kaW5nQXBwcm92YWxzOiBQZW5kaW5nQXBwcm92YWxzO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX21hcmtldHM6IE1hcmtldHM7XG4gIHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgX2NvaW5Ub2tlblBhdHRlcm5TZXBhcmF0b3IgPSAnOic7XG5cbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKGJpdGdvOiBCaXRHbykge1xuICAgIHRoaXMuYml0Z28gPSBiaXRnbztcbiAgICB0aGlzLl91cmwgPSB0aGlzLmJpdGdvLnVybCgnLycsIDIpO1xuICAgIHRoaXMuX3dhbGxldHMgPSBuZXcgV2FsbGV0cyh0aGlzLmJpdGdvLCB0aGlzKTtcbiAgICB0aGlzLl9rZXljaGFpbnMgPSBuZXcgS2V5Y2hhaW5zKHRoaXMuYml0Z28sIHRoaXMpO1xuICAgIHRoaXMuX3dlYmhvb2tzID0gbmV3IFdlYmhvb2tzKHRoaXMuYml0Z28sIHRoaXMpO1xuICAgIHRoaXMuX3BlbmRpbmdBcHByb3ZhbHMgPSBuZXcgUGVuZGluZ0FwcHJvdmFscyh0aGlzLmJpdGdvLCB0aGlzKTtcbiAgICB0aGlzLl9lbnRlcnByaXNlcyA9IG5ldyBFbnRlcnByaXNlcyh0aGlzLmJpdGdvLCB0aGlzKTtcbiAgICB0aGlzLl9tYXJrZXRzID0gbmV3IE1hcmtldHModGhpcy5iaXRnbywgdGhpcyk7XG4gIH1cblxuICBwdWJsaWMgdXJsKHN1ZmZpeDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fdXJsICsgdGhpcy5nZXRDaGFpbigpICsgc3VmZml4O1xuICB9XG5cbiAgcHVibGljIHdhbGxldHMoKTogV2FsbGV0cyB7XG4gICAgcmV0dXJuIHRoaXMuX3dhbGxldHM7XG4gIH1cblxuICBwdWJsaWMgZW50ZXJwcmlzZXMoKTogRW50ZXJwcmlzZXMge1xuICAgIHJldHVybiB0aGlzLl9lbnRlcnByaXNlcztcbiAgfVxuXG4gIHB1YmxpYyBrZXljaGFpbnMoKTogS2V5Y2hhaW5zIHtcbiAgICByZXR1cm4gdGhpcy5fa2V5Y2hhaW5zO1xuICB9XG5cbiAgcHVibGljIHdlYmhvb2tzKCk6IFdlYmhvb2tzIHtcbiAgICByZXR1cm4gdGhpcy5fd2ViaG9va3M7XG4gIH1cblxuICBwdWJsaWMgcGVuZGluZ0FwcHJvdmFscygpOiBQZW5kaW5nQXBwcm92YWxzIHtcbiAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0FwcHJvdmFscztcbiAgfVxuXG4gIHB1YmxpYyBtYXJrZXRzKCk6IE1hcmtldHMge1xuICAgIHJldHVybiB0aGlzLl9tYXJrZXRzO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBnZXQgY29pblRva2VuUGF0dGVyblNlcGFyYXRvcigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9jb2luVG9rZW5QYXR0ZXJuU2VwYXJhdG9yO1xuICB9XG5cbiAgcHVibGljIGdldCB0eXBlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2hhaW4oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSBjaGFpbiB3aGljaCBzdXBwb3J0cyB0aGlzIGNvaW4gKGVnLCAnYnRjJywgJ2V0aCcpXG4gICAqL1xuICBhYnN0cmFjdCBnZXRDaGFpbigpOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIGNvaW4gZmFtaWx5IChlZy4gZm9yIHRidGMsIHRoaXMgd291bGQgYmUgYnRjKVxuICAgKi9cbiAgYWJzdHJhY3QgZ2V0RmFtaWx5KCk6IHN0cmluZztcblxuICAvKipcbiAgICogSHVtYW4gcmVhZGFibGUgZnVsbCBuYW1lIGZvciB0aGUgY29pblxuICAgKi9cbiAgYWJzdHJhY3QgZ2V0RnVsbE5hbWUoKTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBGbGFnIGZvciBzZW5kaW5nIHZhbHVlIG9mIDAuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIG9rYXkgdG8gc2VuZCAwIHZhbHVlLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIHZhbHVlbGVzc1RyYW5zZmVyQWxsb3dlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRmxhZyBmb3Igc2VuZGluZyBkYXRhIGFsb25nIHdpdGggdHJhbnNhY3Rpb25zXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIG9rYXkgdG8gc2VuZCB0eCBkYXRhIChFVEgpLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIHRyYW5zYWN0aW9uRGF0YUFsbG93ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEZsYWcgZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdGhpcyBjb2luIHN1cHBvcnRzIGFjY291bnQgY29uc29saWRhdGlvbnNcbiAgICogZnJvbSBpdHMgcmVjZWl2ZSBhZGRyZXNzZXMgdG8gdGhlIHJvb3QgYWRkcmVzcy5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgb2theSB0byBjb25zb2xpZGF0ZSBvdmVyIHRoaXMgY29pbjsgZmFsc2UsIG90aGVyd2lzZVxuICAgKi9cbiAgYWxsb3dzQWNjb3VudENvbnNvbGlkYXRpb25zKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmYWN0b3IgYmV0d2VlbiB0aGUgYmFzZSB1bml0IGFuZCBpdHMgc21hbGxlc3Qgc3ViZGl2aXNvblxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBhYnN0cmFjdCBnZXRCYXNlRmFjdG9yKCk6IG51bWJlciB8IHN0cmluZztcblxuICAvKipcbiAgICogQ29udmVydCBhIGN1cnJlbmN5IGFtb3VudCByZXByZXNlbnRlZCBpbiBiYXNlIHVuaXRzIChzYXRvc2hpLCB3ZWksIGF0b21zLCBkcm9wcywgc3Ryb29wcylcbiAgICogdG8gYmlnIHVuaXRzIChidGMsIGV0aCwgcm1nLCB4cnAsIHhsbSlcbiAgICovXG4gIGJhc2VVbml0c1RvQmlnVW5pdHMoYmFzZVVuaXRzOiBzdHJpbmcgfCBudW1iZXIpOiBzdHJpbmcge1xuICAgIGNvbnN0IGRpdmlkZW5kID0gdGhpcy5nZXRCYXNlRmFjdG9yKCk7XG4gICAgY29uc3QgYmlnTnVtYmVyID0gbmV3IEJpZ051bWJlcihiYXNlVW5pdHMpLmRpdmlkZWRCeShkaXZpZGVuZCk7XG4gICAgLy8gc2V0IHRoZSBmb3JtYXQgc28gY29tbWFzIGFyZW4ndCBhZGRlZCB0byBsYXJnZSBjb2luIGFtb3VudHNcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIGJpZ051bWJlci50b0Zvcm1hdChudWxsLCBudWxsLCB7IGdyb3VwU2VwYXJhdG9yOiAnJywgZGVjaW1hbFNlcGFyYXRvcjogJy4nIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBjdXJyZW5jeSBhbW91bnQgcmVwcmVzZW50ZWQgaW4gYmlnIHVuaXRzIChidGMsIGV0aCwgcm1nLCB4cnAsIHhsbSlcbiAgICogdG8gYmFzZSB1bml0cyAoc2F0b3NoaSwgd2VpLCBhdG9tcywgZHJvcHMsIHN0cm9vcHMpXG4gICAqIEBwYXJhbSBiaWdVbml0c1xuICAgKi9cbiAgYmlnVW5pdHNUb0Jhc2VVbml0cyhiaWdVbml0czogc3RyaW5nIHwgbnVtYmVyKTogc3RyaW5nIHtcbiAgICBjb25zdCBtdWx0aXBsaWVyID0gdGhpcy5nZXRCYXNlRmFjdG9yKCk7XG4gICAgY29uc3QgYmlnTnVtYmVyID0gbmV3IEJpZ051bWJlcihiaWdVbml0cykudGltZXMobXVsdGlwbGllcik7XG4gICAgaWYgKCFiaWdOdW1iZXIuaXNJbnRlZ2VyKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbm9uLWludGVnZXIgb3V0cHV0IHJlc3VsdGVkIGZyb20gbXVsdGlwbHlpbmcgJHtiaWdVbml0c30gYnkgJHttdWx0aXBsaWVyfWApO1xuICAgIH1cbiAgICByZXR1cm4gYmlnTnVtYmVyLnRvRml4ZWQoMCk7XG4gIH1cblxuICAvKipcbiAgICogU2lnbiBtZXNzYWdlIHdpdGggcHJpdmF0ZSBrZXlcbiAgICpcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcGFyYW0gbWVzc2FnZVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHNpZ25NZXNzYWdlKGtleTogeyBwcnY6IHN0cmluZyB9LCBtZXNzYWdlOiBzdHJpbmcsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPEJ1ZmZlcj4pOiBCbHVlYmlyZDxCdWZmZXI+IHtcbiAgICByZXR1cm4gY288QnVmZmVyPihmdW5jdGlvbiogY29zaWduTWVzc2FnZSgpIHtcbiAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSBiaXRjb2luLkhETm9kZS5mcm9tQmFzZTU4KGtleS5wcnYpLmdldEtleSgpO1xuICAgICAgY29uc3QgcHJpdmF0ZUtleUJ1ZmZlciA9IHByaXZhdGVLZXkuZC50b0J1ZmZlcigzMik7XG4gICAgICBjb25zdCBpc0NvbXByZXNzZWQgPSBwcml2YXRlS2V5LmNvbXByZXNzZWQ7XG4gICAgICBjb25zdCBwcmVmaXggPSBiaXRjb2luLm5ldHdvcmtzLmJpdGNvaW4ubWVzc2FnZVByZWZpeDtcbiAgICAgIHJldHVybiBiaXRjb2luTWVzc2FnZS5zaWduKG1lc3NhZ2UsIHByaXZhdGVLZXlCdWZmZXIsIGlzQ29tcHJlc3NlZCwgcHJlZml4KTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgdGhhdCBhIHRyYW5zYWN0aW9uIHByZWJ1aWxkIGNvbXBsaWVzIHdpdGggdGhlIG9yaWdpbmFsIGludGVudGlvblxuICAgKi9cbiAgYWJzdHJhY3QgdmVyaWZ5VHJhbnNhY3Rpb24ocGFyYW1zOiBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGJvb2xlYW4+KTogQmx1ZWJpcmQ8Ym9vbGVhbj47XG5cbiAgLyoqXG4gICAqIFZlcmlmeSB0aGF0IGFuIGFkZHJlc3MgYmVsb25ncyB0byBhIHdhbGxldFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGFic3RyYWN0IHZlcmlmeUFkZHJlc3MocGFyYW1zOiBWZXJpZnlBZGRyZXNzT3B0aW9ucyk6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgYSBjb2luIHN1cHBvcnRzIGJsb2NrVGFyZ2V0IGZvciB0cmFuc2FjdGlvbnMgdG8gYmUgaW5jbHVkZWQgaW5cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdXBwb3J0c0Jsb2NrVGFyZ2V0KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIb29rIHRvIGFkZCBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgdG8gdGhlIHdhbGxldCBnZW5lcmF0aW9uXG4gICAqIEBwYXJhbSB3YWxsZXRQYXJhbXNcbiAgICogQHBhcmFtIGtleWNoYWluc1xuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgc3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0KHdhbGxldFBhcmFtczogU3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0T3B0aW9ucywga2V5Y2hhaW5zOiBLZXljaGFpbnNUcmlwbGV0KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcmV0dXJuIEJsdWViaXJkLnJlc29sdmUod2FsbGV0UGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZXh0cmEgcGFyYW1ldGVycyBmb3IgcHJlYnVpbGRpbmcgYSB0eC4gQWRkIHRoaW5ncyBsaWtlIGhvcCB0cmFuc2FjdGlvbiBwYXJhbXNcbiAgICovXG4gIGdldEV4dHJhUHJlYnVpbGRQYXJhbXMoYnVpbGRQYXJhbXM6IEV4dHJhUHJlYnVpbGRQYXJhbXNPcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxvYmplY3Q+KTogQmx1ZWJpcmQ8b2JqZWN0PiB7XG4gICAgcmV0dXJuIEJsdWViaXJkLnJlc29sdmUoe30pLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vZGlmeSBwcmVidWlsZCBhZnRlciByZWNlaXZpbmcgaXQgZnJvbSB0aGUgc2VydmVyLiBBZGQgdGhpbmdzIGxpa2UgbmxvY2t0aW1lXG4gICAqL1xuICBwb3N0UHJvY2Vzc1ByZWJ1aWxkKFxuICAgIHByZWJ1aWxkUmVzcG9uc2U6IFRyYW5zYWN0aW9uUHJlYnVpbGQsXG4gICAgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8VHJhbnNhY3Rpb25QcmVidWlsZD5cbiAgKTogQmx1ZWJpcmQ8VHJhbnNhY3Rpb25QcmVidWlsZD4ge1xuICAgIHJldHVybiBCbHVlYmlyZC5yZXNvbHZlKHByZWJ1aWxkUmVzcG9uc2UpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIENvaW4tc3BlY2lmaWMgdGhpbmdzIGRvbmUgYmVmb3JlIHNpZ25pbmcgYSB0cmFuc2FjdGlvbiwgaS5lLiB2ZXJpZmljYXRpb25cbiAgICovXG4gIHByZXNpZ25UcmFuc2FjdGlvbihcbiAgICBwYXJhbXM6IFByZXNpZ25UcmFuc2FjdGlvbk9wdGlvbnMsXG4gICAgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8VHJhbnNhY3Rpb25QcmVidWlsZD5cbiAgKTogQmx1ZWJpcmQ8VHJhbnNhY3Rpb25QcmVidWlsZD4ge1xuICAgIHJldHVybiBCbHVlYmlyZC5yZXNvbHZlKHBhcmFtcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHdhbGxldCBvYmplY3QgZnJvbSBhIHdhbGxldCBkYXRhIG9iamVjdFxuICAgKiBAcGFyYW0gd2FsbGV0UGFyYW1zXG4gICAqL1xuICBuZXdXYWxsZXRPYmplY3Qod2FsbGV0UGFyYW1zOiBhbnkpOiBXYWxsZXQge1xuICAgIHJldHVybiBuZXcgV2FsbGV0KHRoaXMuYml0Z28sIHRoaXMsIHdhbGxldFBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggZmVlIGVzdGltYXRlIGluZm9ybWF0aW9uIGZyb20gdGhlIHNlcnZlclxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIFRoZSBwYXJhbXMgcGFzc2VkIGludG8gdGhlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7SW50ZWdlcn0gcGFyYW1zLm51bUJsb2NrcyBUaGUgbnVtYmVyIG9mIGJsb2NrcyB0byB0YXJnZXQgZm9yIGNvbmZvcm1hdGlvbiAoT25seSB3b3JrcyBmb3IgYnRjKVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIGluZm8gcmV0dXJuZWQgZnJvbSB0aGUgbWVyY2hhbnQgc2VydmVyXG4gICAqL1xuICBmZWVFc3RpbWF0ZShwYXJhbXM6IEZlZUVzdGltYXRlT3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiogY29GZWVFc3RpbWF0ZSgpIHtcbiAgICAgIGNvbnN0IHF1ZXJ5OiBhbnkgPSB7fTtcbiAgICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLm51bUJsb2Nrcykge1xuICAgICAgICBxdWVyeS5udW1CbG9ja3MgPSBwYXJhbXMubnVtQmxvY2tzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5iaXRnb1xuICAgICAgICAuZ2V0KHNlbGYudXJsKCcvdHgvZmVlJykpXG4gICAgICAgIC5xdWVyeShxdWVyeSlcbiAgICAgICAgLnJlc3VsdCgpO1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjb2xkIHdhbGxldCB0b29sIHVzZXMgdGhpcyBmdW5jdGlvbiB0byBkZXJpdmUgYW4gZXh0ZW5kZWQga2V5IHRoYXQgaXMgYmFzZWQgb24gdGhlIHBhc3NlZCBrZXkgYW5kIHNlZWRcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcGFyYW0gc2VlZFxuICAgKiBAcmV0dXJucyB7e2tleTogc3RyaW5nLCBkZXJpdmF0aW9uUGF0aDogc3RyaW5nfX1cbiAgICovXG4gIGRlcml2ZUtleVdpdGhTZWVkKHsga2V5LCBzZWVkIH06IHsga2V5OiBzdHJpbmc7IHNlZWQ6IHN0cmluZyB9KTogeyBrZXk6IHN0cmluZzsgZGVyaXZhdGlvblBhdGg6IHN0cmluZyB9IHtcbiAgICBjb25zdCBkZXJpdmF0aW9uUGF0aElucHV0ID0gYml0Y29pbi5jcnlwdG8uaGFzaDI1NihgJHtzZWVkfWApLnRvU3RyaW5nKCdoZXgnKTtcbiAgICBjb25zdCBkZXJpdmF0aW9uUGF0aFBhcnRzID0gW1xuICAgICAgcGFyc2VJbnQoZGVyaXZhdGlvblBhdGhJbnB1dC5zbGljZSgwLCA3KSwgMTYpLFxuICAgICAgcGFyc2VJbnQoZGVyaXZhdGlvblBhdGhJbnB1dC5zbGljZSg3LCAxNCksIDE2KSxcbiAgICBdO1xuICAgIGNvbnN0IGRlcml2YXRpb25QYXRoID0gJ20vOTk5OTk5LycgKyBkZXJpdmF0aW9uUGF0aFBhcnRzLmpvaW4oJy8nKTtcbiAgICBjb25zdCBrZXlOb2RlID0gYml0Y29pbi5IRE5vZGUuZnJvbUJhc2U1OChrZXkpO1xuICAgIGNvbnN0IGRlcml2ZWRLZXlOb2RlID0gaGRQYXRoKGtleU5vZGUpLmRlcml2ZShkZXJpdmF0aW9uUGF0aCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleTogZGVyaXZlZEtleU5vZGUudG9CYXNlNTgoKSxcbiAgICAgIGRlcml2YXRpb25QYXRoOiBkZXJpdmF0aW9uUGF0aCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB3aGF0IGtleSB3ZSB3aWxsIG5lZWQgZm9yIHNpZ25pbmcgLSByaWdodCBub3cgd2UganVzdCBuZWVkIHRoZVxuICAgKiB1c2VyIGtleS5cbiAgICovXG4gIGtleUlkc0ZvclNpZ25pbmcoKTogbnVtYmVyW10ge1xuICAgIHJldHVybiBbS2V5SW5kaWNlcy5VU0VSXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGFkZGl0aW9uYWwgY2hlY2tzIGJlZm9yZSBhZGRpbmcgYSBiaXRnbyBrZXkuIEJhc2UgY29udHJvbGxlclxuICAgKiBpcyBhIG5vLW9wLCBidXQgY29pbi1zcGVjaWZpYyBjb250cm9sbGVyIG1heSBkbyBzb21ldGhpbmdcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgcHJlQ3JlYXRlQml0R28ocGFyYW1zOiBQcmVjcmVhdGVCaXRHb09wdGlvbnMpOiB2b2lkIHt9XG5cbiAgaW5pdGlhdGVSZWNvdmVyeShwYXJhbXM6IEluaXRpYXRlUmVjb3ZlcnlPcHRpb25zKTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uKiBpbml0aWF0ZVJlY292ZXJ5KCkge1xuICAgICAgY29uc3Qga2V5czogYml0Y29pbi5IRE5vZGVbXSA9IFtdO1xuICAgICAgY29uc3QgdXNlcktleSA9IHBhcmFtcy51c2VyS2V5OyAvLyBCb3ggQVxuICAgICAgbGV0IGJhY2t1cEtleSA9IHBhcmFtcy5iYWNrdXBLZXk7IC8vIEJveCBCXG4gICAgICBjb25zdCBiaXRnb1hwdWIgPSBwYXJhbXMuYml0Z29LZXk7IC8vIEJveCBDXG4gICAgICBjb25zdCBkZXN0aW5hdGlvbkFkZHJlc3MgPSBwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbjtcbiAgICAgIGNvbnN0IHBhc3NwaHJhc2UgPSBwYXJhbXMud2FsbGV0UGFzc3BocmFzZTtcblxuICAgICAgY29uc3QgaXNLcnNSZWNvdmVyeSA9IGJhY2t1cEtleS5zdGFydHNXaXRoKCd4cHViJykgJiYgIXVzZXJLZXkuc3RhcnRzV2l0aCgneHB1YicpO1xuXG4gICAgICBmdW5jdGlvbiB2YWxpZGF0ZVBhc3NwaHJhc2VLZXkodXNlcktleTogc3RyaW5nLCBwYXNzcGhyYXNlPzogc3RyaW5nKTogYml0Y29pbi5IRE5vZGUge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghdXNlcktleS5zdGFydHNXaXRoKCd4cHJ2JykgJiYgIXVzZXJLZXkuc3RhcnRzV2l0aCgneHB1YicpKSB7XG4gICAgICAgICAgICB1c2VyS2V5ID0gc2VsZi5iaXRnby5kZWNyeXB0KHtcbiAgICAgICAgICAgICAgaW5wdXQ6IHVzZXJLZXksXG4gICAgICAgICAgICAgIHBhc3N3b3JkOiBwYXNzcGhyYXNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiaXRjb2luLkhETm9kZS5mcm9tQmFzZTU4KHVzZXJLZXkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZGVjcnlwdCB1c2VyIGtleSB3aXRoIHBhc3Njb2RlIC0gdHJ5IGFnYWluIScpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGtleTogYml0Y29pbi5IRE5vZGUgPSB2YWxpZGF0ZVBhc3NwaHJhc2VLZXkodXNlcktleSwgcGFzc3BocmFzZSk7XG5cbiAgICAgIGtleXMucHVzaChrZXkpO1xuXG4gICAgICAvLyBWYWxpZGF0ZSB0aGUgYmFja3VwIGtleVxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFiYWNrdXBLZXkuc3RhcnRzV2l0aCgneHBydicpICYmICFpc0tyc1JlY292ZXJ5ICYmICFiYWNrdXBLZXkuc3RhcnRzV2l0aCgneHB1YicpKSB7XG4gICAgICAgICAgYmFja3VwS2V5ID0gc2VsZi5iaXRnby5kZWNyeXB0KHtcbiAgICAgICAgICAgIGlucHV0OiBiYWNrdXBLZXksXG4gICAgICAgICAgICBwYXNzd29yZDogcGFzc3BocmFzZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYWNrdXBIRE5vZGUgPSBiaXRjb2luLkhETm9kZS5mcm9tQmFzZTU4KGJhY2t1cEtleSk7XG4gICAgICAgIGtleXMucHVzaChiYWNrdXBIRE5vZGUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkZWNyeXB0IGJhY2t1cCBrZXkgd2l0aCBwYXNzY29kZSAtIHRyeSBhZ2FpbiEnKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGJpdGdvSEROb2RlID0gYml0Y29pbi5IRE5vZGUuZnJvbUJhc2U1OChiaXRnb1hwdWIpO1xuICAgICAgICBrZXlzLnB1c2goYml0Z29IRE5vZGUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoc2VsZi5nZXRGYW1pbHkoKSAhPT0gJ3hycCcpIHtcbiAgICAgICAgICAvLyBpbiBYUlAgcmVjb3ZlcmllcywgdGhlIEJpdEdvIHhwdWIgaXMgb3B0aW9uYWxcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBiaXRnbyB4cHViIScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBWYWxpZGF0ZSB0aGUgZGVzdGluYXRpb24gYWRkcmVzc1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFzZWxmLmlzVmFsaWRBZGRyZXNzKGRlc3RpbmF0aW9uQWRkcmVzcykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGVzdGluYXRpb24gYWRkcmVzcyEnKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpZiBpc1ZhbGlkQWRkcmVzcyBpcyBub3QgaW1wbGVtZW50ZWQsIGFzc3VtZSB0aGUgZGVzdGluYXRpb25cbiAgICAgICAgLy8gYWRkcmVzcyBpcyB2YWxpZCBhbmQgbGV0IHRoZSB0eCBnbyB0aHJvdWdoLiBJZiB0aGUgZGVzdGluYXRpb25cbiAgICAgICAgLy8gaXMgYWN0dWFsbHkgaW52YWxpZCAoYGlzVmFsaWRBZGRyZXNzYCByZXR1cm5zIGZhbHNlIGFuZCBkb2VzXG4gICAgICAgIC8vIG5vdCB0aHJvdyksIHRoaXMgbWV0aG9kIHdpbGwgc3RpbGwgdGhyb3dcbiAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIGVycm9ycy5NZXRob2ROb3RJbXBsZW1lbnRlZEVycm9yKSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGtleXM7XG4gICAgfSkuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIC8vIFNvbWUgY29pbnMgY2FuIGhhdmUgdGhlaXIgdHggaW5mbyB2ZXJpZmllZCwgaWYgYSBwdWJsaWMgdHggZGVjb2RlciBpcyBhdmFpbGFibGVcbiAgdmVyaWZ5UmVjb3ZlcnlUcmFuc2FjdGlvbih0eEluZm86IFZlcmlmeVJlY292ZXJ5VHJhbnNhY3Rpb25PcHRpb25zKTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcmV0dXJuIEJsdWViaXJkLnJlamVjdChuZXcgZXJyb3JzLk1ldGhvZE5vdEltcGxlbWVudGVkRXJyb3IoKSk7XG4gIH1cblxuICBhYnN0cmFjdCBwYXJzZVRyYW5zYWN0aW9uKFxuICAgIHBhcmFtczogUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMsXG4gICAgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8UGFyc2VkVHJhbnNhY3Rpb24+XG4gICk6IEJsdWViaXJkPFBhcnNlZFRyYW5zYWN0aW9uPjtcblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBrZXkgcGFpciBvbiB0aGUgY3VydmUgdXNlZCBieSB0aGUgY29pblxuICAgKlxuICAgKiBAcGFyYW0gc2VlZFxuICAgKi9cbiAgYWJzdHJhY3QgZ2VuZXJhdGVLZXlQYWlyKHNlZWQ/OiBCdWZmZXIpOiBLZXlQYWlyO1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaW5wdXQgaXMgdmFsaWQgcHVibGljIGtleSBmb3IgdGhlIGNvaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwdWIgdGhlIHB1YiB0byBiZSBjaGVja2VkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBpcyBpdCB2YWxpZD9cbiAgICovXG4gIGFic3RyYWN0IGlzVmFsaWRQdWIocHViOiBzdHJpbmcpOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2V0aGVyIHRoZSBnaXZlbiBtIG9mIG4gd2FsbGV0IHNpZ25lcnMvIGtleSBhbW91bnRzIGFyZSB2YWxpZCBmb3IgdGhlIGNvaW5cbiAgICovXG4gIGlzVmFsaWRNb2ZOU2V0dXAoeyBtLCBuIH06IHsgbT86IG51bWJlcjsgbj86IG51bWJlciB9KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIG0gPT09IDIgJiYgbiA9PT0gMztcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBgYWRkcmVzc2AgaXMgYSBwbGF1c2libHkgdmFsaWQgYWRkcmVzcyBmb3IgdGhlIGdpdmVuIGNvaW4uXG4gICAqXG4gICAqIERvZXMgbm90IHZlcmlmeSB0aGF0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8gYSB3YWxsZXQuIEZvciB0aGF0LFxuICAgKiB1c2UgW1t2ZXJpZnlBZGRyZXNzXV1cbiAgICogQHBhcmFtIGFkZHJlc3NcbiAgICovXG4gIGFic3RyYWN0IGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFNpZ24gYSB0cmFuc2FjdGlvblxuICAgKi9cbiAgYWJzdHJhY3Qgc2lnblRyYW5zYWN0aW9uKHBhcmFtczogU2lnblRyYW5zYWN0aW9uT3B0aW9ucyk6IEJsdWViaXJkPFNpZ25lZFRyYW5zYWN0aW9uPjtcbn1cbiJdfQ==